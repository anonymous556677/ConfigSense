function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.service.StorageService:isAuthSetupComplete(),isAuthSetupComplete,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
public boolean isAuthSetupComplete()
    {
        return authSetupComplete;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),getAuthenticator,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IAuthenticator getAuthenticator()
    {
        return authenticator;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.auth.AuthenticatedUser:isAnonymous(),isAnonymous,AuthenticatedUser,../data/xml/cassandra_call_methods/AuthenticatedUser.xml,"/**
     * If IAuthenticator doesn't require authentication, this method may return true.
     */
public boolean isAnonymous()
    {
        return this == ANONYMOUS_USER;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.auth.AuthenticatedUser:isSystem(),isSystem,AuthenticatedUser,../data/xml/cassandra_call_methods/AuthenticatedUser.xml,"/**
     * Some internal operations are performed on behalf of Cassandra itself, in those cases
     * the system user should be used where an identity is required
     * see CreateRoleStatement#execute() and overrides of AlterSchemaStatement#createdResources()
     */
public boolean isSystem()
    {
        return this == SYSTEM_USER;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.auth.AuthenticatedUser:getName(),getName,AuthenticatedUser,../data/xml/cassandra_call_methods/AuthenticatedUser.xml,"
public String getName()
    {
        return name;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.config.DatabaseDescriptor:getRoleManager(),getRoleManager,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IRoleManager getRoleManager()
    {
        return roleManager;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.auth.AuthenticatedUser:getPrimaryRole(),getPrimaryRole,AuthenticatedUser,../data/xml/cassandra_call_methods/AuthenticatedUser.xml,"
public RoleResource getPrimaryRole()
    {
        return role;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IRoleManager:canLogin(org.apache.cassandra.auth.RoleResource),canLogin,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IAuthenticator:requireAuthentication(),requireAuthentication,IAuthenticator,../data/xml/cassandra_call_methods/IAuthenticator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.service.StorageService:hasJoined(),hasJoined,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
public boolean hasJoined()
    {
        return joined;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.service.StorageService:isSurveyMode(),isSurveyMode,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
public boolean isSurveyMode()
    {
        return isSurveyMode;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.service.StorageService:isBootstrapMode(),isBootstrapMode,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
public boolean isBootstrapMode()
    {
        return isBootstrapMode;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.db.SystemKeyspace:bootstrapComplete(),bootstrapComplete,SystemKeyspace,../data/xml/cassandra_call_methods/SystemKeyspace.xml,"
public static boolean bootstrapComplete()
    {
        return getBootstrapState() == BootstrapState.COMPLETED;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.auth.AuthenticatedUser:isSuper(),isSuper,AuthenticatedUser,../data/xml/cassandra_call_methods/AuthenticatedUser.xml,"/**
     * Checks the user's superuser status.
     * Only a superuser is allowed to perform CREATE USER and DROP USER queries.
     * Im most cased, though not necessarily, a superuser will have Permission.ALL on every resource
     * (depends on IAuthorizer implementation).
     */
public boolean isSuper()
    {
        return !isAnonymous() && Roles.hasSuperuserStatus(role);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.db.virtual.VirtualSchemaKeyspace:tables(),tables,VirtualSchemaKeyspace,../data/xml/cassandra_call_methods/VirtualSchemaKeyspace.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.config.DatabaseDescriptor:isDaemonInitialized(),isDaemonInitialized,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean isDaemonInitialized()
    {
        return daemonInitialized;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IAuthenticator:protectedResources(),protectedResources,IAuthenticator,../data/xml/cassandra_call_methods/IAuthenticator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.config.DatabaseDescriptor:getAuthorizer(),getAuthorizer,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IAuthorizer getAuthorizer()
    {
        return authorizer;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IAuthorizer:protectedResources(),protectedResources,IAuthorizer,../data/xml/cassandra_call_methods/IAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IRoleManager:protectedResources(),protectedResources,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.auth.AuthKeyspace:metadata(),metadata,AuthKeyspace,../data/xml/cassandra_call_methods/AuthKeyspace.xml,"
public static KeyspaceMetadata metadata()
    {
        return KeyspaceMetadata.create(SchemaConstants.AUTH_KEYSPACE_NAME,
                                       KeyspaceParams.simple(1),
                                       Tables.of(Roles, RoleMembers, RolePermissions, ResourceRoleIndex, NetworkPermissions));
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,"(S)org.apache.cassandra.schema.MigrationManager:evolveSystemKeyspace(org.apache.cassandra.schema.KeyspaceMetadata,long)",evolveSystemKeyspace,MigrationManager,../data/xml/cassandra_call_methods/MigrationManager.xml,"/**
     * We have a set of non-local, distributed system keyspaces, e.g. system_traces, system_auth, etc.
     * (see {@link SchemaConstants#REPLICATED_SYSTEM_KEYSPACE_NAMES}), that need to be created on cluster initialisation,
     * and later evolved on major upgrades (sometimes minor too). This method compares the current known definitions
     * of the tables (if the keyspace exists) to the expected, most modern ones expected by the running version of C*;
     * if any changes have been detected, a schema Mutation will be created which, when applied, should make
     * cluster's view of that keyspace aligned with the expected modern definition.
     *
     * @param keyspace   the expected modern definition of the keyspace
     * @param generation timestamp to use for the table changes in the schema mutation
     *
     * @return empty Optional if the current definition is up to date, or an Optional with the Mutation that would
     *         bring the schema in line with the expected definition.
     */
public static Optional<Mutation> evolveSystemKeyspace(KeyspaceMetadata keyspace, long generation)
    {
        Mutation.SimpleBuilder builder = null;

        KeyspaceMetadata definedKeyspace = Schema.instance.getKeyspaceMetadata(keyspace.name);
        Tables definedTables = null == definedKeyspace ? Tables.none() : definedKeyspace.tables;

        for (TableMetadata table : keyspace.tables)
        {
            if (table.equals(definedTables.getNullable(table.name)))
                continue;

            if (null == builder)
            {
                // for the keyspace definition itself (name, replication, durability) always use generation 0;
                // this ensures that any changes made to replication by the user will never be overwritten.
                builder = SchemaKeyspace.makeCreateKeyspaceMutation(keyspace.name, keyspace.params, 0);

                // now set the timestamp to generation, so the tables have the expected timestamp
                builder.timestamp(generation);
            }

            // for table definitions always use the provided generation; these tables, unlike their containing
            // keyspaces, are *NOT* meant to be altered by the user; if their definitions need to change,
            // the schema must be updated in code, and the appropriate generation must be bumped.
            SchemaKeyspace.addTableToSchemaMutation(table, true, builder);
        }

        return builder == null ? Optional.empty() : Optional.of(builder.build());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IRoleManager:setup(),setup,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IAuthenticator:setup(),setup,IAuthenticator,../data/xml/cassandra_call_methods/IAuthenticator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.IAuthorizer:setup(),setup,IAuthorizer,../data/xml/cassandra_call_methods/IAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(S)org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),getNetworkAuthorizer,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static INetworkAuthorizer getNetworkAuthorizer()
    {
        return networkAuthorizer;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(I)org.apache.cassandra.auth.INetworkAuthorizer:setup(),setup,INetworkAuthorizer,../data/xml/cassandra_call_methods/INetworkAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(O)org.apache.cassandra.auth.AuthSchemaChangeListener:<init>(),<init>,AuthSchemaChangeListener,../data/xml/cassandra_call_methods/AuthSchemaChangeListener.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.schema.Schema:registerListener(org.apache.cassandra.schema.SchemaChangeListener),registerListener,Schema,../data/xml/cassandra_call_methods/Schema.xml,"
public void registerListener(SchemaChangeListener listener)
    {
        changeListeners.add(listener);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.service.QueryState:getClientAddress(),getClientAddress,QueryState,../data/xml/cassandra_call_methods/QueryState.xml,"
public InetAddress getClientAddress()
    {
        return clientState.getClientAddress();
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(O)org.apache.cassandra.transport.ServerConnection:certificates(),certificates,ServerConnection,../data/xml/cassandra_call_methods/ServerConnection.xml,"
private X509Certificate[] certificates()
    {
        SslHandler sslHandler = (SslHandler) channel().pipeline()
                                                      .get(""ssl"");
        X509Certificate[] certificates = null;

        if (sslHandler != null)
        {
            try
            {
                certificates = sslHandler.engine()
                                         .getSession()
                                         .getPeerCertificateChain();
            }
            catch (SSLPeerUnverifiedException e)
            {
                logger.debug(""Failed to get peer certificates for peer {}"", channel().remoteAddress(), e);
            }
        }
        return certificates;
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.utils.CassandraVersion:compareTo(org.apache.cassandra.utils.CassandraVersion),compareTo,CassandraVersion,../data/xml/cassandra_call_methods/CassandraVersion.xml,"
public int compareTo(CassandraVersion other)
    {
        return compareTo(other, false);
    }

    

public int compareTo(CassandraVersion other, boolean compareToPatchOnly)
    {
        if (major < other.major)
            return -1;
        if (major > other.major)
            return 1;

        if (minor < other.minor)
            return -1;
        if (minor > other.minor)
            return 1;

        if (patch < other.patch)
            return -1;
        if (patch > other.patch)
            return 1;

        if (compareToPatchOnly)
            return 0;

        int c = Integer.compare(hotfix, other.hotfix);
        if (c != 0)
            return c;

        c = compareIdentifiers(preRelease, other.preRelease, 1);
        if (c != 0)
            return c;

        return compareIdentifiers(build, other.build, -1);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.transport.messages.StartupMessage:getSource(),getSource,StartupMessage,../data/xml/cassandra_call_methods/StartupMessage.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.transport.ProtocolVersion:isGreaterOrEqualTo(org.apache.cassandra.transport.ProtocolVersion),isGreaterOrEqualTo,ProtocolVersion,../data/xml/cassandra_call_methods/ProtocolVersion.xml,"
public final boolean isGreaterOrEqualTo(ProtocolVersion other)
    {
        return num >= other.num;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.transport.Connection:setCompressor(org.apache.cassandra.transport.Compressor),setCompressor,Connection,../data/xml/cassandra_call_methods/Connection.xml,"
public void setCompressor(Compressor compressor)
    {
        this.preV5MessageCompressor = compressor;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.transport.Connection:setThrowOnOverload(boolean),setThrowOnOverload,Connection,../data/xml/cassandra_call_methods/Connection.xml,"
public void setThrowOnOverload(boolean throwOnOverload)
    {
        this.throwOnOverload = throwOnOverload;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(M)org.apache.cassandra.service.QueryState:getClientState(),getClientState,QueryState,../data/xml/cassandra_call_methods/QueryState.xml,"
public ClientState getClientState()
    {
        return clientState;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),authenticator,(O)org.apache.cassandra.transport.messages.ReadyMessage:<init>(),<init>,ReadyMessage,../data/xml/cassandra_call_methods/ReadyMessage.xml,"
public ReadyMessage()
    {
        super(Message.Type.READY);
    }

    "
