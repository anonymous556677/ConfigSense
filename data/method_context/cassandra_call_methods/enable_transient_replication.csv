function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:validateExpectedOptions(),validateExpectedOptions,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,"
protected void validateExpectedOptions() throws ConfigurationException
    {
        Collection<String> expectedOptions = recognizedOptions();
        if (expectedOptions == null)
            return;

        for (String key : configOptions.keySet())
        {
            if (!expectedOptions.contains(key))
                throw new ConfigurationException(String.format(""Unrecognized strategy option {%s} passed to %s for keyspace %s"", key, getClass().getSimpleName(), keyspaceName));
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:validateOptions(),validateOptions,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:maybeWarnOnOptions(),maybeWarnOnOptions,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:hasTransientReplicas(),hasTransientReplicas,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,"
public boolean hasTransientReplicas()
    {
        return getReplicationFactor().hasTransientReplicas();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(S)org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),isTransientReplicationEnabled,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean isTransientReplicationEnabled()
    {
        return conf.enable_transient_replication;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(S)org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),getNumTokens,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getNumTokens()
    {
        return conf.num_tokens;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(M)org.apache.cassandra.gms.Gossiper:getLiveMembers(),getLiveMembers,Gossiper,../data/xml/cassandra_call_methods/Gossiper.xml,"/**
     * @return a list of live gossip participants, including fat clients
     */
public Set<InetAddressAndPort> getLiveMembers()
    {
        Set<InetAddressAndPort> liveMembers = new HashSet<>(liveEndpoints);
        if (!liveMembers.contains(FBUtilities.getBroadcastAddressAndPort()))
            liveMembers.add(FBUtilities.getBroadcastAddressAndPort());
        return liveMembers;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(M)org.apache.cassandra.gms.Gossiper:getUnreachableMembers(),getUnreachableMembers,Gossiper,../data/xml/cassandra_call_methods/Gossiper.xml,"/**
     * @return a list of unreachable gossip participants, including fat clients
     */
public Set<InetAddressAndPort> getUnreachableMembers()
    {
        return unreachableEndpoints.keySet();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(S)org.apache.cassandra.utils.FBUtilities:getBroadcastAddressAndPort(),getBroadcastAddressAndPort,FBUtilities,../data/xml/cassandra_call_methods/FBUtilities.xml,"/**
     * Get the broadcast address and port for intra-cluster storage traffic. This the address to advertise that uniquely
     * identifies the node and is reachable from everywhere. This is the one you want unless you are trying to connect
     * to the local address specifically.
     */
public static InetAddressAndPort getBroadcastAddressAndPort()
    {
        if (broadcastInetAddressAndPort == null)
        {
            if(DatabaseDescriptor.getRawConfig() == null)
            {
                broadcastInetAddressAndPort = InetAddressAndPort.getByAddress(getJustBroadcastAddress());
            }
            else
            {
                broadcastInetAddressAndPort = InetAddressAndPort.getByAddressOverrideDefaults(getJustBroadcastAddress(),
                                                                                              DatabaseDescriptor.getStoragePort());
            }
        }
        return broadcastInetAddressAndPort;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),enable_transient_replication,(D)com.google.common.base.Predicate:apply(org.apache.cassandra.locator.InetAddressAndPort),apply,Predicate,../data/xml/cassandra_call_methods/cannot find.xml,not found
