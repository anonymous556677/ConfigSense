function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),getInternodeMessagingEncyptionOptions,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static EncryptionOptions.ServerEncryptionOptions getInternodeMessagingEncyptionOptions()
    {
        return conf.server_encryption_options;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions:withOptional(boolean),withOptional,EncryptionOptions$ServerEncryptionOptions,../data/xml/cassandra_call_methods/EncryptionOptions.xml,"
public EncryptionOptions withOptional(Boolean optional)
    {
        return new EncryptionOptions(keystore, keystore_password, truststore, truststore_password, cipher_suites,
                                           protocol, accepted_protocols, algorithm, store_type, require_client_auth, require_endpoint_verification,
                                           enabled, optional).applyConfig();
    }

    

public ServerEncryptionOptions withOptional(boolean optional)
        {
            return new ServerEncryptionOptions(keystore, keystore_password, truststore, truststore_password, cipher_suites,
                                               protocol, accepted_protocols, algorithm, store_type, require_client_auth, require_endpoint_verification,
                                               optional, internode_encryption, enable_legacy_ssl_storage_port).applyConfigInternal();
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions:withInternodeEncryption(org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions$InternodeEncryption),withInternodeEncryption,EncryptionOptions$ServerEncryptionOptions,../data/xml/cassandra_call_methods/EncryptionOptions.xml,"
public ServerEncryptionOptions withInternodeEncryption(InternodeEncryption internode_encryption)
        {
            return new ServerEncryptionOptions(keystore, keystore_password, truststore, truststore_password, cipher_suites,
                                               protocol, accepted_protocols, algorithm, store_type, require_client_auth, require_endpoint_verification,
                                               optional, internode_encryption, enable_legacy_ssl_storage_port).applyConfigInternal();
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getSSLStoragePort(),getSSLStoragePort,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getSSLStoragePort()
    {
        return Integer.parseInt(System.getProperty(Config.PROPERTY_PREFIX + ""ssl_storage_port"", Integer.toString(conf.ssl_storage_port)));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.locator.InetAddressAndPort:withPort(int),withPort,InetAddressAndPort,../data/xml/cassandra_call_methods/InetAddressAndPort.xml,"
public InetAddressAndPort withPort(int port)
    {
        return new InetAddressAndPort(address, addressBytes, port);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.net.InboundConnectionSettings:withBindAddress(org.apache.cassandra.locator.InetAddressAndPort),withBindAddress,InboundConnectionSettings,../data/xml/cassandra_call_methods/InboundConnectionSettings.xml,"
@SuppressWarnings(""unused"")
    public InboundConnectionSettings withBindAddress(InetAddressAndPort bindAddress)
    {
        return new InboundConnectionSettings(authenticator, bindAddress, encryption,
                                             socketReceiveBufferSizeInBytes, applicationReceiveQueueCapacityInBytes,
                                             acceptMessaging, acceptStreaming, socketFactory, handlers);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.net.InboundConnectionSettings:withEncryption(org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions),withEncryption,InboundConnectionSettings,../data/xml/cassandra_call_methods/InboundConnectionSettings.xml,"
public InboundConnectionSettings withEncryption(ServerEncryptionOptions encryption)
    {
        return new InboundConnectionSettings(authenticator, bindAddress, encryption,
                                             socketReceiveBufferSizeInBytes, applicationReceiveQueueCapacityInBytes,
                                             acceptMessaging, acceptStreaming, socketFactory, handlers);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.net.InboundConnectionSettings:withDefaults(),withDefaults,InboundConnectionSettings,../data/xml/cassandra_call_methods/InboundConnectionSettings.xml,"// note that connectTo is updated even if specified, in the case of pre40 messaging and using encryption (to update port)
public InboundConnectionSettings withDefaults()
    {
        // this is for the socket that can be plain, only ssl, or optional plain/ssl
        if (bindAddress.port != DatabaseDescriptor.getStoragePort() && bindAddress.port != DatabaseDescriptor.getSSLStoragePort())
            throw new ConfigurationException(format(""Local endpoint port %d doesn't match YAML configured port %d or legacy SSL port %d"",
                                                    bindAddress.port, DatabaseDescriptor.getStoragePort(), DatabaseDescriptor.getSSLStoragePort()));

        IInternodeAuthenticator authenticator = this.authenticator;
        ServerEncryptionOptions encryption = this.encryption;
        Integer socketReceiveBufferSizeInBytes = this.socketReceiveBufferSizeInBytes;
        Integer applicationReceiveQueueCapacityInBytes = this.applicationReceiveQueueCapacityInBytes;
        AcceptVersions acceptMessaging = this.acceptMessaging;
        AcceptVersions acceptStreaming = this.acceptStreaming;
        SocketFactory socketFactory = this.socketFactory;
        Function<InetAddressAndPort, InboundMessageHandlers> handlersFactory = this.handlers;

        if (authenticator == null)
            authenticator = DatabaseDescriptor.getInternodeAuthenticator();

        if (encryption == null)
            encryption = DatabaseDescriptor.getInternodeMessagingEncyptionOptions();

        if (socketReceiveBufferSizeInBytes == null)
            socketReceiveBufferSizeInBytes = DatabaseDescriptor.getInternodeSocketReceiveBufferSizeInBytes();

        if (applicationReceiveQueueCapacityInBytes == null)
            applicationReceiveQueueCapacityInBytes = DatabaseDescriptor.getInternodeApplicationReceiveQueueCapacityInBytes();

        if (acceptMessaging == null)
            acceptMessaging = accept_messaging;

        if (acceptStreaming == null)
            acceptStreaming = accept_streaming;

        if (socketFactory == null)
            socketFactory = instance().socketFactory;

        if (handlersFactory == null)
            handlersFactory = instance()::getInbound;

        Preconditions.checkArgument(socketReceiveBufferSizeInBytes == 0 || socketReceiveBufferSizeInBytes >= 1 << 10, ""illegal socket send buffer size: "" + socketReceiveBufferSizeInBytes);
        Preconditions.checkArgument(applicationReceiveQueueCapacityInBytes >= 1 << 10, ""illegal application receive queue capacity: "" + applicationReceiveQueueCapacityInBytes);

        return new InboundConnectionSettings(authenticator, bindAddress, encryption, socketReceiveBufferSizeInBytes, applicationReceiveQueueCapacityInBytes, acceptMessaging, acceptStreaming, socketFactory, handlersFactory);
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getStoragePort(),getStoragePort,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getStoragePort()
    {
        return Integer.parseInt(System.getProperty(Config.PROPERTY_PREFIX + ""storage_port"", Integer.toString(conf.storage_port)));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeAuthenticator(),getInternodeAuthenticator,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IInternodeAuthenticator getInternodeAuthenticator()
    {
        return internodeAuthenticator;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeSocketReceiveBufferSizeInBytes(),getInternodeSocketReceiveBufferSizeInBytes,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getInternodeSocketReceiveBufferSizeInBytes()
    {
        return conf.internode_socket_receive_buffer_size_in_bytes;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueCapacityInBytes(),getInternodeApplicationReceiveQueueCapacityInBytes,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getInternodeApplicationReceiveQueueCapacityInBytes()
    {
        return conf.internode_application_receive_queue_capacity_in_bytes;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.net.MessagingService:instance(),instance,MessagingService,../data/xml/cassandra_call_methods/MessagingService.xml,"
public static MessagingService instance()
    {
        return MSHandle.instance;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(S)org.apache.cassandra.config.DatabaseDescriptor:getNativeProtocolEncryptionOptions(),getNativeProtocolEncryptionOptions,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static EncryptionOptions getNativeProtocolEncryptionOptions()
    {
        return conf.client_encryption_options;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,"(S)org.apache.cassandra.security.SSLFactory:validateSslCerts(org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions,org.apache.cassandra.config.EncryptionOptions)",validateSslCerts,SSLFactory,../data/xml/cassandra_call_methods/SSLFactory.xml,"/**
     * Sanity checks all certificates to ensure we can actually load them
     */
public static void validateSslCerts(EncryptionOptions.ServerEncryptionOptions serverOpts, EncryptionOptions clientOpts) throws IOException
    {
        validateSslContext(""server_encryption_options"", serverOpts, true, false);
        validateSslContext(""client_encryption_options"", clientOpts, clientOpts.require_client_auth, false);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,"(S)org.apache.cassandra.security.SSLFactory:checkCertFilesForHotReloading(org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions,org.apache.cassandra.config.EncryptionOptions)",checkCertFilesForHotReloading,SSLFactory,../data/xml/cassandra_call_methods/SSLFactory.xml,"/**
     * Performs a lightweight check whether the certificate files have been refreshed.
     *
     * @throws IllegalStateException if {@link #initHotReloading(EncryptionOptions.ServerEncryptionOptions, EncryptionOptions, boolean)}
     *                               is not called first
     */
public static void checkCertFilesForHotReloading(EncryptionOptions.ServerEncryptionOptions serverOpts,
                                                     EncryptionOptions clientOpts)
    {
        if (!isHotReloadingInitialized)
            throw new IllegalStateException(""Hot reloading functionality has not been initialized."");

        logger.debug(""Checking whether certificates have been updated {}"", hotReloadableFiles);

        if (hotReloadableFiles.stream().anyMatch(HotReloadableFile::shouldReload))
        {
            logger.info(""SSL certificates have been updated. Reseting the ssl contexts for new connections."");
            try
            {
                validateSslCerts(serverOpts, clientOpts);
                cachedSslContexts.clear();
            }
            catch(Exception e)
            {
                logger.error(""Failed to hot reload the SSL Certificates! Please check the certificate files."", e);
            }
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeMessagingEncyptionOptions(),server_encryption_options,(M)org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions:shouldEncrypt(org.apache.cassandra.locator.InetAddressAndPort),shouldEncrypt,EncryptionOptions$ServerEncryptionOptions,../data/xml/cassandra_call_methods/EncryptionOptions.xml,"
public boolean shouldEncrypt(InetAddressAndPort endpoint)
        {
            IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();
            switch (internode_encryption)
            {
                case none:
                    return false; // if nothing needs to be encrypted then return immediately.
                case all:
                    break;
                case dc:
                    if (snitch.getDatacenter(endpoint).equals(snitch.getLocalDatacenter()))
                        return false;
                    break;
                case rack:
                    // for rack then check if the DC's are the same.
                    if (snitch.getRack(endpoint).equals(snitch.getLocalRack())
                        && snitch.getDatacenter(endpoint).equals(snitch.getLocalDatacenter()))
                        return false;
                    break;
            }
            return true;
        }

        "
