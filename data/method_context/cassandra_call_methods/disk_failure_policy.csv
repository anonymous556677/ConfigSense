function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(M)org.apache.cassandra.service.StorageService:isDaemonSetupCompleted(),isDaemonSetupCompleted,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
public boolean isDaemonSetupCompleted()
    {
        return daemon == null
               ? false
               : daemon.setupCompleted();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(S)org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),getDiskFailurePolicy,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static Config.DiskFailurePolicy getDiskFailurePolicy()
    {
        return conf.disk_failure_policy;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(M)org.apache.cassandra.config.Config$DiskFailurePolicy:ordinal(),ordinal,Config$DiskFailurePolicy,../data/xml/cassandra_call_methods/Config.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(M)org.apache.cassandra.service.StorageService:stopTransports(),stopTransports,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
public void stopTransports()
    {
        if (isNativeTransportRunning())
        {
            logger.error(""Stopping native transport"");
            stopNativeTransport();
        }
        if (isGossipActive())
        {
            logger.error(""Stopping gossiper"");
            stopGossiping();
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(M)org.apache.cassandra.io.FSError:getCause(),getCause,FSError,../data/xml/cassandra_call_methods/FSError.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(S)org.apache.cassandra.utils.HeapUtils:logHeapHistogram(),logHeapHistogram,HeapUtils,../data/xml/cassandra_call_methods/HeapUtils.xml,"/**
     * Generates a HEAP histogram in the log file.
     */
public static void logHeapHistogram()
    {
        try
        {
            logger.info(""Trying to log the heap histogram using jcmd"");

            Long processId = getProcessId();
            if (processId == null)
            {
                logger.error(""The process ID could not be retrieved. Skipping heap histogram generation."");
                return;
            }

            String jcmdPath = getJcmdPath();

            // The jcmd file could not be found. In this case let's default to jcmd in the hope that it is in the path.
            String jcmdCommand = jcmdPath == null ? ""jcmd"" : jcmdPath;

            String[] histoCommands = new String[] {jcmdCommand,
                    processId.toString(),
                    ""GC.class_histogram""};

            logProcessOutput(Runtime.getRuntime().exec(histoCommands));
        }
        catch (Throwable e)
        {
            logger.error(""The heap histogram could not be generated due to the following error: "", e);
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getDiskFailurePolicy(),disk_failure_policy,(M)org.apache.cassandra.service.StorageService:removeShutdownHook(),removeShutdownHook,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"/**
     * In the event of forceful termination we need to remove the shutdown hook to prevent hanging (OOM for instance)
     */
public void removeShutdownHook()
    {
        if (drainOnShutdown != null)
            Runtime.getRuntime().removeShutdownHook(drainOnShutdown);

        if (FBUtilities.isWindows)
            WindowsTimer.endTimerPeriod(DatabaseDescriptor.getWindowsTimerInterval());
    }

    "
