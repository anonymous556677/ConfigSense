function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:getReplicationFactor(),getReplicationFactor,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.ReplicationFactor:transientReplicas(),transientReplicas,ReplicationFactor,../data/xml/cassandra_call_methods/ReplicationFactor.xml,"
public int transientReplicas()
    {
        return allReplicas - fullReplicas;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),getNumTokens,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getNumTokens()
    {
        return conf.num_tokens;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.Keyspace:getColumnFamilyStores(),getColumnFamilyStores,Keyspace,../data/xml/cassandra_call_methods/Keyspace.xml,"
public Collection<ColumnFamilyStore> getColumnFamilyStores()
    {
        return Collections.unmodifiableCollection(columnFamilyStores.values());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.view.TableViews:hasViews(),hasViews,TableViews,../data/xml/cassandra_call_methods/TableViews.xml,"
public boolean hasViews()
    {
        return !views.isEmpty();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.index.SecondaryIndexManager:hasIndexes(),hasIndexes,SecondaryIndexManager,../data/xml/cassandra_call_methods/SecondaryIndexManager.xml,"/**
     * @return if there are ANY indexes registered for this table
     */
public boolean hasIndexes()
    {
        return !indexes.isEmpty();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(I)org.apache.cassandra.dht.IPartitioner:splitter(),splitter,IPartitioner,../data/xml/cassandra_call_methods/IPartitioner.xml,"
default Optional<Splitter> splitter()
    {
        return Optional.empty();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.RangesAtEndpoint:size(),size,RangesAtEndpoint,../data/xml/cassandra_call_methods/RangesAtEndpoint.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.RangesAtEndpoint:onlyFull(),onlyFull,RangesAtEndpoint,../data/xml/cassandra_call_methods/RangesAtEndpoint.xml,"
public RangesAtEndpoint onlyFull()
    {
        RangesAtEndpoint result = onlyFull;
        if (result == null)
            onlyFull = result = filter(Replica::isFull);
        return result;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.RangesAtEndpoint:ranges(),ranges,RangesAtEndpoint,../data/xml/cassandra_call_methods/RangesAtEndpoint.xml,"/**
     * @return a set of all unique Ranges
     * This method is threadsafe, though it is not synchronised
     */
public Set<Range<Token>> ranges()
    {
        return byRange().keySet();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,"(O)org.apache.cassandra.dht.Splitter$WeightedRange:<init>(double,org.apache.cassandra.dht.Range)",<init>,Splitter$WeightedRange,../data/xml/cassandra_call_methods/Splitter.xml,"/**
 * Partition splitter.
 */
public abstract class Splitter
{
    private final IPartitioner partitioner;

    protected Splitter(IPartitioner partitioner)
    {
        this.partitioner = partitioner;
    }

    @VisibleForTesting
    protected abstract Token tokenForValue(BigInteger value);

    @VisibleForTesting
    protected abstract BigInteger valueForToken(Token token);

    @VisibleForTesting
    protected BigInteger tokensInRange(Range<Token> range)
    {
        //full range case
        if (range.left.equals(range.right))
            return tokensInRange(new Range(partitioner.getMinimumToken(), partitioner.getMaximumToken()));

        BigInteger totalTokens = BigInteger.ZERO;
        for (Range<Token> unwrapped : range.unwrap())
        {
            totalTokens = totalTokens.add(valueForToken(token(unwrapped.right)).subtract(valueForToken(unwrapped.left))).abs();
        }
        return totalTokens;
    }

    /**
     * Computes the number of elapsed tokens from the range start until this token
     * @return the number of tokens from the range start to the token
     */
    @VisibleForTesting
    protected BigInteger elapsedTokens(Token token, Range<Token> range)
    {
        // No token elapsed since range does not contain token
        if (!range.contains(token))
            return BigInteger.ZERO;

        BigInteger elapsedTokens = BigInteger.ZERO;
        for (Range<Token> unwrapped : range.unwrap())
        {
            if (unwrapped.contains(token))
            {
                elapsedTokens = elapsedTokens.add(tokensInRange(new Range<>(unwrapped.left, token)));
            }
            else if (token.compareTo(unwrapped.left) < 0)
            {
                elapsedTokens = elapsedTokens.add(tokensInRange(unwrapped));
            }
        }
        return elapsedTokens;
    }

    /**
     * Computes the normalized position of this token relative to this range
     * @return A number between 0.0 and 1.0 representing this token's position
     * in this range or -1.0 if this range doesn't contain this token.
     */
    public double positionInRange(Token token, Range<Token> range)
    {
        //full range case
        if (range.left.equals(range.right))
            return positionInRange(token, new Range(partitioner.getMinimumToken(), partitioner.getMaximumToken()));

        // leftmost token means we are on position 0.0
        if (token.equals(range.left))
            return 0.0;

        // rightmost token means we are on position 1.0
        if (token.equals(range.right))
            return 1.0;

        // Impossible to find position when token is not contained in range
        if (!range.contains(token))
            return -1.0;

        return new BigDecimal(elapsedTokens(token, range)).divide(new BigDecimal(tokensInRange(range)), 3, BigDecimal.ROUND_HALF_EVEN).doubleValue();
    }

    public List<Token> splitOwnedRanges(int parts, List<WeightedRange> weightedRanges, boolean dontSplitRanges)
    {
        if (weightedRanges.isEmpty() || parts == 1)
            return Collections.singletonList(partitioner.getMaximumToken());

        BigInteger totalTokens = BigInteger.ZERO;
        for (WeightedRange weightedRange : weightedRanges)
        {
            totalTokens = totalTokens.add(weightedRange.totalTokens(this));
        }

        BigInteger perPart = totalTokens.divide(BigInteger.valueOf(parts));
        // the range owned is so tiny we can't split it:
        if (perPart.equals(BigInteger.ZERO))
            return Collections.singletonList(partitioner.getMaximumToken());

        if (dontSplitRanges)
            return splitOwnedRangesNoPartialRanges(weightedRanges, perPart, parts);

        List<Token> boundaries = new ArrayList<>();
        BigInteger sum = BigInteger.ZERO;
        for (WeightedRange weightedRange : weightedRanges)
        {
            BigInteger currentRangeWidth = weightedRange.totalTokens(this);
            BigInteger left = valueForToken(weightedRange.left());
            while (sum.add(currentRangeWidth).compareTo(perPart) >= 0)
            {
                BigInteger withinRangeBoundary = perPart.subtract(sum);
                left = left.add(withinRangeBoundary);
                boundaries.add(tokenForValue(left));
                currentRangeWidth = currentRangeWidth.subtract(withinRangeBoundary);
                sum = BigInteger.ZERO;
            }
            sum = sum.add(currentRangeWidth);
        }
        boundaries.set(boundaries.size() - 1, partitioner.getMaximumToken());

        assert boundaries.size() == parts : boundaries.size() + ""!="" + parts + "" "" + boundaries + "":"" + weightedRanges;
        return boundaries;
    }

    private List<Token> splitOwnedRangesNoPartialRanges(List<WeightedRange> weightedRanges, BigInteger perPart, int parts)
    {
        List<Token> boundaries = new ArrayList<>(parts);
        BigInteger sum = BigInteger.ZERO;

        int i = 0;
        final int rangesCount = weightedRanges.size();
        while (boundaries.size() < parts - 1 && i < rangesCount - 1)
        {
            WeightedRange r = weightedRanges.get(i);
            WeightedRange nextRange = weightedRanges.get(i + 1);

            BigInteger currentRangeWidth = r.totalTokens(this);
            BigInteger nextRangeWidth = nextRange.totalTokens(this);
            sum = sum.add(currentRangeWidth);

            // does this or next range take us beyond the per part limit?
            if (sum.compareTo(perPart) > 0 || sum.add(nextRangeWidth).compareTo(perPart) > 0)
            {
                // Either this or the next range will take us beyond the perPart limit. Will stopping now or
                // adding the next range create the smallest difference to perPart?
                BigInteger diffCurrent = sum.subtract(perPart).abs();
                BigInteger diffNext = sum.add(nextRangeWidth).subtract(perPart).abs();
                if (diffNext.compareTo(diffCurrent) >= 0)
                {
                    sum = BigInteger.ZERO;
                    boundaries.add(token(r.right()));
                }
            }
            i++;
        }
        boundaries.add(partitioner.getMaximumToken());
        return boundaries;
    }

    /**
     * We avoid calculating for wrap around ranges, instead we use the actual max token, and then, when translating
     * to PartitionPositions, we include tokens from .minKeyBound to .maxKeyBound to make sure we include all tokens.
     */
    private Token token(Token t)
    {
        return t.equals(partitioner.getMinimumToken()) ? partitioner.getMaximumToken() : t;
    }

    /**
     * Splits the specified token ranges in at least {@code parts} subranges.
     * <p>
     * Each returned subrange will be contained in exactly one of the specified ranges.
     *
     * @param ranges a collection of token ranges to be split
     * @param parts the minimum number of returned ranges
     * @return at least {@code minParts} token ranges covering {@code ranges}
     */
    public Set<Range<Token>> split(Collection<Range<Token>> ranges, int parts)
    {
        int numRanges = ranges.size();
        if (numRanges >= parts)
        {
            return Sets.newHashSet(ranges);
        }
        else
        {
            int partsPerRange = (int) Math.ceil((double) parts / numRanges);
            return ranges.stream()
                         .map(range -> split(range, partsPerRange))
                         .flatMap(Collection::stream)
                         .collect(toSet());
        }
    }

    /**
     * Splits the specified token range in at least {@code minParts} subranges, unless the range has not enough tokens
     * in which case the range will be returned without splitting.
     *
     * @param range a token range
     * @param parts the number of subranges
     * @return {@code parts} even subranges of {@code range}
     */
    private Set<Range<Token>> split(Range<Token> range, int parts)
    {
        // the range might not have enough tokens to split
        BigInteger numTokens = tokensInRange(range);
        if (BigInteger.valueOf(parts).compareTo(numTokens) > 0)
            return Collections.singleton(range);

        Token left = range.left;
        Set<Range<Token>> subranges = new HashSet<>(parts);
        for (double i = 1; i <= parts; i++)
        {
            Token right = partitioner.split(range.left, range.right, i / parts);
            subranges.add(new Range<>(left, right));
            left = right;
        }
        return subranges;
    }

    public static class WeightedRange
    {
        private final double weight;
        private final Range<Token> range;

        public WeightedRange(double weight, Range<Token> range)
        {
            this.weight = weight;
            this.range = range;
        }

        public BigInteger totalTokens(Splitter splitter)
        {
            BigInteger right = splitter.valueForToken(splitter.token(range.right));
            BigInteger left = splitter.valueForToken(range.left);
            BigInteger factor = BigInteger.valueOf(Math.max(1, (long) (1 / weight)));
            BigInteger size = right.subtract(left);
            return size.abs().divide(factor);
        }

        public Token left()
        {
            return range.left;
        }

        public Token right()
        {
            return range.right;
        }

        public Range<Token> range()
        {
            return range;
        }

        public String toString()
        {
            return ""WeightedRange{"" +
                   ""weight="" + weight +
                   "", range="" + range +
                   '}';
        }

        public boolean equals(Object o)
        {
            if (this == o) return true;
            if (!(o instanceof WeightedRange)) return false;
            WeightedRange that = (WeightedRange) o;
            return Objects.equals(range, that.range);
        }

        public int hashCode()
        {
            return Objects.hash(weight, range);
        }
    }
}


protected Splitter(IPartitioner partitioner)
    {
        this.partitioner = partitioner;
    }

    

Splitter "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.RangesAtEndpoint:onlyTransient(),onlyTransient,RangesAtEndpoint,../data/xml/cassandra_call_methods/RangesAtEndpoint.xml,"
public RangesAtEndpoint onlyTransient()
    {
        RangesAtEndpoint result = onlyTransient;
        if (result == null)
            onlyTransient = result = filter(Replica::isTransient);
        return result;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.dht.Token:maxKeyBound(),maxKeyBound,Token,../data/xml/cassandra_call_methods/Token.xml,"
public KeyBound maxKeyBound()
    {
        /*
         * For each token, we needs both minKeyBound and maxKeyBound
         * because a token corresponds to a range of keys. But the minimun
         * token corresponds to no key, so it is valid and actually much
         * simpler to associate the same value for minKeyBound and
         * maxKeyBound for the minimun token.
         */
        if (isMinimum())
            return minKeyBound();
        return new KeyBound(this, false);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(I)org.apache.cassandra.dht.IPartitioner:getMaximumToken(),getMaximumToken,IPartitioner,../data/xml/cassandra_call_methods/IPartitioner.xml,"/**
     * The biggest token for this partitioner, unlike getMinimumToken, this token is actually used and users wanting to
     * include all tokens need to do getMaximumToken().maxKeyBound()
     *
     * Not implemented for the ordered partitioners
     */
default Token getMaximumToken()
    {
        throw new UnsupportedOperationException(""If you are using a splitting partitioner, getMaximumToken has to be implemented"");
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:getAllocateTokensForKeyspace(),getAllocateTokensForKeyspace,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static String getAllocateTokensForKeyspace()
    {
        return System.getProperty(Config.PROPERTY_PREFIX + ""allocate_tokens_for_keyspace"", conf.allocate_tokens_for_keyspace);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:getAllocateTokensForLocalRf(),getAllocateTokensForLocalRf,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static Integer getAllocateTokensForLocalRf()
    {
        return conf.allocate_tokens_for_local_replication_factor;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:getInitialTokens(),getInitialTokens,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static Collection<String> getInitialTokens()
    {
        return tokensFromString(System.getProperty(Config.PROPERTY_PREFIX + ""initial_token"", conf.initial_token));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,"(S)org.apache.cassandra.dht.BootStrapper:allocateTokens(org.apache.cassandra.locator.TokenMetadata,org.apache.cassandra.locator.InetAddressAndPort,int,int,long)",allocateTokens,BootStrapper,../data/xml/cassandra_call_methods/BootStrapper.xml,"
static Collection<Token> allocateTokens(final TokenMetadata metadata,
                                            InetAddressAndPort address,
                                            String allocationKeyspace,
                                            int numTokens,
                                            long schemaWaitDelay)
    {
        StorageService.instance.waitForSchema(schemaWaitDelay);
        if (!FBUtilities.getBroadcastAddressAndPort().equals(InetAddressAndPort.getLoopbackAddress()))
            Gossiper.waitToSettle();

        Keyspace ks = Keyspace.open(allocationKeyspace);
        if (ks == null)
            throw new ConfigurationException(""Problem opening token allocation keyspace "" + allocationKeyspace);
        AbstractReplicationStrategy rs = ks.getReplicationStrategy();

        Collection<Token> tokens = TokenAllocation.allocateTokens(metadata, rs, address, numTokens);
        BootstrapDiagnostics.tokensAllocated(address, metadata, allocationKeyspace, numTokens, tokens);
        return tokens;
    }


    

static Collection<Token> allocateTokens(final TokenMetadata metadata,
                                            InetAddressAndPort address,
                                            int rf,
                                            int numTokens,
                                            long schemaWaitDelay)
    {
        StorageService.instance.waitForSchema(schemaWaitDelay);
        if (!FBUtilities.getBroadcastAddressAndPort().equals(InetAddressAndPort.getLoopbackAddress()))
            Gossiper.waitToSettle();

        Collection<Token> tokens = TokenAllocation.allocateTokens(metadata, rf, address, numTokens);
        BootstrapDiagnostics.tokensAllocated(address, metadata, rf, numTokens, tokens);
        return tokens;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,"(S)org.apache.cassandra.dht.BootStrapper:getRandomTokens(org.apache.cassandra.locator.TokenMetadata,int)",getRandomTokens,BootStrapper,../data/xml/cassandra_call_methods/BootStrapper.xml,"
public static Collection<Token> getRandomTokens(TokenMetadata metadata, int numTokens)
    {
        Set<Token> tokens = new HashSet<>(numTokens);
        while (tokens.size() < numTokens)
        {
            Token token = metadata.partitioner.getRandomToken();
            if (metadata.getEndpoint(token) == null)
                tokens.add(token);
        }

        logger.info(""Generated random tokens. tokens are {}"", tokens);
        return tokens;
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.locator.ReplicationFactor:hasTransientReplicas(),hasTransientReplicas,ReplicationFactor,../data/xml/cassandra_call_methods/ReplicationFactor.xml,"
public boolean hasTransientReplicas()
    {
        return allReplicas != fullReplicas;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:isTransientReplicationEnabled(),isTransientReplicationEnabled,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean isTransientReplicationEnabled()
    {
        return conf.enable_transient_replication;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.gms.Gossiper:getLiveMembers(),getLiveMembers,Gossiper,../data/xml/cassandra_call_methods/Gossiper.xml,"/**
     * @return a list of live gossip participants, including fat clients
     */
public Set<InetAddressAndPort> getLiveMembers()
    {
        Set<InetAddressAndPort> liveMembers = new HashSet<>(liveEndpoints);
        if (!liveMembers.contains(FBUtilities.getBroadcastAddressAndPort()))
            liveMembers.add(FBUtilities.getBroadcastAddressAndPort());
        return liveMembers;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.gms.Gossiper:getUnreachableMembers(),getUnreachableMembers,Gossiper,../data/xml/cassandra_call_methods/Gossiper.xml,"/**
     * @return a list of unreachable gossip participants, including fat clients
     */
public Set<InetAddressAndPort> getUnreachableMembers()
    {
        return unreachableEndpoints.keySet();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.utils.FBUtilities:getBroadcastAddressAndPort(),getBroadcastAddressAndPort,FBUtilities,../data/xml/cassandra_call_methods/FBUtilities.xml,"/**
     * Get the broadcast address and port for intra-cluster storage traffic. This the address to advertise that uniquely
     * identifies the node and is reachable from everywhere. This is the one you want unless you are trying to connect
     * to the local address specifically.
     */
public static InetAddressAndPort getBroadcastAddressAndPort()
    {
        if (broadcastInetAddressAndPort == null)
        {
            if(DatabaseDescriptor.getRawConfig() == null)
            {
                broadcastInetAddressAndPort = InetAddressAndPort.getByAddress(getJustBroadcastAddress());
            }
            else
            {
                broadcastInetAddressAndPort = InetAddressAndPort.getByAddressOverrideDefaults(getJustBroadcastAddress(),
                                                                                              DatabaseDescriptor.getStoragePort());
            }
        }
        return broadcastInetAddressAndPort;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(D)com.google.common.base.Predicate:apply(org.apache.cassandra.locator.InetAddressAndPort),apply,Predicate,../data/xml/cassandra_call_methods/cannot find.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:isAutoBootstrap(),isAutoBootstrap,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean isAutoBootstrap()
    {
        return Boolean.parseBoolean(System.getProperty(Config.PROPERTY_PREFIX + ""auto_bootstrap"", Boolean.toString(conf.auto_bootstrap)));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.db.SystemKeyspace:bootstrapInProgress(),bootstrapInProgress,SystemKeyspace,../data/xml/cassandra_call_methods/SystemKeyspace.xml,"
public static boolean bootstrapInProgress()
    {
        return getBootstrapState() == BootstrapState.IN_PROGRESS;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.db.SystemKeyspace:bootstrapComplete(),bootstrapComplete,SystemKeyspace,../data/xml/cassandra_call_methods/SystemKeyspace.xml,"
public static boolean bootstrapComplete()
    {
        return getBootstrapState() == BootstrapState.COMPLETED;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.config.DatabaseDescriptor:getSeeds(),getSeeds,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static Set<InetAddressAndPort> getSeeds()
    {
        return ImmutableSet.<InetAddressAndPort>builder().addAll(seedProvider.getSeeds()).build();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.service.StorageService:prepareForBootstrap(long),prepareForBootstrap,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
@VisibleForTesting
    public Collection<InetAddressAndPort> prepareForBootstrap(long schemaDelay)
    {
        Set<InetAddressAndPort> collisions = new HashSet<>();
        if (SystemKeyspace.bootstrapInProgress())
            logger.warn(""Detected previous bootstrap failure; retrying"");
        else
            SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.IN_PROGRESS);
        setMode(Mode.JOINING, ""waiting for ring information"", true);
        waitForSchema(schemaDelay);
        setMode(Mode.JOINING, ""schema complete, ready to bootstrap"", true);
        setMode(Mode.JOINING, ""waiting for pending range calculation"", true);
        PendingRangeCalculatorService.instance.blockUntilFinished();
        setMode(Mode.JOINING, ""calculation complete, ready to bootstrap"", true);

        logger.debug(""... got ring + schema info"");

        if (useStrictConsistency && !allowSimultaneousMoves() &&
            (
            tokenMetadata.getBootstrapTokens().valueSet().size() > 0 ||
            tokenMetadata.getSizeOfLeavingEndpoints() > 0 ||
            tokenMetadata.getSizeOfMovingEndpoints() > 0
            ))
        {
            String bootstrapTokens = StringUtils.join(tokenMetadata.getBootstrapTokens().valueSet(), ',');
            String leavingTokens = StringUtils.join(tokenMetadata.getLeavingEndpoints(), ',');
            String movingTokens = StringUtils.join(tokenMetadata.getMovingEndpoints().stream().map(e -> e.right).toArray(), ',');
            throw new UnsupportedOperationException(String.format(""Other bootstrapping/leaving/moving nodes detected, cannot bootstrap while cassandra.consistent.rangemovement is true. Nodes detected, bootstrapping: %s; leaving: %s; moving: %s;"", bootstrapTokens, leavingTokens, movingTokens));
        }

        // get bootstrap tokens
        if (!replacing)
        {
            if (tokenMetadata.isMember(FBUtilities.getBroadcastAddressAndPort()))
            {
                String s = ""This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)"";
                throw new UnsupportedOperationException(s);
            }
            setMode(Mode.JOINING, ""getting bootstrap token"", true);
            bootstrapTokens = BootStrapper.getBootstrapTokens(tokenMetadata, FBUtilities.getBroadcastAddressAndPort(), schemaDelay);
        }
        else
        {
            if (!isReplacingSameAddress())
            {
                try
                {
                    // Sleep additionally to make sure that the server actually is not alive
                    // and giving it more time to gossip if alive.
                    Thread.sleep(LoadBroadcaster.BROADCAST_INTERVAL);
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError(e);
                }

                // check for operator errors...
                for (Token token : bootstrapTokens)
                {
                    InetAddressAndPort existing = tokenMetadata.getEndpoint(token);
                    if (existing != null)
                    {
                        long nanoDelay = schemaDelay * 1000000L;
                        if (Gossiper.instance.getEndpointStateForEndpoint(existing).getUpdateTimestamp() > (System.nanoTime() - nanoDelay))
                            throw new UnsupportedOperationException(""Cannot replace a live node... "");
                        collisions.add(existing);
                    }
                    else
                    {
                        throw new UnsupportedOperationException(""Cannot replace token "" + token + "" which does not exist!"");
                    }
                }
            }
            else
            {
                try
                {
                    Thread.sleep(RING_DELAY);
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError(e);
                }

            }
            setMode(Mode.JOINING, ""Replacing a node with token(s): "" + bootstrapTokens, true);
        }
        return collisions;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.db.SystemKeyspace:getSavedTokens(),getSavedTokens,SystemKeyspace,../data/xml/cassandra_call_methods/SystemKeyspace.xml,"
public static Collection<Token> getSavedTokens()
    {
        String req = ""SELECT tokens FROM system.%s WHERE key='%s'"";
        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));
        return result.isEmpty() || !result.one().has(""tokens"")
             ? Collections.<Token>emptyList()
             : deserializeTokens(result.one().getSet(""tokens"", UTF8Type.instance));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,"(S)org.apache.cassandra.dht.BootStrapper:getBootstrapTokens(org.apache.cassandra.locator.TokenMetadata,org.apache.cassandra.locator.InetAddressAndPort,long)",getBootstrapTokens,BootStrapper,../data/xml/cassandra_call_methods/BootStrapper.xml,"/**
     * if initialtoken was specified, use that (split on comma).
     * otherwise, if allocationKeyspace is specified use the token allocation algorithm to generate suitable tokens
     * else choose num_tokens tokens at random
     */
public static Collection<Token> getBootstrapTokens(final TokenMetadata metadata, InetAddressAndPort address, long schemaWaitDelay) throws ConfigurationException
    {
        String allocationKeyspace = DatabaseDescriptor.getAllocateTokensForKeyspace();
        Integer allocationLocalRf = DatabaseDescriptor.getAllocateTokensForLocalRf();
        Collection<String> initialTokens = DatabaseDescriptor.getInitialTokens();
        if (initialTokens.size() > 0 && allocationKeyspace != null)
            logger.warn(""manually specified tokens override automatic allocation"");

        // if user specified tokens, use those
        if (initialTokens.size() > 0)
        {
            Collection<Token> tokens = getSpecifiedTokens(metadata, initialTokens);
            BootstrapDiagnostics.useSpecifiedTokens(address, allocationKeyspace, tokens, DatabaseDescriptor.getNumTokens());
            return tokens;
        }

        int numTokens = DatabaseDescriptor.getNumTokens();
        if (numTokens < 1)
            throw new ConfigurationException(""num_tokens must be >= 1"");

        if (allocationKeyspace != null)
            return allocateTokens(metadata, address, allocationKeyspace, numTokens, schemaWaitDelay);

        if (allocationLocalRf != null)
            return allocateTokens(metadata, address, allocationLocalRf, numTokens, schemaWaitDelay);

        if (numTokens == 1)
            logger.warn(""Picking random token for a single vnode.  You should probably add more vnodes and/or use the automatic token allocation mechanism."");

        Collection<Token> tokens = getRandomTokens(metadata, numTokens);
        BootstrapDiagnostics.useRandomTokens(address, metadata, numTokens, tokens);
        return tokens;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.service.StorageService:setUpDistributedSystemKeyspaces(),setUpDistributedSystemKeyspaces,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
@VisibleForTesting
    public void setUpDistributedSystemKeyspaces()
    {
        Collection<Mutation> changes = new ArrayList<>(3);

        evolveSystemKeyspace(            TraceKeyspace.metadata(),             TraceKeyspace.GENERATION).ifPresent(changes::add);
        evolveSystemKeyspace(SystemDistributedKeyspace.metadata(), SystemDistributedKeyspace.GENERATION).ifPresent(changes::add);
        evolveSystemKeyspace(             AuthKeyspace.metadata(),              AuthKeyspace.GENERATION).ifPresent(changes::add);

        if (!changes.isEmpty())
            FBUtilities.waitOnFuture(MigrationManager.announceWithoutPush(changes));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(S)org.apache.cassandra.db.SystemKeyspace:getBootstrapState(),getBootstrapState,SystemKeyspace,../data/xml/cassandra_call_methods/SystemKeyspace.xml,"
public static BootstrapState getBootstrapState()
    {
        String req = ""SELECT bootstrapped FROM system.%s WHERE key='%s'"";
        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));

        if (result.isEmpty() || !result.one().has(""bootstrapped""))
            return BootstrapState.NEEDS_BOOTSTRAP;

        return BootstrapState.valueOf(result.one().getString(""bootstrapped""));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.PartitionRangeReadCommand:metadata(),metadata,PartitionRangeReadCommand,../data/xml/cassandra_call_methods/PartitionRangeReadCommand.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.Keyspace:getColumnFamilyStore(org.apache.cassandra.schema.TableId),getColumnFamilyStore,Keyspace,../data/xml/cassandra_call_methods/Keyspace.xml,"
public ColumnFamilyStore getColumnFamilyStore(String cfName)
    {
        TableMetadata table = schema.getTableMetadata(getName(), cfName);
        if (table == null)
            throw new IllegalArgumentException(String.format(""Unknown keyspace/cf pair (%s.%s)"", getName(), cfName));
        return getColumnFamilyStore(table.id);
    }

    

public ColumnFamilyStore getColumnFamilyStore(TableId id)
    {
        ColumnFamilyStore cfs = columnFamilyStores.get(id);
        if (cfs == null)
            throw new IllegalArgumentException(""Unknown CF "" + id);
        return cfs;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.PartitionRangeReadCommand:getIndex(org.apache.cassandra.db.ColumnFamilyStore),getIndex,PartitionRangeReadCommand,../data/xml/cassandra_call_methods/PartitionRangeReadCommand.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.PartitionRangeReadCommand:limits(),limits,PartitionRangeReadCommand,../data/xml/cassandra_call_methods/PartitionRangeReadCommand.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.filter.DataLimits:estimateTotalResults(org.apache.cassandra.db.ColumnFamilyStore),estimateTotalResults,DataLimits,../data/xml/cassandra_call_methods/DataLimits.xml,"
public float estimateTotalResults(ColumnFamilyStore cfs)
        {
            // TODO: we should start storing stats on the number of rows (instead of the number of cells, which
            // is what getMeanColumns returns)
            float rowsPerPartition = ((float) cfs.getMeanEstimatedCellPerPartitionCount()) / cfs.metadata().regularColumns().size();
            return rowsPerPartition * (cfs.estimateKeys());
        }

        

@Override
        public float estimateTotalResults(ColumnFamilyStore cfs)
        {
            // For the moment, we return the estimated number of rows as we have no good way of estimating 
            // the number of groups that will be returned. Hopefully, we should be able to fix
            // that problem at some point.
            return super.estimateTotalResults(cfs);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(I)org.apache.cassandra.index.Index:getEstimatedResultRows(),getEstimatedResultRows,Index,../data/xml/cassandra_call_methods/Index.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNumTokens(),num_tokens,(M)org.apache.cassandra.db.Keyspace:getReplicationStrategy(),getReplicationStrategy,Keyspace,../data/xml/cassandra_call_methods/Keyspace.xml,"
public AbstractReplicationStrategy getReplicationStrategy()
    {
        return replicationStrategy;
    }

    "
