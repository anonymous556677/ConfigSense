function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(S)org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),isCDCEnabled,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean isCDCEnabled()
    {
        return conf.cdc_enabled;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(S)org.apache.cassandra.config.DatabaseDescriptor:getCommitLogLocation(),getCommitLogLocation,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static String getCommitLogLocation()
    {
        return conf.commitlog_directory;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.commitlog.AbstractCommitLogService:shutdown(),shutdown,AbstractCommitLogService,../data/xml/cassandra_call_methods/AbstractCommitLogService.xml,"
public void shutdown()
    {
        shutdown = true;
        requestExtraSync();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.commitlog.AbstractCommitLogService:awaitTermination(),awaitTermination,AbstractCommitLogService,../data/xml/cassandra_call_methods/AbstractCommitLogService.xml,"
public void awaitTermination() throws InterruptedException
    {
        if (thread != null)
            thread.join();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.commitlog.AbstractCommitLogSegmentManager:stopUnsafe(boolean),stopUnsafe,AbstractCommitLogSegmentManager,../data/xml/cassandra_call_methods/AbstractCommitLogSegmentManager.xml,"/**
     * Stops CL, for testing purposes. DO NOT USE THIS OUTSIDE OF TESTS.
     * Only call this after the AbstractCommitLogService is shut down.
     */
public void stopUnsafe(boolean deleteSegments)
    {
        logger.debug(""CLSM closing and clearing existing commit log segments..."");

        shutdown();
        try
        {
            awaitTermination();
        }
        catch (InterruptedException e)
        {
            throw new RuntimeException(e);
        }

        for (CommitLogSegment segment : activeSegments)
            closeAndDeleteSegmentUnsafe(segment, deleteSegments);
        activeSegments.clear();

        size.set(0L);

        logger.trace(""CLSM done with closing and clearing existing commit log segments."");
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(S)org.apache.cassandra.db.commitlog.CommitLogSegment:resetReplayLimit(),resetReplayLimit,CommitLogSegment,../data/xml/cassandra_call_methods/CommitLogSegment.xml,"/**
     * FOR TESTING PURPOSES.
     */
static void resetReplayLimit()
    {
        replayLimitId = getNextId();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(S)org.apache.cassandra.config.DatabaseDescriptor:getCDCLogLocation(),getCDCLogLocation,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static String getCDCLogLocation()
    {
        return conf.cdc_raw_directory;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.Mutation:trackedByCDC(),trackedByCDC,Mutation,../data/xml/cassandra_call_methods/Mutation.xml,"
public boolean trackedByCDC()
    {
        return cdcEnabled;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,"(M)org.apache.cassandra.db.commitlog.CommitLogReplayer$MutationInitiator:initiateMutation(org.apache.cassandra.db.Mutation,long,int,int,org.apache.cassandra.db.commitlog.CommitLogReplayer)",initiateMutation,CommitLogReplayer$MutationInitiator,../data/xml/cassandra_call_methods/CommitLogReplayer.xml,"
protected Future<Integer> initiateMutation(final Mutation mutation,
                                                   final long segmentId,
                                                   final int serializedSize,
                                                   final int entryLocation,
                                                   final CommitLogReplayer commitLogReplayer)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    if (Schema.instance.getKeyspaceMetadata(mutation.getKeyspaceName()) == null)
                        return;
                    if (commitLogReplayer.pointInTimeExceeded(mutation))
                        return;

                    final Keyspace keyspace = Keyspace.open(mutation.getKeyspaceName());

                    // Rebuild the mutation, omitting column families that
                    //    a) the user has requested that we ignore,
                    //    b) have already been flushed,
                    // or c) are part of a cf that was dropped.
                    // Keep in mind that the cf.name() is suspect. do every thing based on the cfid instead.
                    Mutation.PartitionUpdateCollector newPUCollector = null;
                    for (PartitionUpdate update : commitLogReplayer.replayFilter.filter(mutation))
                    {
                        if (Schema.instance.getTableMetadata(update.metadata().id) == null)
                            continue; // dropped

                        // replay if current segment is newer than last flushed one or,
                        // if it is the last known segment, if we are after the commit log segment position
                        if (commitLogReplayer.shouldReplay(update.metadata().id, new CommitLogPosition(segmentId, entryLocation)))
                        {
                            if (newPUCollector == null)
                                newPUCollector = new Mutation.PartitionUpdateCollector(mutation.getKeyspaceName(), mutation.key());
                            newPUCollector.add(update);
                            commitLogReplayer.replayedCount.incrementAndGet();
                        }
                    }
                    if (newPUCollector != null)
                    {
                        assert !newPUCollector.isEmpty();

                        Keyspace.open(newPUCollector.getKeyspaceName()).apply(newPUCollector.build(), false, true, false);
                        commitLogReplayer.keyspacesReplayed.add(keyspace);
                    }
                }
            };
            return Stage.MUTATION.submit(runnable, serializedSize);
        }
    }"
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(I)org.apache.cassandra.db.rows.UnfilteredRowIterator:metadata(),metadata,UnfilteredRowIterator,../data/xml/cassandra_call_methods/UnfilteredRowIterator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,"(S)org.apache.cassandra.db.partitions.PartitionUpdate:fromIterator(org.apache.cassandra.db.rows.UnfilteredRowIterator,org.apache.cassandra.db.filter.ColumnFilter)",fromIterator,PartitionUpdate,../data/xml/cassandra_call_methods/PartitionUpdate.xml,"/**
     * Turns the given iterator into an update.
     *
     * @param iterator the iterator to turn into updates.
     * @param filter the column filter used when querying {@code iterator}. This is used to make
     * sure we don't include data for which the value has been skipped while reading (as we would
     * then be writing something incorrect).
     *
     * Warning: this method does not close the provided iterator, it is up to
     * the caller to close it.
     */
@SuppressWarnings(""resource"")
    public static PartitionUpdate fromIterator(UnfilteredRowIterator iterator, ColumnFilter filter)
    {
        iterator = UnfilteredRowIterators.withOnlyQueriedData(iterator, filter);
        Holder holder = build(iterator, 16);
        MutableDeletionInfo deletionInfo = (MutableDeletionInfo) holder.deletionInfo;
        return new PartitionUpdate(iterator.metadata(), iterator.partitionKey(), holder, deletionInfo, false);
    }

    
/**
     * Turns the given iterator into an update.
     *
     * @param iterator the iterator to turn into updates.
     * @param filter the column filter used when querying {@code iterator}. This is used to make
     * sure we don't include data for which the value has been skipped while reading (as we would
     * then be writing something incorrect).
     *
     * Warning: this method does not close the provided iterator, it is up to
     * the caller to close it.
     */
@SuppressWarnings(""resource"")
    public static PartitionUpdate fromIterator(RowIterator iterator, ColumnFilter filter)
    {
        iterator = RowIterators.withOnlyQueriedData(iterator, filter);
        MutableDeletionInfo deletionInfo = MutableDeletionInfo.live();
        Holder holder = build(iterator, deletionInfo, true);
        return new PartitionUpdate(iterator.metadata(), iterator.partitionKey(), holder, deletionInfo, false);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,"(S)org.apache.cassandra.db.filter.ColumnFilter:allRegularColumnsBuilder(org.apache.cassandra.schema.TableMetadata,boolean)",allRegularColumnsBuilder,ColumnFilter,../data/xml/cassandra_call_methods/ColumnFilter.xml,"/**
     * Returns a {@code ColumnFilter} builder that fetches all regular columns or all columns (and queries the columns
     * added to the builder, or everything if no column is added).
     *
     * @param metadata the table metadata
     * @param returnStaticContentOnPartitionWithNoRows {@code true} if the query must return static contents if the partition has no row,
     * {@code false} otherwise.
     */
public static Builder allRegularColumnsBuilder(TableMetadata metadata, boolean returnStaticContentOnPartitionWithNoRows)
    {
        return new Builder(metadata, returnStaticContentOnPartitionWithNoRows);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.filter.ColumnFilter:fetchedColumns(),fetchedColumns,ColumnFilter,../data/xml/cassandra_call_methods/ColumnFilter.xml,"
@Override
        public RegularAndStaticColumns fetchedColumns()
        {
            return fetchedAndQueried;
        }

        

@Override
        public RegularAndStaticColumns fetchedColumns()
        {
            return fetched;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.RegularAndStaticColumns:iterator(),iterator,RegularAndStaticColumns,../data/xml/cassandra_call_methods/RegularAndStaticColumns.xml,"
public Iterator<ColumnMetadata> iterator()
    {
        return Iterators.concat(statics.iterator(), regulars.iterator());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.cql3.ColumnIdentifier:toString(),toString,ColumnIdentifier,../data/xml/cassandra_call_methods/ColumnIdentifier.xml,"
@Override
    public String toString()
    {
        return text;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.filter.ColumnFilter$Builder:add(org.apache.cassandra.schema.ColumnMetadata),add,ColumnFilter$Builder,../data/xml/cassandra_call_methods/ColumnFilter.xml,"
public Builder add(ColumnMetadata c)
        {
            if (c.isComplex() && c.type.isMultiCell())
            {
                if (fullySelectedComplexColumns == null)
                    fullySelectedComplexColumns = new HashSet<>();
                fullySelectedComplexColumns.add(c);
            }
            return addInternal(c);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.db.filter.ColumnFilter$Builder:build(),build,ColumnFilter$Builder,../data/xml/cassandra_call_methods/ColumnFilter.xml,"
public ColumnFilter build()
        {
            boolean isFetchAll = metadata != null;

            RegularAndStaticColumns queried = queriedBuilder == null ? null : queriedBuilder.build();

            // It's only ok to have queried == null in ColumnFilter if isFetchAll. So deal with the case of a selectionBuilder
            // with nothing selected (we can at least happen on some backward compatible queries - CASSANDRA-10471).
            if (!isFetchAll && queried == null)
                queried = RegularAndStaticColumns.NONE;

            SortedSetMultimap<ColumnIdentifier, ColumnSubselection> s = buildSubSelections();

            if (isFetchAll)
            {
                // When fetchAll is enabled on pre CASSANDRA-10657 (3.4-), queried columns are not considered at all, and it
                // is assumed that all columns are queried. CASSANDRA-10657 (3.4+) brings back skipping values of columns
                // which are not in queried set when fetchAll is enabled. That makes exactly the same filter being
                // interpreted in a different way on 3.4- and 3.4+.
                //
                // Moreover, there is no way to convert the filter with fetchAll and queried != null so that it is
                // interpreted the same way on 3.4- because that Cassandra version does not support such filtering.
                //
                // In order to avoid inconsitencies in data read by 3.4- and 3.4+ we need to avoid creation of incompatible
                // filters when the cluster contains 3.4- nodes. We do that by forcibly setting queried to null.
                //
                // see CASSANDRA-10657, CASSANDRA-15833, CASSANDRA-16415
                if (queried == null || isUpgradingFromVersionLowerThan34())
                {
                    return new WildCardColumnFilter(metadata.regularAndStaticColumns());
                }

                // pre CASSANDRA-12768 (4.0-) all static columns should be fetched along with all regular columns.
                if (isUpgradingFromVersionLowerThan40())
                {
                    return SelectionColumnFilter.newInstance(FetchingStrategy.ALL_COLUMNS, metadata, queried, s);
                }

                // pre CASSANDRA-16686 (4.0-RC2-) static columns where not fetched unless queried witch lead to some wrong results
                // for some queries
                if (!returnStaticContentOnPartitionWithNoRows || isUpgradingFromVersionLowerThan40RC2())
                {
                    return SelectionColumnFilter.newInstance(FetchingStrategy.ALL_REGULARS_AND_QUERIED_STATICS_COLUMNS, metadata, queried, s);
                }

                return SelectionColumnFilter.newInstance(FetchingStrategy.ALL_COLUMNS, metadata, queried, s);
            }

            return SelectionColumnFilter.newInstance(FetchingStrategy.ONLY_QUERIED_COLUMNS, (TableMetadata) null, queried, s);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.schema.CachingParams:asMap(),asMap,CachingParams,../data/xml/cassandra_call_methods/CachingParams.xml,"
public Map<String, String> asMap()
    {
        return ImmutableMap.of(Option.KEYS.toString(),
                               keysAsString(),
                               Option.ROWS_PER_PARTITION.toString(),
                               rowsPerPartitionAsString());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.schema.CompactionParams:asMap(),asMap,CompactionParams,../data/xml/cassandra_call_methods/CompactionParams.xml,"
public Map<String, String> asMap()
    {
        Map<String, String> map = new HashMap<>(options());
        map.put(Option.CLASS.toString(), klass.getName());
        return map;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.schema.CompressionParams:asMap(),asMap,CompressionParams,../data/xml/cassandra_call_methods/CompressionParams.xml,"
public Map<String, String> asMap()
    {
        if (!isEnabled())
            return Collections.singletonMap(ENABLED, ""false"");

        Map<String, String> options = new HashMap<>(otherOptions);
        options.put(CLASS, sstableCompressor.getClass().getName());
        options.put(CHUNK_LENGTH_IN_KB, chunkLengthInKB());
        if (minCompressRatio != DEFAULT_MIN_COMPRESS_RATIO)
            options.put(MIN_COMPRESS_RATIO, String.valueOf(minCompressRatio));

        return options;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:isCDCEnabled(),cdc_enabled,(M)org.apache.cassandra.service.reads.repair.ReadRepairStrategy:toString(),toString,ReadRepairStrategy,../data/xml/cassandra_call_methods/ReadRepairStrategy.xml,not found
