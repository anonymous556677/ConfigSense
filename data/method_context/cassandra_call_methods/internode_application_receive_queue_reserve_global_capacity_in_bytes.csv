function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.MessagingServiceMBeanImpl:<init>(boolean),<init>,MessagingServiceMBeanImpl,../data/xml/cassandra_call_methods/MessagingServiceMBeanImpl.xml,"
MessagingServiceMBeanImpl(boolean testOnly)
    {
        if (!testOnly)
        {
            MBeanWrapper.instance.registerMBean(this, MBEAN_NAME);
            metrics.scheduleLogging();
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.SocketFactory:<init>(),<init>,SocketFactory,../data/xml/cassandra_call_methods/SocketFactory.xml,"
SocketFactory()
    {
        this(Provider.optimalProvider());
    }

    

SocketFactory(Provider provider)
    {
        this.provider = provider;
        this.acceptGroup = provider.makeEventLoopGroup(1, ""Messaging-AcceptLoop"");
        this.defaultGroup = provider.makeEventLoopGroup(EVENT_THREADS, NamedThreadFactory.globalPrefix() + ""Messaging-EventLoop"");
        this.outboundStreamingGroup = provider.makeEventLoopGroup(EVENT_THREADS, ""Streaming-EventLoop"");
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.LatencySubscribers:<init>(),<init>,LatencySubscribers,../data/xml/cassandra_call_methods/LatencySubscribers.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.RequestCallbacks:<init>(org.apache.cassandra.net.MessagingService),<init>,RequestCallbacks,../data/xml/cassandra_call_methods/RequestCallbacks.xml,"
RequestCallbacks(MessagingService messagingService)
    {
        this.messagingService = messagingService;

        long expirationInterval = DatabaseDescriptor.getMinRpcTimeout(NANOSECONDS) / 2;
        executor.scheduleWithFixedDelay(this::expire, expirationInterval, expirationInterval, NANOSECONDS);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.InboundSink:<init>(org.apache.cassandra.net.MessagingService),<init>,InboundSink,../data/xml/cassandra_call_methods/InboundSink.xml,"
InboundSink(MessagingService messaging)
    {
        this.messaging = messaging;
        this.sink = message -> message.header.verb.handler().doVerb((Message<Object>) message);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes()
    {
        return conf.internode_application_receive_queue_reserve_global_capacity_in_bytes;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.ResourceLimits$Concurrent:<init>(long),<init>,ResourceLimits$Concurrent,../data/xml/cassandra_call_methods/ResourceLimits.xml,"
public abstract class ResourceLimits
{
    /**
     * Represents permits to utilise a resource and ways to allocate and release them.
     *
     * Two implementations are currently provided:
     * 1. {@link Concurrent}, for shared limits, which is thread-safe;
     * 2. {@link Basic}, for limits that are not shared between threads, is not thread-safe.
     */
    public interface Limit
    {
        /**
         * @return total amount of permits represented by this {@link Limit} - the capacity
         */
        long limit();

        /**
         * Sets the total amount of permits represented by this {@link Limit} - the capacity
         *
         * If the old limit has been reached and the new limit is large enough to allow for more
         * permits to be aqcuired, subsequent calls to {@link #allocate(long)} or {@link #tryAllocate(long)}
         * will succeed.
         *
         * If the new limit is lower than the current amount of allocated permits then subsequent calls
         * to {@link #allocate(long)} or {@link #tryAllocate(long)} will block or fail respectively.
         *
         * @return the old limit
         */
        long setLimit(long newLimit);

        /**
         * @return remaining, unallocated permit amount
         */
        long remaining();

        /**
         * @return amount of permits currently in use
         */
        long using();

        /**
         * Attempts to allocate an amount of permits from this limit. If allocated, <em>MUST</em> eventually
         * be released back with {@link #release(long)}.
         *
         * @return {@code true} if the allocation was successful, {@code false} otherwise
         */
        boolean tryAllocate(long amount);

        /**
         * Allocates an amount independent of permits available from this limit. <em>MUST</em> eventually
         * be released back with {@link #release(long)}.
         *
         */
        void allocate(long amount);

        /**
         * @param amount return the amount of permits back to this limit
         * @return {@code ABOVE_LIMIT} if there aren't enough permits available even after the release, or
         *         {@code BELOW_LIMIT} if there are enough permits available after the releaese.
         */
        Outcome release(long amount);
    }

    /**
     * A thread-safe permit container.
     */
    public static class Concurrent implements Limit
    {
        private volatile long limit;
        private static final AtomicLongFieldUpdater<Concurrent> limitUpdater =
            AtomicLongFieldUpdater.newUpdater(Concurrent.class, ""limit"");

        private volatile long using;
        private static final AtomicLongFieldUpdater<Concurrent> usingUpdater =
            AtomicLongFieldUpdater.newUpdater(Concurrent.class, ""using"");

        public Concurrent(long limit)
        {
            this.limit = limit;
        }

        public long limit()
        {
            return limit;
        }

        public long setLimit(long newLimit)
        {
            long oldLimit;
            do {
                oldLimit = limit;
            } while (!limitUpdater.compareAndSet(this, oldLimit, newLimit));

            return oldLimit;
        }

        public long remaining()
        {
            return limit - using;
        }

        public long using()
        {
            return using;
        }

        public boolean tryAllocate(long amount)
        {
            long current, next;
            do
            {
                current = using;
                next = current + amount;

                if (next > limit)
                    return false;
            }
            while (!usingUpdater.compareAndSet(this, current, next));

            return true;
        }

        public void allocate(long amount)
        {
            long current, next;
            do
            {
                current = using;
                next = current + amount;
            } while (!usingUpdater.compareAndSet(this, current, next));
        }

        public Outcome release(long amount)
        {
            assert amount >= 0;
            long using = usingUpdater.addAndGet(this, -amount);
            if (using < 0L)
            {
                // Should never be able to release more than was allocated.  While recovery is
                // possible it would require synchronizing the closing of all outbound connections
                // and reinitializing the Concurrent limit before reopening.  For such an unlikely path
                // (previously this was an assert), it is safer to terminate the JVM and have something external
                // restart and get back to a known good state rather than intermittendly crashing on any of
                // the connections sharing this limit.
                throw new UnrecoverableIllegalStateException(
                    ""Internode messaging byte limits that are shared between connections is invalid (using=""+using+"")"");
            }
            return using >= limit ? Outcome.ABOVE_LIMIT : Outcome.BELOW_LIMIT;
        }
    }

    /**
     * A cheaper, thread-unsafe permit container to be used for unshared limits.
     */
    public static class Basic implements Limit
    {
        private long limit;
        private long using;

        public Basic(long limit)
        {
            this.limit = limit;
        }

        public long limit()
        {
            return limit;
        }

        public long setLimit(long newLimit)
        {
            long oldLimit = limit;
            limit = newLimit;

            return oldLimit;
        }

        public long remaining()
        {
            return limit - using;
        }

        public long using()
        {
            return using;
        }

        public boolean tryAllocate(long amount)
        {
            if (using + amount > limit)
                return false;

            using += amount;
            return true;
        }

        public void allocate(long amount)
        {
            using += amount;
        }

        public Outcome release(long amount)
        {
            assert amount >= 0 && amount <= using;
            using -= amount;
            return using >= limit ? Outcome.ABOVE_LIMIT : Outcome.BELOW_LIMIT;
        }
    }

    /**
     * A convenience class that groups a per-endpoint limit with the global one
     * to allow allocating/releasing permits from/to both limits as one logical operation.
     */
    public static class EndpointAndGlobal
    {
        final Limit endpoint;
        final Limit global;

        public EndpointAndGlobal(Limit endpoint, Limit global)
        {
            this.endpoint = endpoint;
            this.global = global;
        }

        public Limit endpoint()
        {
            return endpoint;
        }

        public Limit global()
        {
            return global;
        }

        /**
         * @return {@code INSUFFICIENT_GLOBAL} if there weren't enough permits in the global limit, or
         *         {@code INSUFFICIENT_ENDPOINT} if there weren't enough permits in the per-endpoint limit, or
         *         {@code SUCCESS} if there were enough permits to take from both.
         */
        public Outcome tryAllocate(long amount)
        {
            if (!global.tryAllocate(amount))
                return Outcome.INSUFFICIENT_GLOBAL;

            if (endpoint.tryAllocate(amount))
                return Outcome.SUCCESS;

            global.release(amount);
            return Outcome.INSUFFICIENT_ENDPOINT;
        }

        public void allocate(long amount)
        {
            global.allocate(amount);
            endpoint.allocate(amount);
        }

        public Outcome release(long amount)
        {
            Outcome endpointReleaseOutcome = endpoint.release(amount);
            Outcome globalReleaseOutcome = global.release(amount);
            return (endpointReleaseOutcome == Outcome.ABOVE_LIMIT || globalReleaseOutcome == Outcome.ABOVE_LIMIT)
                   ? Outcome.ABOVE_LIMIT : Outcome.BELOW_LIMIT;
        }
    }

    public enum Outcome { SUCCESS, INSUFFICIENT_ENDPOINT, INSUFFICIENT_GLOBAL, BELOW_LIMIT, ABOVE_LIMIT }
}
"
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.InboundMessageHandlers$GlobalResourceLimits:<init>(org.apache.cassandra.net.ResourceLimits$Limit),<init>,InboundMessageHandlers$GlobalResourceLimits,../data/xml/cassandra_call_methods/InboundMessageHandlers.xml,"/**
 * An aggregation of {@link InboundMessageHandler}s for all connections from a peer.
 *
 * Manages metrics and shared resource limits. Can have multiple connections of a single
 * type open simultaneousely (legacy in particular).
 */
public final class InboundMessageHandlers
{
    private final InetAddressAndPort self;
    private final InetAddressAndPort peer;

    private final int queueCapacity;
    private final ResourceLimits.Limit endpointReserveCapacity;
    private final ResourceLimits.Limit globalReserveCapacity;

    private final InboundMessageHandler.WaitQueue endpointWaitQueue;
    private final InboundMessageHandler.WaitQueue globalWaitQueue;

    private final InboundCounters urgentCounters = new InboundCounters();
    private final InboundCounters smallCounters  = new InboundCounters();
    private final InboundCounters largeCounters  = new InboundCounters();
    private final InboundCounters legacyCounters = new InboundCounters();

    private final InboundMessageCallbacks urgentCallbacks;
    private final InboundMessageCallbacks smallCallbacks;
    private final InboundMessageCallbacks largeCallbacks;
    private final InboundMessageCallbacks legacyCallbacks;

    private final InternodeInboundMetrics metrics;
    private final MessageConsumer messageConsumer;

    private final HandlerProvider handlerProvider;
    private final Collection<InboundMessageHandler> handlers = new CopyOnWriteArrayList<>();

    static class GlobalResourceLimits
    {
        final ResourceLimits.Limit reserveCapacity;
        final InboundMessageHandler.WaitQueue waitQueue;

        GlobalResourceLimits(ResourceLimits.Limit reserveCapacity)
        {
            this.reserveCapacity = reserveCapacity;
            this.waitQueue = InboundMessageHandler.WaitQueue.global(reserveCapacity);
        }
    }

    public interface MessageConsumer extends Consumer<Message<?>>
    {
        void fail(Message.Header header, Throwable failure);
    }

    public interface GlobalMetricCallbacks
    {
        LatencyConsumer internodeLatencyRecorder(InetAddressAndPort to);
        void recordInternalLatency(Verb verb, long timeElapsed, TimeUnit timeUnit);
        void recordInternodeDroppedMessage(Verb verb, long timeElapsed, TimeUnit timeUnit);
    }

    public InboundMessageHandlers(InetAddressAndPort self,
                                  InetAddressAndPort peer,
                                  int queueCapacity,
                                  long endpointReserveCapacity,
                                  GlobalResourceLimits globalResourceLimits,
                                  GlobalMetricCallbacks globalMetricCallbacks,
                                  MessageConsumer messageConsumer)
    {
        this(self, peer, queueCapacity, endpointReserveCapacity, globalResourceLimits, globalMetricCallbacks, messageConsumer, InboundMessageHandler::new);
    }

    public InboundMessageHandlers(InetAddressAndPort self,
                                  InetAddressAndPort peer,
                                  int queueCapacity,
                                  long endpointReserveCapacity,
                                  GlobalResourceLimits globalResourceLimits,
                                  GlobalMetricCallbacks globalMetricCallbacks,
                                  MessageConsumer messageConsumer,
                                  HandlerProvider handlerProvider)
    {
        this.self = self;
        this.peer = peer;

        this.queueCapacity = queueCapacity;
        this.endpointReserveCapacity = new ResourceLimits.Concurrent(endpointReserveCapacity);
        this.globalReserveCapacity = globalResourceLimits.reserveCapacity;
        this.endpointWaitQueue = InboundMessageHandler.WaitQueue.endpoint(this.endpointReserveCapacity);
        this.globalWaitQueue = globalResourceLimits.waitQueue;
        this.messageConsumer = messageConsumer;

        this.handlerProvider = handlerProvider;

        urgentCallbacks = makeMessageCallbacks(peer, urgentCounters, globalMetricCallbacks, messageConsumer);
        smallCallbacks  = makeMessageCallbacks(peer, smallCounters,  globalMetricCallbacks, messageConsumer);
        largeCallbacks  = makeMessageCallbacks(peer, largeCounters,  globalMetricCallbacks, messageConsumer);
        legacyCallbacks = makeMessageCallbacks(peer, legacyCounters, globalMetricCallbacks, messageConsumer);

        metrics = new InternodeInboundMetrics(peer, this);
    }

    InboundMessageHandler createHandler(FrameDecoder frameDecoder, ConnectionType type, Channel channel, int version)
    {
        InboundMessageHandler handler =
            handlerProvider.provide(frameDecoder,

                                    type,
                                    channel,
                                    self,
                                    peer,
                                    version,
                                    OutboundConnections.LARGE_MESSAGE_THRESHOLD,

                                    queueCapacity,
                                    endpointReserveCapacity,
                                    globalReserveCapacity,
                                    endpointWaitQueue,
                                    globalWaitQueue,

                                    this::onHandlerClosed,
                                    callbacksFor(type),
                                    messageConsumer);
        handlers.add(handler);
        return handler;
    }

    void releaseMetrics()
    {
        metrics.release();
    }

    private void onHandlerClosed(AbstractMessageHandler handler)
    {
        assert handler instanceof InboundMessageHandler;
        handlers.remove(handler);
        absorbCounters((InboundMessageHandler)handler);
    }

    @VisibleForTesting
    public int count()
    {
        return handlers.size();
    }

    /*
     * Message callbacks
     */

    private InboundMessageCallbacks callbacksFor(ConnectionType type)
    {
        switch (type)
        {
            case URGENT_MESSAGES: return urgentCallbacks;
            case  SMALL_MESSAGES: return smallCallbacks;
            case  LARGE_MESSAGES: return largeCallbacks;
            case LEGACY_MESSAGES: return legacyCallbacks;
        }

        throw new IllegalArgumentException();
    }

    private static InboundMessageCallbacks makeMessageCallbacks(InetAddressAndPort peer, InboundCounters counters, GlobalMetricCallbacks globalMetrics, MessageConsumer messageConsumer)
    {
        LatencyConsumer internodeLatency = globalMetrics.internodeLatencyRecorder(peer);

        return new InboundMessageCallbacks()
        {
            @Override
            public void onHeaderArrived(int messageSize, Header header, long timeElapsed, TimeUnit unit)
            {
                // do not log latency if we are within error bars of zero
                if (timeElapsed > unit.convert(approxTime.error(), NANOSECONDS))
                    internodeLatency.accept(timeElapsed, unit);
            }

            @Override
            public void onArrived(int messageSize, Header header, long timeElapsed, TimeUnit unit)
            {
            }

            @Override
            public void onArrivedExpired(int messageSize, Header header, boolean wasCorrupt, long timeElapsed, TimeUnit unit)
            {
                counters.addExpired(messageSize);

                globalMetrics.recordInternodeDroppedMessage(header.verb, timeElapsed, unit);
            }

            @Override
            public void onArrivedCorrupt(int messageSize, Header header, long timeElapsed, TimeUnit unit)
            {
                counters.addError(messageSize);

                messageConsumer.fail(header, new Crc.InvalidCrc(0, 0)); // could use one of the original exceptions?
            }

            @Override
            public void onClosedBeforeArrival(int messageSize, Header header, int bytesReceived, boolean wasCorrupt, boolean wasExpired)
            {
                counters.addError(messageSize);

                messageConsumer.fail(header, new InvalidSerializedSizeException(header.verb, messageSize, bytesReceived));
            }

            @Override
            public void onExpired(int messageSize, Header header, long timeElapsed, TimeUnit unit)
            {
                counters.addExpired(messageSize);

                globalMetrics.recordInternodeDroppedMessage(header.verb, timeElapsed, unit);
            }

            @Override
            public void onFailedDeserialize(int messageSize, Header header, Throwable t)
            {
                counters.addError(messageSize);

                /*
                 * If an exception is caught during deser, return a failure response immediately
                 * instead of waiting for the callback on the other end to expire.
                 */
                messageConsumer.fail(header, t);
            }

            @Override
            public void onDispatched(int messageSize, Header header)
            {
                counters.addPending(messageSize);
            }

            @Override
            public void onExecuting(int messageSize, Header header, long timeElapsed, TimeUnit unit)
            {
                globalMetrics.recordInternalLatency(header.verb, timeElapsed, unit);
            }

            @Override
            public void onExecuted(int messageSize, Header header, long timeElapsed, TimeUnit unit)
            {
                counters.removePending(messageSize);
            }

            @Override
            public void onProcessed(int messageSize, Header header)
            {
                counters.addProcessed(messageSize);
            }
        };
    }

    /*
     * Aggregated counters
     */

    InboundCounters countersFor(ConnectionType type)
    {
        switch (type)
        {
            case URGENT_MESSAGES: return urgentCounters;
            case  SMALL_MESSAGES: return smallCounters;
            case  LARGE_MESSAGES: return largeCounters;
            case LEGACY_MESSAGES: return legacyCounters;
        }

        throw new IllegalArgumentException();
    }

    public long receivedCount()
    {
        return sumHandlers(h -> h.receivedCount) + closedReceivedCount;
    }

    public long receivedBytes()
    {
        return sumHandlers(h -> h.receivedBytes) + closedReceivedBytes;
    }

    public long throttledCount()
    {
        return sumHandlers(h -> h.throttledCount) + closedThrottledCount;
    }

    public long throttledNanos()
    {
        return sumHandlers(h -> h.throttledNanos) + closedThrottledNanos;
    }

    public long usingCapacity()
    {
        return sumHandlers(h -> h.queueSize);
    }

    public long usingEndpointReserveCapacity()
    {
        return endpointReserveCapacity.using();
    }

    public long corruptFramesRecovered()
    {
        return sumHandlers(h -> h.corruptFramesRecovered) + closedCorruptFramesRecovered;
    }

    public long corruptFramesUnrecovered()
    {
        return sumHandlers(h -> h.corruptFramesUnrecovered) + closedCorruptFramesUnrecovered;
    }

    public long errorCount()
    {
        return sumCounters(InboundCounters::errorCount);
    }

    public long errorBytes()
    {
        return sumCounters(InboundCounters::errorBytes);
    }

    public long expiredCount()
    {
        return sumCounters(InboundCounters::expiredCount);
    }

    public long expiredBytes()
    {
        return sumCounters(InboundCounters::expiredBytes);
    }

    public long processedCount()
    {
        return sumCounters(InboundCounters::processedCount);
    }

    public long processedBytes()
    {
        return sumCounters(InboundCounters::processedBytes);
    }

    public long scheduledCount()
    {
        return sumCounters(InboundCounters::scheduledCount);
    }

    public long scheduledBytes()
    {
        return sumCounters(InboundCounters::scheduledBytes);
    }

    /*
     * 'Archived' counter values, combined for all connections that have been closed.
     */

    private volatile long closedReceivedCount, closedReceivedBytes;

    private static final AtomicLongFieldUpdater<InboundMessageHandlers> closedReceivedCountUpdater =
        AtomicLongFieldUpdater.newUpdater(InboundMessageHandlers.class, ""closedReceivedCount"");
    private static final AtomicLongFieldUpdater<InboundMessageHandlers> closedReceivedBytesUpdater =
        AtomicLongFieldUpdater.newUpdater(InboundMessageHandlers.class, ""closedReceivedBytes"");

    private volatile long closedThrottledCount, closedThrottledNanos;

    private static final AtomicLongFieldUpdater<InboundMessageHandlers> closedThrottledCountUpdater =
        AtomicLongFieldUpdater.newUpdater(InboundMessageHandlers.class, ""closedThrottledCount"");
    private static final AtomicLongFieldUpdater<InboundMessageHandlers> closedThrottledNanosUpdater =
        AtomicLongFieldUpdater.newUpdater(InboundMessageHandlers.class, ""closedThrottledNanos"");

    private volatile long closedCorruptFramesRecovered, closedCorruptFramesUnrecovered;

    private static final AtomicLongFieldUpdater<InboundMessageHandlers> closedCorruptFramesRecoveredUpdater =
        AtomicLongFieldUpdater.newUpdater(InboundMessageHandlers.class, ""closedCorruptFramesRecovered"");
    private static final AtomicLongFieldUpdater<InboundMessageHandlers> closedCorruptFramesUnrecoveredUpdater =
        AtomicLongFieldUpdater.newUpdater(InboundMessageHandlers.class, ""closedCorruptFramesUnrecovered"");

    private void absorbCounters(InboundMessageHandler handler)
    {
        closedReceivedCountUpdater.addAndGet(this, handler.receivedCount);
        closedReceivedBytesUpdater.addAndGet(this, handler.receivedBytes);

        closedThrottledCountUpdater.addAndGet(this, handler.throttledCount);
        closedThrottledNanosUpdater.addAndGet(this, handler.throttledNanos);

        closedCorruptFramesRecoveredUpdater.addAndGet(this, handler.corruptFramesRecovered);
        closedCorruptFramesUnrecoveredUpdater.addAndGet(this, handler.corruptFramesUnrecovered);
    }

    private long sumHandlers(ToLongFunction<InboundMessageHandler> counter)
    {
        long sum = 0L;
        for (InboundMessageHandler h : handlers)
            sum += counter.applyAsLong(h);
        return sum;
    }

    private long sumCounters(ToLongFunction<InboundCounters> mapping)
    {
        return mapping.applyAsLong(urgentCounters)
             + mapping.applyAsLong(smallCounters)
             + mapping.applyAsLong(largeCounters)
             + mapping.applyAsLong(legacyCounters);
    }

    interface HandlerProvider
    {
        InboundMessageHandler provide(FrameDecoder decoder,

                                      ConnectionType type,
                                      Channel channel,
                                      InetAddressAndPort self,
                                      InetAddressAndPort peer,
                                      int version,
                                      int largeMessageThreshold,

                                      int queueCapacity,
                                      ResourceLimits.Limit endpointReserveCapacity,
                                      ResourceLimits.Limit globalReserveCapacity,
                                      InboundMessageHandler.WaitQueue endpointWaitQueue,
                                      InboundMessageHandler.WaitQueue globalWaitQueue,

                                      InboundMessageHandler.OnHandlerClosed onClosed,
                                      InboundMessageCallbacks callbacks,
                                      Consumer<Message<?>> consumer);
    }
}


public InboundMessageHandlers(InetAddressAndPort self,
                                  InetAddressAndPort peer,
                                  int queueCapacity,
                                  long endpointReserveCapacity,
                                  GlobalResourceLimits globalResourceLimits,
                                  GlobalMetricCallbacks globalMetricCallbacks,
                                  MessageConsumer messageConsumer)
    {
        this(self, peer, queueCapacity, endpointReserveCapacity, globalResourceLimits, globalMetricCallbacks, messageConsumer, InboundMessageHandler::new);
    }

    

public InboundMessageHandlers(InetAddressAndPort self,
                                  InetAddressAndPort peer,
                                  int queueCapacity,
                                  long endpointReserveCapacity,
                                  GlobalResourceLimits globalResourceLimits,
                                  GlobalMetricCallbacks globalMetricCallbacks,
                                  MessageConsumer messageConsumer,
                                  HandlerProvider handlerProvider)
    {
        this.self = self;
        this.peer = peer;

        this.queueCapacity = queueCapacity;
        this.endpointReserveCapacity = new ResourceLimits.Concurrent(endpointReserveCapacity);
        this.globalReserveCapacity = globalResourceLimits.reserveCapacity;
        this.endpointWaitQueue = InboundMessageHandler.WaitQueue.endpoint(this.endpointReserveCapacity);
        this.globalWaitQueue = globalResourceLimits.waitQueue;
        this.messageConsumer = messageConsumer;

        this.handlerProvider = handlerProvider;

        urgentCallbacks = makeMessageCallbacks(peer, urgentCounters, globalMetricCallbacks, messageConsumer);
        smallCallbacks  = makeMessageCallbacks(peer, smallCounters,  globalMetricCallbacks, messageConsumer);
        largeCallbacks  = makeMessageCallbacks(peer, largeCounters,  globalMetricCallbacks, messageConsumer);
        legacyCallbacks = makeMessageCallbacks(peer, legacyCounters, globalMetricCallbacks, messageConsumer);

        metrics = new InternodeInboundMetrics(peer, this);
    }

    

InboundMessageHandlers>

InboundMessageHandlers.class

InboundMessageHandlers>

InboundMessageHandlers.class

InboundMessageHandlers>

InboundMessageHandlers.class

InboundMessageHandlers>

InboundMessageHandlers.class

InboundMessageHandlers>

InboundMessageHandlers.class

InboundMessageHandlers>

InboundMessageHandlers.class"
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.InboundConnectionSettings:<init>(),<init>,InboundConnectionSettings,../data/xml/cassandra_call_methods/InboundConnectionSettings.xml,"
private InboundConnectionSettings(IInternodeAuthenticator authenticator,
                                      InetAddressAndPort bindAddress,
                                      ServerEncryptionOptions encryption,
                                      Integer socketReceiveBufferSizeInBytes,
                                      Integer applicationReceiveQueueCapacityInBytes,
                                      AcceptVersions acceptMessaging,
                                      AcceptVersions acceptStreaming,
                                      SocketFactory socketFactory,
                                      Function<InetAddressAndPort, InboundMessageHandlers> handlers)
    {
        this.authenticator = authenticator;
        this.bindAddress = bindAddress;
        this.encryption = encryption;
        this.socketReceiveBufferSizeInBytes = socketReceiveBufferSizeInBytes;
        this.applicationReceiveQueueCapacityInBytes = applicationReceiveQueueCapacityInBytes;
        this.acceptMessaging = acceptMessaging;
        this.acceptStreaming = acceptStreaming;
        this.socketFactory = socketFactory;
        this.handlers = handlers;
    }

    

public InboundConnectionSettings()
    {
        this(null, null, null, null, null, null, null, null, null);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(M)org.apache.cassandra.net.InboundConnectionSettings:withSocketFactory(org.apache.cassandra.net.SocketFactory),withSocketFactory,InboundConnectionSettings,../data/xml/cassandra_call_methods/InboundConnectionSettings.xml,"
public InboundConnectionSettings withSocketFactory(SocketFactory socketFactory)
    {
        return new InboundConnectionSettings(authenticator, bindAddress, encryption,
                                             socketReceiveBufferSizeInBytes, applicationReceiveQueueCapacityInBytes,
                                             acceptMessaging, acceptStreaming, socketFactory, handlers);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.InboundSockets:<init>(org.apache.cassandra.net.InboundConnectionSettings),<init>,InboundSockets,../data/xml/cassandra_call_methods/InboundSockets.xml,"
InboundSockets(InboundConnectionSettings template)
    {
        this(withDefaultBindAddresses(template));
    }

    

InboundSockets(List<InboundConnectionSettings> templates)
    {
        this.sockets = bindings(templates);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(D)org.apache.cassandra.net.OutboundSink$Sink:accept(org.apache.cassandra.net.MessagingService),accept,OutboundSink$Sink,../data/xml/cassandra_call_methods/OutboundSink.xml,"
public void accept(Message<?> message, InetAddressAndPort to, ConnectionType connectionType)
        {
            if (condition.test(message, to))
                next.accept(message, to, connectionType);
        }
    }

public void accept(Message<?> message, InetAddressAndPort to, ConnectionType connectionType)
    {
        sink.accept(message, to, connectionType);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(O)org.apache.cassandra.net.OutboundSink:<init>(org.apache.cassandra.net.OutboundSink$Sink),<init>,OutboundSink,../data/xml/cassandra_call_methods/OutboundSink.xml,"
OutboundSink(Sink sink)
    {
        this.sink = sink;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes(),internode_application_receive_queue_reserve_global_capacity_in_bytes,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeApplicationSendQueueReserveGlobalCapacityInBytes(),getInternodeApplicationSendQueueReserveGlobalCapacityInBytes,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getInternodeApplicationSendQueueReserveGlobalCapacityInBytes()
    {
        return conf.internode_application_send_queue_reserve_global_capacity_in_bytes;
    }

    "
