function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(S)org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),getEnableMaterializedViews,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean getEnableMaterializedViews()
    {
        return conf.enable_materialized_views;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.KeyspaceMetadata:createReplicationStrategy(),createReplicationStrategy,KeyspaceMetadata,../data/xml/cassandra_call_methods/KeyspaceMetadata.xml,"
public AbstractReplicationStrategy createReplicationStrategy()
    {
        return AbstractReplicationStrategy.createReplicationStrategy(name,
                                                                     params.replication.klass,
                                                                     StorageService.instance.getTokenMetadata(),
                                                                     DatabaseDescriptor.getEndpointSnitch(),
                                                                     params.replication.options);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:hasTransientReplicas(),hasTransientReplicas,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,"
public boolean hasTransientReplicas()
    {
        return getReplicationFactor().hasTransientReplicas();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata:isCounter(),isCounter,TableMetadata,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public boolean isCounter()
    {
        return flags.contains(Flag.COUNTER);
    }

    

public Builder isCounter(boolean val)
        {
            return flag(Flag.COUNTER, val);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata:isView(),isView,TableMetadata,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public boolean isView()
    {
        return kind == Kind.VIEW;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata:columns(),columns,TableMetadata,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public ImmutableCollection<ColumnMetadata> columns()
    {
        return columns.values();
    }

    

public Iterable<ColumnMetadata> columns()
        {
            return columns.values();
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata:primaryKeyColumns(),primaryKeyColumns,TableMetadata,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public Iterable<ColumnMetadata> primaryKeyColumns()
    {
        return Iterables.concat(partitionKeyColumns, clusteringColumns);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.WhereClause:containsTokenRelations(),containsTokenRelations,WhereClause,../data/xml/cassandra_call_methods/WhereClause.xml,"/**
     * Checks if the where clause contains some token relations.
     *
     * @return {@code true} if it is the case, {@code false} otherwise.
     */
public boolean containsTokenRelations()
    {
        for (Relation rel : relations)
        {
            if (rel.onToken())
                return true;
        }
        return false;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.WhereClause:containsCustomExpressions(),containsCustomExpressions,WhereClause,../data/xml/cassandra_call_methods/WhereClause.xml,"
public boolean containsCustomExpressions()
    {
        return !expressions.isEmpty();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(S)org.apache.cassandra.cql3.VariableSpecifications:empty(),empty,VariableSpecifications,../data/xml/cassandra_call_methods/VariableSpecifications.xml,"/**
     * Returns an empty instance of <code>VariableSpecifications</code>.
     * @return an empty instance of <code>VariableSpecifications</code>
     */
public static VariableSpecifications empty()
    {
        return new VariableSpecifications(Collections.emptyList());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,"(O)org.apache.cassandra.cql3.restrictions.StatementRestrictions:<init>(org.apache.cassandra.cql3.statements.StatementType,org.apache.cassandra.schema.TableMetadata,org.apache.cassandra.cql3.WhereClause,org.apache.cassandra.cql3.VariableSpecifications,boolean,boolean,boolean,boolean)",<init>,StatementRestrictions,../data/xml/cassandra_call_methods/StatementRestrictions.xml,"
private StatementRestrictions(StatementType type, TableMetadata table, boolean allowFiltering)
    {
        this.type = type;
        this.table = table;
        this.partitionKeyRestrictions = new PartitionKeySingleRestrictionSet(table.partitionKeyAsClusteringComparator());
        this.clusteringColumnsRestrictions = new ClusteringColumnRestrictions(table, allowFiltering);
        this.nonPrimaryKeyRestrictions = new RestrictionSet();
        this.notNullColumns = new HashSet<>();
    }

    

public StatementRestrictions(StatementType type,
                                 TableMetadata table,
                                 WhereClause whereClause,
                                 VariableSpecifications boundNames,
                                 boolean selectsOnlyStaticColumns,
                                 boolean allowFiltering,
                                 boolean forView)
    {
        this(type, table, whereClause, boundNames, selectsOnlyStaticColumns, type.allowUseOfSecondaryIndices(), allowFiltering, forView);
    }

    
/*
     * We want to override allowUseOfSecondaryIndices flag from the StatementType for MV statements
     * to avoid initing the Keyspace and SecondaryIndexManager.
     */
public StatementRestrictions(StatementType type,
                                 TableMetadata table,
                                 WhereClause whereClause,
                                 VariableSpecifications boundNames,
                                 boolean selectsOnlyStaticColumns,
                                 boolean allowUseOfSecondaryIndices,
                                 boolean allowFiltering,
                                 boolean forView)
    {
        this(type, table, allowFiltering);

        IndexRegistry indexRegistry = null;
        if (type.allowUseOfSecondaryIndices())
            indexRegistry = IndexRegistry.obtain(table);

        /*
         * WHERE clause. For a given entity, rules are:
         *   - EQ relation conflicts with anything else (including a 2nd EQ)
         *   - Can't have more than one LT(E) relation (resp. GT(E) relation)
         *   - IN relation are restricted to row keys (for now) and conflicts with anything else (we could
         *     allow two IN for the same entity but that doesn't seem very useful)
         *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value
         *     in CQL so far)
         *   - CONTAINS and CONTAINS_KEY cannot be used with UPDATE or DELETE
         */
        for (Relation relation : whereClause.relations)
        {
            if ((relation.isContains() || relation.isContainsKey()) && (type.isUpdate() || type.isDelete()))
            {
                throw invalidRequest(""Cannot use %s with %s"", type, relation.operator());
            }

            if (relation.operator() == Operator.IS_NOT)
            {
                if (!forView)
                    throw new InvalidRequestException(""Unsupported restriction: "" + relation);

                this.notNullColumns.addAll(relation.toRestriction(table, boundNames).getColumnDefs());
            }
            else if (relation.isLIKE())
            {
                Restriction restriction = relation.toRestriction(table, boundNames);

                if (!type.allowUseOfSecondaryIndices() || !restriction.hasSupportingIndex(indexRegistry))
                    throw new InvalidRequestException(String.format(""LIKE restriction is only supported on properly "" +
                                                                    ""indexed columns. %s is not valid."",
                                                                    relation.toString()));

                addRestriction(restriction);
            }
            else
            {
                addRestriction(relation.toRestriction(table, boundNames));
            }
        }

        hasRegularColumnsRestrictions = nonPrimaryKeyRestrictions.hasRestrictionFor(ColumnMetadata.Kind.REGULAR);

        boolean hasQueriableClusteringColumnIndex = false;
        boolean hasQueriableIndex = false;

        if (allowUseOfSecondaryIndices)
        {
            if (whereClause.containsCustomExpressions())
                processCustomIndexExpressions(whereClause.expressions, boundNames, indexRegistry);

            hasQueriableClusteringColumnIndex = clusteringColumnsRestrictions.hasSupportingIndex(indexRegistry);
            hasQueriableIndex = !filterRestrictions.getCustomIndexExpressions().isEmpty()
                    || hasQueriableClusteringColumnIndex
                    || partitionKeyRestrictions.hasSupportingIndex(indexRegistry)
                    || nonPrimaryKeyRestrictions.hasSupportingIndex(indexRegistry);
        }

        // At this point, the select statement if fully constructed, but we still have a few things to validate
        processPartitionKeyRestrictions(hasQueriableIndex, allowFiltering, forView);

        // Some but not all of the partition key columns have been specified;
        // hence we need turn these restrictions into a row filter.
        if (usesSecondaryIndexing || partitionKeyRestrictions.needFiltering(table))
            filterRestrictions.add(partitionKeyRestrictions);

        if (selectsOnlyStaticColumns && hasClusteringColumnsRestrictions())
        {
            // If the only updated/deleted columns are static, then we don't need clustering columns.
            // And in fact, unless it is an INSERT, we reject if clustering colums are provided as that
            // suggest something unintended. For instance, given:
            //   CREATE TABLE t (k int, v int, s int static, PRIMARY KEY (k, v))
            // it can make sense to do:
            //   INSERT INTO t(k, v, s) VALUES (0, 1, 2)
            // but both
            //   UPDATE t SET s = 3 WHERE k = 0 AND v = 1
            //   DELETE v FROM t WHERE k = 0 AND v = 1
            // sounds like you don't really understand what your are doing.
            if (type.isDelete() || type.isUpdate())
                throw invalidRequest(""Invalid restrictions on clustering columns since the %s statement modifies only static columns"",
                                     type);
            if (type.isSelect())
                throw invalidRequest(""Cannot restrict clustering columns when selecting only static columns"");
        }

        processClusteringColumnsRestrictions(hasQueriableIndex,
                                             selectsOnlyStaticColumns,
                                             forView,
                                             allowFiltering);

        // Covers indexes on the first clustering column (among others).
        if (isKeyRange && hasQueriableClusteringColumnIndex)
            usesSecondaryIndexing = true;

        if (usesSecondaryIndexing || clusteringColumnsRestrictions.needFiltering())
            filterRestrictions.add(clusteringColumnsRestrictions);

        // Even if usesSecondaryIndexing is false at this point, we'll still have to use one if
        // there is restrictions not covered by the PK.
        if (!nonPrimaryKeyRestrictions.isEmpty())
        {
            if (!type.allowNonPrimaryKeyInWhereClause())
            {
                Collection<ColumnIdentifier> nonPrimaryKeyColumns =
                        ColumnMetadata.toIdentifiers(nonPrimaryKeyRestrictions.getColumnDefs());

                throw invalidRequest(""Non PRIMARY KEY columns found in where clause: %s "",
                                     Joiner.on("", "").join(nonPrimaryKeyColumns));
            }
            if (hasQueriableIndex)
                usesSecondaryIndexing = true;
            else if (!allowFiltering)
                throw invalidRequest(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE);

            filterRestrictions.add(nonPrimaryKeyRestrictions);
        }

        if (usesSecondaryIndexing)
            validateSecondaryIndexSelections();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,"(D)com.google.common.base.Predicate:apply(org.apache.cassandra.cql3.restrictions.StatementRestrictions,org.apache.cassandra.schema.TableMetadata)",apply,Predicate,../data/xml/cassandra_call_methods/cannot find.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.restrictions.StatementRestrictions:nonPKRestrictedColumns(boolean),nonPKRestrictedColumns,StatementRestrictions,../data/xml/cassandra_call_methods/StatementRestrictions.xml,"/**
     * Returns the non-PK column that are restricted.  If includeNotNullRestrictions is true, columns that are restricted
     * by an IS NOT NULL restriction will be included, otherwise they will not be included (unless another restriction
     * applies to them).
     */
public Set<ColumnMetadata> nonPKRestrictedColumns(boolean includeNotNullRestrictions)
    {
        Set<ColumnMetadata> columns = new HashSet<>();
        for (Restrictions r : filterRestrictions.getRestrictions())
        {
            for (ColumnMetadata def : r.getColumnDefs())
                if (!def.isPrimaryKeyColumn())
                    columns.add(def);
        }

        if (includeNotNullRestrictions)
        {
            for (ColumnMetadata def : notNullColumns)
            {
                if (!def.isPrimaryKeyColumn())
                    columns.add(def);
            }
        }

        return columns;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.statements.schema.TableAttributes:validate(),validate,TableAttributes,../data/xml/cassandra_call_methods/TableAttributes.xml,"
public void validate()
    {
        validate(validKeywords, obsoleteKeywords);
        build(TableParams.builder()).validate();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.statements.schema.TableAttributes:hasOption(org.apache.cassandra.schema.TableParams$Option),hasOption,TableAttributes,../data/xml/cassandra_call_methods/TableAttributes.xml,"
public boolean hasOption(Option option)
    {
        return hasProperty(option.toString());
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableParams$Option:toString(),toString,TableParams$Option,../data/xml/cassandra_call_methods/TableParams.xml,"
@Override
        public String toString()
        {
            return name().toLowerCase();
        }
    }

@Override
    public String toString()
    {
        return MoreObjects.toStringHelper(this)
                          .add(Option.COMMENT.toString(), comment)
                          .add(Option.BLOOM_FILTER_FP_CHANCE.toString(), bloomFilterFpChance)
                          .add(Option.CRC_CHECK_CHANCE.toString(), crcCheckChance)
                          .add(Option.GC_GRACE_SECONDS.toString(), gcGraceSeconds)
                          .add(Option.DEFAULT_TIME_TO_LIVE.toString(), defaultTimeToLive)
                          .add(Option.MEMTABLE_FLUSH_PERIOD_IN_MS.toString(), memtableFlushPeriodInMs)
                          .add(Option.MIN_INDEX_INTERVAL.toString(), minIndexInterval)
                          .add(Option.MAX_INDEX_INTERVAL.toString(), maxIndexInterval)
                          .add(Option.SPECULATIVE_RETRY.toString(), speculativeRetry)
                          .add(Option.CACHING.toString(), caching)
                          .add(Option.COMPACTION.toString(), compaction)
                          .add(Option.COMPRESSION.toString(), compression)
                          .add(Option.EXTENSIONS.toString(), extensions)
                          .add(Option.CDC.toString(), cdc)
                          .add(Option.READ_REPAIR.toString(), readRepair)
                          .toString();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.statements.schema.TableAttributes:getId(),getId,TableAttributes,../data/xml/cassandra_call_methods/TableAttributes.xml,"
public TableId getId() throws ConfigurationException
    {
        String id = getSimple(ID);
        try
        {
            return id != null ? TableId.fromString(id) : null;
        }
        catch (IllegalArgumentException e)
        {
            throw new ConfigurationException(""Invalid table id"", e);
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata$Builder:id(org.apache.cassandra.schema.TableId),id,TableMetadata$Builder,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public Builder id(TableId val)
        {
            id = val;
            return this;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.cql3.statements.schema.TableAttributes:asNewTableParams(),asNewTableParams,TableAttributes,../data/xml/cassandra_call_methods/TableAttributes.xml,"
TableParams asNewTableParams()
    {
        return build(TableParams.builder());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata$Builder:params(org.apache.cassandra.schema.TableParams),params,TableMetadata$Builder,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public Builder params(TableParams val)
        {
            params = val.unbuild();
            return this;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata$Builder:kind(org.apache.cassandra.schema.TableMetadata$Kind),kind,TableMetadata$Builder,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public Builder kind(Kind val)
        {
            kind = val;
            return this;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata$Builder:build(),build,TableMetadata$Builder,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public TableMetadata build()
        {
            if (partitioner == null)
                partitioner = DatabaseDescriptor.getPartitioner();

            if (id == null)
                id = TableId.generate();

            if (Flag.isCQLTable(flags))
                return new TableMetadata(this);
            else
                return new CompactTableMetadata(this);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.TableMetadata:validate(),validate,TableMetadata,../data/xml/cassandra_call_methods/TableMetadata.xml,"
public void validate()
    {
        if (!isNameValid(keyspace))
            except(""Keyspace name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \""%s\"")"", SchemaConstants.NAME_LENGTH, keyspace);

        if (!isNameValid(name))
            except(""Table name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \""%s\"")"", SchemaConstants.NAME_LENGTH, name);

        params.validate();

        if (partitionKeyColumns.stream().anyMatch(c -> c.type.isCounter()))
            except(""PRIMARY KEY columns cannot contain counters"");

        // Mixing counter with non counter columns is not supported (#2614)
        if (isCounter())
        {
            for (ColumnMetadata column : regularAndStaticColumns)
                if (!(column.type.isCounter()) && !isSuperColumnMapColumnName(column.name))
                    except(""Cannot have a non counter column (\""%s\"") in a counter table"", column.name);
        }
        else
        {
            for (ColumnMetadata column : regularAndStaticColumns)
                if (column.type.isCounter())
                    except(""Cannot have a counter column (\""%s\"") in a non counter table"", column.name);
        }

        // All tables should have a partition key
        if (partitionKeyColumns.isEmpty())
            except(""Missing partition keys for table %s"", toString());

        indexes.validate(this);
    }

    

public void validate()
        {
            super.validate();

            // A compact table should always have a clustering
            if (!Flag.isCQLTable(flags) && clusteringColumns.isEmpty())
                except(""For table %s, isDense=%b, isCompound=%b, clustering=%s"", toString(),
                       Flag.isDense(flags), Flag.isCompound(flags), clusteringColumns);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.Views:with(org.apache.cassandra.schema.ViewMetadata),with,Views,../data/xml/cassandra_call_methods/Views.xml,"/**
     * Create a MaterializedViews instance with the provided materialized view added
     */
public Views with(ViewMetadata view)
    {
        if (get(view.name()).isPresent())
            throw new IllegalStateException(String.format(""Materialized View %s already exists"", view.name()));

        return builder().put(this).put(view).build();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.KeyspaceMetadata:withSwapped(org.apache.cassandra.schema.Views),withSwapped,KeyspaceMetadata,../data/xml/cassandra_call_methods/KeyspaceMetadata.xml,"
public KeyspaceMetadata withSwapped(KeyspaceParams params)
    {
        return new KeyspaceMetadata(name, kind, params, tables, views, types, functions);
    }

    

public KeyspaceMetadata withSwapped(Tables regular)
    {
        return new KeyspaceMetadata(name, kind, params, regular, views, types, functions);
    }

    

public KeyspaceMetadata withSwapped(Views views)
    {
        return new KeyspaceMetadata(name, kind, params, tables, views, types, functions);
    }

    

public KeyspaceMetadata withSwapped(Types types)
    {
        return new KeyspaceMetadata(name, kind, params, tables, views, types, functions);
    }

    

public KeyspaceMetadata withSwapped(Functions functions)
    {
        return new KeyspaceMetadata(name, kind, params, tables, views, types, functions);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getEnableMaterializedViews(),enable_materialized_views,(M)org.apache.cassandra.schema.Keyspaces:withAddedOrUpdated(org.apache.cassandra.schema.KeyspaceMetadata),withAddedOrUpdated,Keyspaces,../data/xml/cassandra_call_methods/Keyspaces.xml,"
public Keyspaces withAddedOrUpdated(KeyspaceMetadata keyspace)
    {
        return builder().add(Iterables.filter(this, k -> !k.name.equals(keyspace.name)))
                        .add(keyspace)
                        .build();
    }

    "
