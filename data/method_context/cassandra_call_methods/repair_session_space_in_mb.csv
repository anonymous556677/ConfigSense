function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.db.ColumnFamilyStore:getPartitioner(),getPartitioner,ColumnFamilyStore,../data/xml/cassandra_call_methods/ColumnFamilyStore.xml,"
public IPartitioner getPartitioner()
    {
        return metadata().partitioner;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(O)org.apache.cassandra.utils.MerkleTrees:<init>(org.apache.cassandra.dht.IPartitioner),<init>,MerkleTrees,../data/xml/cassandra_call_methods/MerkleTrees.xml,"/**
     * Creates empty MerkleTrees object.
     *
     * @param partitioner The partitioner to use
     */
public MerkleTrees(IPartitioner partitioner)
    {
        this(partitioner, new ArrayList<>());
    }

    

private MerkleTrees(IPartitioner partitioner, Collection<MerkleTree> merkleTrees)
    {
        this.partitioner = partitioner;
        addTrees(merkleTrees);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.repair.ValidationPartitionIterator:estimatedPartitions(),estimatedPartitions,ValidationPartitionIterator,../data/xml/cassandra_call_methods/ValidationPartitionIterator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.repair.ValidationPartitionIterator:getRangePartitionCounts(),getRangePartitionCounts,ValidationPartitionIterator,../data/xml/cassandra_call_methods/ValidationPartitionIterator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(S)org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),getRepairSessionSpaceInMegabytes,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getRepairSessionSpaceInMegabytes()
    {
        return conf.repair_session_space_in_mb;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.db.Keyspace:getReplicationStrategy(),getReplicationStrategy,Keyspace,../data/xml/cassandra_call_methods/Keyspace.xml,"
public AbstractReplicationStrategy getReplicationStrategy()
    {
        return replicationStrategy;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.locator.AbstractReplicationStrategy:getReplicationFactor(),getReplicationFactor,AbstractReplicationStrategy,../data/xml/cassandra_call_methods/AbstractReplicationStrategy.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,"(S)org.apache.cassandra.utils.MerkleTree:estimatedMaxDepthForBytes(org.apache.cassandra.dht.IPartitioner,long,int)",estimatedMaxDepthForBytes,MerkleTree,../data/xml/cassandra_call_methods/MerkleTree.xml,"/**
     * Estimate the allowable depth while keeping the resulting heap usage of this tree under the provided
     * number of bytes. This is important for ensuring that we do not allocate overly large trees that could
     * OOM the JVM and cause instability.
     *
     * Calculated using the following logic:
     *
     * Let T = size of a tree of depth n
     *
     * T = #leafs  * sizeof(leaf) + #inner  * sizeof(inner)
     * T = 2^n     * L            + 2^n - 1 * I
     *
     * T = 2^n * L + 2^n * I - I;
     *
     * So to solve for n given sizeof(tree_n) T:
     *
     * n = floor(log_2((T + I) / (L + I))
     *
     * @param numBytes: The number of bytes to fit the tree within
     * @param bytesPerHash: The number of bytes stored in a leaf node, for example 2 * murmur128 will be 256 bits
     *                    or 32 bytes
     * @return the estimated depth that will fit within the provided number of bytes
     */
public static int estimatedMaxDepthForBytes(IPartitioner partitioner, long numBytes, int bytesPerHash)
    {
        byte[] hashLeft = new byte[bytesPerHash];
        byte[] hashRigth = new byte[bytesPerHash];
        OnHeapLeaf left = new OnHeapLeaf(hashLeft);
        OnHeapLeaf right = new OnHeapLeaf(hashRigth);
        Inner inner = new OnHeapInner(partitioner.getMinimumToken(), left, right);
        inner.fillInnerHashes();

        // Some partioners have variable token sizes, try to estimate as close as we can by using the same
        // heap estimate as the memtables use.
        long innerTokenSize = ObjectSizes.measureDeep(partitioner.getMinimumToken());
        long realInnerTokenSize = partitioner.getMinimumToken().getHeapSize();

        long sizeOfLeaf = ObjectSizes.measureDeep(left);
        long sizeOfInner = ObjectSizes.measureDeep(inner) -
                           (ObjectSizes.measureDeep(left) + ObjectSizes.measureDeep(right) + innerTokenSize) +
                           realInnerTokenSize;

        long adjustedBytes = Math.max(1, (numBytes + sizeOfInner) / (sizeOfLeaf + sizeOfInner));
        return Math.max(1, (int) Math.floor(Math.log(adjustedBytes) / Math.log(2)));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(S)org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionMaxTreeDepth(),getRepairSessionMaxTreeDepth,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getRepairSessionMaxTreeDepth()
    {
        return conf.repair_session_max_tree_depth;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,"(M)org.apache.cassandra.utils.MerkleTrees:addMerkleTree(int,org.apache.cassandra.dht.Range)",addMerkleTree,MerkleTrees,../data/xml/cassandra_call_methods/MerkleTrees.xml,"/**
     * Add a MerkleTree with the defined size and range.
     *
     * @param maxsize
     * @param range
     * @return The created merkle tree.
     */
public MerkleTree addMerkleTree(int maxsize, Range<Token> range)
    {
        return addMerkleTree(maxsize, MerkleTree.RECOMMENDED_DEPTH, range);
    }

    

@VisibleForTesting
    public MerkleTree addMerkleTree(int maxsize, byte hashdepth, Range<Token> range)
    {
        MerkleTree tree = new MerkleTree(partitioner, range, hashdepth, maxsize);
        addTree(tree);

        return tree;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.utils.MerkleTrees:ranges(),ranges,MerkleTrees,../data/xml/cassandra_call_methods/MerkleTrees.xml,"/**
     * Get the ranges that these merkle trees covers.
     *
     * @return
     */
public Collection<Range<Token>> ranges()
    {
        return merkleTrees.keySet();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,(M)org.apache.cassandra.utils.MerkleTrees:size(),size,MerkleTrees,../data/xml/cassandra_call_methods/MerkleTrees.xml,"
public long size()
    {
        long size = 0;

        for (MerkleTree tree : merkleTrees.values())
        {
            size += tree.size();
        }

        return size;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRepairSessionSpaceInMegabytes(),repair_session_space_in_mb,"(M)org.apache.cassandra.utils.MerkleTrees$MerkleTreesSerializer:serializedSize(org.apache.cassandra.utils.MerkleTrees,int)",serializedSize,MerkleTrees$MerkleTreesSerializer,../data/xml/cassandra_call_methods/MerkleTrees.xml,"
public long serializedSize(MerkleTrees trees, int version)
        {
            assert trees != null;

            long size = TypeSizes.sizeof(trees.merkleTrees.size());
            for (MerkleTree tree : trees.merkleTrees.values())
            {
                size += tree.serializedSize(version);
            }
            return size;
        }

    }"
