function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.batchlog.BatchlogManager:<init>(),<init>,BatchlogManager,../data/xml/cassandra_call_methods/BatchlogManager.xml,"
public BatchlogManager()
    {
        ScheduledThreadPoolExecutor executor = new DebuggableScheduledThreadPoolExecutor(""BatchlogTasks"");
        executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
        batchlogTasks = executor;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(S)org.apache.cassandra.config.DatabaseDescriptor:getForceNewPreparedStatementBehaviour(),getForceNewPreparedStatementBehaviour,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean getForceNewPreparedStatementBehaviour()
    {
        return conf.force_new_prepared_statement_behaviour;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.utils.CassandraVersion:compareTo(org.apache.cassandra.utils.CassandraVersion),compareTo,CassandraVersion,../data/xml/cassandra_call_methods/CassandraVersion.xml,"
public int compareTo(CassandraVersion other)
    {
        return compareTo(other, false);
    }

    

public int compareTo(CassandraVersion other, boolean compareToPatchOnly)
    {
        if (major < other.major)
            return -1;
        if (major > other.major)
            return 1;

        if (minor < other.minor)
            return -1;
        if (minor > other.minor)
            return 1;

        if (patch < other.patch)
            return -1;
        if (patch > other.patch)
            return 1;

        if (compareToPatchOnly)
            return 0;

        int c = Integer.compare(hotfix, other.hotfix);
        if (c != 0)
            return c;

        c = compareIdentifiers(preRelease, other.preRelease, 1);
        if (c != 0)
            return c;

        return compareIdentifiers(build, other.build, -1);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(M)org.apache.cassandra.utils.CassandraVersion:compareTo(org.apache.cassandra.utils.CassandraVersion,boolean)",compareTo,CassandraVersion,../data/xml/cassandra_call_methods/CassandraVersion.xml,"
public int compareTo(CassandraVersion other)
    {
        return compareTo(other, false);
    }

    

public int compareTo(CassandraVersion other, boolean compareToPatchOnly)
    {
        if (major < other.major)
            return -1;
        if (major > other.major)
            return 1;

        if (minor < other.minor)
            return -1;
        if (minor > other.minor)
            return 1;

        if (patch < other.patch)
            return -1;
        if (patch > other.patch)
            return 1;

        if (compareToPatchOnly)
            return 0;

        int c = Integer.compare(hotfix, other.hotfix);
        if (c != 0)
            return c;

        c = compareIdentifiers(preRelease, other.preRelease, 1);
        if (c != 0)
            return c;

        return compareIdentifiers(build, other.build, -1);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.utils.concurrent.OpOrder:<init>(),<init>,OpOrder,../data/xml/cassandra_call_methods/OpOrder.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.db.DiskBoundaryManager:<init>(),<init>,DiskBoundaryManager,../data/xml/cassandra_call_methods/DiskBoundaryManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.schema.TableMetadataRef:get(),get,TableMetadataRef,../data/xml/cassandra_call_methods/TableMetadataRef.xml,"
public TableMetadata get()
    {
        return metadata;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.schema.CompactionParams:minCompactionThreshold(),minCompactionThreshold,CompactionParams,../data/xml/cassandra_call_methods/CompactionParams.xml,"
public int minCompactionThreshold()
    {
        String threshold = options.get(Option.MIN_THRESHOLD.toString());
        return threshold == null
             ? DEFAULT_MIN_THRESHOLD
             : Integer.parseInt(threshold);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.schema.CompactionParams:maxCompactionThreshold(),maxCompactionThreshold,CompactionParams,../data/xml/cassandra_call_methods/CompactionParams.xml,"
public int maxCompactionThreshold()
    {
        String threshold = options.get(Option.MAX_THRESHOLD.toString());
        return threshold == null
             ? DEFAULT_MAX_THRESHOLD
             : Integer.parseInt(threshold);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.view.ViewManager:forTable(org.apache.cassandra.schema.TableId),forTable,ViewManager,../data/xml/cassandra_call_methods/ViewManager.xml,"
public TableViews forTable(TableId id)
    {
        TableViews views = viewsByBaseTable.get(id);
        if (views == null)
        {
            views = new TableViews(id);
            TableViews previous = viewsByBaseTable.putIfAbsent(id, views);
            if (previous != null)
                views = previous;
        }
        return views;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Keyspace:getName(),getName,Keyspace,../data/xml/cassandra_call_methods/Keyspace.xml,"
public String getName()
    {
        return metadata.name;
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(S)org.apache.cassandra.config.DatabaseDescriptor:isDaemonInitialized(),isDaemonInitialized,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static boolean isDaemonInitialized()
    {
        return daemonInitialized;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.commitlog.CommitLog:getCurrentPosition(),getCurrentPosition,CommitLog,../data/xml/cassandra_call_methods/CommitLog.xml,"/**
     * @return a CommitLogPosition which, if {@code >= one} returned from add(), implies add() was started
     * (but not necessarily finished) prior to this call
     */
public CommitLogPosition getCurrentPosition()
    {
        return segmentManager.getCurrentPosition();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(O)org.apache.cassandra.db.lifecycle.Tracker:<init>(org.apache.cassandra.db.Memtable,boolean)",<init>,Tracker,../data/xml/cassandra_call_methods/Tracker.xml,"/**
     * @param memtable Initial Memtable. Can be null.
     * @param loadsstables true to indicate to load SSTables (TODO: remove as this is only accessed from 2i)
     */
public Tracker(Memtable memtable, boolean loadsstables)
    {
        this.cfstore = memtable != null ? memtable.cfs : null;
        this.view = new AtomicReference<>();
        this.loadsstables = loadsstables;
        this.reset(memtable);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.lifecycle.Tracker:subscribe(org.apache.cassandra.notifications.INotificationConsumer),subscribe,Tracker,../data/xml/cassandra_call_methods/Tracker.xml,"
public void subscribe(INotificationConsumer consumer)
    {
        subscribers.add(consumer);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Directories:sstableLister(org.apache.cassandra.db.Directories$OnTxnErr),sstableLister,Directories,../data/xml/cassandra_call_methods/Directories.xml,"
public SSTableLister sstableLister(OnTxnErr onTxnErr)
    {
        return new SSTableLister(this.dataPaths, this.metadata, onTxnErr);
    }

    

public SSTableLister sstableLister(File directory, OnTxnErr onTxnErr)
    {
        return new SSTableLister(new File[]{directory}, metadata, onTxnErr);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Directories$SSTableLister:skipTemporary(boolean),skipTemporary,Directories$SSTableLister,../data/xml/cassandra_call_methods/Directories.xml,"
public SSTableLister skipTemporary(boolean b)
        {
            if (filtered)
                throw new IllegalStateException(""list() has already been called"");
            skipTemporary = b;
            return this;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Directories$SSTableLister:list(),list,Directories$SSTableLister,../data/xml/cassandra_call_methods/Directories.xml,"
public Map<Descriptor, Set<Component>> list()
        {
            filter();
            return ImmutableMap.copyOf(components);
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.db.compaction.CompactionStrategyManager:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,CompactionStrategyManager,../data/xml/cassandra_call_methods/CompactionStrategyManager.xml,"
public CompactionStrategyManager(ColumnFamilyStore cfs)
    {
        this(cfs, cfs::getDiskBoundaries, cfs.getPartitioner().splitter().isPresent());
    }

    

@VisibleForTesting
    public CompactionStrategyManager(ColumnFamilyStore cfs, Supplier<DiskBoundaries> boundariesSupplier,
                                     boolean partitionSSTablesByTokenRange)
    {
        AbstractStrategyHolder.DestinationRouter router = new AbstractStrategyHolder.DestinationRouter()
        {
            public int getIndexForSSTable(SSTableReader sstable)
            {
                return compactionStrategyIndexFor(sstable);
            }

            public int getIndexForSSTableDirectory(Descriptor descriptor)
            {
                return compactionStrategyIndexForDirectory(descriptor);
            }
        };
        transientRepairs = new PendingRepairHolder(cfs, router, true);
        pendingRepairs = new PendingRepairHolder(cfs, router, false);
        repaired = new CompactionStrategyHolder(cfs, router, true);
        unrepaired = new CompactionStrategyHolder(cfs, router, false);
        holders = ImmutableList.of(transientRepairs, pendingRepairs, repaired, unrepaired);

        cfs.getTracker().subscribe(this);
        logger.trace(""{} subscribed to the data tracker."", this);
        this.cfs = cfs;
        this.compactionLogger = new CompactionLogger(cfs, this);
        this.boundariesSupplier = boundariesSupplier;
        this.partitionSSTablesByTokenRange = partitionSSTablesByTokenRange;
        params = cfs.metadata().params.compaction;
        enabled = params.isEnabled();
        reload(cfs.metadata().params.compaction);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.utils.DefaultValue:value(),value,DefaultValue,../data/xml/cassandra_call_methods/DefaultValue.xml,"
public T value()
    {
        return currentValue;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.compaction.CompactionStrategyManager:disable(),disable,CompactionStrategyManager,../data/xml/cassandra_call_methods/CompactionStrategyManager.xml,"
public void disable()
    {
        writeLock.lock();
        try
        {
            enabled = false;
        }
        finally
        {
            writeLock.unlock();
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.index.SecondaryIndexManager:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,SecondaryIndexManager,../data/xml/cassandra_call_methods/SecondaryIndexManager.xml,"
public SecondaryIndexManager(ColumnFamilyStore baseCfs)
    {
        this.baseCfs = baseCfs;
        this.keyspace = baseCfs.keyspace;
        baseCfs.getTracker().subscribe(this);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.schema.Indexes:iterator(),iterator,Indexes,../data/xml/cassandra_call_methods/Indexes.xml,"
public Iterator<IndexMetadata> iterator()
    {
        return indexesByName.values().iterator();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(M)org.apache.cassandra.index.SecondaryIndexManager:addIndex(org.apache.cassandra.schema.IndexMetadata,boolean)",addIndex,SecondaryIndexManager,../data/xml/cassandra_call_methods/SecondaryIndexManager.xml,"/**
     * Adds and builds a index
     *
     * @param indexDef the IndexMetadata describing the index
     * @param isNewCF true if the index is added as part of a new table/columnfamily (i.e. loading a CF at startup), 
     * false for all other cases (i.e. newly added index)
     */
public synchronized Future<?> addIndex(IndexMetadata indexDef, boolean isNewCF)
    {
        if (indexes.containsKey(indexDef.name))
            return reloadIndex(indexDef);
        else
            return createIndex(indexDef, isNewCF);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.metrics.TableMetrics:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,TableMetrics,../data/xml/cassandra_call_methods/TableMetrics.xml,"/**
     * Creates metrics for given {@link ColumnFamilyStore}.
     *
     * @param cfs ColumnFamilyStore to measure metrics
     */
public TableMetrics(final ColumnFamilyStore cfs)
    {
        factory = new TableMetricNameFactory(cfs, ""Table"");
        aliasFactory = new TableMetricNameFactory(cfs, ""ColumnFamily"");

        samplers = new EnumMap<>(SamplerType.class);
        topReadPartitionFrequency = new FrequencySampler<ByteBuffer>()
        {
            public String toString(ByteBuffer value)
            {
                return cfs.metadata().partitionKeyType.getString(value);
            }
        };
        topWritePartitionFrequency = new FrequencySampler<ByteBuffer>()
        {
            public String toString(ByteBuffer value)
            {
                return cfs.metadata().partitionKeyType.getString(value);
            }
        };
        topWritePartitionSize = new MaxSampler<ByteBuffer>()
        {
            public String toString(ByteBuffer value)
            {
                return cfs.metadata().partitionKeyType.getString(value);
            }
        };
        topCasPartitionContention = new FrequencySampler<ByteBuffer>()
        {
            public String toString(ByteBuffer value)
            {
                return cfs.metadata().partitionKeyType.getString(value);
            }
        };
        topLocalReadQueryTime = new MaxSampler<String>()
        {
            public String toString(String value)
            {
                return value;
            }
        };

        samplers.put(SamplerType.READS, topReadPartitionFrequency);
        samplers.put(SamplerType.WRITES, topWritePartitionFrequency);
        samplers.put(SamplerType.WRITE_SIZE, topWritePartitionSize);
        samplers.put(SamplerType.CAS_CONTENTIONS, topCasPartitionContention);
        samplers.put(SamplerType.LOCAL_READ_TIME, topLocalReadQueryTime);

        memtableColumnsCount = createTableGauge(""MemtableColumnsCount"", 
                                                () -> cfs.getTracker().getView().getCurrentMemtable().getOperations());

        // MemtableOnHeapSize naming deprecated in 4.0
        memtableOnHeapDataSize = createTableGaugeWithDeprecation(""MemtableOnHeapDataSize"", ""MemtableOnHeapSize"", 
                                                                 () -> cfs.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns(), 
                                                                 new GlobalTableGauge(""MemtableOnHeapDataSize""));

        // MemtableOffHeapSize naming deprecated in 4.0
        memtableOffHeapDataSize = createTableGaugeWithDeprecation(""MemtableOffHeapDataSize"", ""MemtableOffHeapSize"", 
                                                                  () -> cfs.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns(), 
                                                                  new GlobalTableGauge(""MemtableOnHeapDataSize""));
        
        memtableLiveDataSize = createTableGauge(""MemtableLiveDataSize"", 
                                                () -> cfs.getTracker().getView().getCurrentMemtable().getLiveDataSize());

        // AllMemtablesHeapSize naming deprecated in 4.0
        allMemtablesOnHeapDataSize = createTableGaugeWithDeprecation(""AllMemtablesOnHeapDataSize"", ""AllMemtablesHeapSize"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long size = 0;
                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
                    size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
                return size;
            }
        }, new GlobalTableGauge(""AllMemtablesOnHeapDataSize""));

        // AllMemtablesOffHeapSize naming deprecated in 4.0
        allMemtablesOffHeapDataSize = createTableGaugeWithDeprecation(""AllMemtablesOffHeapDataSize"", ""AllMemtablesOffHeapSize"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long size = 0;
                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
                    size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
                return size;
            }
        }, new GlobalTableGauge(""AllMemtablesOffHeapDataSize""));
        allMemtablesLiveDataSize = createTableGauge(""AllMemtablesLiveDataSize"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long size = 0;
                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
                    size += cfs2.getTracker().getView().getCurrentMemtable().getLiveDataSize();
                return size;
            }
        });
        memtableSwitchCount = createTableCounter(""MemtableSwitchCount"");
        estimatedPartitionSizeHistogram = createTableGauge(""EstimatedPartitionSizeHistogram"", ""EstimatedRowSizeHistogram"",
                                                           () -> combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL),
                                                                                   SSTableReader::getEstimatedPartitionSize), null);
        
        estimatedPartitionCount = createTableGauge(""EstimatedPartitionCount"", ""EstimatedRowCount"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long memtablePartitions = 0;
                for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())
                   memtablePartitions += memtable.partitionCount();
                try(ColumnFamilyStore.RefViewFragment refViewFragment = cfs.selectAndReference(View.selectFunction(SSTableSet.CANONICAL)))
                {
                    return SSTableReader.getApproximateKeyCount(refViewFragment.sstables) + memtablePartitions;
                }
            }
        }, null);
        estimatedColumnCountHistogram = createTableGauge(""EstimatedColumnCountHistogram"", ""EstimatedColumnCountHistogram"",
                                                         () -> combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), 
                                                                                 SSTableReader::getEstimatedCellPerPartitionCount), null);
        
        sstablesPerReadHistogram = createTableHistogram(""SSTablesPerReadHistogram"", cfs.keyspace.metric.sstablesPerReadHistogram, true);
        compressionRatio = createTableGauge(""CompressionRatio"", new Gauge<Double>()
        {
            public Double getValue()
            {
                return computeCompressionRatio(cfs.getSSTables(SSTableSet.CANONICAL));
            }
        }, new Gauge<Double>() // global gauge
        {
            public Double getValue()
            {
                List<SSTableReader> sstables = new ArrayList<>();
                Keyspace.all().forEach(ks -> sstables.addAll(ks.getAllSSTables(SSTableSet.CANONICAL)));
                return computeCompressionRatio(sstables);
            }
        });
        percentRepaired = createTableGauge(""PercentRepaired"", new Gauge<Double>()
        {
            public Double getValue()
            {
                double repaired = 0;
                double total = 0;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
                {
                    if (sstable.isRepaired())
                    {
                        repaired += sstable.uncompressedLength();
                    }
                    total += sstable.uncompressedLength();
                }
                return total > 0 ? (repaired / total) * 100 : 100.0;
            }
        });

        bytesRepaired = createTableGauge(""BytesRepaired"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long size = 0;
                for (SSTableReader sstable: Iterables.filter(cfs.getSSTables(SSTableSet.CANONICAL), SSTableReader::isRepaired))
                {
                    size += sstable.uncompressedLength();
                }
                return size;
            }
        });

        bytesUnrepaired = createTableGauge(""BytesUnrepaired"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long size = 0;
                for (SSTableReader sstable: Iterables.filter(cfs.getSSTables(SSTableSet.CANONICAL), s -> !s.isRepaired() && !s.isPendingRepair()))
                {
                    size += sstable.uncompressedLength();
                }
                return size;
            }
        });

        bytesPendingRepair = createTableGauge(""BytesPendingRepair"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long size = 0;
                for (SSTableReader sstable: Iterables.filter(cfs.getSSTables(SSTableSet.CANONICAL), SSTableReader::isPendingRepair))
                {
                    size += sstable.uncompressedLength();
                }
                return size;
            }
        });

        readLatency = createLatencyMetrics(""Read"", cfs.keyspace.metric.readLatency, GLOBAL_READ_LATENCY);
        writeLatency = createLatencyMetrics(""Write"", cfs.keyspace.metric.writeLatency, GLOBAL_WRITE_LATENCY);
        rangeLatency = createLatencyMetrics(""Range"", cfs.keyspace.metric.rangeLatency, GLOBAL_RANGE_LATENCY);
        pendingFlushes = createTableCounter(""PendingFlushes"");
        bytesFlushed = createTableCounter(""BytesFlushed"");

        compactionBytesWritten = createTableCounter(""CompactionBytesWritten"");
        pendingCompactions = createTableGauge(""PendingCompactions"", () -> cfs.getCompactionStrategyManager().getEstimatedRemainingTasks());
        liveSSTableCount = createTableGauge(""LiveSSTableCount"", () -> cfs.getTracker().getView().liveSSTables().size());
        oldVersionSSTableCount = createTableGauge(""OldVersionSSTableCount"", new Gauge<Integer>()
        {
            public Integer getValue()
            {
                int count = 0;
                for (SSTableReader sstable : cfs.getLiveSSTables())
                    if (!sstable.descriptor.version.isLatestVersion())
                        count++;
                return count;
            }
        });
        liveDiskSpaceUsed = createTableCounter(""LiveDiskSpaceUsed"");
        totalDiskSpaceUsed = createTableCounter(""TotalDiskSpaceUsed"");
        minPartitionSize = createTableGauge(""MinPartitionSize"", ""MinRowSize"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long min = 0;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
                {
                    if (min == 0 || sstable.getEstimatedPartitionSize().min() < min)
                        min = sstable.getEstimatedPartitionSize().min();
                }
                return min;
            }
        }, new Gauge<Long>() // global gauge
        {
            public Long getValue()
            {
                long min = Long.MAX_VALUE;
                for (Metric cfGauge : ALL_TABLE_METRICS.get(""MinPartitionSize""))
                {
                    min = Math.min(min, ((Gauge<? extends Number>) cfGauge).getValue().longValue());
                }
                return min;
            }
        });
        maxPartitionSize = createTableGauge(""MaxPartitionSize"", ""MaxRowSize"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long max = 0;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
                {
                    if (sstable.getEstimatedPartitionSize().max() > max)
                        max = sstable.getEstimatedPartitionSize().max();
                }
                return max;
            }
        }, new Gauge<Long>() // global gauge
        {
            public Long getValue()
            {
                long max = 0;
                for (Metric cfGauge : ALL_TABLE_METRICS.get(""MaxPartitionSize""))
                {
                    max = Math.max(max, ((Gauge<? extends Number>) cfGauge).getValue().longValue());
                }
                return max;
            }
        });
        meanPartitionSize = createTableGauge(""MeanPartitionSize"", ""MeanRowSize"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long sum = 0;
                long count = 0;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
                {
                    long n = sstable.getEstimatedPartitionSize().count();
                    sum += sstable.getEstimatedPartitionSize().mean() * n;
                    count += n;
                }
                return count > 0 ? sum / count : 0;
            }
        }, new Gauge<Long>() // global gauge
        {
            public Long getValue()
            {
                long sum = 0;
                long count = 0;
                for (Keyspace keyspace : Keyspace.all())
                {
                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.CANONICAL))
                    {
                        long n = sstable.getEstimatedPartitionSize().count();
                        sum += sstable.getEstimatedPartitionSize().mean() * n;
                        count += n;
                    }
                }
                return count > 0 ? sum / count : 0;
            }
        });
        bloomFilterFalsePositives = createTableGauge(""BloomFilterFalsePositives"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long count = 0L;
                for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))
                    count += sstable.getBloomFilterFalsePositiveCount();
                return count;
            }
        });
        recentBloomFilterFalsePositives = createTableGauge(""RecentBloomFilterFalsePositives"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long count = 0L;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
                    count += sstable.getRecentBloomFilterFalsePositiveCount();
                return count;
            }
        });
        bloomFilterFalseRatio = createTableGauge(""BloomFilterFalseRatio"", new Gauge<Double>()
        {
            public Double getValue()
            {
                long falsePositiveCount = 0L;
                long truePositiveCount = 0L;
                long trueNegativeCount = 0L;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
                {
                    falsePositiveCount += sstable.getBloomFilterFalsePositiveCount();
                    truePositiveCount += sstable.getBloomFilterTruePositiveCount();
                    trueNegativeCount += sstable.getBloomFilterTrueNegativeCount();
                }
                if (falsePositiveCount == 0L && truePositiveCount == 0L)
                    return 0d;
                return (double) falsePositiveCount / (truePositiveCount + falsePositiveCount + trueNegativeCount);
            }
        }, new Gauge<Double>() // global gauge
        {
            public Double getValue()
            {
                long falsePositiveCount = 0L;
                long truePositiveCount = 0L;
                long trueNegativeCount = 0L;
                for (Keyspace keyspace : Keyspace.all())
                {
                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))
                    {
                        falsePositiveCount += sstable.getBloomFilterFalsePositiveCount();
                        truePositiveCount += sstable.getBloomFilterTruePositiveCount();
                        trueNegativeCount += sstable.getBloomFilterTrueNegativeCount();
                    }
                }
                if (falsePositiveCount == 0L && truePositiveCount == 0L)
                    return 0d;
                return (double) falsePositiveCount / (truePositiveCount + falsePositiveCount + trueNegativeCount);
            }
        });
        recentBloomFilterFalseRatio = createTableGauge(""RecentBloomFilterFalseRatio"", new Gauge<Double>()
        {
            public Double getValue()
            {
                long falsePositiveCount = 0L;
                long truePositiveCount = 0L;
                long trueNegativeCount = 0L;
                for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))
                {
                    falsePositiveCount += sstable.getRecentBloomFilterFalsePositiveCount();
                    truePositiveCount += sstable.getRecentBloomFilterTruePositiveCount();
                    trueNegativeCount += sstable.getRecentBloomFilterTrueNegativeCount();
                }
                if (falsePositiveCount == 0L && truePositiveCount == 0L)
                    return 0d;
                return (double) falsePositiveCount / (truePositiveCount + falsePositiveCount + trueNegativeCount);
            }
        }, new Gauge<Double>() // global gauge
        {
            public Double getValue()
            {
                long falsePositiveCount = 0L;
                long truePositiveCount = 0L;
                long trueNegativeCount = 0L;
                for (Keyspace keyspace : Keyspace.all())
                {
                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))
                    {
                        falsePositiveCount += sstable.getRecentBloomFilterFalsePositiveCount();
                        truePositiveCount += sstable.getRecentBloomFilterTruePositiveCount();
                        trueNegativeCount += sstable.getRecentBloomFilterTrueNegativeCount();
                    }
                }
                if (falsePositiveCount == 0L && truePositiveCount == 0L)
                    return 0d;
                return (double) falsePositiveCount / (truePositiveCount + falsePositiveCount + trueNegativeCount);
            }
        });
        bloomFilterDiskSpaceUsed = createTableGauge(""BloomFilterDiskSpaceUsed"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long total = 0;
                for (SSTableReader sst : cfs.getSSTables(SSTableSet.CANONICAL))
                    total += sst.getBloomFilterSerializedSize();
                return total;
            }
        });
        bloomFilterOffHeapMemoryUsed = createTableGauge(""BloomFilterOffHeapMemoryUsed"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long total = 0;
                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
                    total += sst.getBloomFilterOffHeapSize();
                return total;
            }
        });
        indexSummaryOffHeapMemoryUsed = createTableGauge(""IndexSummaryOffHeapMemoryUsed"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long total = 0;
                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
                    total += sst.getIndexSummaryOffHeapSize();
                return total;
            }
        });
        compressionMetadataOffHeapMemoryUsed = createTableGauge(""CompressionMetadataOffHeapMemoryUsed"", new Gauge<Long>()
        {
            public Long getValue()
            {
                long total = 0;
                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
                    total += sst.getCompressionMetadataOffHeapSize();
                return total;
            }
        });
        speculativeRetries = createTableCounter(""SpeculativeRetries"");
        speculativeFailedRetries = createTableCounter(""SpeculativeFailedRetries"");
        speculativeInsufficientReplicas = createTableCounter(""SpeculativeInsufficientReplicas"");
        speculativeSampleLatencyNanos = createTableGauge(""SpeculativeSampleLatencyNanos"", () -> cfs.sampleReadLatencyNanos);

        additionalWrites = createTableCounter(""AdditionalWrites"");
        additionalWriteLatencyNanos = createTableGauge(""AdditionalWriteLatencyNanos"", () -> cfs.additionalWriteLatencyNanos);

        keyCacheHitRate = createTableGauge(""KeyCacheHitRate"", ""KeyCacheHitRate"", new RatioGauge()
        {
            @Override
            public Ratio getRatio()
            {
                return Ratio.of(getNumerator(), getDenominator());
            }

            protected double getNumerator()
            {
                long hits = 0L;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
                    hits += sstable.getKeyCacheHit();
                return hits;
            }

            protected double getDenominator()
            {
                long requests = 0L;
                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
                    requests += sstable.getKeyCacheRequest();
                return Math.max(requests, 1); // to avoid NaN.
            }
        }, null);
        tombstoneScannedHistogram = createTableHistogram(""TombstoneScannedHistogram"", cfs.keyspace.metric.tombstoneScannedHistogram, false);
        liveScannedHistogram = createTableHistogram(""LiveScannedHistogram"", cfs.keyspace.metric.liveScannedHistogram, false);
        colUpdateTimeDeltaHistogram = createTableHistogram(""ColUpdateTimeDeltaHistogram"", cfs.keyspace.metric.colUpdateTimeDeltaHistogram, false);
        coordinatorReadLatency = createTableTimer(""CoordinatorReadLatency"");
        coordinatorScanLatency = createTableTimer(""CoordinatorScanLatency"");
        coordinatorWriteLatency = createTableTimer(""CoordinatorWriteLatency"");
        waitingOnFreeMemtableSpace = createTableHistogram(""WaitingOnFreeMemtableSpace"", false);

        // We do not want to capture view mutation specific metrics for a view
        // They only makes sense to capture on the base table
        if (cfs.metadata().isView())
        {
            viewLockAcquireTime = null;
            viewReadTime = null;
        }
        else
        {
            viewLockAcquireTime = createTableTimer(""ViewLockAcquireTime"", cfs.keyspace.metric.viewLockAcquireTime);
            viewReadTime = createTableTimer(""ViewReadTime"", cfs.keyspace.metric.viewReadTime);
        }

        trueSnapshotsSize = createTableGauge(""SnapshotsSize"", cfs::trueSnapshotsSize);
        rowCacheHitOutOfRange = createTableCounter(""RowCacheHitOutOfRange"");
        rowCacheHit = createTableCounter(""RowCacheHit"");
        rowCacheMiss = createTableCounter(""RowCacheMiss"");

        tombstoneFailures = createTableCounter(""TombstoneFailures"");
        tombstoneWarnings = createTableCounter(""TombstoneWarnings"");

        droppedMutations = createTableCounter(""DroppedMutations"");

        casPrepare = createLatencyMetrics(""CasPrepare"", cfs.keyspace.metric.casPrepare);
        casPropose = createLatencyMetrics(""CasPropose"", cfs.keyspace.metric.casPropose);
        casCommit = createLatencyMetrics(""CasCommit"", cfs.keyspace.metric.casCommit);

        repairsStarted = createTableCounter(""RepairJobsStarted"");
        repairsCompleted = createTableCounter(""RepairJobsCompleted"");

        anticompactionTime = createTableTimer(""AnticompactionTime"", cfs.keyspace.metric.anticompactionTime);
        validationTime = createTableTimer(""ValidationTime"", cfs.keyspace.metric.validationTime);
        repairSyncTime = createTableTimer(""RepairSyncTime"", cfs.keyspace.metric.repairSyncTime);

        bytesValidated = createTableHistogram(""BytesValidated"", cfs.keyspace.metric.bytesValidated, false);
        partitionsValidated = createTableHistogram(""PartitionsValidated"", cfs.keyspace.metric.partitionsValidated, false);
        bytesAnticompacted = createTableCounter(""BytesAnticompacted"");
        bytesMutatedAnticompaction = createTableCounter(""BytesMutatedAnticompaction"");
        mutatedAnticompactionGauge = createTableGauge(""MutatedAnticompactionGauge"", () ->
        {
            double bytesMutated = bytesMutatedAnticompaction.getCount();
            double bytesAnticomp = bytesAnticompacted.getCount();
            if (bytesAnticomp + bytesMutated > 0)
                return bytesMutated / (bytesAnticomp + bytesMutated);
            return 0.0;
        });

        readRepairRequests = createTableMeter(""ReadRepairRequests"");
        shortReadProtectionRequests = createTableMeter(""ShortReadProtectionRequests"");
        replicaFilteringProtectionRequests = createTableMeter(""ReplicaFilteringProtectionRequests"");
        rfpRowsCachedPerQuery = createHistogram(""ReplicaFilteringProtectionRowsCachedPerQuery"", true);

        confirmedRepairedInconsistencies = createTableMeter(""RepairedDataInconsistenciesConfirmed"", cfs.keyspace.metric.confirmedRepairedInconsistencies);
        unconfirmedRepairedInconsistencies = createTableMeter(""RepairedDataInconsistenciesUnconfirmed"", cfs.keyspace.metric.unconfirmedRepairedInconsistencies);

        repairedDataTrackingOverreadRows = createTableHistogram(""RepairedDataTrackingOverreadRows"", cfs.keyspace.metric.repairedDataTrackingOverreadRows, false);
        repairedDataTrackingOverreadTime = createTableTimer(""RepairedDataTrackingOverreadTime"", cfs.keyspace.metric.repairedDataTrackingOverreadTime);

        unleveledSSTables = createTableGauge(""UnleveledSSTables"", cfs::getUnleveledSSTables, () -> {
            // global gauge
            int cnt = 0;
            for (Metric cfGauge : ALL_TABLE_METRICS.get(""UnleveledSSTables""))
            {
                cnt += ((Gauge<? extends Number>) cfGauge).getValue().intValue();
            }
            return cnt;
        });
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.ColumnFamilyStore:isIndex(),isIndex,ColumnFamilyStore,../data/xml/cassandra_call_methods/ColumnFamilyStore.xml,"/** true if this CFS contains secondary index data */
public boolean isIndex()
    {
        return metadata().isIndex();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.db.CassandraTableWriteHandler:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,CassandraTableWriteHandler,../data/xml/cassandra_call_methods/CassandraTableWriteHandler.xml,"
public CassandraTableWriteHandler(ColumnFamilyStore cfs)
    {
        this.cfs = cfs;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.db.streaming.CassandraStreamManager:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,CassandraStreamManager,../data/xml/cassandra_call_methods/CassandraStreamManager.xml,"
public CassandraStreamManager(ColumnFamilyStore cfs)
    {
        this.cfs = cfs;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.db.repair.CassandraTableRepairManager:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,CassandraTableRepairManager,../data/xml/cassandra_call_methods/CassandraTableRepairManager.xml,"
public CassandraTableRepairManager(ColumnFamilyStore cfs)
    {
        this.cfs = cfs;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.db.SSTableImporter:<init>(org.apache.cassandra.db.ColumnFamilyStore),<init>,SSTableImporter,../data/xml/cassandra_call_methods/SSTableImporter.xml,"
public SSTableImporter(ColumnFamilyStore cfs)
    {
        this.cfs = cfs;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Mutation:getTableIds(),getTableIds,Mutation,../data/xml/cassandra_call_methods/Mutation.xml,"
public Collection<TableId> getTableIds()
    {
        return modifications.keySet();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Mutation:key(),key,Mutation,../data/xml/cassandra_call_methods/Mutation.xml,"
public DecoratedKey key()
    {
        return key;
    }

    

public DecoratedKey key()
        {
            return key;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.DecoratedKey:getKey(),getKey,DecoratedKey,../data/xml/cassandra_call_methods/DecoratedKey.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(S)org.apache.cassandra.db.view.ViewManager:acquireLockFor(int),acquireLockFor,ViewManager,../data/xml/cassandra_call_methods/ViewManager.xml,"
public static Lock acquireLockFor(int keyAndCfidHash)
    {
        Lock lock = LOCKS.get(keyAndCfidHash);

        if (lock.tryLock())
            return lock;

        return null;
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(I)org.apache.cassandra.utils.MonotonicClock:isAfter(long),isAfter,MonotonicClock,../data/xml/cassandra_call_methods/MonotonicClock.xml,"
@Override
        public boolean isAfter(long instant)
        {
            return now() > instant;
        }

        

@Override
        public boolean isAfter(long now, long instant)
        {
            return now > instant;
        }
    }

@Override
        public boolean isAfter(long instant)
        {
            return isAfter(almostNow, instant);
        }

        

@Override
        public boolean isAfter(long now, long instant)
        {
            return now - ERROR_NANOS > instant;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(O)org.apache.cassandra.exceptions.WriteTimeoutException:<init>(org.apache.cassandra.db.WriteType,org.apache.cassandra.db.ConsistencyLevel,int,int)",<init>,WriteTimeoutException,../data/xml/cassandra_call_methods/WriteTimeoutException.xml,"
public WriteTimeoutException(WriteType writeType, ConsistencyLevel consistency, int received, int blockFor)
    {
        super(ExceptionCode.WRITE_TIMEOUT, consistency, received, blockFor);
        this.writeType = writeType;
    }

    

public WriteTimeoutException(WriteType writeType, ConsistencyLevel consistency, int received, int blockFor, String msg)
    {
        super(ExceptionCode.WRITE_TIMEOUT, consistency, received, blockFor, msg);
        this.writeType = writeType;
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(S)org.apache.cassandra.utils.FBUtilities:nowInSeconds(),nowInSeconds,FBUtilities,../data/xml/cassandra_call_methods/FBUtilities.xml,"
public static int nowInSeconds()
    {
        return (int) (System.currentTimeMillis() / 1000);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Keyspace:getWriteHandler(),getWriteHandler,Keyspace,../data/xml/cassandra_call_methods/Keyspace.xml,"
public KeyspaceWriteHandler getWriteHandler()
    {
        return writeHandler;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(I)org.apache.cassandra.db.KeyspaceWriteHandler:beginWrite(org.apache.cassandra.db.Mutation,boolean)",beginWrite,KeyspaceWriteHandler,../data/xml/cassandra_call_methods/KeyspaceWriteHandler.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.Mutation:getPartitionUpdates(),getPartitionUpdates,Mutation,../data/xml/cassandra_call_methods/Mutation.xml,"
public ImmutableCollection<PartitionUpdate> getPartitionUpdates()
    {
        return modifications.values();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.partitions.PartitionUpdate:metadata(),metadata,PartitionUpdate,../data/xml/cassandra_call_methods/PartitionUpdate.xml,"
public TableMetadata metadata()
    {
        return metadata;
    }

    

public TableMetadata metadata()
        {
            return metadata;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.schema.TableMetadata:toString(),toString,TableMetadata,../data/xml/cassandra_call_methods/TableMetadata.xml,"
@Override
    public String toString()
    {
        return format(""%s.%s"", ColumnIdentifier.maybeQuote(keyspace), ColumnIdentifier.maybeQuote(name));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(M)org.apache.cassandra.index.SecondaryIndexManager:newUpdateTransaction(org.apache.cassandra.db.partitions.PartitionUpdate,org.apache.cassandra.db.WriteContext,int)",newUpdateTransaction,SecondaryIndexManager,../data/xml/cassandra_call_methods/SecondaryIndexManager.xml,"/*
     * Handling of index updates.
     * Implementations of the various IndexTransaction interfaces, for keeping indexes in sync with base data
     * during updates, compaction and cleanup. Plus factory methods for obtaining transaction instances.
     */
/**
     * Transaction for updates on the write path.
     */
public UpdateTransaction newUpdateTransaction(PartitionUpdate update, WriteContext ctx, int nowInSec)
    {
        if (!hasIndexes())
            return UpdateTransaction.NO_OP;
        
        ArrayList<Index.Indexer> idxrs = new ArrayList<>();
        for (Index i : writableIndexes.values())
        {
            Index.Indexer idxr = i.indexerFor(update.partitionKey(), update.columns(), nowInSec, ctx, IndexTransaction.Type.UPDATE);
            if (idxr != null)
                idxrs.add(idxr);
        }
        
        if (idxrs.size() == 0)
            return UpdateTransaction.NO_OP;
        else
            return new WriteTimeTransaction(idxrs.toArray(new Index.Indexer[idxrs.size()]));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.db.ColumnFamilyStore:getWriteHandler(),getWriteHandler,ColumnFamilyStore,../data/xml/cassandra_call_methods/ColumnFamilyStore.xml,"
public TableWriteHandler getWriteHandler()
    {
        return writeHandler;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,"(I)org.apache.cassandra.db.TableWriteHandler:write(org.apache.cassandra.db.partitions.PartitionUpdate,org.apache.cassandra.db.WriteContext,org.apache.cassandra.index.transactions.UpdateTransaction)",write,TableWriteHandler,../data/xml/cassandra_call_methods/TableWriteHandler.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(I)org.apache.cassandra.db.WriteContext:close(),close,WriteContext,../data/xml/cassandra_call_methods/WriteContext.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.locator.TokenMetadata:getHostId(org.apache.cassandra.locator.InetAddressAndPort),getHostId,TokenMetadata,../data/xml/cassandra_call_methods/TokenMetadata.xml,"/** Return the unique host ID for an end-point. */
public UUID getHostId(InetAddressAndPort endpoint)
    {
        lock.readLock().lock();
        try
        {
            return endpointToHostIdMap.get(endpoint);
        }
        finally
        {
            lock.readLock().unlock();
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.locator.TokenMetadata:isMember(org.apache.cassandra.locator.InetAddressAndPort),isMember,TokenMetadata,../data/xml/cassandra_call_methods/TokenMetadata.xml,"
public boolean isMember(InetAddressAndPort endpoint)
    {
        assert endpoint != null;

        lock.readLock().lock();
        try
        {
            return tokenToEndpointMap.inverse().containsKey(endpoint);
        }
        finally
        {
            lock.readLock().unlock();
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.service.StorageService:removeEndpoint(org.apache.cassandra.locator.InetAddressAndPort),removeEndpoint,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"/** unlike excise we just need this endpoint gone without going through any notifications **/
private void removeEndpoint(InetAddressAndPort endpoint)
    {
        Gossiper.runInGossipStageBlocking(() -> Gossiper.instance.removeEndpoint(endpoint));
        MigrationCoordinator.instance.removeAndIgnoreEndpoint(endpoint);
        SystemKeyspace.removeEndpoint(endpoint);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.locator.TokenMetadata:removeEndpoint(org.apache.cassandra.locator.InetAddressAndPort),removeEndpoint,TokenMetadata,../data/xml/cassandra_call_methods/TokenMetadata.xml,"
public void removeEndpoint(InetAddressAndPort endpoint)
    {
        assert endpoint != null;

        lock.writeLock().lock();
        try
        {
            bootstrapTokens.removeValue(endpoint);
            tokenToEndpointMap.removeValue(endpoint);
            topology = topology.unbuild().removeEndpoint(endpoint).build();
            leavingEndpoints.remove(endpoint);
            if (replacementToOriginal.remove(endpoint) != null)
            {
                logger.debug(""Node {} failed during replace."", endpoint);
            }
            endpointToHostIdMap.remove(endpoint);
            sortedTokens = sortTokens();
            invalidateCachedRingsUnsafe();
        }
        finally
        {
            lock.writeLock().unlock();
        }
    }

    
/**
             * Removes current DC/rack assignment for ep
             */
Builder removeEndpoint(InetAddressAndPort ep)
            {
                if (!currentLocations.containsKey(ep))
                    return this;

                doRemoveEndpoint(ep, currentLocations.remove(ep));
                return this;
            }

            "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(O)org.apache.cassandra.service.StorageService:notifyLeft(org.apache.cassandra.locator.InetAddressAndPort),notifyLeft,StorageService,../data/xml/cassandra_call_methods/StorageService.xml,"
private void notifyLeft(InetAddressAndPort endpoint)
    {
        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)
            subscriber.onLeaveCluster(endpoint);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.service.PendingRangeCalculatorService:update(),update,PendingRangeCalculatorService,../data/xml/cassandra_call_methods/PendingRangeCalculatorService.xml,"
public void update()
    {
        int jobs = updateJobs.incrementAndGet();
        PendingRangeCalculatorServiceDiagnostics.taskCountChanged(instance, jobs);
        executor.execute(new PendingRangeTask(updateJobs));
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getWriteRpcTimeout(java.util.concurrent.TimeUnit),write_request_timeout_in_ms,(M)org.apache.cassandra.service.paxos.AbstractPaxosCallback:getResponseCount(),getResponseCount,AbstractPaxosCallback,../data/xml/cassandra_call_methods/AbstractPaxosCallback.xml,"
public int getResponseCount()
    {
        return (int) (targets - latch.getCount());
    }

    "
