function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(O)org.apache.cassandra.db.ColumnIndex:currentPosition(),currentPosition,ColumnIndex,../data/xml/cassandra_call_methods/ColumnIndex.xml,"private long currentPosition()
    {
        return writer.position() - initialPosition;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(I)org.apache.cassandra.db.rows.Unfiltered:clustering(),clustering,Unfiltered,../data/xml/cassandra_call_methods/Unfiltered.xml,not found.
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,"(M)org.apache.cassandra.db.rows.UnfilteredSerializer:serialize(org.apache.cassandra.db.rows.Unfiltered,org.apache.cassandra.db.rows.SerializationHelper,org.apache.cassandra.io.util.DataOutputPlus,long,int)",serialize,UnfilteredSerializer,../data/xml/cassandra_call_methods/UnfilteredSerializer.xml,"public void serialize(Unfiltered unfiltered, SerializationHelper helper, DataOutputPlus out, int version)
    throws IOException
    {
        assert !helper.header.isForSSTable();
        serialize(unfiltered, helper, out, 0, version);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(I)org.apache.cassandra.db.rows.Unfiltered:kind(),kind,Unfiltered,../data/xml/cassandra_call_methods/Unfiltered.xml,not found.
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(I)org.apache.cassandra.db.rows.RangeTombstoneMarker:isOpen(boolean),isOpen,RangeTombstoneMarker,../data/xml/cassandra_call_methods/RangeTombstoneMarker.xml,not found.
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(I)org.apache.cassandra.db.rows.RangeTombstoneMarker:openDeletionTime(boolean),openDeletionTime,RangeTombstoneMarker,../data/xml/cassandra_call_methods/RangeTombstoneMarker.xml,not found.
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(S)org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),getColumnIndexSize,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"public static int getColumnIndexSize()
    {
        return (int) ByteUnit.KIBI_BYTES.toBytes(conf.column_index_size_in_kb);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getColumnIndexSize(),column_index_size_in_kb_0,(O)org.apache.cassandra.db.ColumnIndex:addIndexBlock(),addIndexBlock,ColumnIndex,../data/xml/cassandra_call_methods/ColumnIndex.xml,"private void addIndexBlock() throws IOException
    {
        IndexInfo cIndexInfo = new IndexInfo(firstClustering,
                                             lastClustering,
                                             startPosition,
                                             currentPosition() - startPosition,
                                             openMarker);

        // indexOffsets is used for both shallow (ShallowIndexedEntry) and non-shallow IndexedEntry.
        // For shallow ones, we need it to serialize the offsts in finish().
        // For non-shallow ones, the offsts are passed into IndexedEntry, so we don't have to
        // calculate the offsets again.

        // indexOffsets contains the offsets of the serialized IndexInfo objects.
        // I.e. indexOffsets[0] is always 0 so we don't have to deal with a special handling
        // for index #0 and always subtracting 1 for the index (which could be error-prone).
        if (indexOffsets == null)
            indexOffsets = new int[10];
        else
        {
            if (columnIndexCount >= indexOffsets.length)
                indexOffsets = Arrays.copyOf(indexOffsets, indexOffsets.length + 10);

            //the 0th element is always 0
            if (columnIndexCount == 0)
            {
                indexOffsets[columnIndexCount] = 0;
            }
            else
            {
                indexOffsets[columnIndexCount] =
                buffer != null
                ? Ints.checkedCast(buffer.position())
                : indexSamplesSerializedSize;
            }
        }
        columnIndexCount++;

        // First, we collect the IndexInfo objects until we reach Config.column_index_cache_size_in_kb in an ArrayList.
        // When column_index_cache_size_in_kb is reached, we switch to byte-buffer mode.
        if (buffer == null)
        {
            indexSamplesSerializedSize += idxSerializer.serializedSize(cIndexInfo);
            if (indexSamplesSerializedSize + columnIndexCount * TypeSizes.sizeof(0) > cacheSizeThreshold)
            {
                buffer = reuseOrAllocateBuffer();
                for (IndexInfo indexSample : indexSamples)
                {
                    idxSerializer.serialize(indexSample, buffer);
                }
            }
            else
            {
                indexSamples.add(cIndexInfo);
            }
        }
        // don't put an else here since buffer may be allocated in preceding if block
        if (buffer != null)
        {
            idxSerializer.serialize(cIndexInfo, buffer);
        }

        firstClustering = null;
    }

    "
