function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(M)org.apache.cassandra.net.ConnectionCategory:ordinal(),ordinal,ConnectionCategory,../data/xml/cassandra_call_methods/ConnectionCategory.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeTcpUserTimeoutInMS(),getInternodeTcpUserTimeoutInMS,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getInternodeTcpUserTimeoutInMS()
    {
        return conf.internode_tcp_user_timeout_in_ms;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(S)org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),getInternodeStreamingTcpUserTimeoutInMS,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getInternodeStreamingTcpUserTimeoutInMS()
    {
        return conf.internode_streaming_tcp_user_timeout_in_ms;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(M)org.apache.cassandra.streaming.StreamSession:isPreview(),isPreview,StreamSession,../data/xml/cassandra_call_methods/StreamSession.xml,"
public boolean isPreview()
    {
        return previewKind.isPreview();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(M)org.apache.cassandra.streaming.StreamSession:planId(),planId,StreamSession,../data/xml/cassandra_call_methods/StreamSession.xml,"
public UUID planId()
    {
        return streamResult == null ? null : streamResult.planId;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(I)org.apache.cassandra.streaming.IncomingStream:getSize(),getSize,IncomingStream,../data/xml/cassandra_call_methods/IncomingStream.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,"(O)org.apache.cassandra.streaming.messages.ReceivedMessage:<init>(org.apache.cassandra.schema.TableId,int)",<init>,ReceivedMessage,../data/xml/cassandra_call_methods/ReceivedMessage.xml,"
public ReceivedMessage(TableId tableId, int sequenceNumber)
    {
        super(Type.RECEIVED);
        this.tableId = tableId;
        this.sequenceNumber = sequenceNumber;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(M)org.apache.cassandra.streaming.async.NettyStreamingMessageSender:sendMessage(org.apache.cassandra.streaming.messages.StreamMessage),sendMessage,NettyStreamingMessageSender,../data/xml/cassandra_call_methods/NettyStreamingMessageSender.xml,"
@Override
    public void sendMessage(StreamMessage message)
    {
        if (closed)
            throw new RuntimeException(""stream has been closed, cannot send "" + message);

        if (message instanceof OutgoingStreamMessage)
        {
            if (isPreview)
                throw new RuntimeException(""Cannot send stream data messages for preview streaming sessions"");
            if (logger.isDebugEnabled())
                logger.debug(""{} Sending {}"", createLogTag(session, null), message);

            // Supply a preferred IP up-front to avoid trying to get it in the executor thread, which can be interrupted.
            OutboundConnectionSettings templateWithConnectTo = template.withConnectTo(template.connectTo());
            fileTransferExecutor.submit(new FileStreamTask((OutgoingStreamMessage) message, templateWithConnectTo));
            return;
        }

        try
        {
            setupControlMessageChannel(template);
            sendControlMessage(controlMessageChannel, message, future -> onControlMessageComplete(future, message));
        }
        catch (Exception e)
        {
            close();
            session.onError(e);
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,"(I)org.apache.cassandra.streaming.StreamHook:reportIncomingStream(org.apache.cassandra.schema.TableId,org.apache.cassandra.streaming.IncomingStream,org.apache.cassandra.streaming.StreamSession,int)",reportIncomingStream,StreamHook,../data/xml/cassandra_call_methods/StreamHook.xml,"
public void reportIncomingStream(TableId tableId, IncomingStream stream, StreamSession session, int sequenceNumber) {}
            }"
org.apache.cassandra.config.DatabaseDescriptor:getInternodeStreamingTcpUserTimeoutInMS(),internode_streaming_tcp_user_timeout_in_ms,(M)org.apache.cassandra.streaming.StreamReceiveTask:received(org.apache.cassandra.streaming.IncomingStream),received,StreamReceiveTask,../data/xml/cassandra_call_methods/StreamReceiveTask.xml,"/**
     * Process received stream.
     *
     * @param stream Stream received.
     */
public synchronized void received(IncomingStream stream)
    {
        Preconditions.checkState(!session.isPreview(), ""we should never receive sstables when previewing"");

        if (done)
        {
            logger.warn(""[{}] Received stream {} on already finished stream received task. Aborting stream."", session.planId(),
                        stream.getName());
            receiver.discardStream(stream);
            return;
        }

        remoteStreamsReceived += stream.getNumFiles();
        bytesReceived += stream.getSize();
        Preconditions.checkArgument(tableId.equals(stream.getTableId()));
        logger.debug(""received {} of {} total files, {} of total bytes {}"", remoteStreamsReceived, totalStreams,
                     bytesReceived, stream.getSize());

        receiver.received(stream);

        if (remoteStreamsReceived == totalStreams)
        {
            done = true;
            executor.submit(new OnCompletionRunnable(this));
        }
    }

    "
