function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(I)org.apache.cassandra.io.util.DataInputPlus:readUnsignedVInt(),readUnsignedVInt,DataInputPlus,../data/xml/cassandra_call_methods/DataInputPlus.xml,"/**
     * Think hard before opting for an unsigned encoding. Is this going to bite someone because some day
     * they might need to pass in a sentinel value using negative numbers? Is the risk worth it
     * to save a few bytes?
     *
     * Signed, not a fan of unsigned values in protocols and formats
     */
default long readUnsignedVInt() throws IOException
    {
        return VIntCoding.readUnsignedVInt(this);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(S)org.apache.cassandra.db.ClusteringPrefix$Serializer:access$000(long,int)",access$000,ClusteringPrefix$Serializer,../data/xml/cassandra_call_methods/ClusteringPrefix.xml,"
ClusteringPrefix<V> 

ClusteringPrefix<V>

ClusteringPrefix<?>

ClusteringPrefix<byte[]>

ClusteringPrefix<?>

ClusteringPrefix<V>

ClusteringPrefix<V>

ClusteringPrefix<V>

ClusteringPrefix.Kind

ClusteringPrefix.Kind.values

ClusteringPrefix.Kind

ClusteringPrefix<V>

ClusteringPrefix<V1>

ClusteringPrefix<V2>

ClusteringPrefix<?>

ClusteringPrefix<?>"
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(S)org.apache.cassandra.db.ClusteringPrefix$Serializer:access$100(long,int)",access$100,ClusteringPrefix$Serializer,../data/xml/cassandra_call_methods/ClusteringPrefix.xml,"
ClusteringPrefix<V> 

ClusteringPrefix<V>

ClusteringPrefix<?>

ClusteringPrefix<byte[]>

ClusteringPrefix<?>

ClusteringPrefix<V>

ClusteringPrefix<V>

ClusteringPrefix<V>

ClusteringPrefix.Kind

ClusteringPrefix.Kind.values

ClusteringPrefix.Kind

ClusteringPrefix<V>

ClusteringPrefix<V1>

ClusteringPrefix<V2>

ClusteringPrefix<?>

ClusteringPrefix<?>"
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.SerializationHeader:clusteringTypes(),clusteringTypes,SerializationHeader,../data/xml/cassandra_call_methods/SerializationHeader.xml,"
public List<AbstractType<?>> clusteringTypes()
    {
        return clusteringTypes;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(S)org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),getMaxValueSize,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static int getMaxValueSize()
    {
        return conf.max_value_size_in_mb * 1024 * 1024;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(M)org.apache.cassandra.db.marshal.AbstractType:readArray(org.apache.cassandra.io.util.DataInputPlus,int)",readArray,AbstractType,../data/xml/cassandra_call_methods/AbstractType.xml,"
public byte[] readArray(DataInputPlus in, int maxValueSize) throws IOException
    {
        return read(ByteArrayAccessor.instance, in, maxValueSize);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(S)org.apache.cassandra.db.ClusteringPrefix$Serializer:isNull(long,int)",isNull,ClusteringPrefix$Serializer,../data/xml/cassandra_call_methods/ClusteringPrefix.xml,"// no need to do modulo arithmetic for i, since the left-shift execute on the modulus of RH operand by definition
private static boolean isNull(long header, int i)
        {
            long mask = 1L << (i * 2) + 1;
            return (header & mask) != 0;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(S)org.apache.cassandra.db.ClusteringPrefix$Serializer:isEmpty(long,int)",isEmpty,ClusteringPrefix$Serializer,../data/xml/cassandra_call_methods/ClusteringPrefix.xml,"
default boolean isEmpty()
    {
        return size() == 0;
    }

    
// no need to do modulo arithmetic for i, since the left-shift execute on the modulus of RH operand by definition
private static boolean isEmpty(long header, int i)
        {
            long mask = 1L << (i * 2);
            return (header & mask) != 0;
        }
    }"
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(M)org.apache.cassandra.db.marshal.AbstractType:readBuffer(org.apache.cassandra.io.util.DataInputPlus,int)",readBuffer,AbstractType,../data/xml/cassandra_call_methods/AbstractType.xml,"
public ByteBuffer readBuffer(DataInputPlus in) throws IOException
    {
        return readBuffer(in, Integer.MAX_VALUE);
    }

    

public ByteBuffer readBuffer(DataInputPlus in, int maxValueSize) throws IOException
    {
        return read(ByteBufferAccessor.instance, in, maxValueSize);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(I)org.apache.cassandra.db.filter.ClusteringIndexFilter$Serializer:deserialize(org.apache.cassandra.io.util.DataInputPlus,int,org.apache.cassandra.schema.TableMetadata)",deserialize,ClusteringIndexFilter$Serializer,../data/xml/cassandra_call_methods/ClusteringIndexFilter.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(O)org.apache.cassandra.db.SinglePartitionReadCommand:<init>(boolean,int,boolean,org.apache.cassandra.schema.TableMetadata,int,org.apache.cassandra.db.filter.ColumnFilter,org.apache.cassandra.db.filter.RowFilter,org.apache.cassandra.db.filter.DataLimits,org.apache.cassandra.db.DecoratedKey,org.apache.cassandra.db.filter.ClusteringIndexFilter,org.apache.cassandra.schema.IndexMetadata)",<init>,SinglePartitionReadCommand,../data/xml/cassandra_call_methods/SinglePartitionReadCommand.xml,"
@VisibleForTesting
    protected SinglePartitionReadCommand(boolean isDigest,
                                         int digestVersion,
                                         boolean acceptsTransient,
                                         TableMetadata metadata,
                                         int nowInSec,
                                         ColumnFilter columnFilter,
                                         RowFilter rowFilter,
                                         DataLimits limits,
                                         DecoratedKey partitionKey,
                                         ClusteringIndexFilter clusteringIndexFilter,
                                         IndexMetadata index)
    {
        super(Kind.SINGLE_PARTITION, isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, index);
        assert partitionKey.getPartitioner() == metadata.partitioner;
        this.partitionKey = partitionKey;
        this.clusteringIndexFilter = clusteringIndexFilter;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(I)org.apache.cassandra.io.util.DataInputPlus:readUnsignedByte(),readUnsignedByte,DataInputPlus,../data/xml/cassandra_call_methods/DataInputPlus.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.LivenessInfo:timestamp(),timestamp,LivenessInfo,../data/xml/cassandra_call_methods/LivenessInfo.xml,"/**
     * The timestamp for this liveness info.
     *
     * @return the liveness info timestamp (or {@link #NO_TIMESTAMP} if the info is empty).
     */
public long timestamp()
    {
        return timestamp;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.SerializationHeader:readTimestamp(org.apache.cassandra.io.util.DataInputPlus),readTimestamp,SerializationHeader,../data/xml/cassandra_call_methods/SerializationHeader.xml,"
public long readTimestamp(DataInputPlus in) throws IOException
    {
        return in.readUnsignedVInt() + stats.minTimestamp;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.LivenessInfo:localExpirationTime(),localExpirationTime,LivenessInfo,../data/xml/cassandra_call_methods/LivenessInfo.xml,"/**
     * The expiration time (in seconds) if the info is expiring ({@link #NO_EXPIRATION_TIME} otherwise).
     *
     */
public int localExpirationTime()
    {
        return NO_EXPIRATION_TIME;
    }

    

@Override
        public int localExpirationTime()
        {
            return localExpirationTime;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.SerializationHeader:readLocalDeletionTime(org.apache.cassandra.io.util.DataInputPlus),readLocalDeletionTime,SerializationHeader,../data/xml/cassandra_call_methods/SerializationHeader.xml,"
public int readLocalDeletionTime(DataInputPlus in) throws IOException
    {
        return (int)in.readUnsignedVInt() + stats.minLocalDeletionTime;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.LivenessInfo:ttl(),ttl,LivenessInfo,../data/xml/cassandra_call_methods/LivenessInfo.xml,"/**
     * The ttl (if any) on the row primary key columns or {@link #NO_TTL} if it is not
     * expiring.
     *
     * Please note that this value is the TTL that was set originally and is thus not
     * changing.
     */
public int ttl()
    {
        return NO_TTL;
    }

    

@Override
        public int ttl()
        {
            return ttl;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.SerializationHeader:readTTL(org.apache.cassandra.io.util.DataInputPlus),readTTL,SerializationHeader,../data/xml/cassandra_call_methods/SerializationHeader.xml,"
public int readTTL(DataInputPlus in) throws IOException
    {
        return (int)in.readUnsignedVInt() + stats.minTTL;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.schema.ColumnMetadata:isComplex(),isComplex,ColumnMetadata,../data/xml/cassandra_call_methods/ColumnMetadata.xml,"
public boolean isComplex()
    {
        return cellPathComparator != null;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.schema.ColumnMetadata:cellPathSerializer(),cellPathSerializer,ColumnMetadata,../data/xml/cassandra_call_methods/ColumnMetadata.xml,"
public CellPath.Serializer cellPathSerializer()
    {
        // Collections are our only complex so far, so keep it simple
        return CollectionType.cellPathSerializer;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(I)org.apache.cassandra.db.rows.CellPath$Serializer:deserialize(org.apache.cassandra.io.util.DataInputPlus),deserialize,CellPath$Serializer,../data/xml/cassandra_call_methods/CellPath.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(I)org.apache.cassandra.db.marshal.ValueAccessor:empty(),empty,ValueAccessor,../data/xml/cassandra_call_methods/ValueAccessor.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.rows.DeserializationHelper:canSkipValue(org.apache.cassandra.schema.ColumnMetadata),canSkipValue,DeserializationHelper,../data/xml/cassandra_call_methods/DeserializationHelper.xml,"
public boolean canSkipValue(ColumnMetadata column)
    {
        return columnsToFetch != null && !columnsToFetch.fetchedColumnIsQueried(column);
    }

    

public boolean canSkipValue(CellPath path)
    {
        return path != null && tester != null && !tester.fetchedCellIsQueried(path);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.rows.DeserializationHelper:canSkipValue(org.apache.cassandra.db.rows.CellPath),canSkipValue,DeserializationHelper,../data/xml/cassandra_call_methods/DeserializationHelper.xml,"
public boolean canSkipValue(ColumnMetadata column)
    {
        return columnsToFetch != null && !columnsToFetch.fetchedColumnIsQueried(column);
    }

    

public boolean canSkipValue(CellPath path)
    {
        return path != null && tester != null && !tester.fetchedCellIsQueried(path);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.SerializationHeader:getType(org.apache.cassandra.schema.ColumnMetadata),getType,SerializationHeader,../data/xml/cassandra_call_methods/SerializationHeader.xml,"
public AbstractType<?> getType(ColumnMetadata column)
    {
        return typeMap == null ? column.type : typeMap.get(column.name.bytes);
    }

    

public MetadataType getType()
        {
            return MetadataType.HEADER;
        }

        "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.marshal.AbstractType:skipValue(org.apache.cassandra.io.util.DataInputPlus),skipValue,AbstractType,../data/xml/cassandra_call_methods/AbstractType.xml,"
public void skipValue(DataInputPlus in) throws IOException
    {
        int length = valueLengthIfFixed();
        if (length >= 0)
            in.skipBytesFully(length);
        else
            ByteBufferUtil.skipWithVIntLength(in);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(M)org.apache.cassandra.db.marshal.AbstractType:isCounter(),isCounter,AbstractType,../data/xml/cassandra_call_methods/AbstractType.xml,"
public boolean isCounter()
    {
        return false;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,"(M)org.apache.cassandra.db.marshal.AbstractType:read(org.apache.cassandra.db.marshal.ValueAccessor,org.apache.cassandra.io.util.DataInputPlus,int)",read,AbstractType,../data/xml/cassandra_call_methods/AbstractType.xml,"
public <V> V read(ValueAccessor<V> accessor, DataInputPlus in, int maxValueSize) throws IOException
    {
        int length = valueLengthIfFixed();

        if (length >= 0)
            return accessor.read(in, length);
        else
        {
            int l = (int)in.readUnsignedVInt();
            if (l < 0)
                throw new IOException(""Corrupt (negative) value length encountered"");

            if (l > maxValueSize)
                throw new IOException(String.format(""Corrupt value length %d encountered, as it exceeds the maximum of %d, "" +
                                                    ""which is set via max_value_size_in_mb in cassandra.yaml"",
                                                    l, maxValueSize));

            return accessor.read(in, l);
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getMaxValueSize(),max_value_size_in_mb,(I)org.apache.cassandra.db.marshal.ValueAccessor:factory(),factory,ValueAccessor,../data/xml/cassandra_call_methods/ValueAccessor.xml,not found
