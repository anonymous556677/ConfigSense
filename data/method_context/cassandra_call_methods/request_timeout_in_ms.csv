function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.repair.messages.RepairOption:getPreviewKind(),getPreviewKind,RepairOption,../data/xml/cassandra_call_methods/RepairOption.xml,"
public PreviewKind getPreviewKind()
    {
        return previewKind;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,"(S)org.apache.cassandra.service.ActiveRepairService:getRepairedAt(org.apache.cassandra.repair.messages.RepairOption,boolean)",getRepairedAt,ActiveRepairService,../data/xml/cassandra_call_methods/ActiveRepairService.xml,"/**
     * we only want to set repairedAt for incremental repairs including all replicas for a token range. For non-global
     * incremental repairs, forced incremental repairs, and full repairs, the UNREPAIRED_SSTABLE value will prevent
     * sstables from being promoted to repaired or preserve the repairedAt/pendingRepair values, respectively.
     */
static long getRepairedAt(RepairOption options, boolean force)
    {
        // we only want to set repairedAt for incremental repairs including all replicas for a token range. For non-global incremental repairs, full repairs, the UNREPAIRED_SSTABLE value will prevent
        // sstables from being promoted to repaired or preserve the repairedAt/pendingRepair values, respectively. For forced repairs, repairedAt time is only set to UNREPAIRED_SSTABLE if we actually
        // end up skipping replicas
        if (options.isIncremental() && options.isGlobal() && ! force)
        {
            return System.currentTimeMillis();
        }
        else
        {
            return  ActiveRepairService.UNREPAIRED_SSTABLE;
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.repair.messages.RepairOption:getRanges(),getRanges,RepairOption,../data/xml/cassandra_call_methods/RepairOption.xml,"
public Collection<Range<Token>> getRanges()
    {
        return ranges;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.repair.messages.RepairOption:isIncremental(),isIncremental,RepairOption,../data/xml/cassandra_call_methods/RepairOption.xml,"
public boolean isIncremental()
    {
        return incremental;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.repair.messages.RepairOption:isGlobal(),isGlobal,RepairOption,../data/xml/cassandra_call_methods/RepairOption.xml,"
public boolean isGlobal()
    {
        return dataCenters.isEmpty() && hosts.isEmpty();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(I)org.apache.cassandra.gms.IFailureDetector:isAlive(org.apache.cassandra.locator.InetAddressAndPort),isAlive,IFailureDetector,../data/xml/cassandra_call_methods/IFailureDetector.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(S)org.apache.cassandra.net.MessagingService:instance(),instance,MessagingService,../data/xml/cassandra_call_methods/MessagingService.xml,"
public static MessagingService instance()
    {
        return MSHandle.instance;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,"(M)org.apache.cassandra.net.MessagingService:sendWithCallback(org.apache.cassandra.net.Message,org.apache.cassandra.locator.InetAddressAndPort,org.apache.cassandra.net.RequestCallback)",sendWithCallback,MessagingService,../data/xml/cassandra_call_methods/MessagingService.xml,"/**
     * Send a non-mutation message to a given endpoint. This method specifies a callback
     * which is invoked with the actual response.
     *
     * @param message message to be sent.
     * @param to      endpoint to which the message needs to be sent
     * @param cb      callback interface which is used to pass the responses or
     *                suggest that a timeout occurred to the invoker of the send().
     */
public void sendWithCallback(Message message, InetAddressAndPort to, RequestCallback cb)
    {
        sendWithCallback(message, to, cb, null);
    }

    

public void sendWithCallback(Message message, InetAddressAndPort to, RequestCallback cb, ConnectionType specifyConnection)
    {
        callbacks.addWithExpiration(cb, message, to);
        if (cb.invokeOnFailure() && !message.callBackOnFailure())
            message = message.withCallBackOnFailure();
        send(message, to, specifyConnection);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.schema.Schema:getVersion(),getVersion,Schema,../data/xml/cassandra_call_methods/Schema.xml,"/* Version control */
/**
     * @return current schema version
     */
public UUID getVersion()
    {
        return version;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.gms.Gossiper:getLiveMembers(),getLiveMembers,Gossiper,../data/xml/cassandra_call_methods/Gossiper.xml,"/**
     * @return a list of live gossip participants, including fat clients
     */
public Set<InetAddressAndPort> getLiveMembers()
    {
        Set<InetAddressAndPort> liveMembers = new HashSet<>(liveEndpoints);
        if (!liveMembers.contains(FBUtilities.getBroadcastAddressAndPort()))
            liveMembers.add(FBUtilities.getBroadcastAddressAndPort());
        return liveMembers;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.gms.Gossiper:getUnreachableMembers(),getUnreachableMembers,Gossiper,../data/xml/cassandra_call_methods/Gossiper.xml,"/**
     * @return a list of unreachable gossip participants, including fat clients
     */
public Set<InetAddressAndPort> getUnreachableMembers()
    {
        return unreachableEndpoints.keySet();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.locator.InetAddressAndPort:getHostAddress(boolean),getHostAddress,InetAddressAndPort,../data/xml/cassandra_call_methods/InetAddressAndPort.xml,"
public String getHostAddress(boolean withPort)
    {
        if (withPort)
        {
            return HostAndPort.fromParts(address.getHostAddress(), port).toString();
        }
        else
        {
            return address.getHostAddress();
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(O)org.apache.cassandra.net.AsyncOneResponse:<init>(),<init>,AsyncOneResponse,../data/xml/cassandra_call_methods/AsyncOneResponse.xml,"
public AsyncOneResponse()
    {
        super(ImmediateEventExecutor.INSTANCE);
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.net.AsyncOneResponse:isSuccess(),isSuccess,AsyncOneResponse,../data/xml/cassandra_call_methods/AsyncOneResponse.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getRpcTimeout(java.util.concurrent.TimeUnit),request_timeout_in_ms,(M)org.apache.cassandra.net.AsyncOneResponse:cause(),cause,AsyncOneResponse,../data/xml/cassandra_call_methods/AsyncOneResponse.xml,not found
