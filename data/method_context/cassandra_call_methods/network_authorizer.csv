function,option,Method,Method_short,class_name,xml_path,Method_body
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(S)org.apache.cassandra.config.DatabaseDescriptor:getAuthorizer(),getAuthorizer,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IAuthorizer getAuthorizer()
    {
        return authorizer;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(O)org.apache.cassandra.auth.PermissionsCache:<init>(org.apache.cassandra.auth.IAuthorizer),<init>,PermissionsCache,../data/xml/cassandra_call_methods/PermissionsCache.xml,"
public PermissionsCache(IAuthorizer authorizer)
    {
        super(""PermissionsCache"",
              DatabaseDescriptor::setPermissionsValidity,
              DatabaseDescriptor::getPermissionsValidity,
              DatabaseDescriptor::setPermissionsUpdateInterval,
              DatabaseDescriptor::getPermissionsUpdateInterval,
              DatabaseDescriptor::setPermissionsCacheMaxEntries,
              DatabaseDescriptor::getPermissionsCacheMaxEntries,
              (p) -> authorizer.authorize(p.left, p.right),
              () -> DatabaseDescriptor.getAuthorizer().requireAuthorization());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(S)org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),getNetworkAuthorizer,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static INetworkAuthorizer getNetworkAuthorizer()
    {
        return networkAuthorizer;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(O)org.apache.cassandra.auth.NetworkAuthCache:<init>(org.apache.cassandra.auth.INetworkAuthorizer),<init>,NetworkAuthCache,../data/xml/cassandra_call_methods/NetworkAuthCache.xml,"
public NetworkAuthCache(INetworkAuthorizer authorizer)
    {
        super(""NetworkAuthCache"",
              DatabaseDescriptor::setRolesValidity,
              DatabaseDescriptor::getRolesValidity,
              DatabaseDescriptor::setRolesUpdateInterval,
              DatabaseDescriptor::getRolesUpdateInterval,
              DatabaseDescriptor::setRolesCacheMaxEntries,
              DatabaseDescriptor::getRolesCacheMaxEntries,
              authorizer::authorize,
              () -> DatabaseDescriptor.getAuthenticator().requireAuthentication());
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(M)org.apache.cassandra.auth.RoleOptions:isEmpty(),isEmpty,RoleOptions,../data/xml/cassandra_call_methods/RoleOptions.xml,"/**
     * Return true if there are no options with values set, false otherwise
     * @return whether any options have values set or not
     */
public boolean isEmpty()
    {
        return options.isEmpty();
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(S)org.apache.cassandra.config.DatabaseDescriptor:getRoleManager(),getRoleManager,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IRoleManager getRoleManager()
    {
        return roleManager;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(M)org.apache.cassandra.service.ClientState:getUser(),getUser,ClientState,../data/xml/cassandra_call_methods/ClientState.xml,"
public AuthenticatedUser getUser()
    {
        return user;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,"(I)org.apache.cassandra.auth.IRoleManager:alterRole(org.apache.cassandra.auth.AuthenticatedUser,org.apache.cassandra.auth.RoleResource,org.apache.cassandra.auth.RoleOptions)",alterRole,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,"(I)org.apache.cassandra.auth.INetworkAuthorizer:setRoleDatacenters(org.apache.cassandra.auth.RoleResource,org.apache.cassandra.auth.DCPermissions)",setRoleDatacenters,INetworkAuthorizer,../data/xml/cassandra_call_methods/INetworkAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IRoleManager:isExistingRole(org.apache.cassandra.auth.RoleResource),isExistingRole,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,"(I)org.apache.cassandra.auth.IRoleManager:createRole(org.apache.cassandra.auth.AuthenticatedUser,org.apache.cassandra.auth.RoleResource,org.apache.cassandra.auth.RoleOptions)",createRole,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.INetworkAuthorizer:requireAuthorization(),requireAuthorization,INetworkAuthorizer,../data/xml/cassandra_call_methods/INetworkAuthorizer.xml,"/**
     * Whether or not the authorizer will attempt authorization.
     * If false the authorizer will not be called for authorization of resources.
     */
default boolean requireAuthorization()
    {
        return true;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(O)org.apache.cassandra.cql3.statements.CreateRoleStatement:grantPermissionsToCreator(org.apache.cassandra.service.ClientState),grantPermissionsToCreator,CreateRoleStatement,../data/xml/cassandra_call_methods/CreateRoleStatement.xml,"/**
     * Grant all applicable permissions on the newly created role to the user performing the request
     * see also: AlterTableStatement#createdResources() and the overridden implementations
     * of it in subclasses CreateKeyspaceStatement & CreateTableStatement.
     * @param state
     */
private void grantPermissionsToCreator(ClientState state)
    {
        // The creator of a Role automatically gets ALTER/DROP/AUTHORIZE/DESCRIBE permissions on it if:
        // * the user is not anonymous
        // * the configured IAuthorizer supports granting of permissions (not all do, AllowAllAuthorizer doesn't and
        //   custom external implementations may not)
        if (!state.getUser().isAnonymous())
        {
            try
            {
                DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
                                                         role.applicablePermissions(),
                                                         role,
                                                         RoleResource.role(state.getUser().getName()));
            }
            catch (UnsupportedOperationException e)
            {
                // not a problem, grant is an optional method on IAuthorizer
            }
        }
    }
    
    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,"(I)org.apache.cassandra.auth.IRoleManager:dropRole(org.apache.cassandra.auth.AuthenticatedUser,org.apache.cassandra.auth.RoleResource)",dropRole,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IAuthorizer:revokeAllFrom(org.apache.cassandra.auth.RoleResource),revokeAllFrom,IAuthorizer,../data/xml/cassandra_call_methods/IAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IAuthorizer:revokeAllOn(org.apache.cassandra.auth.IResource),revokeAllOn,IAuthorizer,../data/xml/cassandra_call_methods/IAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.INetworkAuthorizer:drop(org.apache.cassandra.auth.RoleResource),drop,INetworkAuthorizer,../data/xml/cassandra_call_methods/INetworkAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(O)org.apache.cassandra.cql3.ResultSet:<init>(org.apache.cassandra.cql3.ResultSet$ResultMetadata),<init>,ResultSet,../data/xml/cassandra_call_methods/ResultSet.xml,"
public ResultSet(ResultMetadata resultMetadata)
    {
        this(resultMetadata, new ArrayList<List<ByteBuffer>>());
    }

    

public ResultSet(ResultMetadata resultMetadata, List<List<ByteBuffer>> rows)
    {
        this.metadata = resultMetadata;
        this.rows = rows;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(M)org.apache.cassandra.auth.RoleResource:getRoleName(),getRoleName,RoleResource,../data/xml/cassandra_call_methods/RoleResource.xml,"/**
     * @return short form name of a role level resource. i.e. not the full ""root/name"" version returned by getName().
     * Throws IllegalStateException if called on the root-level resource.
     */
public String getRoleName()
    {
        if (level == Level.ROOT)
            throw new IllegalStateException(String.format(""%s role resource has no role name"", level));
        return name;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IRoleManager:isSuper(org.apache.cassandra.auth.RoleResource),isSuper,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IRoleManager:canLogin(org.apache.cassandra.auth.RoleResource),canLogin,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IRoleManager:getCustomOptions(org.apache.cassandra.auth.RoleResource),getCustomOptions,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.INetworkAuthorizer:authorize(org.apache.cassandra.auth.RoleResource),authorize,INetworkAuthorizer,../data/xml/cassandra_call_methods/INetworkAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(O)org.apache.cassandra.transport.messages.ResultMessage$Rows:<init>(org.apache.cassandra.cql3.ResultSet),<init>,ResultMessage$Rows,../data/xml/cassandra_call_methods/ResultMessage.xml,"
public abstract class ResultMessage extends Message.Response
{
    public static final Message.Codec<ResultMessage> codec = new Message.Codec<ResultMessage>()
    {
        public ResultMessage decode(ByteBuf body, ProtocolVersion version)
        {
            Kind kind = Kind.fromId(body.readInt());
            return kind.subcodec.decode(body, version);
        }

        public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
        {
            dest.writeInt(msg.kind.id);
            msg.kind.subcodec.encode(msg, dest, version);
        }

        public int encodedSize(ResultMessage msg, ProtocolVersion version)
        {
            return 4 + msg.kind.subcodec.encodedSize(msg, version);
        }
    };

    public enum Kind
    {

        VOID               (1, Void.subcodec),
        ROWS               (2, Rows.subcodec),
        SET_KEYSPACE       (3, SetKeyspace.subcodec),
        PREPARED           (4, Prepared.subcodec),
        SCHEMA_CHANGE      (5, SchemaChange.subcodec);
        public final int id;
        public final Message.Codec<ResultMessage> subcodec;

        private static final Kind[] ids;
        static
        {
            int maxId = -1;
            for (Kind k : Kind.values())
                maxId = Math.max(maxId, k.id);
            ids = new Kind[maxId + 1];
            for (Kind k : Kind.values())
            {
                if (ids[k.id] != null)
                    throw new IllegalStateException(""Duplicate kind id"");
                ids[k.id] = k;
            }
        }

        private Kind(int id, Message.Codec<ResultMessage> subcodec)
        {
            this.id = id;
            this.subcodec = subcodec;
        }

        public static Kind fromId(int id)
        {
            Kind k = ids[id];
            if (k == null)
                throw new ProtocolException(String.format(""Unknown kind id %d in RESULT message"", id));
            return k;
        }
    }

    public final Kind kind;

    protected ResultMessage(Kind kind)
    {
        super(Message.Type.RESULT);
        this.kind = kind;
    }

    public static class Void extends ResultMessage
    {
        // Even though we have no specific information here, don't make a
        // singleton since as each message it has in fact a streamid and connection.
        public Void()
        {
            super(Kind.VOID);
        }

        public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
        {
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
                return new Void();
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
                assert msg instanceof Void;
            }

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
                return 0;
            }
        };

        @Override
        public String toString()
        {
            return ""EMPTY RESULT"";
        }
    }

    public static class SetKeyspace extends ResultMessage
    {
        public final String keyspace;

        public SetKeyspace(String keyspace)
        {
            super(Kind.SET_KEYSPACE);
            this.keyspace = keyspace;
        }

        public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
        {
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
                String keyspace = CBUtil.readString(body);
                return new SetKeyspace(keyspace);
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
                assert msg instanceof SetKeyspace;
                CBUtil.writeAsciiString(((SetKeyspace)msg).keyspace, dest);
            }

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
                assert msg instanceof SetKeyspace;
                return CBUtil.sizeOfAsciiString(((SetKeyspace)msg).keyspace);
            }
        };

        @Override
        public String toString()
        {
            return ""RESULT set keyspace "" + keyspace;
        }
    }

    public static class Rows extends ResultMessage
    {
        public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
        {
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
                return new Rows(ResultSet.codec.decode(body, version));
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
                assert msg instanceof Rows;
                Rows rowMsg = (Rows)msg;
                ResultSet.codec.encode(rowMsg.result, dest, version);
            }

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
                assert msg instanceof Rows;
                Rows rowMsg = (Rows)msg;
                return ResultSet.codec.encodedSize(rowMsg.result, version);
            }
        };

        public final ResultSet result;

        public Rows(ResultSet result)
        {
            super(Kind.ROWS);
            this.result = result;
        }

        @Override
        public String toString()
        {
            return ""ROWS "" + result;
        }
    }

    public static class Prepared extends ResultMessage
    {
        public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
        {
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
                MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
                MD5Digest resultMetadataId = null;
                if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
                    resultMetadataId = MD5Digest.wrap(CBUtil.readBytes(body));
                ResultSet.PreparedMetadata metadata = ResultSet.PreparedMetadata.codec.decode(body, version);

                ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.EMPTY;
                if (version.isGreaterThan(ProtocolVersion.V1))
                    resultMetadata = ResultSet.ResultMetadata.codec.decode(body, version);

                return new Prepared(id, resultMetadataId, metadata, resultMetadata);
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
                assert msg instanceof Prepared;
                Prepared prepared = (Prepared)msg;
                assert prepared.statementId != null;

                CBUtil.writeBytes(prepared.statementId.bytes, dest);
                if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
                    CBUtil.writeBytes(prepared.resultMetadataId.bytes, dest);

                ResultSet.PreparedMetadata.codec.encode(prepared.metadata, dest, version);
                if (version.isGreaterThan(ProtocolVersion.V1))
                    ResultSet.ResultMetadata.codec.encode(prepared.resultMetadata, dest, version);
            }

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
                assert msg instanceof Prepared;
                Prepared prepared = (Prepared)msg;
                assert prepared.statementId != null;

                int size = 0;
                size += CBUtil.sizeOfBytes(prepared.statementId.bytes);
                if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
                    size += CBUtil.sizeOfBytes(prepared.resultMetadataId.bytes);
                size += ResultSet.PreparedMetadata.codec.encodedSize(prepared.metadata, version);
                if (version.isGreaterThan(ProtocolVersion.V1))
                    size += ResultSet.ResultMetadata.codec.encodedSize(prepared.resultMetadata, version);
                return size;
            }
        };

        public final MD5Digest statementId;
        public final MD5Digest resultMetadataId;

        /** Describes the variables to be bound in the prepared statement */
        public final ResultSet.PreparedMetadata metadata;

        /** Describes the results of executing this prepared statement */
        public final ResultSet.ResultMetadata resultMetadata;

        public Prepared(MD5Digest statementId, MD5Digest resultMetadataId, ResultSet.PreparedMetadata metadata, ResultSet.ResultMetadata resultMetadata)
        {
            super(Kind.PREPARED);
            this.statementId = statementId;
            this.resultMetadataId = resultMetadataId;
            this.metadata = metadata;
            this.resultMetadata = resultMetadata;
        }

        @VisibleForTesting
        public Prepared withResultMetadata(ResultSet.ResultMetadata resultMetadata)
        {
            return new Prepared(statementId, resultMetadata.getResultMetadataId(), metadata, resultMetadata);
        }

        @Override
        public String toString()
        {
            return ""RESULT PREPARED "" + statementId + "" "" + metadata + "" (resultMetadata="" + resultMetadata + "")"";
        }
    }

    public static class SchemaChange extends ResultMessage
    {
        public final Event.SchemaChange change;

        public SchemaChange(Event.SchemaChange change)
        {
            super(Kind.SCHEMA_CHANGE);
            this.change = change;
        }

        public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
        {
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
                return new SchemaChange(Event.SchemaChange.deserializeEvent(body, version));
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
                assert msg instanceof SchemaChange;
                SchemaChange scm = (SchemaChange)msg;
                scm.change.serializeEvent(dest, version);
            }

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
                assert msg instanceof SchemaChange;
                SchemaChange scm = (SchemaChange)msg;
                return scm.change.eventSerializedSize(version);
            }
        };

        @Override
        public String toString()
        {
            return ""RESULT schema change "" + change;
        }
    }
}


ResultMessage>

ResultMessage>

public ResultMessage 

ResultMessage 

ResultMessage 

ResultMessage>

ResultMessage>

protected ResultMessage(Kind kind)
    {
        super(Message.Type.RESULT);
        this.kind = kind;
    }

    

ResultMessage

ResultMessage>

ResultMessage>

public ResultMessage 

ResultMessage 

ResultMessage 

ResultMessage

ResultMessage>

ResultMessage>

public ResultMessage 

ResultMessage 

ResultMessage 

ResultMessage

ResultMessage>

ResultMessage>

public ResultMessage 

ResultMessage 

ResultMessage 

ResultMessage

ResultMessage>

ResultMessage>

public ResultMessage 

ResultMessage 

ResultMessage 

ResultMessage

ResultMessage>

ResultMessage>

public ResultMessage 

ResultMessage 

ResultMessage "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(S)org.apache.cassandra.auth.Roles:hasSuperuserStatus(org.apache.cassandra.auth.RoleResource),hasSuperuserStatus,Roles,../data/xml/cassandra_call_methods/Roles.xml,"/**
     * Returns true if the supplied role or any other role granted to it
     * (directly or indirectly) has superuser status.
     *
     * @param role the primary role
     * @return true if the role has superuser status, false otherwise
     */
public static boolean hasSuperuserStatus(RoleResource role)
    {
        try
        {
            for (Role r : getRoleDetails(role))
                if (r.isSuper)
                    return true;

            return false;
        }
        catch (RequestExecutionException e)
        {
            logger.debug(""Failed to authorize {} for super-user permission"", role.getRoleName());
            throw new UnauthorizedException(""Unable to perform authorization of super-user permission: "" + e.getMessage(), e);
        }
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(S)org.apache.cassandra.auth.AuthKeyspace:metadata(),metadata,AuthKeyspace,../data/xml/cassandra_call_methods/AuthKeyspace.xml,"
public static KeyspaceMetadata metadata()
    {
        return KeyspaceMetadata.create(SchemaConstants.AUTH_KEYSPACE_NAME,
                                       KeyspaceParams.simple(1),
                                       Tables.of(Roles, RoleMembers, RolePermissions, ResourceRoleIndex, NetworkPermissions));
    }
}"
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,"(S)org.apache.cassandra.schema.MigrationManager:evolveSystemKeyspace(org.apache.cassandra.schema.KeyspaceMetadata,long)",evolveSystemKeyspace,MigrationManager,../data/xml/cassandra_call_methods/MigrationManager.xml,"/**
     * We have a set of non-local, distributed system keyspaces, e.g. system_traces, system_auth, etc.
     * (see {@link SchemaConstants#REPLICATED_SYSTEM_KEYSPACE_NAMES}), that need to be created on cluster initialisation,
     * and later evolved on major upgrades (sometimes minor too). This method compares the current known definitions
     * of the tables (if the keyspace exists) to the expected, most modern ones expected by the running version of C*;
     * if any changes have been detected, a schema Mutation will be created which, when applied, should make
     * cluster's view of that keyspace aligned with the expected modern definition.
     *
     * @param keyspace   the expected modern definition of the keyspace
     * @param generation timestamp to use for the table changes in the schema mutation
     *
     * @return empty Optional if the current definition is up to date, or an Optional with the Mutation that would
     *         bring the schema in line with the expected definition.
     */
public static Optional<Mutation> evolveSystemKeyspace(KeyspaceMetadata keyspace, long generation)
    {
        Mutation.SimpleBuilder builder = null;

        KeyspaceMetadata definedKeyspace = Schema.instance.getKeyspaceMetadata(keyspace.name);
        Tables definedTables = null == definedKeyspace ? Tables.none() : definedKeyspace.tables;

        for (TableMetadata table : keyspace.tables)
        {
            if (table.equals(definedTables.getNullable(table.name)))
                continue;

            if (null == builder)
            {
                // for the keyspace definition itself (name, replication, durability) always use generation 0;
                // this ensures that any changes made to replication by the user will never be overwritten.
                builder = SchemaKeyspace.makeCreateKeyspaceMutation(keyspace.name, keyspace.params, 0);

                // now set the timestamp to generation, so the tables have the expected timestamp
                builder.timestamp(generation);
            }

            // for table definitions always use the provided generation; these tables, unlike their containing
            // keyspaces, are *NOT* meant to be altered by the user; if their definitions need to change,
            // the schema must be updated in code, and the appropriate generation must be bumped.
            SchemaKeyspace.addTableToSchemaMutation(table, true, builder);
        }

        return builder == null ? Optional.empty() : Optional.of(builder.build());
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IRoleManager:setup(),setup,IRoleManager,../data/xml/cassandra_call_methods/IRoleManager.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(S)org.apache.cassandra.config.DatabaseDescriptor:getAuthenticator(),getAuthenticator,DatabaseDescriptor,../data/xml/cassandra_call_methods/DatabaseDescriptor.xml,"
public static IAuthenticator getAuthenticator()
    {
        return authenticator;
    }

    "
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IAuthenticator:setup(),setup,IAuthenticator,../data/xml/cassandra_call_methods/IAuthenticator.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.IAuthorizer:setup(),setup,IAuthorizer,../data/xml/cassandra_call_methods/IAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(I)org.apache.cassandra.auth.INetworkAuthorizer:setup(),setup,INetworkAuthorizer,../data/xml/cassandra_call_methods/INetworkAuthorizer.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(O)org.apache.cassandra.auth.AuthSchemaChangeListener:<init>(),<init>,AuthSchemaChangeListener,../data/xml/cassandra_call_methods/AuthSchemaChangeListener.xml,not found
org.apache.cassandra.config.DatabaseDescriptor:getNetworkAuthorizer(),network_authorizer,(M)org.apache.cassandra.schema.Schema:registerListener(org.apache.cassandra.schema.SchemaChangeListener),registerListener,Schema,../data/xml/cassandra_call_methods/Schema.xml,"
public void registerListener(SchemaChangeListener listener)
    {
        changeListeners.add(listener);
    }

    "
