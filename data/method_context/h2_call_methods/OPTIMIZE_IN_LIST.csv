function,Method_body,option,Method,Method_short,class_name,xml_path
org.h2.engine.Database:getSettings(),"
public TableFilter getTableFilter() {
        return columnResolver == null ? null : columnResolver.getTableFilter();
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.expression.ExpressionColumn:getTableFilter(),getTableFilter,ExpressionColumn,../data/xml/h2_call_methods/ExpressionColumn.xml
org.h2.engine.Database:getSettings(),"
public Database getDatabase() {
        return database;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.engine.SessionLocal:getDatabase(),getDatabase,SessionLocal,../data/xml/h2_call_methods/SessionLocal.xml
org.h2.engine.Database:getSettings(),"
public DbSettings getSettings() {
        return dbSettings;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.engine.Database:getSettings(),getSettings,Database,../data/xml/h2_call_methods/Database.xml
org.h2.engine.Database:getSettings(),"
@Override
    public TypeInfo getType() {
        return column != null ? column.getType() : rowId ? TypeInfo.TYPE_BIGINT : TypeInfo.TYPE_UNKNOWN;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.expression.ExpressionColumn:getType(),getType,ExpressionColumn,../data/xml/h2_call_methods/ExpressionColumn.xml
org.h2.engine.Database:getSettings(),"/**
     * Get the higher data type of all values.
     *
     * @param values
     *            the values
     * @return the higher data type
     */
public static TypeInfo getHigherType(Typed[] values) {
        int cardinality = values.length;
        TypeInfo type;
        if (cardinality == 0) {
            type = TypeInfo.TYPE_NULL;
        } else {
            type = values[0].getType();
            boolean hasUnknown = false, hasNull = false;
            switch (type.getValueType()) {
            case Value.UNKNOWN:
                hasUnknown = true;
                break;
            case Value.NULL:
                hasNull = true;
            }
            for (int i = 1; i < cardinality; i++) {
                TypeInfo t = values[i].getType();
                switch (t.getValueType()) {
                case Value.UNKNOWN:
                    hasUnknown = true;
                    break;
                case Value.NULL:
                    hasNull = true;
                    break;
                default:
                    type = getHigherType(type, t);
                }
            }
            if (type.getValueType() <= Value.NULL && hasUnknown) {
                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, hasNull ? ""NULL, ?"" : ""?"");
            }
        }
        return type;
    }

    
/**
     * Get the higher data type of two data types. If values need to be
     * converted to match the other operands data type, the value with the lower
     * order is converted to the value with the higher order.
     *
     * @param type1
     *            the first data type
     * @param type2
     *            the second data type
     * @return the higher data type of the two
     */
public static TypeInfo getHigherType(TypeInfo type1, TypeInfo type2) {
        int t1 = type1.getValueType(), t2 = type2.getValueType(), dataType;
        if (t1 == t2) {
            if (t1 == Value.UNKNOWN) {
                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""?, ?"");
            }
            dataType = t1;
        } else {
            if (t1 < t2) {
                int t = t1;
                t1 = t2;
                t2 = t;
                TypeInfo type = type1;
                type1 = type2;
                type2 = type;
            }
            if (t1 == Value.UNKNOWN) {
                if (t2 == Value.NULL) {
                    throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""?, NULL"");
                }
                return type2;
            } else if (t2 == Value.UNKNOWN) {
                if (t1 == Value.NULL) {
                    throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""NULL, ?"");
                }
                return type1;
            }
            if (t2 == Value.NULL) {
                return type1;
            }
            dataType = Value.getHigherOrderKnown(t1, t2);
        }
        long precision;
        switch (dataType) {
        case Value.NUMERIC: {
            type1 = type1.toNumericType();
            type2 = type2.toNumericType();
            long precision1 = type1.getPrecision(), precision2 = type2.getPrecision();
            int scale1 = type1.getScale(), scale2 = type2.getScale(), scale;
            if (scale1 < scale2) {
                precision1 += scale2 - scale1;
                scale = scale2;
            } else {
                precision2 += scale1 - scale2;
                scale = scale1;
            }
            return TypeInfo.getTypeInfo(Value.NUMERIC, Math.max(precision1, precision2), scale, null);
        }
        case Value.REAL:
        case Value.DOUBLE:
            precision = -1L;
            break;
        case Value.ARRAY:
            return getHigherArray(type1, type2, dimensions(type1), dimensions(type2));
        case Value.ROW:
            return getHigherRow(type1, type2);
        default:
            precision = Math.max(type1.getPrecision(), type2.getPrecision());
        }
        ExtTypeInfo ext1 = type1.extTypeInfo;
        return TypeInfo.getTypeInfo(dataType, //
                precision, //
                Math.max(type1.getScale(), type2.getScale()), //
                dataType == t1 && ext1 != null ? ext1 : dataType == t2 ? type2.extTypeInfo : null);
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.value.TypeInfo:getHigherType(org.h2.value.TypeInfo,org.h2.value.TypeInfo)",getHigherType,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Determines whether two specified types have the same ordering rules.
     *
     * @param t1
     *            first data type
     * @param t2
     *            second data type
     * @return whether types are comparable
     */
public static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {
        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();
        if (vt1 > vt2) {
            int vt = vt1;
            vt1 = vt2;
            vt2 = vt;
            TypeInfo t = t1;
            t1 = t2;
            t2 = t;
        }
        if (vt1 <= Value.NULL) {
            return true;
        }
        if (vt1 == vt2) {
            switch (vt1) {
            case Value.ARRAY:
                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());
            case Value.ROW: {
                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();
                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();
                int degree = f1.size();
                if (f2.size() != degree) {
                    return false;
                }
                Iterator<Entry<String, TypeInfo>> i1 = f1.iterator(), i2 = f2.iterator();
                while (i1.hasNext()) {
                    if (!haveSameOrdering(i1.next().getValue(), i2.next().getValue())) {
                        return false;
                    }
                }
            }
            //$FALL-THROUGH$
            default:
                return true;
            }
        }
        byte g1 = Value.GROUPS[vt1], g2 = Value.GROUPS[vt2];
        if (g1 == g2) {
            switch (g1) {
            default:
                return true;
            case Value.GROUP_CHARACTER_STRING:
                return (vt1 == Value.VARCHAR_IGNORECASE) == (vt2 == Value.VARCHAR_IGNORECASE);
            case Value.GROUP_DATETIME:
                switch (vt1) {
                case Value.DATE:
                    return vt2 == Value.TIMESTAMP || vt2 == Value.TIMESTAMP_TZ;
                case Value.TIME:
                case Value.TIME_TZ:
                    return vt2 == Value.TIME || vt2 == Value.TIME_TZ;
                default: // TIMESTAMP TIMESTAMP_TZ
                    return true;
                }
            case Value.GROUP_OTHER:
            case Value.GROUP_COLLECTION:
                return false;
            }
        }
        if (g1 == Value.GROUP_BINARY_STRING) {
            switch (vt2) {
            case Value.JAVA_OBJECT:
            case Value.GEOMETRY:
            case Value.JSON:
            case Value.UUID:
                return true;
            default:
                return false;
            }
        }
        return false;
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.value.TypeInfo:haveSameOrdering(org.h2.value.TypeInfo,org.h2.value.TypeInfo)",haveSameOrdering,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Add an index condition.
     *
     * @param condition the index condition
     */
public void addIndexCondition(IndexCondition condition) {
        indexConditions.add(condition);
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.table.TableFilter:addIndexCondition(org.h2.index.IndexCondition),addIndexCondition,TableFilter,../data/xml/h2_call_methods/TableFilter.xml
org.h2.engine.Database:getSettings(),"
public Database getDatabase() {
        return database;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.engine.SessionLocal:getDatabase(),getDatabase,SessionLocal,../data/xml/h2_call_methods/SessionLocal.xml
org.h2.engine.Database:getSettings(),"
public DbSettings getSettings() {
        return dbSettings;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.engine.Database:getSettings(),getSettings,Database,../data/xml/h2_call_methods/Database.xml
org.h2.engine.Database:getSettings(),"/**
     * Get the column count of this query.
     *
     * @return the column count
     */
public int getColumnCount() {
        return visibleColumnCount;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.command.query.Query:getColumnCount(),getColumnCount,Query,../data/xml/h2_call_methods/Query.xml
org.h2.engine.Database:getSettings(),not found,OPTIMIZE_IN_LIST,(M)org.h2.expression.Expression:getType(),getType,Expression,../data/xml/h2_call_methods/Expression.xml
org.h2.engine.Database:getSettings(),"/**
     * The the list of select expressions.
     * This may include invisible expressions such as order by expressions.
     *
     * @return the list of expressions
     */
public ArrayList<Expression> getExpressions() {
        return expressions;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.command.query.Query:getExpressions(),getExpressions,Query,../data/xml/h2_call_methods/Query.xml
org.h2.engine.Database:getSettings(),"/**
     * Get the higher data type of all values.
     *
     * @param values
     *            the values
     * @return the higher data type
     */
public static TypeInfo getHigherType(Typed[] values) {
        int cardinality = values.length;
        TypeInfo type;
        if (cardinality == 0) {
            type = TypeInfo.TYPE_NULL;
        } else {
            type = values[0].getType();
            boolean hasUnknown = false, hasNull = false;
            switch (type.getValueType()) {
            case Value.UNKNOWN:
                hasUnknown = true;
                break;
            case Value.NULL:
                hasNull = true;
            }
            for (int i = 1; i < cardinality; i++) {
                TypeInfo t = values[i].getType();
                switch (t.getValueType()) {
                case Value.UNKNOWN:
                    hasUnknown = true;
                    break;
                case Value.NULL:
                    hasNull = true;
                    break;
                default:
                    type = getHigherType(type, t);
                }
            }
            if (type.getValueType() <= Value.NULL && hasUnknown) {
                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, hasNull ? ""NULL, ?"" : ""?"");
            }
        }
        return type;
    }

    
/**
     * Get the higher data type of two data types. If values need to be
     * converted to match the other operands data type, the value with the lower
     * order is converted to the value with the higher order.
     *
     * @param type1
     *            the first data type
     * @param type2
     *            the second data type
     * @return the higher data type of the two
     */
public static TypeInfo getHigherType(TypeInfo type1, TypeInfo type2) {
        int t1 = type1.getValueType(), t2 = type2.getValueType(), dataType;
        if (t1 == t2) {
            if (t1 == Value.UNKNOWN) {
                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""?, ?"");
            }
            dataType = t1;
        } else {
            if (t1 < t2) {
                int t = t1;
                t1 = t2;
                t2 = t;
                TypeInfo type = type1;
                type1 = type2;
                type2 = type;
            }
            if (t1 == Value.UNKNOWN) {
                if (t2 == Value.NULL) {
                    throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""?, NULL"");
                }
                return type2;
            } else if (t2 == Value.UNKNOWN) {
                if (t1 == Value.NULL) {
                    throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""NULL, ?"");
                }
                return type1;
            }
            if (t2 == Value.NULL) {
                return type1;
            }
            dataType = Value.getHigherOrderKnown(t1, t2);
        }
        long precision;
        switch (dataType) {
        case Value.NUMERIC: {
            type1 = type1.toNumericType();
            type2 = type2.toNumericType();
            long precision1 = type1.getPrecision(), precision2 = type2.getPrecision();
            int scale1 = type1.getScale(), scale2 = type2.getScale(), scale;
            if (scale1 < scale2) {
                precision1 += scale2 - scale1;
                scale = scale2;
            } else {
                precision2 += scale1 - scale2;
                scale = scale1;
            }
            return TypeInfo.getTypeInfo(Value.NUMERIC, Math.max(precision1, precision2), scale, null);
        }
        case Value.REAL:
        case Value.DOUBLE:
            precision = -1L;
            break;
        case Value.ARRAY:
            return getHigherArray(type1, type2, dimensions(type1), dimensions(type2));
        case Value.ROW:
            return getHigherRow(type1, type2);
        default:
            precision = Math.max(type1.getPrecision(), type2.getPrecision());
        }
        ExtTypeInfo ext1 = type1.extTypeInfo;
        return TypeInfo.getTypeInfo(dataType, //
                precision, //
                Math.max(type1.getScale(), type2.getScale()), //
                dataType == t1 && ext1 != null ? ext1 : dataType == t2 ? type2.extTypeInfo : null);
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.value.TypeInfo:getHigherType(org.h2.value.TypeInfo,org.h2.value.TypeInfo)",getHigherType,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Determines whether two specified types have the same ordering rules.
     *
     * @param t1
     *            first data type
     * @param t2
     *            second data type
     * @return whether types are comparable
     */
public static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {
        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();
        if (vt1 > vt2) {
            int vt = vt1;
            vt1 = vt2;
            vt2 = vt;
            TypeInfo t = t1;
            t1 = t2;
            t2 = t;
        }
        if (vt1 <= Value.NULL) {
            return true;
        }
        if (vt1 == vt2) {
            switch (vt1) {
            case Value.ARRAY:
                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());
            case Value.ROW: {
                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();
                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();
                int degree = f1.size();
                if (f2.size() != degree) {
                    return false;
                }
                Iterator<Entry<String, TypeInfo>> i1 = f1.iterator(), i2 = f2.iterator();
                while (i1.hasNext()) {
                    if (!haveSameOrdering(i1.next().getValue(), i2.next().getValue())) {
                        return false;
                    }
                }
            }
            //$FALL-THROUGH$
            default:
                return true;
            }
        }
        byte g1 = Value.GROUPS[vt1], g2 = Value.GROUPS[vt2];
        if (g1 == g2) {
            switch (g1) {
            default:
                return true;
            case Value.GROUP_CHARACTER_STRING:
                return (vt1 == Value.VARCHAR_IGNORECASE) == (vt2 == Value.VARCHAR_IGNORECASE);
            case Value.GROUP_DATETIME:
                switch (vt1) {
                case Value.DATE:
                    return vt2 == Value.TIMESTAMP || vt2 == Value.TIMESTAMP_TZ;
                case Value.TIME:
                case Value.TIME_TZ:
                    return vt2 == Value.TIME || vt2 == Value.TIME_TZ;
                default: // TIMESTAMP TIMESTAMP_TZ
                    return true;
                }
            case Value.GROUP_OTHER:
            case Value.GROUP_COLLECTION:
                return false;
            }
        }
        if (g1 == Value.GROUP_BINARY_STRING) {
            switch (vt2) {
            case Value.JAVA_OBJECT:
            case Value.GEOMETRY:
            case Value.JSON:
            case Value.UUID:
                return true;
            default:
                return false;
            }
        }
        return false;
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.value.TypeInfo:haveSameOrdering(org.h2.value.TypeInfo,org.h2.value.TypeInfo)",haveSameOrdering,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Returns the value type.
     *
     * @return the value type
     */
public int getValueType() {
        return valueType;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.value.TypeInfo:getValueType(),getValueType,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Check if the given type has total ordering.
     *
     * @param type the value type
     * @return true if the value type has total ordering
     */
public static boolean hasTotalOrdering(int type) {
        switch (type) {
        case Value.BOOLEAN:
        case Value.TINYINT:
        case Value.SMALLINT:
        case Value.INTEGER:
        case Value.BIGINT:
        // Negative zeroes and NaNs are normalized
        case Value.DOUBLE:
        case Value.REAL:
        case Value.TIME:
        case Value.DATE:
        case Value.TIMESTAMP:
        case Value.VARBINARY:
        // Serialized data is compared
        case Value.JAVA_OBJECT:
        case Value.UUID:
        // EWKB is used
        case Value.GEOMETRY:
        case Value.ENUM:
        case Value.INTERVAL_YEAR:
        case Value.INTERVAL_MONTH:
        case Value.INTERVAL_DAY:
        case Value.INTERVAL_HOUR:
        case Value.INTERVAL_MINUTE:
        case Value.INTERVAL_SECOND:
        case Value.INTERVAL_YEAR_TO_MONTH:
        case Value.INTERVAL_DAY_TO_HOUR:
        case Value.INTERVAL_DAY_TO_MINUTE:
        case Value.INTERVAL_DAY_TO_SECOND:
        case Value.INTERVAL_HOUR_TO_MINUTE:
        case Value.INTERVAL_HOUR_TO_SECOND:
        case Value.INTERVAL_MINUTE_TO_SECOND:
        case Value.BINARY:
            return true;
        default:
            return false;
        }
    }

    ",OPTIMIZE_IN_LIST,(S)org.h2.value.DataType:hasTotalOrdering(int),hasTotalOrdering,DataType,../data/xml/h2_call_methods/DataType.xml
org.h2.engine.Database:getSettings(),"
public TableFilter getTableFilter() {
        return columnResolver == null ? null : columnResolver.getTableFilter();
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.expression.ExpressionColumn:getTableFilter(),getTableFilter,ExpressionColumn,../data/xml/h2_call_methods/ExpressionColumn.xml
org.h2.engine.Database:getSettings(),"/**
     * Create a new visitor to check if no expression depends on the given
     * resolver.
     *
     * @param resolver the resolver
     * @return the new visitor
     */
public static ExpressionVisitor getNotFromResolverVisitor(ColumnResolver resolver) {
        return new ExpressionVisitor(NOT_FROM_RESOLVER, 0, null, null, null,
                resolver, null);
    }

    ",OPTIMIZE_IN_LIST,(S)org.h2.expression.ExpressionVisitor:getNotFromResolverVisitor(org.h2.table.ColumnResolver),getNotFromResolverVisitor,ExpressionVisitor,../data/xml/h2_call_methods/ExpressionVisitor.xml
org.h2.engine.Database:getSettings(),not found,OPTIMIZE_IN_LIST,(M)org.h2.command.query.Query:isEverything(org.h2.expression.ExpressionVisitor),isEverything,Query,../data/xml/h2_call_methods/Query.xml
org.h2.engine.Database:getSettings(),"/**
     * Create an index condition with the compare type IN_QUERY and with the
     * given parameters.
     *
     * @param column the column
     * @param query the select statement
     * @return the index condition
     */
public static IndexCondition getInQuery(ExpressionColumn column, Query query) {
        assert query.isRandomAccessResult();
        IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column, null);
        cond.expressionQuery = query;
        return cond;
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.index.IndexCondition:getInQuery(org.h2.expression.ExpressionColumn,org.h2.command.query.Query)",getInQuery,IndexCondition,../data/xml/h2_call_methods/IndexCondition.xml
org.h2.engine.Database:getSettings(),"/**
     * Add an index condition.
     *
     * @param condition the index condition
     */
public void addIndexCondition(IndexCondition condition) {
        indexConditions.add(condition);
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.table.TableFilter:addIndexCondition(org.h2.index.IndexCondition),addIndexCondition,TableFilter,../data/xml/h2_call_methods/TableFilter.xml
org.h2.engine.Database:getSettings(),"
public TableFilter getTableFilter() {
        return columnResolver == null ? null : columnResolver.getTableFilter();
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.expression.ExpressionColumn:getTableFilter(),getTableFilter,ExpressionColumn,../data/xml/h2_call_methods/ExpressionColumn.xml
org.h2.engine.Database:getSettings(),"
public Database getDatabase() {
        return database;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.engine.SessionLocal:getDatabase(),getDatabase,SessionLocal,../data/xml/h2_call_methods/SessionLocal.xml
org.h2.engine.Database:getSettings(),"
public DbSettings getSettings() {
        return dbSettings;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.engine.Database:getSettings(),getSettings,Database,../data/xml/h2_call_methods/Database.xml
org.h2.engine.Database:getSettings(),"/**
     * Create a new visitor to check if no expression depends on the given
     * resolver.
     *
     * @param resolver the resolver
     * @return the new visitor
     */
public static ExpressionVisitor getNotFromResolverVisitor(ColumnResolver resolver) {
        return new ExpressionVisitor(NOT_FROM_RESOLVER, 0, null, null, null,
                resolver, null);
    }

    ",OPTIMIZE_IN_LIST,(S)org.h2.expression.ExpressionVisitor:getNotFromResolverVisitor(org.h2.table.ColumnResolver),getNotFromResolverVisitor,ExpressionVisitor,../data/xml/h2_call_methods/ExpressionVisitor.xml
org.h2.engine.Database:getSettings(),"
@Override
    public TypeInfo getType() {
        return column != null ? column.getType() : rowId ? TypeInfo.TYPE_BIGINT : TypeInfo.TYPE_UNKNOWN;
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.expression.ExpressionColumn:getType(),getType,ExpressionColumn,../data/xml/h2_call_methods/ExpressionColumn.xml
org.h2.engine.Database:getSettings(),not found,OPTIMIZE_IN_LIST,(M)org.h2.expression.Expression:isEverything(org.h2.expression.ExpressionVisitor),isEverything,Expression,../data/xml/h2_call_methods/Expression.xml
org.h2.engine.Database:getSettings(),not found,OPTIMIZE_IN_LIST,(M)org.h2.expression.Expression:getType(),getType,Expression,../data/xml/h2_call_methods/Expression.xml
org.h2.engine.Database:getSettings(),"/**
     * Get the higher data type of all values.
     *
     * @param values
     *            the values
     * @return the higher data type
     */
public static TypeInfo getHigherType(Typed[] values) {
        int cardinality = values.length;
        TypeInfo type;
        if (cardinality == 0) {
            type = TypeInfo.TYPE_NULL;
        } else {
            type = values[0].getType();
            boolean hasUnknown = false, hasNull = false;
            switch (type.getValueType()) {
            case Value.UNKNOWN:
                hasUnknown = true;
                break;
            case Value.NULL:
                hasNull = true;
            }
            for (int i = 1; i < cardinality; i++) {
                TypeInfo t = values[i].getType();
                switch (t.getValueType()) {
                case Value.UNKNOWN:
                    hasUnknown = true;
                    break;
                case Value.NULL:
                    hasNull = true;
                    break;
                default:
                    type = getHigherType(type, t);
                }
            }
            if (type.getValueType() <= Value.NULL && hasUnknown) {
                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, hasNull ? ""NULL, ?"" : ""?"");
            }
        }
        return type;
    }

    
/**
     * Get the higher data type of two data types. If values need to be
     * converted to match the other operands data type, the value with the lower
     * order is converted to the value with the higher order.
     *
     * @param type1
     *            the first data type
     * @param type2
     *            the second data type
     * @return the higher data type of the two
     */
public static TypeInfo getHigherType(TypeInfo type1, TypeInfo type2) {
        int t1 = type1.getValueType(), t2 = type2.getValueType(), dataType;
        if (t1 == t2) {
            if (t1 == Value.UNKNOWN) {
                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""?, ?"");
            }
            dataType = t1;
        } else {
            if (t1 < t2) {
                int t = t1;
                t1 = t2;
                t2 = t;
                TypeInfo type = type1;
                type1 = type2;
                type2 = type;
            }
            if (t1 == Value.UNKNOWN) {
                if (t2 == Value.NULL) {
                    throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""?, NULL"");
                }
                return type2;
            } else if (t2 == Value.UNKNOWN) {
                if (t1 == Value.NULL) {
                    throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, ""NULL, ?"");
                }
                return type1;
            }
            if (t2 == Value.NULL) {
                return type1;
            }
            dataType = Value.getHigherOrderKnown(t1, t2);
        }
        long precision;
        switch (dataType) {
        case Value.NUMERIC: {
            type1 = type1.toNumericType();
            type2 = type2.toNumericType();
            long precision1 = type1.getPrecision(), precision2 = type2.getPrecision();
            int scale1 = type1.getScale(), scale2 = type2.getScale(), scale;
            if (scale1 < scale2) {
                precision1 += scale2 - scale1;
                scale = scale2;
            } else {
                precision2 += scale1 - scale2;
                scale = scale1;
            }
            return TypeInfo.getTypeInfo(Value.NUMERIC, Math.max(precision1, precision2), scale, null);
        }
        case Value.REAL:
        case Value.DOUBLE:
            precision = -1L;
            break;
        case Value.ARRAY:
            return getHigherArray(type1, type2, dimensions(type1), dimensions(type2));
        case Value.ROW:
            return getHigherRow(type1, type2);
        default:
            precision = Math.max(type1.getPrecision(), type2.getPrecision());
        }
        ExtTypeInfo ext1 = type1.extTypeInfo;
        return TypeInfo.getTypeInfo(dataType, //
                precision, //
                Math.max(type1.getScale(), type2.getScale()), //
                dataType == t1 && ext1 != null ? ext1 : dataType == t2 ? type2.extTypeInfo : null);
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.value.TypeInfo:getHigherType(org.h2.value.TypeInfo,org.h2.value.TypeInfo)",getHigherType,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Determines whether two specified types have the same ordering rules.
     *
     * @param t1
     *            first data type
     * @param t2
     *            second data type
     * @return whether types are comparable
     */
public static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {
        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();
        if (vt1 > vt2) {
            int vt = vt1;
            vt1 = vt2;
            vt2 = vt;
            TypeInfo t = t1;
            t1 = t2;
            t2 = t;
        }
        if (vt1 <= Value.NULL) {
            return true;
        }
        if (vt1 == vt2) {
            switch (vt1) {
            case Value.ARRAY:
                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());
            case Value.ROW: {
                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();
                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();
                int degree = f1.size();
                if (f2.size() != degree) {
                    return false;
                }
                Iterator<Entry<String, TypeInfo>> i1 = f1.iterator(), i2 = f2.iterator();
                while (i1.hasNext()) {
                    if (!haveSameOrdering(i1.next().getValue(), i2.next().getValue())) {
                        return false;
                    }
                }
            }
            //$FALL-THROUGH$
            default:
                return true;
            }
        }
        byte g1 = Value.GROUPS[vt1], g2 = Value.GROUPS[vt2];
        if (g1 == g2) {
            switch (g1) {
            default:
                return true;
            case Value.GROUP_CHARACTER_STRING:
                return (vt1 == Value.VARCHAR_IGNORECASE) == (vt2 == Value.VARCHAR_IGNORECASE);
            case Value.GROUP_DATETIME:
                switch (vt1) {
                case Value.DATE:
                    return vt2 == Value.TIMESTAMP || vt2 == Value.TIMESTAMP_TZ;
                case Value.TIME:
                case Value.TIME_TZ:
                    return vt2 == Value.TIME || vt2 == Value.TIME_TZ;
                default: // TIMESTAMP TIMESTAMP_TZ
                    return true;
                }
            case Value.GROUP_OTHER:
            case Value.GROUP_COLLECTION:
                return false;
            }
        }
        if (g1 == Value.GROUP_BINARY_STRING) {
            switch (vt2) {
            case Value.JAVA_OBJECT:
            case Value.GEOMETRY:
            case Value.JSON:
            case Value.UUID:
                return true;
            default:
                return false;
            }
        }
        return false;
    }

    ",OPTIMIZE_IN_LIST,"(S)org.h2.value.TypeInfo:haveSameOrdering(org.h2.value.TypeInfo,org.h2.value.TypeInfo)",haveSameOrdering,TypeInfo,../data/xml/h2_call_methods/TypeInfo.xml
org.h2.engine.Database:getSettings(),"/**
     * Add an index condition.
     *
     * @param condition the index condition
     */
public void addIndexCondition(IndexCondition condition) {
        indexConditions.add(condition);
    }

    ",OPTIMIZE_IN_LIST,(M)org.h2.table.TableFilter:addIndexCondition(org.h2.index.IndexCondition),addIndexCondition,TableFilter,../data/xml/h2_call_methods/TableFilter.xml
