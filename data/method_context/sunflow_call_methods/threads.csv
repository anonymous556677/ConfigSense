function,option,Method_short,class_name,xml_path,Method_body,Method
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,<init>,FrameDisplay,../data/xml/sunflow_call_methods/FrameDisplay.xml,"
public FrameDisplay() {
        this(null);
    }

    

public FrameDisplay(String filename) {
        this.filename = filename;
        frame = null;
    }

    ",(O)org.sunflow.core.display.FrameDisplay:<init>()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getBakingPrimitives,Instance,../data/xml/sunflow_call_methods/Instance.xml,"
public PrimitiveList getBakingPrimitives() {
        return geometry.getBakingPrimitives();
    }

    ",(M)org.sunflow.core.Instance:getBakingPrimitives()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getNumPrimitives,PrimitiveList,../data/xml/sunflow_call_methods/PrimitiveList.xml,not found,(I)org.sunflow.core.PrimitiveList:getNumPrimitives()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,build,AccelerationStructure,../data/xml/sunflow_call_methods/AccelerationStructure.xml,not found,(I)org.sunflow.core.AccelerationStructure:build(org.sunflow.core.PrimitiveList)
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,clamp,MathUtils,../data/xml/sunflow_call_methods/MathUtils.xml,"
public static final int clamp(int x, int min, int max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }

    

public static final float clamp(float x, float min, float max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }

    

public static final double clamp(double x, double min, double max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }

    ","(S)org.sunflow.math.MathUtils:clamp(int,int,int)"
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getNumPrimitives,InstanceList,../data/xml/sunflow_call_methods/InstanceList.xml,"
public final int getNumPrimitives() {
        return instances.length;
    }

    

public final int getNumPrimitives(int primID) {
        return instances[primID].getNumPrimitives();
    }

    ",(M)org.sunflow.core.InstanceList:getNumPrimitives()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getNumPrimitives,InstanceList,../data/xml/sunflow_call_methods/InstanceList.xml,"
public final int getNumPrimitives() {
        return instances.length;
    }

    

public final int getNumPrimitives(int primID) {
        return instances[primID].getNumPrimitives();
    }

    ",(M)org.sunflow.core.InstanceList:getNumPrimitives(int)
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getBounds,Scene,../data/xml/sunflow_call_methods/Scene.xml,"
public BoundingBox getBounds() {
        return instanceList.getWorldBounds(null);
    }

    ",(M)org.sunflow.core.Scene:getBounds()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getCenter,BoundingBox,../data/xml/sunflow_call_methods/BoundingBox.xml,"/**
     * Gets the center of the box, computed as (min + max) / 2.
     * 
     * @return a reference to the center of the box
     */
public final Point3 getCenter() {
        return Point3.mid(minimum, maximum, new Point3());
    }

    ",(M)org.sunflow.math.BoundingBox:getCenter()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,getExtents,BoundingBox,../data/xml/sunflow_call_methods/BoundingBox.xml,"/**
     * Gets the extents vector for the box. This vector is computed as (max -
     * min). Its coordinates are always positive and represent the dimensions of
     * the box along the three axes.
     * 
     * @return a refreence to the extent vector
     * @see org.sunflow.math.Vector3#length()
     */
public final Vector3 getExtents() {
        return Point3.sub(maximum, minimum, new Vector3());
    }

    ",(M)org.sunflow.math.BoundingBox:getExtents()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,length,Vector3,../data/xml/sunflow_call_methods/Vector3.xml,"
public final float length() {
        return (float) Math.sqrt((x * x) + (y * y) + (z * z));
    }

    ",(M)org.sunflow.math.Vector3:length()
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,build,LightServer,../data/xml/sunflow_call_methods/LightServer.xml,"
boolean build(Options options) {
        // read options
        maxDiffuseDepth = options.getInt(""depths.diffuse"", maxDiffuseDepth);
        maxReflectionDepth = options.getInt(""depths.reflection"", maxReflectionDepth);
        maxRefractionDepth = options.getInt(""depths.refraction"", maxRefractionDepth);
        giEngine = GIEngineFactory.create(options);
        String caustics = options.getString(""caustics"", null);
        if (caustics == null || caustics.equals(""none""))
            causticPhotonMap = null;
        else if (caustics != null && caustics.equals(""kd""))
            causticPhotonMap = new CausticPhotonMap(options);
        else {
            UI.printWarning(Module.LIGHT, ""Unrecognized caustics photon map engine \""%s\"" - ignoring"", caustics);
            causticPhotonMap = null;
        }

        // validate options
        maxDiffuseDepth = Math.max(0, maxDiffuseDepth);
        maxReflectionDepth = Math.max(0, maxReflectionDepth);
        maxRefractionDepth = Math.max(0, maxRefractionDepth);

        Timer t = new Timer();
        t.start();
        // count total number of light samples
        int numLightSamples = 0;
        for (int i = 0; i < lights.length; i++) {
            assert lights[i].getNumSamples() >= 0;
            numLightSamples += lights[i].getNumSamples();
        }
        // initialize gi engine
        if (giEngine != null) {
            if (!giEngine.init(scene))
                return false;
        }

        if (!calculatePhotons(causticPhotonMap, ""caustic"", 0))
            return false;
        t.end();
        cacheLookups = 0;
        cacheHits = 0;
        cacheEmptyEntryMisses = 0;
        cacheWrongEntryMisses = 0;
        cacheEntryAdditions = 0;
        if (shadingCache != null) {
            // clear shading cache
            for (int i = 0; i < shadingCache.length; i++)
                shadingCache[i] = null;
        }
        UI.printInfo(Module.LIGHT, ""Light Server stats:"");
        UI.printInfo(Module.LIGHT, ""  * Light sources found: %d"", lights.length);
        UI.printInfo(Module.LIGHT, ""  * Light samples:       %d"", numLightSamples);
        UI.printInfo(Module.LIGHT, ""  * Max raytrace depth:"");
        UI.printInfo(Module.LIGHT, ""      - Diffuse          %d"", maxDiffuseDepth);
        UI.printInfo(Module.LIGHT, ""      - Reflection       %d"", maxReflectionDepth);
        UI.printInfo(Module.LIGHT, ""      - Refraction       %d"", maxRefractionDepth);
        UI.printInfo(Module.LIGHT, ""  * GI engine            %s"", options.getString(""gi.engine"", ""none""));
        UI.printInfo(Module.LIGHT, ""  * Caustics:            %s"", caustics == null ? ""none"" : caustics);
        UI.printInfo(Module.LIGHT, ""  * Shader override:     %b"", shaderOverride);
        UI.printInfo(Module.LIGHT, ""  * Photon override:     %b"", shaderOverridePhotons);
        UI.printInfo(Module.LIGHT, ""  * Shading cache:       %s"", shadingCache == null ? ""off"" : ""on"");
        UI.printInfo(Module.LIGHT, ""  * Build time:          %s"", t.toString());
        return true;
    }

    ",(M)org.sunflow.core.LightServer:build(org.sunflow.core.Options)
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,prepare,ImageSampler,../data/xml/sunflow_call_methods/ImageSampler.xml,not found,"(I)org.sunflow.core.ImageSampler:prepare(org.sunflow.core.Options,org.sunflow.core.Scene,int,int)"
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,render,ImageSampler,../data/xml/sunflow_call_methods/ImageSampler.xml,not found,(I)org.sunflow.core.ImageSampler:render(org.sunflow.core.Display)
"org.sunflow.core.Options:getInt(java.lang.String,int)",threads,showStats,LightServer,../data/xml/sunflow_call_methods/LightServer.xml,"
void showStats() {
        if (shadingCache == null)
            return;
        int numUsedEntries = 0;
        for (CacheEntry e : shadingCache)
            numUsedEntries += (e != null) ? 1 : 0;
        UI.printInfo(Module.LIGHT, ""Shading cache stats:"");
        UI.printInfo(Module.LIGHT, ""  * Used entries:        %d (%d%%)"", numUsedEntries, (100 * numUsedEntries) / shadingCache.length);
        UI.printInfo(Module.LIGHT, ""  * Lookups:             %d"", cacheLookups);
        UI.printInfo(Module.LIGHT, ""  * Hits:                %d"", cacheHits);
        UI.printInfo(Module.LIGHT, ""  * Hit rate:            %d%%"", (100 * cacheHits) / cacheLookups);
        UI.printInfo(Module.LIGHT, ""  * Empty entry misses:  %d"", cacheEmptyEntryMisses);
        UI.printInfo(Module.LIGHT, ""  * Wrong entry misses:  %d"", cacheWrongEntryMisses);
        UI.printInfo(Module.LIGHT, ""  * Entry adds:          %d"", cacheEntryAdditions);
    }

    ",(M)org.sunflow.core.LightServer:showStats()
