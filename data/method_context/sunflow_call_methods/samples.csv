function,option,Method_short,class_name,xml_path,Method_body,Method
org.sunflow.Benchmark:_get_Samples(),samples,_get_Threads,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_Threads()
org.sunflow.Benchmark:_get_Samples(),samples,_get_Resolution,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_Resolution()
org.sunflow.Benchmark:_get_Samples(),samples,_get_DiffuseDepth,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_DiffuseDepth()
org.sunflow.Benchmark:_get_Samples(),samples,_get_ReflectionDepth,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_ReflectionDepth()
org.sunflow.Benchmark:_get_Samples(),samples,_get_RefractionDepth,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_RefractionDepth()
org.sunflow.Benchmark:_get_Samples(),samples,_get_BucketSize,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_BucketSize()
org.sunflow.Benchmark:_get_Samples(),samples,_get_Samples,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_Samples()
org.sunflow.Benchmark:_get_Samples(),samples,buildCornellBox,Benchmark$BenchmarkScene,../data/xml/sunflow_call_methods/Benchmark.xml,"
private void buildCornellBox() {
            // camera
            parameter(""eye"", new Point3(0, 0, -600));
            parameter(""target"", new Point3(0, 0, 0));
            parameter(""up"", new Vector3(0, 1, 0));
            parameter(""fov"", 45.0f);
            camera(""main_camera"", new PinholeLens());
            parameter(""camera"", ""main_camera"");
            options(SunflowAPI.DEFAULT_OPTIONS);
            // cornell box
            Color gray = new Color(0.70f, 0.70f, 0.70f);
            Color blue = new Color(0.25f, 0.25f, 0.80f);
            Color red = new Color(0.80f, 0.25f, 0.25f);
            Color emit = new Color(15, 15, 15);

            float minX = -200;
            float maxX = 200;
            float minY = -160;
            float maxY = minY + 400;
            float minZ = -250;
            float maxZ = 200;

            float[] verts = new float[] { minX, minY, minZ, maxX, minY, minZ,
                    maxX, minY, maxZ, minX, minY, maxZ, minX, maxY, minZ, maxX,
                    maxY, minZ, maxX, maxY, maxZ, minX, maxY, maxZ, };
            int[] indices = new int[] { 0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4, 1,
                    2, 5, 5, 6, 2, 2, 3, 6, 6, 7, 3, 0, 3, 4, 4, 7, 3 };

            parameter(""diffuse"", gray);
            shader(""gray_shader"", new DiffuseShader());
            parameter(""diffuse"", red);
            shader(""red_shader"", new DiffuseShader());
            parameter(""diffuse"", blue);
            shader(""blue_shader"", new DiffuseShader());

            // build walls
            parameter(""triangles"", indices);
            parameter(""points"", ""point"", ""vertex"", verts);
            parameter(""faceshaders"", new int[] { 0, 0, 0, 0, 1, 1, 0, 0, 2, 2 });
            geometry(""walls"", new TriangleMesh());

            // instance walls
            parameter(""shaders"", new String[] { ""gray_shader"", ""red_shader"",
                    ""blue_shader"" });
            instance(""walls.instance"", ""walls"");

            // create mesh light
            parameter(""points"", ""point"", ""vertex"", new float[] { -50, maxY - 1,
                    -50, 50, maxY - 1, -50, 50, maxY - 1, 50, -50, maxY - 1, 50 });
            parameter(""triangles"", new int[] { 0, 1, 2, 2, 3, 0 });
            parameter(""radiance"", emit);
            parameter(""samples"", 8);
            TriangleMeshLight light = new TriangleMeshLight();
            light.init(""light"", this);

            // spheres
            parameter(""eta"", 1.6f);
            shader(""Glass"", new GlassShader());
            sphere(""glass_sphere"", ""Glass"", -120, minY + 55, -150, 50);
            parameter(""color"", new Color(0.70f, 0.70f, 0.70f));
            shader(""Mirror"", new MirrorShader());
            sphere(""mirror_sphere"", ""Mirror"", 100, minY + 60, -50, 50);

            // scanned model
            geometry(""teapot"", (Tesselatable) new Teapot());
            parameter(""transform"", Matrix4.translation(80, -50, 100).multiply(Matrix4.rotateX((float) -Math.PI / 6)).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
            parameter(""shaders"", ""gray_shader"");
            instance(""teapot.instance1"", ""teapot"");
            parameter(""transform"", Matrix4.translation(-80, -160, 50).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
            parameter(""shaders"", ""gray_shader"");
            instance(""teapot.instance2"", ""teapot"");
        }

        ",(O)org.sunflow.Benchmark$BenchmarkScene:buildCornellBox()
"org.sunflow.core.Options:getInt(java.lang.String,int)",samples,<init>,GlobalPhotonMap,../data/xml/sunflow_call_methods/GlobalPhotonMap.xml,"
public GlobalPhotonMap(int numEmit, int numGather, float gatherRadius) {
        this.numEmit = numEmit;
        this.numGather = numGather;
        this.gatherRadius = gatherRadius;
        bounds = new BoundingBox();
        hasRadiance = false;
        maxPower = 0;
        maxRadius = 0;
    }

    ","(O)org.sunflow.core.photonmap.GlobalPhotonMap:<init>(int,int,float)"
"org.sunflow.core.Options:getInt(java.lang.String,int)",samples,<init>,GridPhotonMap,../data/xml/sunflow_call_methods/GridPhotonMap.xml,"
public GridPhotonMap(int numEmit, int numGather, float gatherRadius) {
        this.numEmit = numEmit;
        this.numGather = numGather;
        this.gatherRadius = gatherRadius;
        numStoredPhotons = 0;
        hashSize = 0; // number of unique IDs in the hash
        rwl = new ReentrantReadWriteLock();
        numEmit = 100000;
    }

    ","(O)org.sunflow.core.photonmap.GridPhotonMap:<init>(int,int,float)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,updateBasis,ImageBasedLight,../data/xml/sunflow_call_methods/ImageBasedLight.xml,"
private void updateBasis(Vector3 center, Vector3 up) {
        if (center != null && up != null) {
            basis = OrthoNormalBasis.makeFromWV(center, up);
            basis.swapWU();
            basis.flipV();
        }
    }

    ","(O)org.sunflow.core.light.ImageBasedLight:updateBasis(org.sunflow.math.Vector3,org.sunflow.math.Vector3)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,getBitmap,Texture,../data/xml/sunflow_call_methods/Texture.xml,"
public Bitmap getBitmap() {
        if (loaded == 0)
            load();
        return bitmap;
    }

    ",(M)org.sunflow.core.Texture:getBitmap()
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,getWidth,Bitmap,../data/xml/sunflow_call_methods/Bitmap.xml,"
public int getWidth() {
        return width;
    }

    ",(M)org.sunflow.image.Bitmap:getWidth()
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,getHeight,Bitmap,../data/xml/sunflow_call_methods/Bitmap.xml,"
public int getHeight() {
        return height;
    }

    ",(M)org.sunflow.image.Bitmap:getHeight()
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,getPixel,Texture,../data/xml/sunflow_call_methods/Texture.xml,"/**
     * Gets the color at location (x,y) in the texture. The lookup is performed
     * using the fractional component of the coordinates, treating the texture
     * as a unit square tiled in both directions. Bicubic filtering is performed
     * on the four nearest pixels to the lookup point.
     * 
     * @param x x coordinate into the texture
     * @param y y coordinate into the texture
     * @return filtered color at location (x,y)
     */
public Color getPixel(float x, float y) {
        Bitmap bitmap = getBitmap();
        if (bitmap == null)
            return Color.BLACK;
        x = x - (int) x;
        y = y - (int) y;
        if (x < 0)
            x++;
        if (y < 0)
            y++;
        float dx = (float) x * (bitmap.getWidth() - 1);
        float dy = (float) y * (bitmap.getHeight() - 1);
        int ix0 = (int) dx;
        int iy0 = (int) dy;
        int ix1 = (ix0 + 1) % bitmap.getWidth();
        int iy1 = (iy0 + 1) % bitmap.getHeight();
        float u = dx - ix0;
        float v = dy - iy0;
        u = u * u * (3.0f - (2.0f * u));
        v = v * v * (3.0f - (2.0f * v));
        float k00 = (1.0f - u) * (1.0f - v);
        Color c00 = bitmap.getPixel(ix0, iy0);
        float k01 = (1.0f - u) * v;
        Color c01 = bitmap.getPixel(ix0, iy1);
        float k10 = u * (1.0f - v);
        Color c10 = bitmap.getPixel(ix1, iy0);
        float k11 = u * v;
        Color c11 = bitmap.getPixel(ix1, iy1);
        Color c = Color.mul(k00, c00);
        c.madd(k01, c01);
        c.madd(k10, c10);
        c.madd(k11, c11);
        return c;
    }

    ","(M)org.sunflow.core.Texture:getPixel(float,float)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,getLuminance,Color,../data/xml/sunflow_call_methods/Color.xml,"
public final float getLuminance() {
        return (0.2989f * r) + (0.5866f * g) + (0.1145f * b);
    }

    ",(M)org.sunflow.image.Color:getLuminance()
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,halton,QMC,../data/xml/sunflow_call_methods/QMC.xml,"
public static final double halton(int d, int i) {
        // generalized Halton sequence
        switch (d) {
            case 0: {
                i = (i << 16) | (i >>> 16);
                i = ((i & 0x00ff00ff) << 8) | ((i & 0xff00ff00) >>> 8);
                i = ((i & 0x0f0f0f0f) << 4) | ((i & 0xf0f0f0f0) >>> 4);
                i = ((i & 0x33333333) << 2) | ((i & 0xcccccccc) >>> 2);
                i = ((i & 0x55555555) << 1) | ((i & 0xaaaaaaaa) >>> 1);
                return (double) (i & 0xFFFFFFFFL) / (double) 0x100000000L;
            }
            case 1: {
                double v = 0;
                double inv = 1.0 / 3;
                double p;
                int n;
                for (p = inv, n = i; n != 0; p *= inv, n /= 3)
                    v += (n % 3) * p;
                return v;
            }
            default:
        }
        int base = PRIMES[d];
        int[] perm = SIGMA[d];
        double v = 0;
        double inv = 1.0 / base;
        double p;
        int n;
        for (p = inv, n = i; n != 0; p *= inv, n /= base)
            v += perm[n % base] * p;
        return v;
    }

    ","(S)org.sunflow.math.QMC:halton(int,int)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,getDirection,ImageBasedLight,../data/xml/sunflow_call_methods/ImageBasedLight.xml,"
private Vector3 getDirection(float u, float v) {
        Vector3 dest = new Vector3();
        double phi = 0, theta = 0;
        theta = u * 2 * Math.PI;
        phi = v * Math.PI;
        double sin_phi = Math.sin(phi);
        dest.x = (float) (-sin_phi * Math.cos(theta));
        dest.y = (float) Math.cos(phi);
        dest.z = (float) (sin_phi * Math.sin(theta));
        return dest;
    }

    ","(O)org.sunflow.core.light.ImageBasedLight:getDirection(float,float)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,transform,OrthoNormalBasis,../data/xml/sunflow_call_methods/OrthoNormalBasis.xml,"
public Vector3 transform(Vector3 a, Vector3 dest) {
        dest.x = (a.x * u.x) + (a.y * v.x) + (a.z * w.x);
        dest.y = (a.x * u.y) + (a.y * v.y) + (a.z * w.y);
        dest.z = (a.x * u.z) + (a.y * v.z) + (a.z * w.z);
        return dest;
    }

    

public Vector3 transform(Vector3 a) {
        float x = (a.x * u.x) + (a.y * v.x) + (a.z * w.x);
        float y = (a.x * u.y) + (a.y * v.y) + (a.z * w.y);
        float z = (a.x * u.z) + (a.y * v.z) + (a.z * w.z);
        return a.set(x, y, z);
    }

    ",(M)org.sunflow.math.OrthoNormalBasis:transform(org.sunflow.math.Vector3)
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,mul,Color,../data/xml/sunflow_call_methods/Color.xml,"
public final Color mul(Color c) {
        r *= c.r;
        g *= c.g;
        b *= c.b;
        return this;
    }

    

public static final Color mul(Color c1, Color c2) {
        return Color.mul(c1, c2, new Color());
    }

    

public static final Color mul(Color c1, Color c2, Color dest) {
        dest.r = c1.r * c2.r;
        dest.g = c1.g * c2.g;
        dest.b = c1.b * c2.b;
        return dest;
    }

    

public final Color mul(float s) {
        r *= s;
        g *= s;
        b *= s;
        return this;
    }

    

public static final Color mul(float s, Color c) {
        return Color.mul(s, c, new Color());
    }

    

public static final Color mul(float s, Color c, Color dest) {
        dest.r = s * c.r;
        dest.g = s * c.g;
        dest.b = s * c.b;
        return dest;
    }

    ",(M)org.sunflow.image.Color:mul(float)
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,makeFromWV,OrthoNormalBasis,../data/xml/sunflow_call_methods/OrthoNormalBasis.xml,"
public static final OrthoNormalBasis makeFromWV(Vector3 w, Vector3 v) {
        OrthoNormalBasis onb = new OrthoNormalBasis();
        w.normalize(onb.w);
        Vector3.cross(v, onb.w, onb.u).normalize();
        Vector3.cross(onb.w, onb.u, onb.v);
        return onb;
    }
}","(S)org.sunflow.math.OrthoNormalBasis:makeFromWV(org.sunflow.math.Vector3,org.sunflow.math.Vector3)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,makeFromW,OrthoNormalBasis,../data/xml/sunflow_call_methods/OrthoNormalBasis.xml,"
public static final OrthoNormalBasis makeFromW(Vector3 w) {
        OrthoNormalBasis onb = new OrthoNormalBasis();
        w.normalize(onb.w);
        if ((Math.abs(onb.w.x) < Math.abs(onb.w.y)) && (Math.abs(onb.w.x) < Math.abs(onb.w.z))) {
            onb.v.x = 0;
            onb.v.y = onb.w.z;
            onb.v.z = -onb.w.y;
        } else if (Math.abs(onb.w.y) < Math.abs(onb.w.z)) {
            onb.v.x = onb.w.z;
            onb.v.y = 0;
            onb.v.z = -onb.w.x;
        } else {
            onb.v.x = onb.w.y;
            onb.v.y = -onb.w.x;
            onb.v.z = 0;
        }
        Vector3.cross(onb.v.normalize(), onb.w, onb.u);
        return onb;
    }

    ",(S)org.sunflow.math.OrthoNormalBasis:makeFromW(org.sunflow.math.Vector3)
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,initSunSky,SunSkyLight,../data/xml/sunflow_call_methods/SunSkyLight.xml,"
private void initSunSky() {
        // perform all the required initialization of constants
        sunDirWorld.normalize();
        sunDir = basis.untransform(sunDirWorld, new Vector3());
        sunDir.normalize();
        sunTheta = (float) Math.acos(MathUtils.clamp(sunDir.z, -1, 1));
        if (sunDir.z > 0) {
            sunSpectralRadiance = computeAttenuatedSunlight(sunTheta, turbidity);
            // produce color suitable for rendering
            sunColor = RGBSpace.SRGB.convertXYZtoRGB(sunSpectralRadiance.toXYZ().mul(1e-4f)).constrainRGB();
        } else {
            sunSpectralRadiance = new ConstantSpectralCurve(0);
        }
        // sunSolidAngle = (float) (0.25 * Math.PI * 1.39 * 1.39 / (150 * 150));
        float theta2 = sunTheta * sunTheta;
        float theta3 = sunTheta * theta2;
        float T = turbidity;
        float T2 = turbidity * turbidity;
        double chi = (4.0 / 9.0 - T / 120.0) * (Math.PI - 2.0 * sunTheta);
        zenithY = (4.0453 * T - 4.9710) * Math.tan(chi) - 0.2155 * T + 2.4192;
        zenithY *= 1000; /* conversion from kcd/m^2 to cd/m^2 */
        zenithx = (0.00165 * theta3 - 0.00374 * theta2 + 0.00208 * sunTheta + 0) * T2 + (-0.02902 * theta3 + 0.06377 * theta2 - 0.03202 * sunTheta + 0.00394) * T + (0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * sunTheta + 0.25885);
        zenithy = (0.00275 * theta3 - 0.00610 * theta2 + 0.00316 * sunTheta + 0) * T2 + (-0.04212 * theta3 + 0.08970 * theta2 - 0.04153 * sunTheta + 0.00515) * T + (0.15346 * theta3 - 0.26756 * theta2 + 0.06669 * sunTheta + 0.26688);

        perezY[0] = 0.17872 * T - 1.46303;
        perezY[1] = -0.35540 * T + 0.42749;
        perezY[2] = -0.02266 * T + 5.32505;
        perezY[3] = 0.12064 * T - 2.57705;
        perezY[4] = -0.06696 * T + 0.37027;

        perezx[0] = -0.01925 * T - 0.25922;
        perezx[1] = -0.06651 * T + 0.00081;
        perezx[2] = -0.00041 * T + 0.21247;
        perezx[3] = -0.06409 * T - 0.89887;
        perezx[4] = -0.00325 * T + 0.04517;

        perezy[0] = -0.01669 * T - 0.26078;
        perezy[1] = -0.09495 * T + 0.00921;
        perezy[2] = -0.00792 * T + 0.21023;
        perezy[3] = -0.04405 * T - 1.65369;
        perezy[4] = -0.01092 * T + 0.05291;

        final int w = 32, h = 32;
        imageHistogram = new float[w][h];
        colHistogram = new float[w];
        float du = 1.0f / w;
        float dv = 1.0f / h;
        for (int x = 0; x < w; x++) {
            for (int y = 0; y < h; y++) {
                float u = (x + 0.5f) * du;
                float v = (y + 0.5f) * dv;
                Color c = getSkyRGB(getDirection(u, v));
                imageHistogram[x][y] = c.getLuminance() * (float) Math.sin(Math.PI * v);
                if (y > 0)
                    imageHistogram[x][y] += imageHistogram[x][y - 1];
            }
            colHistogram[x] = imageHistogram[x][h - 1];
            if (x > 0)
                colHistogram[x] += colHistogram[x - 1];
            for (int y = 0; y < h; y++)
                imageHistogram[x][y] /= imageHistogram[x][h - 1];
        }
        for (int x = 0; x < w; x++)
            colHistogram[x] /= colHistogram[w - 1];
        jacobian = (float) (2 * Math.PI * Math.PI) / (w * h);
    }

    ",(O)org.sunflow.core.light.SunSkyLight:initSunSky()
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,update,TriangleMesh,../data/xml/sunflow_call_methods/TriangleMesh.xml,"
public boolean update(ParameterList pl, SunflowAPI api) {
        boolean updatedTopology = false;
        {
            int[] triangles = pl.getIntArray(""triangles"");
            if (triangles != null) {
                this.triangles = triangles;
                updatedTopology = true;
            }
        }
        if (triangles == null) {
            UI.printError(Module.GEOM, ""Unable to update mesh - triangle indices are missing"");
            return false;
        }
        if (triangles.length % 3 != 0)
            UI.printWarning(Module.GEOM, ""Triangle index data is not a multiple of 3 - triangles may be missing"");
        pl.setFaceCount(triangles.length / 3);
        {
            FloatParameter pointsP = pl.getPointArray(""points"");
            if (pointsP != null)
                if (pointsP.interp != InterpolationType.VERTEX)
                    UI.printError(Module.GEOM, ""Point interpolation type must be set to \""vertex\"" - was \""%s\"""", pointsP.interp.name().toLowerCase());
                else {
                    points = pointsP.data;
                    updatedTopology = true;
                }
        }
        if (points == null) {
            UI.printError(Module.GEOM, ""Unable to update mesh - vertices are missing"");
            return false;
        }
        pl.setVertexCount(points.length / 3);
        pl.setFaceVertexCount(3 * (triangles.length / 3));
        FloatParameter normals = pl.getVectorArray(""normals"");
        if (normals != null)
            this.normals = normals;
        FloatParameter uvs = pl.getTexCoordArray(""uvs"");
        if (uvs != null)
            this.uvs = uvs;
        int[] faceShaders = pl.getIntArray(""faceshaders"");
        if (faceShaders != null && faceShaders.length == triangles.length / 3) {
            this.faceShaders = new byte[faceShaders.length];
            for (int i = 0; i < faceShaders.length; i++) {
                int v = faceShaders[i];
                if (v > 255)
                    UI.printWarning(Module.GEOM, ""Shader index too large on triangle %d"", i);
                this.faceShaders[i] = (byte) (v & 0xFF);
            }
        }
        if (updatedTopology) {
            // create triangle acceleration structure
            init();
        }
        return true;
    }

    

public boolean update(ParameterList pl, SunflowAPI api) {
            return true;
        }
    }","(O)org.sunflow.core.primitive.TriangleMesh:update(org.sunflow.core.ParameterList,org.sunflow.SunflowAPI)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,updateGeometry,CornellBox,../data/xml/sunflow_call_methods/CornellBox.xml,"
private void updateGeometry(Point3 c0, Point3 c1) {
        // figure out cube extents
        lightBounds = new BoundingBox(c0);
        lightBounds.include(c1);

        // cube extents
        minX = lightBounds.getMinimum().x;
        minY = lightBounds.getMinimum().y;
        minZ = lightBounds.getMinimum().z;
        maxX = lightBounds.getMaximum().x;
        maxY = lightBounds.getMaximum().y;
        maxZ = lightBounds.getMaximum().z;

        // work around epsilon problems for light test
        lightBounds.enlargeUlps();

        // light source geometry
        lxmin = maxX / 3 + 2 * minX / 3;
        lxmax = minX / 3 + 2 * maxX / 3;
        lymin = maxY / 3 + 2 * minY / 3;
        lymax = minY / 3 + 2 * maxY / 3;
        area = (lxmax - lxmin) * (lymax - lymin);
    }

    ","(O)org.sunflow.core.primitive.CornellBox:updateGeometry(org.sunflow.math.Point3,org.sunflow.math.Point3)"
"org.sunflow.core.ParameterList:getInt(java.lang.String,int)",samples,clamp,MathUtils,../data/xml/sunflow_call_methods/MathUtils.xml,"
public static final int clamp(int x, int min, int max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }

    

public static final float clamp(float x, float min, float max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }

    

public static final double clamp(double x, double min, double max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }

    ","(S)org.sunflow.math.MathUtils:clamp(float,float,float)"
