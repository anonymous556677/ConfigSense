function,option,Method_short,class_name,xml_path,Method_body,Method
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_Threads,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_Threads()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_Resolution,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_Resolution()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_DiffuseDepth,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_DiffuseDepth()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_ReflectionDepth,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_ReflectionDepth()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_RefractionDepth,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_RefractionDepth()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_BucketSize,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_BucketSize()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,_get_Samples,Benchmark,../data/xml/sunflow_call_methods/Benchmark.xml,not found,(M)org.sunflow.Benchmark:_get_Samples()
org.sunflow.Benchmark:_get_DiffuseDepth(),diffuseDepth,buildCornellBox,Benchmark$BenchmarkScene,../data/xml/sunflow_call_methods/Benchmark.xml,"
private void buildCornellBox() {
            // camera
            parameter(""eye"", new Point3(0, 0, -600));
            parameter(""target"", new Point3(0, 0, 0));
            parameter(""up"", new Vector3(0, 1, 0));
            parameter(""fov"", 45.0f);
            camera(""main_camera"", new PinholeLens());
            parameter(""camera"", ""main_camera"");
            options(SunflowAPI.DEFAULT_OPTIONS);
            // cornell box
            Color gray = new Color(0.70f, 0.70f, 0.70f);
            Color blue = new Color(0.25f, 0.25f, 0.80f);
            Color red = new Color(0.80f, 0.25f, 0.25f);
            Color emit = new Color(15, 15, 15);

            float minX = -200;
            float maxX = 200;
            float minY = -160;
            float maxY = minY + 400;
            float minZ = -250;
            float maxZ = 200;

            float[] verts = new float[] { minX, minY, minZ, maxX, minY, minZ,
                    maxX, minY, maxZ, minX, minY, maxZ, minX, maxY, minZ, maxX,
                    maxY, minZ, maxX, maxY, maxZ, minX, maxY, maxZ, };
            int[] indices = new int[] { 0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4, 1,
                    2, 5, 5, 6, 2, 2, 3, 6, 6, 7, 3, 0, 3, 4, 4, 7, 3 };

            parameter(""diffuse"", gray);
            shader(""gray_shader"", new DiffuseShader());
            parameter(""diffuse"", red);
            shader(""red_shader"", new DiffuseShader());
            parameter(""diffuse"", blue);
            shader(""blue_shader"", new DiffuseShader());

            // build walls
            parameter(""triangles"", indices);
            parameter(""points"", ""point"", ""vertex"", verts);
            parameter(""faceshaders"", new int[] { 0, 0, 0, 0, 1, 1, 0, 0, 2, 2 });
            geometry(""walls"", new TriangleMesh());

            // instance walls
            parameter(""shaders"", new String[] { ""gray_shader"", ""red_shader"",
                    ""blue_shader"" });
            instance(""walls.instance"", ""walls"");

            // create mesh light
            parameter(""points"", ""point"", ""vertex"", new float[] { -50, maxY - 1,
                    -50, 50, maxY - 1, -50, 50, maxY - 1, 50, -50, maxY - 1, 50 });
            parameter(""triangles"", new int[] { 0, 1, 2, 2, 3, 0 });
            parameter(""radiance"", emit);
            parameter(""samples"", 8);
            TriangleMeshLight light = new TriangleMeshLight();
            light.init(""light"", this);

            // spheres
            parameter(""eta"", 1.6f);
            shader(""Glass"", new GlassShader());
            sphere(""glass_sphere"", ""Glass"", -120, minY + 55, -150, 50);
            parameter(""color"", new Color(0.70f, 0.70f, 0.70f));
            shader(""Mirror"", new MirrorShader());
            sphere(""mirror_sphere"", ""Mirror"", 100, minY + 60, -50, 50);

            // scanned model
            geometry(""teapot"", (Tesselatable) new Teapot());
            parameter(""transform"", Matrix4.translation(80, -50, 100).multiply(Matrix4.rotateX((float) -Math.PI / 6)).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
            parameter(""shaders"", ""gray_shader"");
            instance(""teapot.instance1"", ""teapot"");
            parameter(""transform"", Matrix4.translation(-80, -160, 50).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
            parameter(""shaders"", ""gray_shader"");
            instance(""teapot.instance2"", ""teapot"");
        }

        ",(O)org.sunflow.Benchmark$BenchmarkScene:buildCornellBox()
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,create,GIEngineFactory,../data/xml/sunflow_call_methods/GIEngineFactory.xml,"
public static final GIEngine create(Options options) {
        String type = options.getString(""gi.engine"", null);
        if (type == null || type.equals(""null"") || type.equals(""none""))
            return null;
        else if (type.equals(""ambocc""))
            return new AmbientOcclusionGIEngine(options);
        else if (type.equals(""fake""))
            return new FakeGIEngine(options);
        else if (type.equals(""igi""))
            return new InstantGI(options);
        else if (type.equals(""irr-cache""))
            return new IrradianceCacheGIEngine(options);
        else if (type.equals(""path""))
            return new PathTracingGIEngine(options);
        else {
            UI.printWarning(Module.LIGHT, ""Unrecognized GI engine type \""%s\"" - ignoring"", type);
            return null;
        }
    }
}",(S)org.sunflow.core.gi.GIEngineFactory:create(org.sunflow.core.Options)
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,<init>,CausticPhotonMap,../data/xml/sunflow_call_methods/CausticPhotonMap.xml,"
public CausticPhotonMap(Options options) {
        numEmit = options.getInt(""caustics.emit"", 10000);
        gatherNum = options.getInt(""caustics.gather"", 50);
        gatherRadius = options.getFloat(""caustics.radius"", 0.5f);
        filterValue = options.getFloat(""caustics.filter"", 1.1f);
        bounds = new BoundingBox();
        maxPower = 0;
        maxRadius = 0;
    }

    ",(O)org.sunflow.core.photonmap.CausticPhotonMap:<init>(org.sunflow.core.Options)
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,<init>,Timer,../data/xml/sunflow_call_methods/Timer.xml,"
public Timer() {
        startTime = endTime = 0;
    }

    ",(O)org.sunflow.system.Timer:<init>()
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,start,Timer,../data/xml/sunflow_call_methods/Timer.xml,"
public void start() {
        startTime = endTime = System.nanoTime();
    }

    ",(M)org.sunflow.system.Timer:start()
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,getNumSamples,LightSource,../data/xml/sunflow_call_methods/LightSource.xml,not found,(I)org.sunflow.core.LightSource:getNumSamples()
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,init,GIEngine,../data/xml/sunflow_call_methods/GIEngine.xml,not found,(I)org.sunflow.core.GIEngine:init(org.sunflow.core.Scene)
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,end,Timer,../data/xml/sunflow_call_methods/Timer.xml,"
public void end() {
        endTime = System.nanoTime();
    }

    ",(M)org.sunflow.system.Timer:end()
"org.sunflow.core.Options:getInt(java.lang.String,int)",diffuseDepth,toString,Timer,../data/xml/sunflow_call_methods/Timer.xml,"
public static String toString(long nanos) {
        Timer t = new Timer();
        t.endTime = nanos;
        return t.toString();
    }

    

public static String toString(double seconds) {
        Timer t = new Timer();
        t.endTime = (long) (seconds * 1e9);
        return t.toString();
    }

    

@Override
    public String toString() {
        long millis = nanos() / (1000 * 1000);
        if (millis < 10000)
            return String.format(""%dms"", millis);
        long hours = millis / (60 * 60 * 1000);
        millis -= hours * 60 * 60 * 1000;
        long minutes = millis / (60 * 1000);
        millis -= minutes * 60 * 1000;
        long seconds = millis / 1000;
        millis -= seconds * 1000;
        return String.format(""%d:%02d:%02d.%1d"", hours, minutes, seconds, millis / 100);
    }
}",(M)org.sunflow.system.Timer:toString()
