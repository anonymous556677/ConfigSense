<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/locator/ReplicaPlans.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name></name>;</package>

<import>import <name><name>com</name><operator>.</operator><name>carrotsearch</name><operator>.</operator><name>hppc</name><operator>.</operator><name>ObjectIntHashMap</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>carrotsearch</name><operator>.</operator><name>hppc</name><operator>.</operator><name>cursors</name><operator>.</operator><name>ObjectIntCursor</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>carrotsearch</name><operator>.</operator><name>hppc</name><operator>.</operator><name>cursors</name><operator>.</operator><name>ObjectObjectCursor</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>ArrayListMultimap</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>HashMultimap</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>ListMultimap</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Lists</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Multimap</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ConsistencyLevel</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>DecoratedKey</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>Keyspace</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>PartitionPosition</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>AbstractBounds</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>UnavailableException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>gms</name><operator>.</operator><name>FailureDetector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaConstants</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>StorageService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>reads</name><operator>.</operator><name>AlwaysSpeculativeRetryPolicy</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>reads</name><operator>.</operator><name>SpeculativeRetryPolicy</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collection</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ThreadLocalRandom</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Consumer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Function</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Predicate</name></name>;</import>

<import>import static <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name><operator>.</operator><name>any</name></name>;</import>
<import>import static <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name><operator>.</operator><name>filter</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ConsistencyLevel</name><operator>.</operator><name>EACH_QUORUM</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ConsistencyLevel</name><operator>.</operator><name>eachQuorumForRead</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ConsistencyLevel</name><operator>.</operator><name>eachQuorumForWrite</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ConsistencyLevel</name><operator>.</operator><name>localQuorumFor</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ConsistencyLevel</name><operator>.</operator><name>localQuorumForOurDc</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>Replicas</name><operator>.</operator><name>addToCountPerDc</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>Replicas</name><operator>.</operator><name>countInOurDc</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>Replicas</name><operator>.</operator><name>countPerDc</name></name>;</import>

<class><specifier>public</specifier> class <name>ReplicaPlans</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>ReplicaPlans</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isSufficientLiveReplicasForRead</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>liveReplicas</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>consistencyLevel</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>ANY</name></expr>:</case>
                <comment type="line">// local hint is acceptable, and local node is always live</comment>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            <case>case <expr><name>LOCAL_ONE</name></expr>:</case>
                <return>return <expr><call><name>countInOurDc</name><argument_list>(<argument><expr><name>liveReplicas</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasAtleast</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
            <case>case <expr><name>LOCAL_QUORUM</name></expr>:</case>
                <return>return <expr><call><name>countInOurDc</name><argument_list>(<argument><expr><name>liveReplicas</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasAtleast</name><argument_list>(<argument><expr><call><name>localQuorumForOurDc</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
            <case>case <expr><name>EACH_QUORUM</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>replicationStrategy</name> <operator>instanceof</operator> <name>NetworkTopologyStrategy</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>fullCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>dcs</name> <init>= <expr><operator>(</operator><operator>(</operator><name>NetworkTopologyStrategy</name><operator>)</operator> <name>replicationStrategy</name><operator>)</operator><operator>.</operator><call><name>getDatacenters</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name><name>ObjectObjectCursor</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>Replicas</name><operator>.</operator><name>ReplicaCount</name></name></argument>&gt;</argument_list></name></type> <name>entry</name> <range>: <expr><call><name>countPerDc</name><argument_list>(<argument><expr><name>dcs</name></expr></argument>, <argument><expr><name>liveReplicas</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name><name>Replicas</name><operator>.</operator><name>ReplicaCount</name></name></type> <name>count</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>count</name><operator>.</operator><name>hasAtleast</name></name><argument_list>(<argument><expr><call><name>localQuorumFor</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>fullCount</name> <operator>+=</operator> <call><name><name>count</name><operator>.</operator><name>fullReplicas</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <return>return <expr><name>fullCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// Fallthough on purpose for SimpleStrategy</comment>
            <default>default:</default>
                <return>return <expr><call><name><name>liveReplicas</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>consistencyLevel</name><operator>.</operator><name>blockFor</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>)</argument_list></call>
                        <operator>&amp;&amp;</operator> <call><name><name>Replicas</name><operator>.</operator><name>countFull</name></name><argument_list>(<argument><expr><name>liveReplicas</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>assureSufficientLiveReplicasForRead</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>liveReplicas</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assureSufficientLiveReplicas</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>liveReplicas</name></expr></argument>, <argument><expr><call><name><name>consistencyLevel</name><operator>.</operator><name>blockFor</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>assureSufficientLiveReplicasForWrite</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>allLive</name></decl></parameter>, <parameter><decl><type><name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>pendingWithDown</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assureSufficientLiveReplicas</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>allLive</name></expr></argument>, <argument><expr><call><name><name>consistencyLevel</name><operator>.</operator><name>blockForWrite</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>pendingWithDown</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>assureSufficientLiveReplicas</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>allLive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>blockFor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>blockForFullReplicas</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>consistencyLevel</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>ANY</name></expr>:</case>
                <comment type="line">// local hint is acceptable, and local node is always live</comment>
                <break>break;</break>
            <case>case <expr><name>LOCAL_ONE</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Replicas</name><operator>.</operator><name>ReplicaCount</name></name></type> <name>localLive</name> <init>= <expr><call><name>countInOurDc</name><argument_list>(<argument><expr><name>allLive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>localLive</name><operator>.</operator><name>hasAtleast</name></name><argument_list>(<argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><call><name><name>UnavailableException</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>, <argument><expr><call><name><name>localLive</name><operator>.</operator><name>allReplicas</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>localLive</name><operator>.</operator><name>fullReplicas</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>LOCAL_QUORUM</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Replicas</name><operator>.</operator><name>ReplicaCount</name></name></type> <name>localLive</name> <init>= <expr><call><name>countInOurDc</name><argument_list>(<argument><expr><name>allLive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>localLive</name><operator>.</operator><name>hasAtleast</name></name><argument_list>(<argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Local replicas %s are insufficient to satisfy LOCAL_QUORUM requirement of %d live replicas and %d full replicas in '%s'"</literal></expr></argument>,
                                <argument><expr><call><name><name>allLive</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><call><name><name>InOurDcTester</name><operator>.</operator><name>replicas</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getLocalDataCenter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <throw>throw <expr><call><name><name>UnavailableException</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>, <argument><expr><call><name><name>localLive</name><operator>.</operator><name>allReplicas</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>localLive</name><operator>.</operator><name>fullReplicas</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>EACH_QUORUM</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>replicationStrategy</name> <operator>instanceof</operator> <name>NetworkTopologyStrategy</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>totalFull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>dcs</name> <init>= <expr><operator>(</operator><operator>(</operator><name>NetworkTopologyStrategy</name><operator>)</operator> <name>replicationStrategy</name><operator>)</operator><operator>.</operator><call><name>getDatacenters</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name><name>ObjectObjectCursor</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>Replicas</name><operator>.</operator><name>ReplicaCount</name></name></argument>&gt;</argument_list></name></type> <name>entry</name> <range>: <expr><call><name>countPerDc</name><argument_list>(<argument><expr><name>dcs</name></expr></argument>, <argument><expr><name>allLive</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>dcBlockFor</name> <init>= <expr><call><name>localQuorumFor</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name><name>Replicas</name><operator>.</operator><name>ReplicaCount</name></name></type> <name>dcCount</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dcCount</name><operator>.</operator><name>hasAtleast</name></name><argument_list>(<argument><expr><name>dcBlockFor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <throw>throw <expr><call><name><name>UnavailableException</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>dcBlockFor</name></expr></argument>, <argument><expr><call><name><name>dcCount</name><operator>.</operator><name>allReplicas</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>dcCount</name><operator>.</operator><name>fullReplicas</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>totalFull</name> <operator>+=</operator> <call><name><name>dcCount</name><operator>.</operator><name>fullReplicas</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name><name>dcCount</name><operator>.</operator><name>allReplicas</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <if_stmt><if>if <condition>(<expr><name>totalFull</name> <operator>&lt;</operator> <name>blockForFullReplicas</name></expr>)</condition><block type="pseudo"><block_content>
                        <throw>throw <expr><call><name><name>UnavailableException</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>total</name></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>, <argument><expr><name>totalFull</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// Fallthough on purpose for SimpleStrategy</comment>
            <default>default:</default>
                <decl_stmt><decl><type><name>int</name></type> <name>live</name> <init>= <expr><call><name><name>allLive</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>full</name> <init>= <expr><call><name><name>Replicas</name><operator>.</operator><name>countFull</name></name><argument_list>(<argument><expr><name>allLive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>live</name> <operator>&lt;</operator> <name>blockFor</name> <operator>||</operator> <name>full</name> <operator>&lt;</operator> <name>blockForFullReplicas</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Live nodes {} do not satisfy ConsistencyLevel ({} required)"</literal></expr></argument>, <argument><expr><call><name><name>Iterables</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>allLive</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <throw>throw <expr><call><name><name>UnavailableException</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockForFullReplicas</name></expr></argument>, <argument><expr><name>live</name></expr></argument>, <argument><expr><name>full</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Construct a ReplicaPlan for writing to exactly one node, with CL.ONE. This node is *assumed* to be alive.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forSingleReplicaWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>Replica</name></type> <name>replica</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>one</name> <init>= <expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>empty</name> <init>= <expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ConsistencyLevel</name><operator>.</operator><name>ONE</name></name></expr></argument>, <argument><expr><name>empty</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * A forwarding counter write is always sent to a single owning coordinator for the range, by the original coordinator
     * (if it is not itself an owner)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forForwardingCounterWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>Replica</name></type> <name>replica</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>forSingleReplicaWrite</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forLocalBatchlogWrite</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMinimumToken</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Keyspace</name></type> <name>systemKeypsace</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name><name>SchemaConstants</name><operator>.</operator><name>SYSTEM_KEYSPACE_NAME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Replica</name></type> <name>localSystemReplica</name> <init>= <expr><call><name><name>SystemReplicas</name><operator>.</operator><name>getSystemReplica</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>liveAndDown</name> <init>= <expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenWrite</name></name><argument_list>(
                <argument><expr><call><name><name>systemKeypsace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>localSystemReplica</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name>systemKeypsace</name></expr></argument>, <argument><expr><name><name>ConsistencyLevel</name><operator>.</operator><name>ONE</name></name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name>writeAll</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Requires that the provided endpoints are alive.  Converts them to their relevant system replicas.
     * Note that the liveAndDown collection and live are equal to the provided endpoints.
     *
     * @param isAny if batch consistency level is ANY, in which case a local node will be picked
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forBatchlogWrite</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>isAny</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <comment type="line">// A single case we write not for range or token, but multiple mutations to many tokens</comment>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMinimumToken</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>TokenMetadata</name><operator>.</operator><name>Topology</name></name></type> <name>topology</name> <init>= <expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTokenMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>cachedOnlyTokenMap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTopology</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>localEndpoints</name> <init>= <expr><call><name><name>HashMultimap</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>topology</name><operator>.</operator><name>getDatacenterRacks</name></name><argument_list>()</argument_list></call>
                                                                                          <operator>.</operator><call><name>get</name><argument_list>(<argument><expr><call><name><name>snitch</name><operator>.</operator><name>getLocalDatacenter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Replicas are picked manually:</comment>
        <comment type="line">//  - replicas should be alive according to the failure detector</comment>
        <comment type="line">//  - replicas should be in the local datacenter</comment>
        <comment type="line">//  - choose min(2, number of qualifying candiates above)</comment>
        <comment type="line">//  - allow the local node to be the only replica only if it's a single-node DC</comment>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>chosenEndpoints</name> <init>= <expr><call><name>filterBatchlogEndpoints</name><argument_list>(<argument><expr><call><name><name>snitch</name><operator>.</operator><name>getLocalRack</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>localEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>chosenEndpoints</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>isAny</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>chosenEndpoints</name> <operator>=</operator> <call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>Keyspace</name></type> <name>systemKeypsace</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name><name>SchemaConstants</name><operator>.</operator><name>SYSTEM_KEYSPACE_NAME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>liveAndDown</name> <init>= <expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenWrite</name></name><argument_list>(
                <argument><expr><call><name><name>systemKeypsace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>SystemReplicas</name><operator>.</operator><name>getSystemReplicas</name></name><argument_list>(<argument><expr><name>chosenEndpoints</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>forToken</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Batchlog is hosted by either one node or two nodes from different racks.</comment>
        <decl_stmt><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name> <init>= <expr><ternary><condition><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>ConsistencyLevel</name><operator>.</operator><name>ONE</name></name></expr> </then><else>: <expr><name><name>ConsistencyLevel</name><operator>.</operator><name>TWO</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <comment type="line">// assume that we have already been given live endpoints, and skip applying the failure detector</comment>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name>systemKeypsace</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name>writeAll</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>filterBatchlogEndpoints</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>localRack</name></decl></parameter>,
                                                                          <parameter><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>filterBatchlogEndpoints</name><argument_list>(<argument><expr><name>localRack</name></expr></argument>,
                                       <argument><expr><name>endpoints</name></expr></argument>,
                                       <argument><expr><name>Collections</name><operator>::</operator><name>shuffle</name></expr></argument>,
                                       <argument><expr><name><name>FailureDetector</name><operator>.</operator><name>isEndpointAlive</name></name></expr></argument>,
                                       <argument><expr><call><name><name>ThreadLocalRandom</name><operator>.</operator><name>current</name></name><argument_list>()</argument_list></call><operator>::</operator><name>nextInt</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="line">// Collect a list of candidates for batchlog hosting. If possible these will be two nodes from different racks.</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>static</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>filterBatchlogEndpoints</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>localRack</name></decl></parameter>,
                                                                         <parameter><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></parameter>,
                                                                         <parameter><decl><type><name><name>Consumer</name><argument_list type="generic">&lt;<argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>shuffle</name></decl></parameter>,
                                                                         <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>isAlive</name></decl></parameter>,
                                                                         <parameter><decl><type><name><name>Function</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>indexPicker</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// special case for single-node data centers</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>endpoints</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>endpoints</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// strip out dead endpoints and localhost</comment>
        <decl_stmt><decl><type><name><name>ListMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>validated</name> <init>= <expr><call><name><name>ArrayListMultimap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>endpoints</name><operator>.</operator><name>entries</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InetAddressAndPort</name></type> <name>addr</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addr</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>isAlive</name><operator>.</operator><name>test</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>validated</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><call><name><name>validated</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>validated</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>validated</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>validated</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>localRack</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// we have enough endpoints in other racks</comment>
            <expr_stmt><expr><call><name><name>validated</name><operator>.</operator><name>removeAll</name></name><argument_list>(<argument><expr><name>localRack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>validated</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * we have only 1 `other` rack to select replicas from (whether it be the local rack or a single non-local rack)
             * pick two random nodes from there; we are guaranteed to have at least two nodes in the single remaining rack
             * because of the preceding if block.
             */</comment>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>otherRack</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>validated</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>shuffle</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><name>otherRack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>otherRack</name><operator>.</operator><name>subList</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// randomize which racks we pick from if more than 2 remaining</comment>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>racks</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>validated</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>racks</name> <operator>=</operator> <call><name><name>validated</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>racks</name> <operator>=</operator> <call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>validated</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>shuffle</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><operator>(</operator><name><name>List</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>racks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// grab a random member of up to two racks</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>rack</name> <range>: <expr><call><name><name>Iterables</name><operator>.</operator><name>limit</name></name><argument_list>(<argument><expr><name>racks</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>rackMembers</name> <init>= <expr><call><name><name>validated</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>rack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>rackMembers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>indexPicker</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><call><name><name>rackMembers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forReadRepair</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaPlan</name><operator>.</operator><name><name>ForRead</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></name></type> <name>readPlan</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name><name>readPlan</name><operator>.</operator><name>keyspace</name></name></expr></argument>, <argument><expr><name><name>readPlan</name><operator>.</operator><name>consistencyLevel</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><call><name>writeReadRepair</name><argument_list>(<argument><expr><name>readPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>Selector</name></type> <name>selector</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenWriteLiveAndDown</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>pending</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Replica</name></argument>&gt;</argument_list></name></type> <name>isAlive</name></decl></parameter>, <parameter><decl><type><name>Selector</name></type> <name>selector</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenWrite</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isAlive</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name>Selector</name></type> <name>selector</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name><name>FailureDetector</name><operator>.</operator><name>isReplicaAlive</name></name></expr></argument>, <argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Replica</name></argument>&gt;</argument_list></name></type> <name>isAlive</name></decl></parameter>, <parameter><decl><type><name>Selector</name></type> <name>selector</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>live</name> <init>= <expr><call><name><name>liveAndDown</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name>isAlive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>forWrite</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name>live</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forWrite</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>live</name></decl></parameter>, <parameter><decl><type><name>Selector</name></type> <name>selector</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <assert>assert <expr><call><name><name>liveAndDown</name><operator>.</operator><name>replicationStrategy</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>live</name><operator>.</operator><name>replicationStrategy</name></name><argument_list>()</argument_list></call>
               <operator>:</operator> <literal type="string">"ReplicaLayout liveAndDown and live should be derived from the same replication strategy."</literal></expr>;</assert>
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name> <init>= <expr><call><name><name>liveAndDown</name><operator>.</operator><name>replicationStrategy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>contacts</name> <init>= <expr><call><name><name>selector</name><operator>.</operator><name>select</name></name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>liveAndDown</name></expr></argument>, <argument><expr><name>live</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assureSufficientLiveReplicasForWrite</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenWrite</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>contacts</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <interface><specifier>public</specifier> interface <name>Selector</name>
    <block>{
        <comment type="block" format="javadoc">/**
         * Select the {@code Endpoints} from {@param liveAndDown} and {@param live} to contact according to the consistency level.
         */</comment>
        <function_decl><type><parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>, <parameter><name>L</name> <extends>extends <name>ReplicaLayout</name><operator>.</operator><name><name>ForWrite</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list>
        <name>E</name></type> <name>select</name><parameter_list>(<parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>live</name></decl></parameter>)</parameter_list>;</function_decl>
    }</block></interface>

    <comment type="block" format="javadoc">/**
     * Select all nodes, transient or otherwise, as targets for the operation.
     *
     * This is may no longer be useful once we finish implementing transient replication support, however
     * it can be of value to stipulate that a location writes to all nodes without regard to transient status.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Selector</name></type> <name>writeAll</name> <init>= <expr><operator>new</operator> <class><super><name>Selector</name></super><argument_list>()</argument_list>
    <block>{
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>, <parameter><name>L</name> <extends>extends <name>ReplicaLayout</name><operator>.</operator><name><name>ForWrite</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list>
        <name>E</name></type> <name>select</name><parameter_list>(<parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>live</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Select all full nodes, live or down, as write targets.  If there are insufficient nodes to complete the write,
     * but there are live transient nodes, select a sufficient number of these to reach our consistency level.
     *
     * Pending nodes are always contacted, whether or not they are full.  When a transient replica is undergoing
     * a pending move to a new node, if we write (transiently) to it, this write would not be replicated to the
     * pending transient node, and so when completing the move, the write could effectively have not reached the
     * promised consistency level.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Selector</name></type> <name>writeNormal</name> <init>= <expr><operator>new</operator> <class><super><name>Selector</name></super><argument_list>()</argument_list>
    <block>{
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>, <parameter><name>L</name> <extends>extends <name>ReplicaLayout</name><operator>.</operator><name><name>ForWrite</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list>
        <name>E</name></type> <name>select</name><parameter_list>(<parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>live</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>any</name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Replica</name><operator>::</operator><name>isTransient</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name><name>ReplicaCollection</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></name></type> <name>contacts</name> <init>= <expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>newBuilder</name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>contacts</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name>filter</name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>natural</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Replica</name><operator>::</operator><name>isFull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>contacts</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block" format="javadoc">/**
             * Per CASSANDRA-14768, we ensure we write to at least a QUORUM of nodes in every DC,
             * regardless of how many responses we need to wait for and our requested consistencyLevel.
             * This is to minimally surprise users with transient replication; with normal writes, we
             * soft-ensure that we reach QUORUM in all DCs we are able to, by writing to every node;
             * even if we don't wait for ACK, we have in both cases sent sufficient messages.
              */</comment>
            <decl_stmt><decl><type><name><name>ObjectIntHashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>requiredPerDc</name> <init>= <expr><call><name>eachQuorumForWrite</name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>replicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>addToCountPerDc</name><argument_list>(<argument><expr><name>requiredPerDc</name></expr></argument>, <argument><expr><call><name><name>live</name><operator>.</operator><name>natural</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>Replica</name><operator>::</operator><name>isFull</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addToCountPerDc</name><argument_list>(<argument><expr><name>requiredPerDc</name></expr></argument>, <argument><expr><call><name><name>live</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><call><name>filter</name><argument_list>(<argument><expr><call><name><name>live</name><operator>.</operator><name>natural</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Replica</name><operator>::</operator><name>isTransient</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>dc</name> <init>= <expr><call><name><name>snitch</name><operator>.</operator><name>getDatacenter</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>requiredPerDc</name><operator>.</operator><name>addTo</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>contacts</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <return>return <expr><call><name><name>contacts</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * TODO: Transient Replication C-14404/C-14665
     * TODO: We employ this even when there is no monotonicity to guarantee,
     *          e.g. in case of CL.TWO, CL.ONE with speculation, etc.
     *
     * Construct a read-repair write plan to provide monotonicity guarantees on any data we return as part of a read.
     *
     * Since this is not a regular write, this is just to guarantee future reads will read this data, we select only
     * the minimal number of nodes to meet the consistency level, and prefer nodes we contacted on read to minimise
     * data transfer.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Selector</name></type> <name>writeReadRepair</name><parameter_list>(<parameter><decl><type><name><name>ReplicaPlan</name><operator>.</operator><name><name>ForRead</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></name></type> <name>readPlan</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <class><super><name>Selector</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>, <parameter><name>L</name> <extends>extends <name>ReplicaLayout</name><operator>.</operator><name><name>ForWrite</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list>
            <name>E</name></type> <name>select</name><parameter_list>(<parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>liveAndDown</name></decl></parameter>, <parameter><decl><type><name>L</name></type> <name>live</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <assert>assert <expr><operator>!</operator><call><name>any</name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Replica</name><operator>::</operator><name>isTransient</name></expr></argument>)</argument_list></call></expr>;</assert>

                <decl_stmt><decl><type><name><name>ReplicaCollection</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></name></type> <name>contacts</name> <init>= <expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>newBuilder</name><argument_list>(<argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// add all live nodes we might write to that we have already contacted on read</comment>
                <expr_stmt><expr><call><name><name>contacts</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name>filter</name><argument_list>(<argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>r</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>readPlan</name><operator>.</operator><name>contacts</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>endpoints</name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><call><name><name>r</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// finally, add sufficient nodes to achieve our consistency level</comment>
                <if_stmt><if>if <condition>(<expr><name>consistencyLevel</name> <operator>!=</operator> <name>EACH_QUORUM</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>add</name> <init>= <expr><call><name><name>consistencyLevel</name><operator>.</operator><name>blockForWrite</name></name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>replicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <call><name><name>contacts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>add</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><call><name>filter</name><argument_list>(<argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>r</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>contacts</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
                        <block>{
                            <expr><call><name><name>contacts</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</block></for>
                            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>add</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></function>
                <if_stmt><else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>ObjectIntHashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>requiredPerDc</name> <init>= <expr><call><name>eachQuorumForWrite</name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>replicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>addToCountPerDc</name><argument_list>(<argument><expr><name>requiredPerDc</name></expr></argument>, <argument><expr><call><name><name>contacts</name><operator>.</operator><name>snapshot</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><call><name>filter</name><argument_list>(<argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>r</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>contacts</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
                    <block>{
                        <expr><name>String</name> <name>dc</name> <operator>=</operator> <call><name><name>snitch</name><operator>.</operator><name>getDatacenter</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</block></for>
                        <if_stmt><if>if <condition>(<expr><call><name><name>requiredPerDc</name><operator>.</operator><name>addTo</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name><name>contacts</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
                }</block></class></expr></return>
                <return>return <expr><call><name><name>contacts</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></function>
        }</block></class><empty_stmt>;</empty_stmt>
    }

    <comment type="block" format="javadoc">/**
     * Construct the plan for a paxos round - NOT the write or read consistency level for either the write or comparison,
     * but for the paxos linearisation agreement.
     *
     * This will select all live nodes as the candidates for the operation.  Only the required number of participants
     */</comment>
    public <function><type><specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForPaxosWrite</name></name></type> <name>forPaxos</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyForPaxos</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Token</name></type> <name>tk</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>liveAndDown</name> <init>= <expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenWriteLiveAndDown</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>tk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>Replicas</name><operator>.</operator><name>temporaryAssertFull</name></name><argument_list>(<argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// TODO CASSANDRA-14547</comment>

        <if_stmt><if>if <condition>(<expr><name>consistencyForPaxos</name> <operator>==</operator> <name><name>ConsistencyLevel</name><operator>.</operator><name>LOCAL_SERIAL</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// TODO: we should cleanup our semantics here, as we're filtering ALL nodes to localDC which is unexpected for ReplicaPlan</comment>
            <comment type="line">// Restrict natural and pending to node in the local DC only</comment>
            <expr_stmt><expr><name>liveAndDown</name> <operator>=</operator> <call><name><name>liveAndDown</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><call><name><name>InOurDcTester</name><operator>.</operator><name>replicas</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>live</name> <init>= <expr><call><name><name>liveAndDown</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name><name>FailureDetector</name><operator>.</operator><name>isReplicaAlive</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// TODO: this should use assureSufficientReplicas</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>participants</name> <init>= <expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>requiredParticipants</name> <init>= <expr><name>participants</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// See CASSANDRA-8346, CASSANDRA-833</comment>

        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>contacts</name> <init>= <expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>contacts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>requiredParticipants</name></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name><name>UnavailableException</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>consistencyForPaxos</name></expr></argument>, <argument><expr><name>requiredParticipants</name></expr></argument>, <argument><expr><call><name><name>contacts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <comment type="line">// We cannot allow CAS operations with 2 or more pending endpoints, see #8346.</comment>
        <comment type="line">// Note that we fake an impossible number of required nodes in the unavailable exception</comment>
        <comment type="line">// to nail home the point that it's an impossible operation no matter how many nodes are live.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>UnavailableException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Cannot perform LWT operation as there is more than one (%d) pending range movement"</literal></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>consistencyForPaxos</name></expr></argument>,
                    <argument><expr><name>participants</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                    <argument><expr><call><name><name>contacts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForPaxosWrite</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>consistencyForPaxos</name></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>pending</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>liveAndDown</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>live</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>contacts</name></expr></argument>, <argument><expr><name>requiredParticipants</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>


    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>E</name></type> <name>candidatesForRead</name><parameter_list>(<parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>liveNaturalReplicas</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><call><name><name>consistencyLevel</name><operator>.</operator><name>isDatacenterLocal</name></name><argument_list>()</argument_list></call></expr>
                ?</condition><then> <expr><call><name><name>liveNaturalReplicas</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><call><name><name>InOurDcTester</name><operator>.</operator><name>replicas</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>
                </then><else>: <expr><name>liveNaturalReplicas</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>E</name></type> <name>contactForEachQuorumRead</name><parameter_list>(<parameter><decl><type><name>NetworkTopologyStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>candidates</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>ObjectIntHashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>perDc</name> <init>= <expr><call><name>eachQuorumForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>candidates</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>replica</name></decl></parameter></parameter_list> -&gt; <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>dc</name> <init>= <expr><call><name><name>snitch</name><operator>.</operator><name>getDatacenter</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>perDc</name><operator>.</operator><name>addTo</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>E</name></type> <name>contactForRead</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>alwaysSpeculate</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>candidates</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="block">/*
         * If we are doing an each quorum query, we have to make sure that the endpoints we select
         * provide a quorum for each data center. If we are not using a NetworkTopologyStrategy,
         * we should fall through and grab a quorum in the replication strategy.
         *
         * We do not speculate for EACH_QUORUM.
         *
         * TODO: this is still very inconistently managed between {LOCAL,EACH}_QUORUM and other consistency levels - should address this in a follow-up
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>consistencyLevel</name> <operator>==</operator> <name>EACH_QUORUM</name> <operator>&amp;&amp;</operator> <name>replicationStrategy</name> <operator>instanceof</operator> <name>NetworkTopologyStrategy</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>contactForEachQuorumRead</name><argument_list>(<argument><expr><operator>(</operator><name>NetworkTopologyStrategy</name><operator>)</operator> <name>replicationStrategy</name></expr></argument>, <argument><expr><name>candidates</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name><name>consistencyLevel</name><operator>.</operator><name>blockFor</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>alwaysSpeculate</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>candidates</name><operator>.</operator><name>subList</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><call><name><name>candidates</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Construct a plan for reading from a single node - this permits no speculation or read-repair
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenRead</name></name></type> <name>forSingleReplicaRead</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>Replica</name></type> <name>replica</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>one</name> <init>= <expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenRead</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ConsistencyLevel</name><operator>.</operator><name>ONE</name></name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Construct a plan for reading from a single node - this permits no speculation or read-repair
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>forSingleReplicaRead</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>, <parameter><decl><type><name>Replica</name></type> <name>replica</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vnodeCount</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// TODO: this is unsafe, as one.range() may be inconsistent with our supplied range; should refactor Range/AbstractBounds to single class</comment>
        <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>one</name> <init>= <expr><call><name><name>EndpointsForRange</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ConsistencyLevel</name><operator>.</operator><name>ONE</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>vnodeCount</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Construct a plan for reading the provided token at the provided consistency level.  This translates to a collection of
     *   - candidates who are: alive, replicate the token, and are sorted by their snitch scores
     *   - contacts who are: the first blockFor + (retry == ALWAYS ? 1 : 0) candidates
     *
     * The candidate collection can be used for speculation, although at present
     * it would break EACH_QUORUM to do so without further filtering
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenRead</name></name></type> <name>forRead</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name>SpeculativeRetryPolicy</name></type> <name>retry</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>candidates</name> <init>= <expr><call><name>candidatesForRead</name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenReadLiveSorted</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>natural</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>contacts</name> <init>= <expr><call><name>contactForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>retry</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>AlwaysSpeculativeRetryPolicy</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>candidates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assureSufficientLiveReplicasForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>contacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForTokenRead</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>candidates</name></expr></argument>, <argument><expr><name>contacts</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Construct a plan for reading the provided range at the provided consistency level.  This translates to a collection of
     *   - candidates who are: alive, replicate the range, and are sorted by their snitch scores
     *   - contacts who are: the first blockFor candidates
     *
     * There is no speculation for range read queries at present, so we never 'always speculate' here, and a failed response fails the query.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>forRangeRead</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vnodeCount</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>candidates</name> <init>= <expr><call><name>candidatesForRead</name><argument_list>(<argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forRangeReadLiveSorted</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>natural</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>contacts</name> <init>= <expr><call><name>contactForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>candidates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assureSufficientLiveReplicasForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>contacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>candidates</name></expr></argument>, <argument><expr><name>contacts</name></expr></argument>, <argument><expr><name>vnodeCount</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Take two range read plans for adjacent ranges, and check if it is OK (and worthwhile) to combine them into a single plan
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>maybeMerge</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// TODO: should we be asserting that the ranges are adjacent?</comment>
        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>newRange</name> <init>= <expr><call><name><name>left</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>withNewRight</name><argument_list>(<argument><expr><call><name><name>right</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>mergedCandidates</name> <init>= <expr><call><name><name>left</name><operator>.</operator><name>candidates</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>keep</name><argument_list>(<argument><expr><call><name><name>right</name><operator>.</operator><name>candidates</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>endpoints</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check if there are enough shared endpoints for the merge to be possible.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isSufficientLiveReplicasForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>mergedCandidates</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>contacts</name> <init>= <expr><call><name>contactForRead</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>mergedCandidates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Estimate whether merging will be a win or not</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isWorthMergingForRangeQuery</name><argument_list>(<argument><expr><name>contacts</name></expr></argument>, <argument><expr><call><name><name>left</name><operator>.</operator><name>contacts</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>right</name><operator>.</operator><name>contacts</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// If we get there, merge this range and the next one</comment>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaPlan</name><operator>.</operator><name>ForRangeRead</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>, <argument><expr><name>newRange</name></expr></argument>, <argument><expr><name>mergedCandidates</name></expr></argument>, <argument><expr><name>contacts</name></expr></argument>, <argument><expr><call><name><name>left</name><operator>.</operator><name>vnodeCount</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>right</name><operator>.</operator><name>vnodeCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
}
</unit>
