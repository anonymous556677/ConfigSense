<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/transport/Envelope.java">
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>EnumSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Preconditions</name></name>;</import>

<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ByteBuf</name></name>;</import>
<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>buffer</name><operator>.</operator><name>Unpooled</name></name>;</import>
<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>channel</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>handler</name><operator>.</operator><name>codec</name><operator>.</operator><name>ByteToMessageDecoder</name></name>;</import>
<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>handler</name><operator>.</operator><name>codec</name><operator>.</operator><name>MessageToMessageDecoder</name></name>;</import>
<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>handler</name><operator>.</operator><name>codec</name><operator>.</operator><name>MessageToMessageEncoder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>InvalidRequestException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>ClientMessageSizeMetrics</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>messages</name><operator>.</operator><name>ErrorMessage</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>ByteBufferUtil</name></name>;</import>

<class><specifier>public</specifier> class <name>Envelope</name>
<block>{
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name></type> <name>PROTOCOL_VERSION_MASK</name> <init>= <expr><literal type="number">0x7f</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Header</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>ByteBuf</name></type> <name>body</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * An on-wire message envelope consists of a header and a body.
     *
     * The header is defined the following way in native protocol version 3 and later:
     *
     *   0         8        16        24        32         40
     *   +---------+---------+---------+---------+---------+
     *   | version |  flags  |      stream       | opcode  |
     *   +---------+---------+---------+---------+---------+
     *   |                length                 |
     *   +---------+---------+---------+---------+
     */</comment>
    <constructor><specifier>public</specifier> <name>Envelope</name><parameter_list>(<parameter><decl><type><name>Header</name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>ByteBuf</name></type> <name>body</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>header</name></name> <operator>=</operator> <name>header</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>body</name></name> <operator>=</operator> <name>body</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>retain</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>body</name><operator>.</operator><name>retain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>release</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>body</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>Envelope</name></type> <name>clone</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>Envelope</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><call><name><name>Unpooled</name><operator>.</operator><name>wrappedBuffer</name></name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name><operator>.</operator><name>clone</name></name><argument_list>(<argument><expr><call><name><name>body</name><operator>.</operator><name>nioBuffer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Envelope</name></type> <name>create</name><parameter_list>(<parameter><decl><type><name><name>Message</name><operator>.</operator><name>Type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>streamId</name></decl></parameter>, <parameter><decl><type><name>ProtocolVersion</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name><name>Header</name><operator>.</operator><name>Flag</name></name></argument>&gt;</argument_list></name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ByteBuf</name></type> <name>body</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Header</name></type> <name>header</name> <init>= <expr><operator>new</operator> <call><name>Header</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>streamId</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name><name>body</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name>Envelope</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="line">// used by V4 and earlier in Encoder.encode</comment>
    <function><type><specifier>public</specifier> <name>ByteBuf</name></type> <name>encodeHeader</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ByteBuf</name></type> <name>buf</name> <init>= <expr><call><name><name>CBUtil</name><operator>.</operator><name>allocator</name><operator>.</operator><name>buffer</name></name><argument_list>(<argument><expr><name><name>Header</name><operator>.</operator><name>LENGTH</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Message</name><operator>.</operator><name>Type</name></name></type> <name>type</name> <init>= <expr><name><name>header</name><operator>.</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><call><name><name>type</name><operator>.</operator><name>direction</name><operator>.</operator><name>addToVersion</name></name><argument_list>(<argument><expr><call><name><name>header</name><operator>.</operator><name>version</name><operator>.</operator><name>asInt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><call><name><name>Header</name><operator>.</operator><name>Flag</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><name><name>header</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Continue to support writing pre-v3 headers so that we can give proper error messages to drivers that</comment>
        <comment type="line">// connect with the v1/v2 protocol. See CASSANDRA-11464.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>header</name><operator>.</operator><name>version</name><operator>.</operator><name>isGreaterOrEqualTo</name></name><argument_list>(<argument><expr><name><name>ProtocolVersion</name><operator>.</operator><name>V3</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>writeShort</name></name><argument_list>(<argument><expr><name><name>header</name><operator>.</operator><name>streamId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><name><name>header</name><operator>.</operator><name>streamId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><name><name>type</name><operator>.</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>writeInt</name></name><argument_list>(<argument><expr><call><name><name>body</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="line">// Used by V5 and later</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>encodeHeaderInto</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <call><name><name>header</name><operator>.</operator><name>type</name><operator>.</operator><name>direction</name><operator>.</operator><name>addToVersion</name></name><argument_list>(<argument><expr><call><name><name>header</name><operator>.</operator><name>version</name><operator>.</operator><name>asInt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <call><name><name>Envelope</name><operator>.</operator><name>Header</name><operator>.</operator><name>Flag</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><name><name>header</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>header</name><operator>.</operator><name>version</name><operator>.</operator><name>isGreaterOrEqualTo</name></name><argument_list>(<argument><expr><name><name>ProtocolVersion</name><operator>.</operator><name>V3</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>putShort</name></name><argument_list>(<argument><expr><operator>(</operator><name>short</name><operator>)</operator> <name><name>header</name><operator>.</operator><name>streamId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <name><name>header</name><operator>.</operator><name>streamId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><operator>(</operator><name>byte</name><operator>)</operator> <name><name>header</name><operator>.</operator><name>type</name><operator>.</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>putInt</name></name><argument_list>(<argument><expr><call><name><name>body</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line">// Used by V5 and later</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>encodeInto</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>encodeHeaderInto</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>body</name><operator>.</operator><name>nioBuffer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Header</name>
    <block>{
        <comment type="line">// 9 bytes in protocol version 3 and later</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>LENGTH</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BODY_LENGTH_SIZE</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>ProtocolVersion</name></type> <name>version</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name>Flag</name></argument>&gt;</argument_list></name></type> <name>flags</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>streamId</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>Message</name><operator>.</operator><name>Type</name></name></type> <name>type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>long</name></type> <name>bodySizeInBytes</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Header</name><parameter_list>(<parameter><decl><type><name>ProtocolVersion</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name>Flag</name></argument>&gt;</argument_list></name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>streamId</name></decl></parameter>, <parameter><decl><type><name><name>Message</name><operator>.</operator><name>Type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>bodySizeInBytes</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>streamId</name></name> <operator>=</operator> <name>streamId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>bodySizeInBytes</name></name> <operator>=</operator> <name>bodySizeInBytes</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <enum><specifier>public</specifier> enum <name>Flag</name>
        <block>{
            <comment type="line">// The order of that enum matters!!</comment>
            <decl><name>COMPRESSED</name></decl>,
            <decl><name>TRACING</name></decl>,
            <decl><name>CUSTOM_PAYLOAD</name></decl>,
            <decl><name>WARNING</name></decl>,
            <decl><name>USE_BETA</name></decl>;

            <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Flag</name><index>[]</index></name></type> <name>ALL_VALUES</name> <init>= <expr><call><name>values</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name>Flag</name></argument>&gt;</argument_list></name></type> <name>deserialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name>Flag</name></argument>&gt;</argument_list></name></type> <name>set</name> <init>= <expr><call><name><name>EnumSet</name><operator>.</operator><name>noneOf</name></name><argument_list>(<argument><expr><name><name>Flag</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>ALL_VALUES</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>set</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>ALL_VALUES</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <return>return <expr><name>set</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>serialize</name><parameter_list>(<parameter><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name>Flag</name></argument>&gt;</argument_list></name></type> <name>flags</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>Flag</name></type> <name>flag</name> <range>: <expr><name>flags</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>i</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name><name>flag</name><operator>.</operator><name>ordinal</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <return>return <expr><name>i</name></expr>;</return>
            </block_content>}</block></function>
        }</block></enum>
    }</block></class>

    <function><type><specifier>public</specifier> <name>Envelope</name></type> <name>with</name><parameter_list>(<parameter><decl><type><name>ByteBuf</name></type> <name>newBody</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>Envelope</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>newBody</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Decoder</name> <super_list><extends>extends <super><name>ByteToMessageDecoder</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MAX_TOTAL_LENGTH</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getNativeTransportMaxFrameSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>discardingTooLongMessage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>tooLongTotalLength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>bytesToDiscard</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>tooLongStreamId</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Used by protocol V5 and later to extract a CQL message header from the buffer containing
         * it, without modifying the position of the underlying buffer. This essentially mirrors the
         * pre-V5 code in {@link Decoder#decode(ByteBuf)}, with three differences:
         * &lt;ul&gt;
         *  &lt;li&gt;The input is a ByteBuffer rather than a ByteBuf&lt;/li&gt;
         *  &lt;li&gt;This cannot return null, as V5 always deals with entire CQL messages. Coalescing of bytes
         *  off the wire happens at the layer below, in {@link org.apache.cassandra.net.FrameDecoder}&lt;/li&gt;
         *  &lt;li&gt;This method never throws {@link ProtocolException}. Instead, a subclass of
         *  {@link HeaderExtractionResult} is returned which may provide either a {@link Header} or a
         *  {@link ProtocolException},depending on the result of its {@link HeaderExtractionResult#isSuccess()}
         *  method.&lt;/li&gt;
         *&lt;/ul&gt;
         *
         * @param buffer ByteBuffer containing the message envelope
         * @return The result of attempting to extract a header from the input buffer.
         */</comment>
        <function><type><name>HeaderExtractionResult</name></type> <name>extractHeader</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>Preconditions</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><call><name><name>buffer</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name><name>Header</name><operator>.</operator><name>LENGTH</name></name></expr></argument>,
                                        <argument><expr><literal type="string">"Undersized buffer supplied. Expected %s, actual %s"</literal></expr></argument>,
                                        <argument><expr><name><name>Header</name><operator>.</operator><name>LENGTH</name></name></expr></argument>,
                                        <argument><expr><call><name><name>buffer</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>firstByte</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>idx</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>versionNum</name> <init>= <expr><name>firstByte</name> <operator>&amp;</operator> <name>PROTOCOL_VERSION_MASK</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>idx</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>streamId</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getShort</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>opcode</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>idx</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>bodyLength</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getInt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// if a negative length is read, return error but report length as 0 so we don't attempt to skip</comment>
            <if_stmt><if>if <condition>(<expr><name>bodyLength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>new</operator> <call><name><name>HeaderExtractionResult</name><operator>.</operator><name>Error</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>ProtocolException</name><argument_list>(<argument><expr><literal type="string">"Invalid value for envelope header body length field: "</literal> <operator>+</operator> <name>bodyLength</name></expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><name>streamId</name></expr></argument>, <argument><expr><name>bodyLength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name><name>Message</name><operator>.</operator><name>Direction</name></name></type> <name>direction</name> <init>= <expr><call><name><name>Message</name><operator>.</operator><name>Direction</name><operator>.</operator><name>extractFromVersion</name></name><argument_list>(<argument><expr><name>firstByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Message</name><operator>.</operator><name>Type</name></name></type> <name>type</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ProtocolVersion</name></type> <name>version</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name><name>Header</name><operator>.</operator><name>Flag</name></name></argument>&gt;</argument_list></name></type> <name>decodedFlags</name></decl>;</decl_stmt>
            <try>try
            <block>{<block_content>
                <comment type="line">// This throws a protocol exception if the version number is unsupported,</comment>
                <comment type="line">// the opcode is unknown or invalid flags are set for the version</comment>
                <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name><name>ProtocolVersion</name><operator>.</operator><name>decode</name></name><argument_list>(<argument><expr><name>versionNum</name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getNativeTransportAllowOlderProtocols</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>decodedFlags</name> <operator>=</operator> <call><name>decodeFlags</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name><name>Message</name><operator>.</operator><name>Type</name><operator>.</operator><name>fromOpcode</name></name><argument_list>(<argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><operator>new</operator> <call><name><name>HeaderExtractionResult</name><operator>.</operator><name>Success</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Header</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>decodedFlags</name></expr></argument>, <argument><expr><name>streamId</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>bodyLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>ProtocolException</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <comment type="line">// Including the streamId and bodyLength is a best effort to allow the caller</comment>
                <comment type="line">// to send a meaningful response to the client and continue processing the</comment>
                <comment type="line">// rest of the frame. It's possible that these are bogus and may have contributed</comment>
                <comment type="line">// to the ProtocolException. If so, the upstream CQLMessageHandler should run into</comment>
                <comment type="line">// further errors and once it breaches its threshold for consecutive errors, it will</comment>
                <comment type="line">// cause the channel to be closed.</comment>
                <return>return <expr><operator>new</operator> <call><name><name>HeaderExtractionResult</name><operator>.</operator><name>Error</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>streamId</name></expr></argument>, <argument><expr><name>bodyLength</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></catch></try>
        </block_content>}</block></function>

        <class><specifier>public</specifier> <specifier>static</specifier> <specifier>abstract</specifier> class <name>HeaderExtractionResult</name>
        <block>{
            <enum>enum <name>Outcome</name> <block>{ <decl><name>SUCCESS</name></decl>, <decl><name>ERROR</name></decl> }</block></enum><empty_stmt>;</empty_stmt>

            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Outcome</name></type> <name>outcome</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>streamId</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>bodyLength</name></decl>;</decl_stmt>
            <constructor><specifier>private</specifier> <name>HeaderExtractionResult</name><parameter_list>(<parameter><decl><type><name>Outcome</name></type> <name>outcome</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>streamId</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>bodyLength</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>outcome</name></name> <operator>=</operator> <name>outcome</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>streamId</name></name> <operator>=</operator> <name>streamId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>bodyLength</name></name> <operator>=</operator> <name>bodyLength</name></expr>;</expr_stmt>
            </block_content>}</block></constructor>

            <function><type><name>boolean</name></type> <name>isSuccess</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <return>return <expr><name>outcome</name> <operator>==</operator> <name><name>Outcome</name><operator>.</operator><name>SUCCESS</name></name></expr>;</return>
            </block_content>}</block></function>

            <function><type><name>int</name></type> <name>streamId</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <return>return <expr><name>streamId</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><name>long</name></type> <name>bodyLength</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <return>return <expr><name>bodyLength</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><name>Header</name></type> <name>header</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Unable to provide header from extraction result : %s"</literal></expr></argument>, <argument><expr><name>outcome</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></function><empty_stmt>;</empty_stmt>

            <function><type><name>ProtocolException</name></type> <name>error</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Unable to provide error from extraction result : %s"</literal></expr></argument>, <argument><expr><name>outcome</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></function>

            <class><specifier>private</specifier> <specifier>static</specifier> class <name>Success</name> <super_list><extends>extends <super><name>HeaderExtractionResult</name></super></extends></super_list>
            <block>{
                <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Header</name></type> <name>header</name></decl>;</decl_stmt>
                <constructor><name>Success</name><parameter_list>(<parameter><decl><type><name>Header</name></type> <name>header</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name><name>Outcome</name><operator>.</operator><name>SUCCESS</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>streamId</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>bodySizeInBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>header</name></name> <operator>=</operator> <name>header</name></expr>;</expr_stmt>
                </block_content>}</block></constructor>

                <function><annotation>@<name>Override</name></annotation>
                <type><name>Header</name></type> <name>header</name><parameter_list>()</parameter_list>
                <block>{<block_content>
                    <return>return <expr><name>header</name></expr>;</return>
                </block_content>}</block></function>
            }</block></class>

            <class><specifier>private</specifier> <specifier>static</specifier> class <name>Error</name> <super_list><extends>extends <super><name>HeaderExtractionResult</name></super></extends></super_list>
            <block>{
                <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ProtocolException</name></type> <name>error</name></decl>;</decl_stmt>
                <constructor><specifier>private</specifier> <name>Error</name><parameter_list>(<parameter><decl><type><name>ProtocolException</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>streamId</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>bodyLength</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name><name>Outcome</name><operator>.</operator><name>ERROR</name></name></expr></argument>, <argument><expr><name>streamId</name></expr></argument>, <argument><expr><name>bodyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>error</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
                </block_content>}</block></constructor>

                <function><annotation>@<name>Override</name></annotation>
                <type><name>ProtocolException</name></type> <name>error</name><parameter_list>()</parameter_list>
                <block>{<block_content>
                    <return>return <expr><name>error</name></expr>;</return>
                </block_content>}</block></function>
            }</block></class>
        }</block></class>

        <function><annotation>@<name>VisibleForTesting</name></annotation>
        <type><name>Envelope</name></type> <name>decode</name><parameter_list>(<parameter><decl><type><name>ByteBuf</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>discardingTooLongMessage</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>bytesToDiscard</name> <operator>=</operator> <call><name>discard</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bytesToDiscard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// If we have discarded everything, throw the exception</comment>
                <if_stmt><if>if <condition>(<expr><name>bytesToDiscard</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>readableBytes</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>readableBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>readerIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Check the first byte for the protocol version before we wait for a complete header.  Protocol versions</comment>
            <comment type="line">// 1 and 2 use a shorter header, so we may never have a complete header's worth of bytes.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>firstByte</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getByte</name></name><argument_list>(<argument><expr><name>idx</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Message</name><operator>.</operator><name>Direction</name></name></type> <name>direction</name> <init>= <expr><call><name><name>Message</name><operator>.</operator><name>Direction</name><operator>.</operator><name>extractFromVersion</name></name><argument_list>(<argument><expr><name>firstByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>versionNum</name> <init>= <expr><name>firstByte</name> <operator>&amp;</operator> <name>PROTOCOL_VERSION_MASK</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ProtocolVersion</name></type> <name>version</name> <init>= <expr><call><name><name>ProtocolVersion</name><operator>.</operator><name>decode</name></name><argument_list>(<argument><expr><name>versionNum</name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getNativeTransportAllowOlderProtocols</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Wait until we have the complete header</comment>
            <if_stmt><if>if <condition>(<expr><name>readableBytes</name> <operator>&lt;</operator> <name><name>Header</name><operator>.</operator><name>LENGTH</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getByte</name></name><argument_list>(<argument><expr><name>idx</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name><name>Header</name><operator>.</operator><name>Flag</name></name></argument>&gt;</argument_list></name></type> <name>decodedFlags</name> <init>= <expr><call><name>decodeFlags</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>streamId</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getShort</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

            <comment type="line">// This throws a protocol exceptions if the opcode is unknown</comment>
            <decl_stmt><decl><type><name><name>Message</name><operator>.</operator><name>Type</name></name></type> <name>type</name></decl>;</decl_stmt>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name><name>Message</name><operator>.</operator><name>Type</name><operator>.</operator><name>fromOpcode</name></name><argument_list>(<argument><expr><call><name><name>buffer</name><operator>.</operator><name>getByte</name></name><argument_list>(<argument><expr><name>idx</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>ProtocolException</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><call><name><name>ErrorMessage</name><operator>.</operator><name>wrap</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>streamId</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>

            <decl_stmt><decl><type><name>long</name></type> <name>bodyLength</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getUnsignedInt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name><name>Header</name><operator>.</operator><name>BODY_LENGTH_SIZE</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>long</name></type> <name>totalLength</name> <init>= <expr><name>bodyLength</name> <operator>+</operator> <name><name>Header</name><operator>.</operator><name>LENGTH</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>totalLength</name> <operator>&gt;</operator> <name>MAX_TOTAL_LENGTH</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Enter the discard mode and discard everything received so far.</comment>
                <expr_stmt><expr><name>discardingTooLongMessage</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>tooLongStreamId</name> <operator>=</operator> <name>streamId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tooLongTotalLength</name> <operator>=</operator> <name>totalLength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bytesToDiscard</name> <operator>=</operator> <call><name>discard</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>totalLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>bytesToDiscard</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>totalLength</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>ClientMessageSizeMetrics</name><operator>.</operator><name>bytesReceived</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>totalLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientMessageSizeMetrics</name><operator>.</operator><name>bytesReceivedPerRequest</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><name>totalLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// extract body</comment>
            <decl_stmt><decl><type><name>ByteBuf</name></type> <name>body</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>bodyLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>body</name><operator>.</operator><name>retain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>bodyLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>readerIndex</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><operator>new</operator> <call><name>Envelope</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Header</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>decodedFlags</name></expr></argument>, <argument><expr><name>streamId</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>bodyLength</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name><name>Header</name><operator>.</operator><name>Flag</name></name></argument>&gt;</argument_list></name></type> <name>decodeFlags</name><parameter_list>(<parameter><decl><type><name>ProtocolVersion</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>EnumSet</name><argument_list type="generic">&lt;<argument><name><name>Header</name><operator>.</operator><name>Flag</name></name></argument>&gt;</argument_list></name></type> <name>decodedFlags</name> <init>= <expr><call><name><name>Header</name><operator>.</operator><name>Flag</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>version</name><operator>.</operator><name>isBeta</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>decodedFlags</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Header</name><operator>.</operator><name>Flag</name><operator>.</operator><name>USE_BETA</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>ProtocolException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Beta version of the protocol used (%s), but USE_BETA flag is unset"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
            <return>return <expr><name>decodedFlags</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>void</name></type> <name>decode</name><parameter_list>(<parameter><decl><type><name>ChannelHandlerContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>ByteBuf</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>results</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Envelope</name></type> <name>envelope</name> <init>= <expr><call><name>decode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>envelope</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>envelope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>fail</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <comment type="line">// Reset to the initial state and throw the exception</comment>
            <decl_stmt><decl><type><name>long</name></type> <name>tooLongTotalLength</name> <init>= <expr><name><name>this</name><operator>.</operator><name>tooLongTotalLength</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tooLongTotalLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>discardingTooLongMessage</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>msg</name> <init>= <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Request is too big: length %d exceeds maximum allowed length %d."</literal></expr></argument>, <argument><expr><name>tooLongTotalLength</name></expr></argument>, <argument><expr><name>MAX_TOTAL_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <throw>throw <expr><call><name><name>ErrorMessage</name><operator>.</operator><name>wrap</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>InvalidRequestException</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tooLongStreamId</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></function>
    }</block></class>

    <comment type="line">// How much remains to be discarded</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>long</name></type> <name>discard</name><parameter_list>(<parameter><decl><type><name>ByteBuf</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>remainingToDiscard</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>availableToDiscard</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>remainingToDiscard</name></expr></argument>, <argument><expr><call><name><name>buffer</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>skipBytes</name></name><argument_list>(<argument><expr><name>availableToDiscard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>remainingToDiscard</name> <operator>-</operator> <name>availableToDiscard</name></expr>;</return>
    </block_content>}</block></function>

    <class><annotation>@<name><name>ChannelHandler</name><operator>.</operator><name>Sharable</name></name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> class <name>Encoder</name> <super_list><extends>extends <super><name><name>MessageToMessageEncoder</name><argument_list type="generic">&lt;<argument><name>Envelope</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Encoder</name></type> <name>instance</name> <init>= <expr><operator>new</operator> <call><name><name>Envelope</name><operator>.</operator><name>Encoder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <constructor><specifier>private</specifier> <name>Encoder</name><parameter_list>()</parameter_list><block>{<block_content/>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>encode</name><parameter_list>(<parameter><decl><type><name>ChannelHandlerContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>Envelope</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>results</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ByteBuf</name></type> <name>serializedHeader</name> <init>= <expr><call><name><name>source</name><operator>.</operator><name>encodeHeader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>messageSize</name> <init>= <expr><call><name><name>serializedHeader</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>source</name><operator>.</operator><name>body</name><operator>.</operator><name>readableBytes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ClientMessageSizeMetrics</name><operator>.</operator><name>bytesSent</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>messageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientMessageSizeMetrics</name><operator>.</operator><name>bytesSentPerResponse</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><name>messageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>serializedHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>source</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <class><annotation>@<name><name>ChannelHandler</name><operator>.</operator><name>Sharable</name></name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> class <name>Decompressor</name> <super_list><extends>extends <super><name><name>MessageToMessageDecoder</name><argument_list type="generic">&lt;<argument><name>Envelope</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <name>Decompressor</name></type> <name>instance</name> <init>= <expr><operator>new</operator> <call><name><name>Envelope</name><operator>.</operator><name>Decompressor</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <constructor><specifier>private</specifier> <name>Decompressor</name><parameter_list>()</parameter_list><block>{<block_content/>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>decode</name><parameter_list>(<parameter><decl><type><name>ChannelHandlerContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>Envelope</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>results</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Connection</name></type> <name>connection</name> <init>= <expr><call><name><name>ctx</name><operator>.</operator><name>channel</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><name><name>Connection</name><operator>.</operator><name>attributeKey</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>source</name><operator>.</operator><name>header</name><operator>.</operator><name>flags</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Header</name><operator>.</operator><name>Flag</name><operator>.</operator><name>COMPRESSED</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>connection</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>Compressor</name></name></type> <name>compressor</name> <init>= <expr><call><name><name>connection</name><operator>.</operator><name>getCompressor</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>compressor</name><operator>.</operator><name>decompress</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <class><annotation>@<name><name>ChannelHandler</name><operator>.</operator><name>Sharable</name></name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> class <name>Compressor</name> <super_list><extends>extends <super><name><name>MessageToMessageEncoder</name><argument_list type="generic">&lt;<argument><name>Envelope</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <name>Compressor</name></type> <name>instance</name> <init>= <expr><operator>new</operator> <call><name>Compressor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <constructor><specifier>private</specifier> <name>Compressor</name><parameter_list>()</parameter_list><block>{<block_content/>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>encode</name><parameter_list>(<parameter><decl><type><name>ChannelHandlerContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>Envelope</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>results</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Connection</name></type> <name>connection</name> <init>= <expr><call><name><name>ctx</name><operator>.</operator><name>channel</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><name><name>Connection</name><operator>.</operator><name>attributeKey</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Never compress STARTUP messages</comment>
            <if_stmt><if>if <condition>(<expr><name><name>source</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>Message</name><operator>.</operator><name>Type</name><operator>.</operator><name>STARTUP</name></name> <operator>||</operator> <name>connection</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>Compressor</name></name></type> <name>compressor</name> <init>= <expr><call><name><name>connection</name><operator>.</operator><name>getCompressor</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>source</name><operator>.</operator><name>header</name><operator>.</operator><name>flags</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>Header</name><operator>.</operator><name>Flag</name><operator>.</operator><name>COMPRESSED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>compressor</name><operator>.</operator><name>compress</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>
}</block></class>
</unit>
