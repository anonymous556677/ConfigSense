<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/cql3/statements/schema/CreateTableStatement.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>schema</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>ImmutableSet</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang3</name><operator>.</operator><name>StringUtils</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>audit</name><operator>.</operator><name>AuditLogContext</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>audit</name><operator>.</operator><name>AuditLogEntryType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>auth</name><operator>.</operator><name>DataResource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>auth</name><operator>.</operator><name>IResource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>auth</name><operator>.</operator><name>Permission</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>AlreadyExistsException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>Keyspaces</name><operator>.</operator><name>KeyspacesDiff</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>ClientState</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>reads</name><operator>.</operator><name>repair</name><operator>.</operator><name>ReadRepairStrategy</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>Event</name><operator>.</operator><name>SchemaChange</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>Event</name><operator>.</operator><name>SchemaChange</name><operator>.</operator><name>Change</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>Event</name><operator>.</operator><name>SchemaChange</name><operator>.</operator><name>Target</name></name>;</import>

<import>import static <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Comparator</name><operator>.</operator><name>comparing</name></name>;</import>

<import>import static <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name><operator>.</operator><name>concat</name></name>;</import>

<class><specifier>public</specifier> <specifier>final</specifier> class <name>CreateTableStatement</name> <super_list><extends>extends <super><name>AlterSchemaStatement</name></super></extends></super_list>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>CreateTableStatement</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name><name>CQL3Type</name><operator>.</operator><name>Raw</name></name></argument>&gt;</argument_list></name></type> <name>rawColumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>staticColumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>partitionKeyColumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>clusteringColumns</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>LinkedHashMap</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>clusteringOrder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>TableAttributes</name></type> <name>attrs</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>ifNotExists</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>useCompactStorage</name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>CreateTableStatement</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>,
                                <parameter><decl><type><name>String</name></type> <name>tableName</name></decl></parameter>,

                                <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name><name>CQL3Type</name><operator>.</operator><name>Raw</name></name></argument>&gt;</argument_list></name></type> <name>rawColumns</name></decl></parameter>,
                                <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>staticColumns</name></decl></parameter>,
                                <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>partitionKeyColumns</name></decl></parameter>,
                                <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>clusteringColumns</name></decl></parameter>,

                                <parameter><decl><type><name><name>LinkedHashMap</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>clusteringOrder</name></decl></parameter>,
                                <parameter><decl><type><name>TableAttributes</name></type> <name>attrs</name></decl></parameter>,

                                <parameter><decl><type><name>boolean</name></type> <name>ifNotExists</name></decl></parameter>,
                                <parameter><decl><type><name>boolean</name></type> <name>useCompactStorage</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tableName</name></name> <operator>=</operator> <name>tableName</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>rawColumns</name></name> <operator>=</operator> <name>rawColumns</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>staticColumns</name></name> <operator>=</operator> <name>staticColumns</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>partitionKeyColumns</name></name> <operator>=</operator> <name>partitionKeyColumns</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>clusteringColumns</name></name> <operator>=</operator> <name>clusteringColumns</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>clusteringOrder</name></name> <operator>=</operator> <name>clusteringOrder</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>attrs</name></name> <operator>=</operator> <name>attrs</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ifNotExists</name></name> <operator>=</operator> <name>ifNotExists</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>useCompactStorage</name></name> <operator>=</operator> <name>useCompactStorage</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <name>Keyspaces</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>Keyspaces</name></type> <name>schema</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>KeyspaceMetadata</name></type> <name>keyspace</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getNullable</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>keyspace</name></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Keyspace '%s' doesn't exist"</literal></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>keyspace</name><operator>.</operator><name>hasTable</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ifNotExists</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>schema</name></expr>;</return></block_content></block></if></if_stmt>

            <throw>throw <expr><operator>new</operator> <call><name>AlreadyExistsException</name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>TableMetadata</name></type> <name>table</name> <init>= <expr><call><name>builder</name><argument_list>(<argument><expr><name><name>keyspace</name><operator>.</operator><name>types</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>table</name><operator>.</operator><name>validate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>keyspace</name><operator>.</operator><name>createReplicationStrategy</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasTransientReplicas</name><argument_list>()</argument_list></call>
            <operator>&amp;&amp;</operator> <name><name>table</name><operator>.</operator><name>params</name><operator>.</operator><name>readRepair</name></name> <operator>!=</operator> <name><name>ReadRepairStrategy</name><operator>.</operator><name>NONE</name></name></expr>)</condition>
        <block>{<block_content>
            <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"read_repair must be set to 'NONE' for transiently replicated keyspaces"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name><name>schema</name><operator>.</operator><name>withAddedOrUpdated</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>withSwapped</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>tables</name><operator>.</operator><name>with</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>SchemaChange</name></type> <name>schemaChangeEvent</name><parameter_list>(<parameter><decl><type><name>KeyspacesDiff</name></type> <name>diff</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>SchemaChange</name><argument_list>(<argument><expr><name><name>Change</name><operator>.</operator><name>CREATED</name></name></expr></argument>, <argument><expr><name><name>Target</name><operator>.</operator><name>TABLE</name></name></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>authorize</name><parameter_list>(<parameter><decl><type><name>ClientState</name></type> <name>client</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>client</name><operator>.</operator><name>ensureKeyspacePermission</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name><name>Permission</name><operator>.</operator><name>CREATE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>IResource</name></argument>&gt;</argument_list></name></type> <name>createdResources</name><parameter_list>(<parameter><decl><type><name>KeyspacesDiff</name></type> <name>diff</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><call><name><name>DataResource</name><operator>.</operator><name>table</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>AuditLogContext</name></type> <name>getAuditLogContext</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>AuditLogContext</name><argument_list>(<argument><expr><name><name>AuditLogEntryType</name><operator>.</operator><name>CREATE_TABLE</name></name></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"%s (%s, %s)"</literal></expr></argument>, <argument><expr><call><name>getClass</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSimpleName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>TableMetadata</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name><parameter_list>(<parameter><decl><type><name>Types</name></type> <name>types</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>attrs</name><operator>.</operator><name>validate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>TableParams</name></type> <name>params</name> <init>= <expr><call><name><name>attrs</name><operator>.</operator><name>asNewTableParams</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// use a TreeMap to preserve ordering across JDK versions (see CASSANDRA-9492) - important for stable unit tests</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>CQL3Type</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr><operator>new</operator> <call><name><name>TreeMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name>comparing</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>o</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name><name>o</name><operator>.</operator><name>bytes</name></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>rawColumns</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>column</name></decl></parameter>, <parameter><decl><name>type</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>columns</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>prepare</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// check for nested non-frozen UDTs or collections in a non-frozen UDT</comment>
        <expr_stmt><expr><call><name><name>columns</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>column</name></decl></parameter>, <parameter><decl><name>type</name></decl></parameter>)</parameter_list> -&gt;
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isUDT</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMultiCell</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>UserType</name><operator>)</operator> <call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>fieldTypes</name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>field</name></decl></parameter></parameter_list> -&gt;
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>field</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Non-frozen UDTs with nested non-frozen collections are not supported"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
                </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Deal with PRIMARY KEY columns
         */</comment>

        <decl_stmt><decl><type><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>primaryKeyColumns</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>concat</name><argument_list>(<argument><expr><name>partitionKeyColumns</name></expr></argument>, <argument><expr><name>clusteringColumns</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>column</name></decl></parameter></parameter_list> -&gt;
        <block>{<block_content>
            <decl_stmt><decl><type><name>CQL3Type</name></type> <name>type</name> <init>= <expr><call><name><name>columns</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Unknown column '%s' referenced in PRIMARY KEY for table '%s'"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>primaryKeyColumns</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Duplicate column '%s' in PRIMARY KEY clause for table '%s'"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMultiCell</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isCollection</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Invalid non-frozen collection type %s for PRIMARY KEY column '%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Invalid non-frozen user-defined type %s for PRIMARY KEY column '%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isCounter</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"counter type is not supported for PRIMARY KEY column '%s'"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>referencesDuration</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"duration type is not supported for PRIMARY KEY column '%s'"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>staticColumns</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Static column '%s' cannot be part of the PRIMARY KEY"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>partitionKeyTypes</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>clusteringTypes</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>partitionKeyColumns</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>column</name></decl></parameter></parameter_list> -&gt;
        <block>{<block_content>
            <decl_stmt><decl><type><name>CQL3Type</name></type> <name>type</name> <init>= <expr><call><name><name>columns</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>partitionKeyTypes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>clusteringColumns</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>column</name></decl></parameter></parameter_list> -&gt;
        <block>{<block_content>
            <decl_stmt><decl><type><name>CQL3Type</name></type> <name>type</name> <init>= <expr><call><name><name>columns</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>reverse</name> <init>= <expr><operator>!</operator><call><name><name>clusteringOrder</name><operator>.</operator><name>getOrDefault</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>clusteringTypes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>reverse</name></expr> ?</condition><then> <expr><call><name><name>ReversedType</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>clusteringOrder</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>clusteringColumns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Only clustering columns can be defined in CLUSTERING ORDER directive"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ColumnIdentifier</name></type> <name>id</name> <range>: <expr><call><name><name>clusteringOrder</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnIdentifier</name></type> <name>c</name> <init>= <expr><call><name><name>clusteringColumns</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>id</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>clusteringOrder</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"The order of columns in the CLUSTERING ORDER directive must match that of the clustering columns (%s must appear before %s)"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Missing CLUSTERING ORDER for column %s"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// For COMPACT STORAGE, we reject any "feature" that we wouldn't be able to translate back to thrift.</comment>
        <if_stmt><if>if <condition>(<expr><name>useCompactStorage</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>validateCompactTable</name><argument_list>(<argument><expr><name>clusteringTypes</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Static columns only make sense if we have at least one clustering column. Otherwise everything is static anyway</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>clusteringColumns</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>staticColumns</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Static columns are only useful (and thus allowed) if the table has at least one clustering column"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Counter table validation
         */</comment>

        <decl_stmt><decl><type><name>boolean</name></type> <name>hasCounters</name> <init>= <expr><call><name><name>rawColumns</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call><operator>.</operator><call><name>anyMatch</name><argument_list>(<argument><expr><name><name>CQL3Type</name><operator>.</operator><name>Raw</name></name><operator>::</operator><name>isCounter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>hasCounters</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// We've handled anything that is not a PRIMARY KEY so columns only contains NON-PK columns. So</comment>
            <comment type="line">// if it's a counter table, make sure we don't have non-counter types</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>columns</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call><operator>.</operator><call><name>anyMatch</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>t</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>t</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isCounter</name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Cannot mix counter and non counter columns in the same table"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>defaultTimeToLive</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Cannot set %s on a table with counters"</literal></expr></argument>, <argument><expr><name><name>TableParams</name><operator>.</operator><name>Option</name><operator>.</operator><name>DEFAULT_TIME_TO_LIVE</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Create the builder
         */</comment>

        <decl_stmt><decl><type><name><name>TableMetadata</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name> <init>= <expr><call><name><name>TableMetadata</name><operator>.</operator><name>builder</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>attrs</name><operator>.</operator><name>hasProperty</name></name><argument_list>(<argument><expr><name><name>TableAttributes</name><operator>.</operator><name>ID</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>id</name></name><argument_list>(<argument><expr><call><name><name>attrs</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>isCounter</name></name><argument_list>(<argument><expr><name>hasCounters</name></expr></argument>)</argument_list></call>
               <operator>.</operator><call><name>params</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>partitionKeyColumns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addPartitionKeyColumn</name></name><argument_list>(<argument><expr><call><name><name>partitionKeyColumns</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>partitionKeyTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>clusteringColumns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addClusteringColumn</name></name><argument_list>(<argument><expr><call><name><name>clusteringColumns</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>clusteringTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <if_stmt><if>if <condition>(<expr><name>useCompactStorage</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fixupCompactTable</name><argument_list>(<argument><expr><name>clusteringTypes</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>, <argument><expr><name>hasCounters</name></expr></argument>, <argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>columns</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>column</name></decl></parameter>, <parameter><decl><name>type</name></decl></parameter>)</parameter_list> -&gt; <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>staticColumns</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addStaticColumn</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addRegularColumn</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>builder</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>validateCompactTable</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>clusteringTypes</name></decl></parameter>,
                                      <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>CQL3Type</name></argument>&gt;</argument_list></name></type> <name>columns</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>isDense</name> <init>= <expr><operator>!</operator><call><name><name>clusteringTypes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>columns</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call><operator>.</operator><call><name>anyMatch</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>c</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>c</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMultiCell</name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Non-frozen collections and UDTs are not supported with COMPACT STORAGE"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>staticColumns</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Static columns are not supported in COMPACT STORAGE tables"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>clusteringTypes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// It's a thrift "static CF" so there should be some columns definition</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>columns</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"No definition found that is not part of the PRIMARY KEY"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isDense</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// We can have no columns (only the PK), but we can't have more than one.</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>columns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)"</literal></expr></argument>, <argument><expr><call><name><name>StringUtils</name><operator>.</operator><name>join</name></name><argument_list>(<argument><expr><call><name><name>columns</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// we are in the "static" case, so we need at least one column defined. For non-compact however, having</comment>
            <comment type="line">// just the PK is fine.</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>columns</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>fixupCompactTable</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>clusteringTypes</name></decl></parameter>,
                                   <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>CQL3Type</name></argument>&gt;</argument_list></name></type> <name>columns</name></decl></parameter>,
                                   <parameter><decl><type><name>boolean</name></type> <name>hasCounters</name></decl></parameter>,
                                   <parameter><decl><type><name><name>TableMetadata</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>TableMetadata</name><operator>.</operator><name>Flag</name></name></argument>&gt;</argument_list></name></type> <name>flags</name> <init>= <expr><call><name><name>EnumSet</name><operator>.</operator><name>noneOf</name></name><argument_list>(<argument><expr><name><name>TableMetadata</name><operator>.</operator><name>Flag</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>isDense</name> <init>= <expr><operator>!</operator><call><name><name>clusteringTypes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>isCompound</name> <init>= <expr><call><name><name>clusteringTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>isDense</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>flags</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>TableMetadata</name><operator>.</operator><name>Flag</name><operator>.</operator><name>DENSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>isCompound</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>flags</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>TableMetadata</name><operator>.</operator><name>Flag</name><operator>.</operator><name>COMPOUND</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>hasCounters</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>flags</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>TableMetadata</name><operator>.</operator><name>Flag</name><operator>.</operator><name>COUNTER</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>isStaticCompact</name> <init>= <expr><operator>!</operator><name>isDense</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCompound</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>flags</name></name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>columns</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>name</name></decl></parameter>, <parameter><decl><name>type</name></decl></parameter>)</parameter_list> -&gt; <block>{<block_content>
            <comment type="line">// Note that for "static" no-clustering compact storage we use static for the defined columns</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>staticColumns</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>isStaticCompact</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addStaticColumn</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addRegularColumn</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>DefaultNames</name></type> <name>names</name> <init>= <expr><operator>new</operator> <call><name>DefaultNames</name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>columnNames</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Compact tables always have a clustering and a single regular value.</comment>
        <if_stmt><if>if <condition>(<expr><name>isStaticCompact</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addClusteringColumn</name></name><argument_list>(<argument><expr><call><name><name>names</name><operator>.</operator><name>defaultClusteringName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>UTF8Type</name><operator>.</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addRegularColumn</name></name><argument_list>(<argument><expr><call><name><name>names</name><operator>.</operator><name>defaultCompactValueName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>hasCounters</name></expr> ?</condition><then> <expr><name><name>CounterColumnType</name><operator>.</operator><name>instance</name></name></expr> </then><else>: <expr><name><name>BytesType</name><operator>.</operator><name>instance</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name><name>builder</name><operator>.</operator><name>hasRegularColumns</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Even for dense, we might not have our regular column if it wasn't part of the declaration. If</comment>
            <comment type="line">// that's the case, add it but with a specific EmptyType so we can recognize that case later</comment>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addRegularColumn</name></name><argument_list>(<argument><expr><call><name><name>names</name><operator>.</operator><name>defaultCompactValueName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>EmptyType</name><operator>.</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>clientWarnings</name><parameter_list>(<parameter><decl><type><name>KeyspacesDiff</name></type> <name>diff</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tableCount</name> <init>= <expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getNumberOfTables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>tableCount</name> <operator>&gt;</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>tableCountWarnThreshold</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>msg</name> <init>= <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Cluster already contains %d tables in %d keyspaces. Having a large number of tables will significantly slow down schema dependent cluster operations."</literal></expr></argument>,
                                       <argument><expr><name>tableCount</name></expr></argument>,
                                       <argument><expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getKeyspaces</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>of</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>DefaultNames</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>DEFAULT_CLUSTERING_NAME</name> <init>= <expr><literal type="string">"column"</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>DEFAULT_COMPACT_VALUE_NAME</name> <init>= <expr><literal type="string">"value"</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>usedNames</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>clusteringIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>compactIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>DefaultNames</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>usedNames</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>usedNames</name></name> <operator>=</operator> <name>usedNames</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>defaultClusteringName</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>candidate</name> <init>= <expr><name>DEFAULT_CLUSTERING_NAME</name> <operator>+</operator> <name>clusteringIndex</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>++</operator><name>clusteringIndex</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>usedNames</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>candidate</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>defaultCompactValueName</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>candidate</name> <init>= <expr><ternary><condition><expr><name>compactIndex</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>DEFAULT_COMPACT_VALUE_NAME</name></expr> </then><else>: <expr><name>DEFAULT_COMPACT_VALUE_NAME</name> <operator>+</operator> <name>compactIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>++</operator><name>compactIndex</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>usedNames</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>candidate</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>TableMetadata</name><operator>.</operator><name>Builder</name></name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>cql</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>keyspace</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>CQLFragmentParser</name><operator>.</operator><name>parseAny</name></name><argument_list>(<argument><expr><name>CqlParser</name><operator>::</operator><name>createTableStatement</name></expr></argument>, <argument><expr><name>cql</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE"</literal></expr></argument>)</argument_list></call>
                                <operator>.</operator><call><name>keyspace</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>
                                <operator>.</operator><call><name>prepare</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call> <comment type="line">// works around a messy ClientState/QueryProcessor class init deadlock</comment>
                                <operator>.</operator><call><name>builder</name><argument_list>(<argument><expr><call><name><name>Types</name><operator>.</operator><name>none</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>public</specifier> <specifier>final</specifier> <specifier>static</specifier> class <name>Raw</name> <super_list><extends>extends <super><name><name>CQLStatement</name><operator>.</operator><name>Raw</name></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>QualifiedName</name></type> <name>name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>ifNotExists</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>useCompactStorage</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name><name>CQL3Type</name><operator>.</operator><name>Raw</name></name></argument>&gt;</argument_list></name></type> <name>rawColumns</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>staticColumns</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>clusteringColumns</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>partitionKeyColumns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>LinkedHashMap</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>clusteringOrder</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>TableAttributes</name></type> <name>attrs</name> <init>= <expr><operator>new</operator> <call><name>TableAttributes</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>Raw</name><parameter_list>(<parameter><decl><type><name>QualifiedName</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>ifNotExists</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ifNotExists</name></name> <operator>=</operator> <name>ifNotExists</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>CreateTableStatement</name></type> <name>prepare</name><parameter_list>(<parameter><decl><type><name>ClientState</name></type> <name>state</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>keyspaceName</name> <init>= <expr><ternary><condition><expr><call><name><name>name</name><operator>.</operator><name>hasKeyspace</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>name</name><operator>.</operator><name>getKeyspace</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>state</name><operator>.</operator><name>getKeyspace</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>partitionKeyColumns</name></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"No PRIMARY KEY specifed for table '%s' (exactly one required)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <return>return <expr><operator>new</operator> <call><name>CreateTableStatement</name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>,
                                            <argument><expr><call><name><name>name</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>,

                                            <argument><expr><name>rawColumns</name></expr></argument>,
                                            <argument><expr><name>staticColumns</name></expr></argument>,
                                            <argument><expr><name>partitionKeyColumns</name></expr></argument>,
                                            <argument><expr><name>clusteringColumns</name></expr></argument>,

                                            <argument><expr><name>clusteringOrder</name></expr></argument>,
                                            <argument><expr><name>attrs</name></expr></argument>,

                                            <argument><expr><name>ifNotExists</name></expr></argument>,
                                            <argument><expr><name>useCompactStorage</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>keyspace</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>name</name><operator>.</operator><name>getKeyspace</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Raw</name></type> <name>keyspace</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspace</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>name</name><operator>.</operator><name>setKeyspace</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>table</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>name</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>addColumn</name><parameter_list>(<parameter><decl><type><name>ColumnIdentifier</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name><name>CQL3Type</name><operator>.</operator><name>Raw</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isStatic</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <call><name><name>rawColumns</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Duplicate column '%s' declaration for table '%s'"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>isStatic</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>staticColumns</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactStorage</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>useCompactStorage</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setPartitionKeyColumn</name><parameter_list>(<parameter><decl><type><name>ColumnIdentifier</name></type> <name>column</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>setPartitionKeyColumns</name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singletonList</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setPartitionKeyColumns</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>columns</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>partitionKeyColumns</name></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Multiple PRIMARY KEY specified for table '%s' (exactly one required)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>partitionKeyColumns</name> <operator>=</operator> <name>columns</name></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>markClusteringColumn</name><parameter_list>(<parameter><decl><type><name>ColumnIdentifier</name></type> <name>column</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>clusteringColumns</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>extendClusteringOrder</name><parameter_list>(<parameter><decl><type><name>ColumnIdentifier</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>ascending</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <call><name><name>clusteringOrder</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name>ascending</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>ire</name><argument_list>(<argument><expr><literal type="string">"Duplicate column '%s' in CLUSTERING ORDER BY clause for table '%s'"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></function>
    }</block></class>
}</block></class>
</unit>
