<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/h2database/h2/src/main/org/h2/mvstore/MVStore.java"><comment type="block">/*
 * Copyright 2004-2022 H2 Group. Multiple-Licensed under the MPL 2.0,
 * and the EPL 1.0 (https://h2database.com/html/license.html).
 * Initial Developer: H2 Group
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name></name>;</package>

<import>import static <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>MVMap</name><operator>.</operator><name>INITIAL_VERSION</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>Thread</name><operator>.</operator><name>UncaughtExceptionHandler</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>charset</name><operator>.</operator><name>StandardCharsets</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayDeque</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>BitSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Comparator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Deque</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Iterator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>PriorityQueue</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Queue</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ArrayBlockingQueue</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ConcurrentHashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ExecutionException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Future</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>LinkedBlockingQueue</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>PriorityBlockingQueue</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>RejectedExecutionException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ThreadPoolExecutor</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>TimeUnit</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicIntegerFieldUpdater</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicLong</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicReference</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>locks</name><operator>.</operator><name>ReentrantLock</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Predicate</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Supplier</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>compress</name><operator>.</operator><name>CompressDeflate</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>compress</name><operator>.</operator><name>CompressLZF</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>compress</name><operator>.</operator><name>Compressor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>cache</name><operator>.</operator><name>CacheLongKeyLIRS</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>type</name><operator>.</operator><name>StringDataType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>MathUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>Utils</name></name>;</import>

<comment type="block">/*

TODO:

Documentation
- rolling docs review: at "Metadata Map"
- better document that writes are in background thread
- better document how to do non-unique indexes
- document pluggable store and OffHeapStore

TransactionStore:
- ability to disable the transaction log,
    if there is only one connection

MVStore:
- better and clearer memory usage accounting rules
    (heap memory versus disk memory), so that even there is
    never an out of memory
    even for a small heap, and so that chunks
    are still relatively big on average
- make sure serialization / deserialization errors don't corrupt the file
- test and possibly improve compact operation (for large dbs)
- automated 'kill process' and 'power failure' test
- defragment (re-creating maps, specially those with small pages)
- store number of write operations per page (maybe defragment
    if much different than count)
- r-tree: nearest neighbor search
- use a small object value cache (StringCache), test on Android
    for default serialization
- MVStoreTool.dump should dump the data if possible;
    possibly using a callback for serialization
- implement a sharded map (in one store, multiple stores)
    to support concurrent updates and writes, and very large maps
- to save space when persisting very small transactions,
    use a transaction log where only the deltas are stored
- serialization for lists, sets, sets, sorted sets, maps, sorted maps
- maybe rename 'rollback' to 'revert' to distinguish from transactions
- support other compression algorithms (deflate, LZ4,...)
- remove features that are not really needed; simplify the code
    possibly using a separate layer or tools
    (retainVersion?)
- optional pluggable checksum mechanism (per page), which
    requires that everything is a page (including headers)
- rename "store" to "save", as "store" is used in "storeVersion"
- rename setStoreVersion to setDataVersion, setSchemaVersion or similar
- temporary file storage
- simple rollback method (rollback to last committed version)
- MVMap to implement SortedMap, then NavigableMap
- storage that splits database into multiple files,
    to speed up compact and allow using trim
    (by truncating / deleting empty files)
- add new feature to the file system API to avoid copying data
    (reads that returns a ByteBuffer instead of writing into one)
    for memory mapped files and off-heap storage
- support log structured merge style operations (blind writes)
    using one map per level plus bloom filter
- have a strict call order MVStore -&gt; MVMap -&gt; Page -&gt; FileStore
- autocommit commits, stores, and compacts from time to time;
    the background thread should wait at least 90% of the
    configured write delay to store changes
- compact* should also store uncommitted changes (if there are any)
- write a LSM-tree (log structured merge tree) utility on top of the MVStore
    with blind writes and/or a bloom filter that
    internally uses regular maps and merge sort
- chunk metadata: maybe split into static and variable,
    or use a small page size for metadata
- data type "string": maybe use prefix compression for keys
- test chunk id rollover
- feature to auto-compact from time to time and on close
- compact very small chunks
- Page: to save memory, combine keys &amp; values into one array
    (also children &amp; counts). Maybe remove some other
    fields (childrenCount for example)
- Support SortedMap for MVMap
- compact: copy whole pages (without having to open all maps)
- maybe change the length code to have lower gaps
- test with very low limits (such as: short chunks, small pages)
- maybe allow to read beyond the retention time:
    when compacting, move live pages in old chunks
    to a map (possibly the metadata map) -
    this requires a change in the compaction code, plus
    a map lookup when reading old data; also, this
    old data map needs to be cleaned up somehow;
    maybe using an additional timeout
*/</comment>

<comment type="block" format="javadoc">/**
 * A persistent storage for maps.
 */</comment>
<class><specifier>public</specifier> class <name>MVStore</name> <super_list><implements>implements <super><name>AutoCloseable</name></super></implements></super_list> <block>{

    <comment type="line">// The following are attribute names (keys) in store header map</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_H</name> <init>= <expr><literal type="string">"H"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_BLOCK_SIZE</name> <init>= <expr><literal type="string">"blockSize"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_FORMAT</name> <init>= <expr><literal type="string">"format"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_CREATED</name> <init>= <expr><literal type="string">"created"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_FORMAT_READ</name> <init>= <expr><literal type="string">"formatRead"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_CHUNK</name> <init>= <expr><literal type="string">"chunk"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_BLOCK</name> <init>= <expr><literal type="string">"block"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_VERSION</name> <init>= <expr><literal type="string">"version"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_CLEAN</name> <init>= <expr><literal type="string">"clean"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HDR_FLETCHER</name> <init>= <expr><literal type="string">"fletcher"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The key for the entry within "layout" map, which contains id of "meta" map.
     * Entry value (hex encoded) is usually equal to 1, unless it's a legacy
     * (upgraded) database and id 1 has been taken already by another map.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>META_ID_KEY</name> <init>= <expr><literal type="string">"meta.id"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The block size (physical sector size) of the disk. The store header is
     * written twice, one copy in each block, to ensure it survives a crash.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BLOCK_SIZE</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>FORMAT_WRITE_MIN</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>FORMAT_WRITE_MAX</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>FORMAT_READ_MIN</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>FORMAT_READ_MAX</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Store is open.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STATE_OPEN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Store is about to close now, but is still operational.
     * Outstanding store operation by background writer or other thread may be in progress.
     * New updates must not be initiated, unless they are part of a closing procedure itself.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STATE_STOPPING</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Store is closing now, and any operation on it may fail.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STATE_CLOSING</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Store is closed.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STATE_CLOSED</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>PIPE_LENGTH</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


    <comment type="block" format="javadoc">/**
     * Lock which governs access to major store operations: store(), close(), ...
     * It serves as a replacement for synchronized(this), except it allows for
     * non-blocking lock attempts.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ReentrantLock</name></type> <name>storeLock</name> <init>= <expr><operator>new</operator> <call><name>ReentrantLock</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ReentrantLock</name></type> <name>serializationLock</name> <init>= <expr><operator>new</operator> <call><name>ReentrantLock</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ReentrantLock</name></type> <name>saveChunkLock</name> <init>= <expr><operator>new</operator> <call><name>ReentrantLock</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Reference to a background thread, which is expected to be running, if any.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>AtomicReference</name><argument_list type="generic">&lt;<argument><name>BackgroundWriterThread</name></argument>&gt;</argument_list></name></type> <name>backgroundWriterThread</name> <init>= <expr><operator>new</operator> <call><name><name>AtomicReference</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Single-threaded executor for serialization of the store snapshot into ByteBuffer
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ThreadPoolExecutor</name></type> <name>serializationExecutor</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Single-threaded executor for saving ByteBuffer as a new Chunk
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ThreadPoolExecutor</name></type> <name>bufferSaveExecutor</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>reuseSpace</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>state</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>FileStore</name></type> <name>fileStore</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>fileStoreIsProvided</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>pageSplitSize</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>keysPerPage</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The page cache. The default size is 16 MB, and the average size is 2 KB.
     * It is split in 16 segments. The stack move distance is 2% of the expected
     * number of entries.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>CacheLongKeyLIRS</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>cache</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Cache for chunks "Table of Content" used to translate page's
     * sequential number within containing chunk into byte position
     * within chunk's image. Cache keyed by chunk id.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>CacheLongKeyLIRS</name><argument_list type="generic">&lt;<argument><name><name>long</name><index>[]</index></name></argument>&gt;</argument_list></name></type> <name>chunksToC</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The newest chunk. If nothing was stored yet, this field is not set.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>Chunk</name></type> <name>lastChunk</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The map of chunks.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>chunks</name> <init>= <expr><operator>new</operator> <call><name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Queue</name><argument_list type="generic">&lt;<argument><name>RemovedPageInfo</name></argument>&gt;</argument_list></name></type> <name>removedPages</name> <init>= <expr><operator>new</operator> <call><name><name>PriorityBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Deque</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>deadChunks</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayDeque</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>updateCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>updateAttemptCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The layout map. Contains chunks metadata and root locations for all maps.
     * This is relatively fast changing part of metadata
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>layout</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The metadata map. Holds name -&gt; id and id -&gt; name and id -&gt; metadata
     * mapping for all maps. This is relatively slow changing part of metadata
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>meta</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>maps</name> <init>= <expr><operator>new</operator> <call><name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>storeHeader</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Queue</name><argument_list type="generic">&lt;<argument><name>WriteBuffer</name></argument>&gt;</argument_list></name></type> <name>writeBufferPool</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>PIPE_LENGTH</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>lastMapId</name> <init>= <expr><operator>new</operator> <call><name>AtomicInteger</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>lastChunkId</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>versionsToKeep</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The compression level for new pages (0 for disabled, 1 for fast, 2 for
     * high). Even if disabled, the store may contain (old) compressed pages.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>compressionLevel</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>Compressor</name></type> <name>compressorFast</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>Compressor</name></type> <name>compressorHigh</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>recoveryMode</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>UncaughtExceptionHandler</name></type> <name>backgroundExceptionHandler</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>long</name></type> <name>currentVersion</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Oldest store version in use. All version beyond this can be safely dropped
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>oldestVersionToKeep</name> <init>= <expr><operator>new</operator> <call><name>AtomicLong</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Ordered collection of all version usage counters for all versions starting
     * from oldestVersionToKeep and up to current.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Deque</name><argument_list type="generic">&lt;<argument><name>TxCounter</name></argument>&gt;</argument_list></name></type> <name>versions</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Counter of open transactions for the latest (current) store version
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>TxCounter</name></type> <name>currentTxCounter</name> <init>= <expr><operator>new</operator> <call><name>TxCounter</name><argument_list>(<argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The estimated memory used by unsaved pages. This number is not accurate,
     * also because it may be changed concurrently, and because temporary pages
     * are counted.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>unsavedMemory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>autoCommitMemory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>saveNeeded</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The time the store was created, in milliseconds since 1970.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>creationTime</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * How long to retain old, persisted chunks, in milliseconds. For larger or
     * equal to zero, a chunk is never directly overwritten if unused, but
     * instead, the unused field is set. If smaller zero, chunks are directly
     * overwritten if unused.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>retentionTime</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>lastCommitTime</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The version of the current store operation (if any).
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>long</name></type> <name>currentStoreVersion</name> <init>= <expr><name>INITIAL_VERSION</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>metaChanged</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The delay in milliseconds to automatically commit and write changes.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>autoCommitDelay</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>autoCompactFillRate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>autoCompactLastFileOpCount</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>MVStoreException</name></type> <name>panicException</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>lastTimeAbsolute</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>leafCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>nonLeafCount</name></decl>;</decl_stmt>


    <comment type="block" format="javadoc">/**
     * Create and open the store.
     *
     * @param config the configuration to use
     * @throws MVStoreException if the file is corrupt, or an exception
     *             occurred while opening
     * @throws IllegalArgumentException if the directory does not exist
     */</comment>
    <constructor><name>MVStore</name><parameter_list>(<parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>config</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>recoveryMode</name> <operator>=</operator> <call><name><name>config</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><literal type="string">"recoveryMode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>compressionLevel</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"compress"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><operator>(</operator><name>String</name><operator>)</operator> <call><name><name>config</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"fileName"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FileStore</name></type> <name>fileStore</name> <init>= <expr><operator>(</operator><name>FileStore</name><operator>)</operator> <call><name><name>config</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"fileStore"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fileStore</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>fileStoreIsProvided</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fileName</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>fileStore</name> <operator>=</operator> <operator>new</operator> <call><name>FileStore</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>fileName</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"fileName &amp;&amp; fileStore"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>fileStoreIsProvided</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fileStore</name></name> <operator>=</operator> <name>fileStore</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>pgSplitSize</name> <init>= <expr><literal type="number">48</literal></expr></init></decl>;</decl_stmt> <comment type="line">// for "mem:" case it is # of keys</comment>
        <decl_stmt><decl><type><name><name>CacheLongKeyLIRS</name><operator>.</operator><name>Config</name></name></type> <name>cc</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>CacheLongKeyLIRS</name><operator>.</operator><name>Config</name></name></type> <name>cc2</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>fileStore</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>mb</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"cacheSize"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>mb</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>new</operator> <call><name><name>CacheLongKeyLIRS</name><operator>.</operator><name>Config</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>maxMemory</name></name> <operator>=</operator> <name>mb</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>Object</name></type> <name>o</name> <init>= <expr><call><name><name>config</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"cacheConcurrency"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>o</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>segmentCount</name></name> <operator>=</operator> <operator>(</operator><name>Integer</name><operator>)</operator><name>o</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>cc2</name> <operator>=</operator> <operator>new</operator> <call><name><name>CacheLongKeyLIRS</name><operator>.</operator><name>Config</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cc2</name><operator>.</operator><name>maxMemory</name></name> <operator>=</operator> <literal type="number">1024L</literal> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgSplitSize</name> <operator>=</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cache</name> <operator>=</operator> <operator>new</operator> <call><name><name>CacheLongKeyLIRS</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>cache</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>chunksToC</name> <operator>=</operator> <ternary><condition><expr><name>cc2</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>new</operator> <call><name><name>CacheLongKeyLIRS</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>cc2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

        <expr_stmt><expr><name>pgSplitSize</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"pageSplitSize"</literal></expr></argument>, <argument><expr><name>pgSplitSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Make sure pages will fit into cache</comment>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>pgSplitSize</name> <operator>&gt;</operator> <call><name><name>cache</name><operator>.</operator><name>getMaxItemSize</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>pgSplitSize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name><name>cache</name><operator>.</operator><name>getMaxItemSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pageSplitSize</name> <operator>=</operator> <name>pgSplitSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>keysPerPage</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"keysPerPage"</literal></expr></argument>, <argument><expr><literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>backgroundExceptionHandler</name> <operator>=</operator>
                <operator>(</operator><name>UncaughtExceptionHandler</name><operator>)</operator><call><name><name>config</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"backgroundExceptionHandler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>layout</name> <operator>=</operator> <operator>new</operator> <call><name><name>MVMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>StringDataType</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>, <argument><expr><name><name>StringDataType</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>fileStore</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>retentionTime</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>fileStore</name><operator>.</operator><name>getDefaultRetentionTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// 19 KB memory is about 1 KB storage</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>kb</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">19</literal></expr></argument>, <argument><expr><call><name><name>Utils</name><operator>.</operator><name>scaleForAvailableMemory</name></name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>kb</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"autoCommitBufferSize"</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>autoCommitMemory</name> <operator>=</operator> <name>kb</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>autoCompactFillRate</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"autoCompactFillRate"</literal></expr></argument>, <argument><expr><literal type="number">90</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>encryptionKey</name> <init>= <expr><operator>(</operator><name><name>char</name><index>[]</index></name><operator>)</operator> <call><name><name>config</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"encryptionKey"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// there is no need to lock store here, since it is not opened (or even created) yet,</comment>
            <comment type="line">// just to make some assertions happy, when they ensure single-threaded access</comment>
            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <try>try <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fileStoreIsProvided</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>boolean</name></type> <name>readOnly</name> <init>= <expr><call><name><name>config</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><literal type="string">"readOnly"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>fileStore</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>readOnly</name></expr></argument>, <argument><expr><name>encryptionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>fileStore</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>creationTime</name> <operator>=</operator> <call><name>getTimeAbsolute</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_H</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_BLOCK_SIZE</name></expr></argument>, <argument><expr><name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_FORMAT</name></expr></argument>, <argument><expr><name>FORMAT_WRITE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_CREATED</name></expr></argument>, <argument><expr><name>creationTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>setLastChunk</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>writeStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>readStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block> <finally>finally <block>{<block_content>
                    <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></finally></try>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></catch> <finally>finally <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>encryptionKey</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>encryptionKey</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
            <expr_stmt><expr><name>lastCommitTime</name> <operator>=</operator> <call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>meta</name> <operator>=</operator> <call><name>openMetaMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>scrubLayoutMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>scrubMetaMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// setAutoCommitDelay starts the thread, but only if</comment>
            <comment type="line">// the parameter is different from the old value</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>delay</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getConfigParam</name></name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="string">"autoCommitDelay"</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>setAutoCommitDelay</name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>autoCommitMemory</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>autoCompactFillRate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>meta</name> <operator>=</operator> <call><name>openMetaMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>onVersionChange</name><argument_list>(<argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>private</specifier> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>openMetaMap</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>metaIdStr</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>META_ID_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>metaId</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>metaIdStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>metaId</name> <operator>=</operator> <call><name><name>lastMapId</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>META_ID_KEY</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>metaId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>metaId</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>parseHexInt</name></name><argument_list>(<argument><expr><name>metaIdStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><operator>new</operator> <call><name><name>MVMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>metaId</name></expr></argument>, <argument><expr><name><name>StringDataType</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>, <argument><expr><name><name>StringDataType</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>setRootPos</name></name><argument_list>(<argument><expr><call><name>getRootPos</name><argument_list>(<argument><expr><call><name><name>map</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>currentVersion</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>map</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>scrubLayoutMap</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>keysToRemove</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// split meta map off layout map</comment>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>prefix</name> <range>: <expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{ <expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name></expr>, <expr><name><name>DataUtils</name><operator>.</operator><name>META_MAP</name></name></expr> }</block></expr></range></decl></init>)</control> <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>keyIterator</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name><name>layout</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>keysToRemove</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// remove roots of non-existent maps (leftover after unfinished map removal)</comment>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>keyIterator</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_ROOT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_ROOT</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>mapIdStr</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>lastIndexOf</name></name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>meta</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_MAP</name></name> <operator>+</operator> <name>mapIdStr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>DataUtils</name><operator>.</operator><name>parseHexInt</name></name><argument_list>(<argument><expr><name>mapIdStr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>meta</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>keysToRemove</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>String</name></type> <name>key</name> <range>: <expr><name>keysToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>scrubMetaMap</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>keysToRemove</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// ensure that there is only one name mapped to each id</comment>
        <comment type="line">// this could be a leftover of an unfinished map rename</comment>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>keyIterator</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>mapName</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>mapId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseHexInt</name></name><argument_list>(<argument><expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>realMapName</name> <init>= <expr><call><name>getMapName</name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>mapName</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>realMapName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>keysToRemove</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>String</name></type> <name>key</name> <range>: <expr><name>keysToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>keyIterator</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_MAP</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_MAP</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>mapName</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getMapName</name></name><argument_list>(<argument><expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>mapIdStr</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>META_MAP</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// ensure that last map id is not smaller than max of any existing map ids</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>mapId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseHexInt</name></name><argument_list>(<argument><expr><name>mapIdStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>mapId</name> <operator>&gt;</operator> <call><name><name>lastMapId</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>lastMapId</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// each map should have a proper name</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>mapIdStr</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>mapName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>mapName</name></expr></argument>, <argument><expr><name>mapIdStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>unlockAndCheckPanicCondition</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getPanicException</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>closeImmediately</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>panic</name><parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isOpen</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>handleException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>panicException</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <throw>throw <expr><name>e</name></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>MVStoreException</name></type> <name>getPanicException</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>panicException</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Open a store in exclusive mode. For a file-based store, the parent
     * directory must already exist.
     *
     * @param fileName the file name (null for in-memory)
     * @return the store
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>MVStore</name></type> <name>open</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>config</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>config</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"fileName"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name>MVStore</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Open a map with the default settings. The map is automatically create if
     * it does not yet exist. If a map with this name is already open, this map
     * is returned.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param name the name of the map
     * @return the map
     */</comment>
    <function><type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>K</name></parameter>, <parameter><name>V</name></parameter>&gt;</parameter_list> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></type> <name>openMap</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>openMap</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>MVMap</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;&gt;</argument_list></name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Open a map with the given builder. The map is automatically create if it
     * does not yet exist. If a map with this name is already open, this map is
     * returned.
     *
     * @param &lt;M&gt; the map type
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param name the name of the map
     * @param builder the map builder
     * @return the map
     */</comment>
    <function><type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>M</name> <extends>extends <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></extends></parameter>, <parameter><name>K</name></parameter>, <parameter><name>V</name></parameter>&gt;</parameter_list> <name>M</name></type> <name>openMap</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>MVMap</name><operator>.</operator><name><name>MapBuilder</name><argument_list type="generic">&lt;<argument><name>M</name></argument>, <argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></name></type> <name>builder</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>getMapId</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
            <type><name>M</name></type> <name>map</name> <init>= <expr><operator>(</operator><name>M</name><operator>)</operator> <call><name>getMap</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>(<expr><name>map</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>openMap</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <assert>assert <expr><call><name><name>builder</name><operator>.</operator><name>getKeyType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>map</name><operator>.</operator><name>getKeyType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>getKeyType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</assert>
            <assert>assert <expr><call><name><name>builder</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal>
                    <operator>||</operator> <call><name><name>map</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</assert>
            <return>return <expr><name>map</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>c</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name><name>lastMapId</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name>getMap</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>;</assert>
            <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"createVersion"</literal></expr></argument>, <argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>M</name></type> <name>map</name> <init>= <expr><call><name><name>builder</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>x</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>map</name><operator>.</operator><name>asString</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>existing</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>name</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>existing</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// looks like map was created concurrently, cleanup and re-start</comment>
                <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>openMap</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>lastStoredVersion</name> <init>= <expr><name>currentVersion</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>setRootPos</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lastStoredVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
            <type><name>M</name></type> <name>existingMap</name> <init>= <expr><operator>(</operator><name>M</name><operator>)</operator> <call><name><name>maps</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>existingMap</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <name>existingMap</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>map</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Open an existing map with the given builder.
     *
     * @param &lt;M&gt; the map type
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param id the map id
     * @param builder the map builder
     * @return the map
     */</comment>
    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>M</name> <extends>extends <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></extends></parameter>, <parameter><name>K</name></parameter>, <parameter><name>V</name></parameter>&gt;</parameter_list> <name>M</name></type> <name>openMap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name><name>MVMap</name><operator>.</operator><name><name>MapBuilder</name><argument_list type="generic">&lt;<argument><name>M</name></argument>, <argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></name></type> <name>builder</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>M</name></type> <name>map</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>map</name> <operator>=</operator> <operator>(</operator><name>M</name><operator>)</operator><call><name>getMap</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>configAsString</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><name>configAsString</name> <operator>!=</operator> <literal type="null">null</literal></expr></argument>, <argument><expr><literal type="string">"Missing map with id {0}"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>config</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>parseMap</name></name><argument_list>(<argument><expr><name>configAsString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>config</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>map</name> <operator>=</operator> <call><name><name>builder</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>root</name> <init>= <expr><call><name>getRootPos</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>lastStoredVersion</name> <init>= <expr><name>currentVersion</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>setRootPos</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>lastStoredVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>maps</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// looks like map has been concurrently created already, re-start</comment>
        </block_content>}</block></while>
        <return>return <expr><name>map</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get map by id.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param id map id
     * @return Map
     */</comment>
    <function><type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>K</name></parameter>, <parameter><name>V</name></parameter>&gt;</parameter_list> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>getMap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
        <type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><operator>(</operator><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name><operator>)</operator> <call><name><name>maps</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>map</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the set of all map names.
     *
     * @return the set of names
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getMapNames</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>set</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>keyIterator</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>x</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>x</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>mapName</name> <init>= <expr><call><name><name>x</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>set</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>mapName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>set</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get this store's layout map. This data is for informational purposes only. The
     * data is subject to change in future versions.
     * &lt;p&gt;
     * The data in this map should not be modified (changing system data may corrupt the store).
     * &lt;p&gt;
     * The layout map contains the following entries:
     * &lt;pre&gt;
     * chunk.{chunkId} = {chunk metadata}
     * root.{mapId} = {root position}
     * &lt;/pre&gt;
     *
     * @return the metadata map
     */</comment>
    <function><type><specifier>public</specifier> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLayoutMap</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>layout</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the metadata map. This data is for informational purposes only. The
     * data is subject to change in future versions.
     * &lt;p&gt;
     * The data in this map should not be modified (changing system data may corrupt the store).
     * &lt;p&gt;
     * The metadata map contains the following entries:
     * &lt;pre&gt;
     * name.{name} = {mapId}
     * map.{mapId} = {map metadata}
     * setting.storeVersion = {version}
     * &lt;/pre&gt;
     *
     * @return the metadata map
     */</comment>
    <function><type><specifier>public</specifier> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getMetaMap</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>meta</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLayoutMap</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name>getChunkForVersion</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <literal type="null">null</literal></expr></argument>, <argument><expr><literal type="string">"Unknown version {0}"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>block</name> <init>= <expr><name><name>c</name><operator>.</operator><name>block</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>readChunkHeader</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>oldMap</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>openReadOnly</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>layoutRootPos</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>oldMap</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>getChunkForVersion</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>newest</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name>version</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>newest</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>c</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>newest</name><operator>.</operator><name>id</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>newest</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>newest</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check whether a given map exists.
     *
     * @param name the map name
     * @return true if it exists
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasMap</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>meta</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check whether a given map exists and has data.
     *
     * @param name the map name
     * @return true if it exists and has data.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasData</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>hasMap</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getRootPos</name><argument_list>(<argument><expr><call><name>getMapId</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>markMetaChanged</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// changes in the metadata alone are usually not detected, as the meta</comment>
        <comment type="line">// map is changed after storing</comment>
        <expr_stmt><expr><name>metaChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>readStoreHeader</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>newest</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>assumeCleanShutdown</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>validStoreHeader</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// find out which chunk and version are the newest</comment>
        <comment type="line">// read the first two blocks</comment>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>fileHeaderBlocks</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buff</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>BLOCK_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>BLOCK_SIZE</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>BLOCK_SIZE</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>fileHeaderBlocks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// the following can fail for various reasons</comment>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseChecksummedMap</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>version</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>HDR_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// if both header blocks do agree on version</comment>
                <comment type="line">// we'll continue on happy path - assume that previous shutdown was clean</comment>
                <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <name>assumeCleanShutdown</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>newest</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>version</name> <operator>==</operator> <name><name>newest</name><operator>.</operator><name>version</name></name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>newest</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>version</name> <operator>&gt;</operator> <name><name>newest</name><operator>.</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>validStoreHeader</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>putAll</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>creationTime</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>HDR_CREATED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexInt</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>HDR_CHUNK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>long</name></type> <name>block</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>HDR_BLOCK</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>test</name> <init>= <expr><call><name>readChunkHeaderAndFooter</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>newest</name> <operator>=</operator> <name>test</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>ignore</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>validStoreHeader</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                    <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_FILE_CORRUPT</name></name></expr></argument>,
                    <argument><expr><literal type="string">"Store header is corrupt: {0}"</literal></expr></argument>, <argument><expr><name>fileStore</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexInt</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_BLOCK_SIZE</name></expr></argument>, <argument><expr><name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>!=</operator> <name>BLOCK_SIZE</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                    <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_UNSUPPORTED_FORMAT</name></name></expr></argument>,
                    <argument><expr><literal type="string">"Block size {0} is currently not supported"</literal></expr></argument>,
                    <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>format</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_FORMAT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fileStore</name><operator>.</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>format</name> <operator>&gt;</operator> <name>FORMAT_WRITE_MAX</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getUnsupportedWriteFormatException</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>FORMAT_WRITE_MAX</name></expr></argument>,
                        <argument><expr><literal type="string">"The write format {0} is larger than the supported format {1}"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>format</name> <operator>&lt;</operator> <name>FORMAT_WRITE_MIN</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getUnsupportedWriteFormatException</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>FORMAT_WRITE_MIN</name></expr></argument>,
                        <argument><expr><literal type="string">"The write format {0} is smaller than the supported format {1}"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>format</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_FORMAT_READ</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>format</name> <operator>&gt;</operator> <name>FORMAT_READ_MAX</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                    <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_UNSUPPORTED_FORMAT</name></name></expr></argument>,
                    <argument><expr><literal type="string">"The read format {0} is larger than the supported format {1}"</literal></expr></argument>,
                    <argument><expr><name>format</name></expr></argument>, <argument><expr><name>FORMAT_READ_MAX</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>format</name> <operator>&lt;</operator> <name>FORMAT_READ_MIN</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                    <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_UNSUPPORTED_FORMAT</name></name></expr></argument>,
                    <argument><expr><literal type="string">"The read format {0} is smaller than the supported format {1}"</literal></expr></argument>,
                    <argument><expr><name>format</name></expr></argument>, <argument><expr><name>FORMAT_READ_MIN</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <name>assumeCleanShutdown</name> <operator>&amp;&amp;</operator> <name>newest</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recoveryMode</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>assumeCleanShutdown</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>readHexInt</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_CLEAN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>now</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// calculate the year (doesn't have to be exact;</comment>
        <comment type="line">// we assume 365.25 days per year, * 4 = 1461)</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>year</name> <init>=  <expr><literal type="number">1970</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>now</name> <operator>/</operator> <operator>(</operator><literal type="number">1000L</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">6</literal> <operator>*</operator> <literal type="number">1461</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>year</name> <operator>&lt;</operator> <literal type="number">2014</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// if the year is before 2014,</comment>
            <comment type="line">// we assume the system doesn't have a real-time clock,</comment>
            <comment type="line">// and we set the creationTime to the past, so that</comment>
            <comment type="line">// existing chunks are overwritten</comment>
            <expr_stmt><expr><name>creationTime</name> <operator>=</operator> <name>now</name> <operator>-</operator> <call><name><name>fileStore</name><operator>.</operator><name>getDefaultRetentionTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>now</name> <operator>&lt;</operator> <name>creationTime</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// the system time was set to the past:</comment>
            <comment type="line">// we change the creation time</comment>
            <expr_stmt><expr><name>creationTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_CREATED</name></expr></argument>, <argument><expr><name>creationTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>fileSize</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>blocksInStore</name> <init>= <expr><name>fileSize</name> <operator>/</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>chunkComparator</name> <init>= <expr><lambda><parameter_list>(<parameter><decl><name>one</name></decl></parameter>, <parameter><decl><name>two</name></decl></parameter>)</parameter_list> -&gt; <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name><name>two</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>one</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// out of two copies of the same chunk we prefer the one</comment>
                <comment type="line">// close to the beginning of file (presumably later version)</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>Long</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name><name>one</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>two</name><operator>.</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>validChunksByLocation</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>assumeCleanShutdown</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>tailChunk</name> <init>= <expr><call><name>discoverChunk</name><argument_list>(<argument><expr><name>blocksInStore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>tailChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>blocksInStore</name> <operator>=</operator> <name><name>tailChunk</name><operator>.</operator><name>block</name></name></expr>;</expr_stmt> <comment type="line">// for a possible full scan later on</comment>
                <if_stmt><if>if <condition>(<expr><name>newest</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>tailChunk</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <name><name>newest</name><operator>.</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>newest</name> <operator>=</operator> <name>tailChunk</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>newest</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// read the chunk header and footer,</comment>
                <comment type="line">// and follow the chain of next chunks</comment>
                <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>validChunksByLocation</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>newest</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name>newest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>newest</name><operator>.</operator><name>next</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>newest</name><operator>.</operator><name>next</name></name> <operator>&gt;=</operator> <name>blocksInStore</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// no (valid) next</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>test</name> <init>= <expr><call><name>readChunkHeaderAndFooter</name><argument_list>(<argument><expr><name><name>newest</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>newest</name><operator>.</operator><name>id</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>test</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name><name>newest</name><operator>.</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <comment type="line">// if shutdown was really clean then chain should be empty</comment>
                    <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newest</name> <operator>=</operator> <name>test</name></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>assumeCleanShutdown</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// quickly check latest 20 chunks referenced in meta table</comment>
            <decl_stmt><decl><type><name><name>Queue</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>chunksToVerify</name> <init>= <expr><operator>new</operator> <call><name><name>PriorityQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>(<argument><expr><name>chunkComparator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><call><name>setLastChunk</name><argument_list>(<argument><expr><name>newest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// load the chunk metadata: although meta's root page resides in the lastChunk,</comment>
                <comment type="line">// traversing meta map might recursively load another chunk(s)</comment>
                <decl_stmt><decl><type><name><name>Cursor</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>cursor</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>cursor</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>cursor</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>cursor</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>startsWith</name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name><name>Chunk</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><call><name><name>cursor</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <assert>assert <expr><name><name>c</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name>currentVersion</name></expr>;</assert>
                    <comment type="line">// might be there already, due to meta traversal</comment>
                    <comment type="line">// see readPage() ... getChunkIfFound()</comment>
                    <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>chunksToVerify</name><operator>.</operator><name>offer</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>chunksToVerify</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>chunksToVerify</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>assumeCleanShutdown</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name><name>chunksToVerify</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>test</name> <init>= <expr><call><name>readChunkHeaderAndFooter</name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <name>test</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>assumeCleanShutdown</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>validChunksByLocation</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>test</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>ignored</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><name>assumeCleanShutdown</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>assumeCleanShutdown</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>boolean</name></type> <name>quickRecovery</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recoveryMode</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// now we know, that previous shutdown did not go well and file</comment>
                <comment type="line">// is possibly corrupted but there is still hope for a quick</comment>
                <comment type="line">// recovery</comment>

                <comment type="line">// this collection will hold potential candidates for lastChunk to fall back to,</comment>
                <comment type="line">// in order from the most to least likely</comment>
                <decl_stmt><decl><type><name><name>Chunk</name><index>[]</index></name></type> <name>lastChunkCandidates</name> <init>= <expr><call><name><name>validChunksByLocation</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toArray</name><argument_list>(<argument><expr><operator>new</operator> <name><name>Chunk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>lastChunkCandidates</name></expr></argument>, <argument><expr><name>chunkComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>validChunksById</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><name>lastChunkCandidates</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>validChunksById</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>quickRecovery</name> <operator>=</operator> <call><name>findLastChunkWithCompleteValidChunkSet</name><argument_list>(<argument><expr><name>lastChunkCandidates</name></expr></argument>, <argument><expr><name>validChunksByLocation</name></expr></argument>,
                        <argument><expr><name>validChunksById</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quickRecovery</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// scan whole file and try to fetch chunk header and/or footer out of every block</comment>
                <comment type="line">// matching pairs with nothing in-between are considered as valid chunk</comment>
                <decl_stmt><decl><type><name>long</name></type> <name>block</name> <init>= <expr><name>blocksInStore</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>tailChunk</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>tailChunk</name> <operator>=</operator> <call><name>discoverChunk</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>block</name> <operator>=</operator> <name><name>tailChunk</name><operator>.</operator><name>block</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>validChunksByLocation</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>tailChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>

                <comment type="line">// this collection will hold potential candidates for lastChunk to fall back to,</comment>
                <comment type="line">// in order from the most to least likely</comment>
                <decl_stmt><decl><type><name><name>Chunk</name><index>[]</index></name></type> <name>lastChunkCandidates</name> <init>= <expr><call><name><name>validChunksByLocation</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toArray</name><argument_list>(<argument><expr><operator>new</operator> <name><name>Chunk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>lastChunkCandidates</name></expr></argument>, <argument><expr><name>chunkComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>validChunksById</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><name>lastChunkCandidates</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>validChunksById</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>findLastChunkWithCompleteValidChunkSet</name><argument_list>(<argument><expr><name>lastChunkCandidates</name></expr></argument>, <argument><expr><name>validChunksByLocation</name></expr></argument>,
                        <argument><expr><name>validChunksById</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                            <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_FILE_CORRUPT</name></name></expr></argument>,
                            <argument><expr><literal type="string">"File is corrupted - unable to recover a valid set of chunks"</literal></expr></argument>)</argument_list></call></expr>;</throw>

                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// build the free space list</comment>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>c</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>markUsed</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>c</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>deadChunks</name><operator>.</operator><name>offer</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <assert>assert <expr><call><name>validateFileLength</name><argument_list>(<argument><expr><literal type="string">"on open"</literal></expr></argument>)</argument_list></call></expr>;</assert>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>MVStoreException</name></type> <name>getUnsupportedWriteFormatException</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expectedFormat</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>format</name> <operator>=</operator> <call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_FORMAT_READ</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>format</name> <operator>&gt;=</operator> <name>FORMAT_READ_MIN</name> <operator>&amp;&amp;</operator> <name>format</name> <operator>&lt;=</operator> <name>FORMAT_READ_MAX</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="string">", and the file was not opened in read-only mode"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_UNSUPPORTED_FORMAT</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>expectedFormat</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>findLastChunkWithCompleteValidChunkSet</name><parameter_list>(<parameter><decl><type><name><name>Chunk</name><index>[]</index></name></type> <name>lastChunkCandidates</name></decl></parameter>,
            <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>validChunksByLocation</name></decl></parameter>,
            <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>validChunksById</name></decl></parameter>,
            <parameter><decl><type><name>boolean</name></type> <name>afterFullScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// Try candidates for "last chunk" in order from newest to oldest</comment>
        <comment type="line">// until suitable is found. Suitable one should have meta map</comment>
        <comment type="line">// where all chunk references point to valid locations.</comment>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><name>lastChunkCandidates</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>boolean</name></type> <name>verified</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><call><name>setLastChunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// load the chunk metadata: although meta's root page resides in the lastChunk,</comment>
                <comment type="line">// traversing meta map might recursively load another chunk(s)</comment>
                <decl_stmt><decl><type><name><name>Cursor</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>cursor</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>cursor</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>cursor</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>cursor</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>startsWith</name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name><name>Chunk</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><call><name><name>cursor</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <assert>assert <expr><name><name>c</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name>currentVersion</name></expr>;</assert>
                    <comment type="line">// might be there already, due to meta traversal</comment>
                    <comment type="line">// see readPage() ... getChunkIfFound()</comment>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>test</name> <init>= <expr><call><name><name>chunks</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>test</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <assert>assert <expr><call><name><name>chunks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>c</name></expr>;</assert>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>test</name> <operator>=</operator> <call><name><name>validChunksByLocation</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>block</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>test</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name><name>c</name><operator>.</operator><name>id</name></name></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>test</name> <operator>=</operator> <call><name><name>validChunksById</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                            <comment type="line">// We do not have a valid chunk at that location,</comment>
                            <comment type="line">// but there is a copy of same chunk from original</comment>
                            <comment type="line">// location.</comment>
                            <comment type="line">// Chunk header at original location does not have</comment>
                            <comment type="line">// any dynamic (occupancy) metadata, so it can't be</comment>
                            <comment type="line">// used here as is, re-point our chunk to original</comment>
                            <comment type="line">// location instead.</comment>
                            <expr_stmt><expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name><name>test</name><operator>.</operator><name>block</name></name></expr>;</expr_stmt>
                        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>c</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>afterFullScan</name> <operator>||</operator> <call><name>readChunkHeaderAndFooter</name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                            <comment type="line">// chunk reference is invalid</comment>
                            <comment type="line">// this "last chunk" candidate is not suitable</comment>
                            <expr_stmt><expr><name>verified</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>c</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// we can just remove entry from meta, referencing to this chunk,</comment>
                        <comment type="line">// but store maybe R/O, and it's not properly started yet,</comment>
                        <comment type="line">// so lets make this chunk "dead" and taking no space,</comment>
                        <comment type="line">// and it will be automatically removed later.</comment>
                        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>unused</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name><name>c</name><operator>.</operator><name>unused</name></name> <operator>=</operator> <name>creationTime</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>unusedAtVersion</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name><name>c</name><operator>.</operator><name>unusedAtVersion</name></name> <operator>=</operator> <name>INITIAL_VERSION</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>ignored</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><name>verified</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
            <if_stmt><if>if <condition>(<expr><name>verified</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setLastChunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>last</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastChunk</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastChunkId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentVersion</name> <operator>=</operator> <call><name>lastChunkVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>layoutRootPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>mapId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>last</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content> <comment type="line">// there is a valid chunk</comment>
            <expr_stmt><expr><name>lastChunkId</name> <operator>=</operator> <name><name>last</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>currentVersion</name> <operator>=</operator> <name><name>last</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>layoutRootPos</name> <operator>=</operator> <name><name>last</name><operator>.</operator><name>layoutRootPos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mapId</name> <operator>=</operator> <name><name>last</name><operator>.</operator><name>mapId</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>last</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>lastMapId</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>setRootPos</name></name><argument_list>(<argument><expr><name>layoutRootPos</name></expr></argument>, <argument><expr><name>currentVersion</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Discover a valid chunk, searching file backwards from the given block
     *
     * @param block to start search from (found chunk footer should be no
     *            further than block-1)
     * @return valid chunk or null if none found
     */</comment>
    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>discoverChunk</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>candidateLocation</name> <init>= <expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>candidate</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>block</name> <operator>==</operator> <name>candidateLocation</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>candidate</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>block</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> <comment type="line">// number of blocks occupied by headers</comment>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>test</name> <init>= <expr><call><name>readChunkFooter</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>test</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// if we encounter chunk footer (with or without corresponding header)</comment>
                <comment type="line">// in the middle of prospective chunk, stop considering it</comment>
                <expr_stmt><expr><name>candidateLocation</name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>readChunkHeaderOptionally</name><argument_list>(<argument><expr><name><name>test</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>test</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>test</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// if that footer has a corresponding header,</comment>
                    <comment type="line">// consider them as a new candidate for a valid chunk</comment>
                    <expr_stmt><expr><name>candidate</name> <operator>=</operator> <name>test</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>candidateLocation</name> <operator>=</operator> <name><name>test</name><operator>.</operator><name>block</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// if we encounter chunk header without corresponding footer</comment>
            <comment type="line">// (due to incomplete write?) in the middle of prospective</comment>
            <comment type="line">// chunk, stop considering it</comment>
            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>block</name> <operator>&gt;</operator> <name>candidateLocation</name> <operator>&amp;&amp;</operator> <call><name>readChunkHeaderOptionally</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>candidateLocation</name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Read a chunk header and footer, and verify the stored data is consistent.
     *
     * @param block the block
     * @param expectedId of the chunk
     * @return the chunk, or null if the header or footer don't match or are not
     *         consistent
     */</comment>
    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>readChunkHeaderAndFooter</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expectedId</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>header</name> <init>= <expr><call><name>readChunkHeaderOptionally</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>expectedId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>header</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>footer</name> <init>= <expr><call><name>readChunkFooter</name><argument_list>(<argument><expr><name>block</name> <operator>+</operator> <name><name>header</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>footer</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>footer</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name>expectedId</name> <operator>||</operator> <name><name>footer</name><operator>.</operator><name>block</name></name> <operator>!=</operator> <name><name>header</name><operator>.</operator><name>block</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>header</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Try to read a chunk footer.
     *
     * @param block the index of the next block after the chunk
     * @return the chunk, or null if not successful
     */</comment>
    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>readChunkFooter</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// the following can fail for various reasons</comment>
        <try>try <block>{<block_content>
            <comment type="line">// read the chunk footer of the last block of the file</comment>
            <decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><name>block</name> <operator>*</operator> <name>BLOCK_SIZE</name> <operator>-</operator> <name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>lastBlock</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buff</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>lastBlock</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseChecksummedMap</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>m</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><operator>new</operator> <call><name>Chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <comment type="line">// ignore</comment>
        </block_content>}</block></catch></try>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeStoreHeader</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>lastChunk</name> <init>= <expr><name><name>this</name><operator>.</operator><name>lastChunk</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_BLOCK</name></expr></argument>, <argument><expr><name><name>lastChunk</name><operator>.</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_CHUNK</name></expr></argument>, <argument><expr><name><name>lastChunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_VERSION</name></expr></argument>, <argument><expr><name><name>lastChunk</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><literal type="number">112</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>appendMap</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>storeHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBytes</name><argument_list>(<argument><expr><name><name>StandardCharsets</name><operator>.</operator><name>ISO_8859_1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>checksum</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getFletcher32</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>bytes</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>appendMap</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>HDR_FLETCHER</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBytes</name><argument_list>(<argument><expr><name><name>StandardCharsets</name><operator>.</operator><name>ISO_8859_1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>header</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>header</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>header</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>header</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>header</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>writeFully</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Close the file and the store. Unsaved changes are written to disk first.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>closeStore</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Close the file and the store. Unsaved changes are written to disk first,
     * and compaction (up to a specified number of milliseconds) is attempted.
     *
     * @param allowedCompactionTime the allowed time for compaction (in
     *            milliseconds)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>allowedCompactionTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>closeStore</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>allowedCompactionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Close the file and the store, without writing anything.
     * This will try to stop the background thread (without waiting for it).
     * This method ignores all errors.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>closeImmediately</name><parameter_list>()</parameter_list> <block>{<block_content>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>closeStore</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>handleException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>closeStore</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>normalShutdown</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowedCompactionTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// If any other thead have already initiated closure procedure,</comment>
        <comment type="line">// isClosed() would wait until closure is done and then  we jump out of the loop.</comment>
        <comment type="line">// This is a subtle difference between !isClosed() and isOpen().</comment>
        <while>while <condition>(<expr><operator>!</operator><call><name>isClosed</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>stopBackgroundThread</name><argument_list>(<argument><expr><name>normalShutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>STATE_OPEN</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>STATE_STOPPING</name></expr>;</expr_stmt>
                    <try>try <block>{<block_content>
                        <try>try <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>normalShutdown</name> <operator>&amp;&amp;</operator> <name>fileStore</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>fileStore</name><operator>.</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                                <for>for <control>(<init><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name> <range>: <expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><call><name><name>map</name><operator>.</operator><name>isClosed</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                                        <expr_stmt><expr><call><name>deregisterMapRoot</name><argument_list>(<argument><expr><call><name><name>map</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></for>
                                <expr_stmt><expr><call><name>setRetentionTime</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>commit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>allowedCompactionTime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                                    <expr_stmt><expr><call><name>compactFile</name><argument_list>(<argument><expr><name>allowedCompactionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>allowedCompactionTime</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                                    <expr_stmt><expr><call><name>doMaintenance</name><argument_list>(<argument><expr><name>autoCompactFillRate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <try>try <block>{<block_content>
                                    <expr_stmt><expr><call><name>shrinkFileIfPossible</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_CLEAN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>writeStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                    <assert>assert <expr><call><name>validateFileLength</name><argument_list>(<argument><expr><literal type="string">"on close"</literal></expr></argument>)</argument_list></call></expr>;</assert>
                                </block_content>}</block> <finally>finally <block>{<block_content>
                                    <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></finally></try>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>state</name> <operator>=</operator> <name>STATE_CLOSING</name></expr>;</expr_stmt>

                            <comment type="line">// release memory early - this is important when called</comment>
                            <comment type="line">// because of out of memory</comment>
                            <expr_stmt><expr><call><name>clearCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <for>for <control>(<init><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>m</name> <range>: <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                                <expr_stmt><expr><call><name><name>m</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>
                            <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>maps</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block> <finally>finally <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>fileStore</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>fileStoreIsProvided</name></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></finally></try>
                    </block_content>}</block> <finally>finally <block>{<block_content>
                        <expr_stmt><expr><name>state</name> <operator>=</operator> <name>STATE_CLOSED</name></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>shutdownExecutor</name><parameter_list>(<parameter><decl><type><name>ThreadPoolExecutor</name></type> <name>executor</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>executor</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>executor</name><operator>.</operator><name>awaitTermination</name></name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>ignore</name></decl></parameter>)</parameter_list> <block>{<block_content><comment type="block">/**/</comment></block_content>}</block></catch></try>
            <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>shutdownNow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the chunk for the given position.
     *
     * @param pos the position
     * @return the chunk
     */</comment>
    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>getChunk</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageChunkId</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name><name>chunks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>Chunk</name><operator>.</operator><name>getMetaKey</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                        <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_CHUNK_NOT_FOUND</name></name></expr></argument>,
                        <argument><expr><literal type="string">"Chunk {0} not found"</literal></expr></argument>, <argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>Chunk</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>c</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                        <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_FILE_CORRUPT</name></name></expr></argument>,
                        <argument><expr><literal type="string">"Chunk {0} is invalid"</literal></expr></argument>, <argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>c</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setWriteVersion</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>map</name> <operator>!=</operator> <name>layout</name> <operator>&amp;&amp;</operator> <name>map</name> <operator>!=</operator> <name>meta</name></expr>;</assert>
            <if_stmt><if>if <condition>(<expr><call><name><name>map</name><operator>.</operator><name>setWriteVersion</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>iter</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>setWriteVersion</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>setWriteVersion</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>onVersionChange</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Unlike regular commit this method returns immediately if there is commit
     * in progress on another thread, otherwise it acts as regular commit.
     *
     * This method may return BEFORE this thread changes are actually persisted!
     *
     * @return the new version (incremented if there were changes)
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>tryCommit</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>tryCommit</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>x</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><literal type="boolean">true</literal></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>tryCommit</name><parameter_list>(<parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>MVStore</name></argument>&gt;</argument_list></name></type> <name>check</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// we need to prevent re-entrance, which may be possible,</comment>
        <comment type="line">// because meta map is modified within storeNow() and that</comment>
        <comment type="line">// causes beforeWrite() call with possibility of going back here</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>currentStoreVersion</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name><name>storeLock</name><operator>.</operator><name>tryLock</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <try>try <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>check</name><operator>.</operator><name>test</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>store</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>currentVersion</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Commit the changes.
     * &lt;p&gt;
     * This method does nothing if there are no unsaved changes,
     * otherwise it increments the current version
     * and stores the data (for file based stores).
     * &lt;p&gt;
     * It is not necessary to call this method when auto-commit is enabled (the default
     * setting), as in this case it is automatically called from time to time or
     * when enough changes have accumulated. However, it may still be called to
     * flush all changes to disk.
     * &lt;p&gt;
     * At most one store operation may run at any time.
     *
     * @return the new version (incremented if there were changes)
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>commit</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>commit</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>x</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><literal type="boolean">true</literal></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>commit</name><parameter_list>(<parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>MVStore</name></argument>&gt;</argument_list></name></type> <name>check</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// we need to prevent re-entrance, which may be possible,</comment>
        <comment type="line">// because meta map is modified within storeNow() and that</comment>
        <comment type="line">// causes beforeWrite() call with possibility of going back here</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>currentStoreVersion</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>check</name><operator>.</operator><name>test</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>store</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>currentVersion</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>store</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>syncWrite</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><operator>!</operator><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <if_stmt><if>if <condition>(<expr><call><name>isOpenOrStopping</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>hasUnsavedChanges</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dropUnusedChunks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><name>currentStoreVersion</name> <operator>=</operator> <name>currentVersion</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fileStore</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <comment type="line">//noinspection NonAtomicOperationOnVolatileField</comment>
                        <expr_stmt><expr><operator>++</operator><name>currentVersion</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>setWriteVersion</name><argument_list>(<argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>metaChanged</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name><name>fileStore</name><operator>.</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                            <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                                    <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_WRITING_FAILED</name></name></expr></argument>, <argument><expr><literal type="string">"This store is read-only"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>storeNow</name><argument_list>(<argument><expr><name>syncWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><operator>)</operator> <operator>-&gt;</operator> <name>reuseSpace</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>getAfterLastBlock</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block> <finally>finally <block>{<block_content>
                    <comment type="line">// in any case reset the current store version,</comment>
                    <comment type="line">// to allow closing the store</comment>
                    <expr_stmt><expr><name>currentStoreVersion</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></finally></try>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>storeNow</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>syncWrite</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>reservedLow</name></decl></parameter>, <parameter><decl><type><name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>reservedHighSupplier</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <try>try <block>{<block_content>
            <expr_stmt><expr><name>lastCommitTime</name> <operator>=</operator> <call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>currentUnsavedPageCount</name> <init>= <expr><name>unsavedMemory</name></expr></init></decl>;</decl_stmt>
            <comment type="line">// it is ok, since that path suppose to be single-threaded under storeLock</comment>
            <comment type="line">//noinspection NonAtomicOperationOnVolatileField</comment>
            <decl_stmt><decl><type><name>long</name></type> <name>version</name> <init>= <expr><operator>++</operator><name>currentVersion</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>changed</name> <init>= <expr><call><name>collectChangedMapRoots</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <assert>assert <expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <expr_stmt><expr><call><name>submitOrRun</name><argument_list>(<argument><expr><name>serializationExecutor</name></expr></argument>,
                    <argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>serializeAndStore</name><argument_list>(<argument><expr><name>syncWrite</name></expr></argument>, <argument><expr><name>reservedLow</name></expr></argument>, <argument><expr><name>reservedHighSupplier</name></expr></argument>,
                                            <argument><expr><name>changed</name></expr></argument>, <argument><expr><name>lastCommitTime</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>,
                    <argument><expr><name>syncWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// some pages might have been changed in the meantime (in the newest</comment>
            <comment type="line">// version)</comment>
            <expr_stmt><expr><name>saveNeeded</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unsavedMemory</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>unsavedMemory</name> <operator>-</operator> <name>currentUnsavedPageCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_INTERNAL</name></name></expr></argument>, <argument><expr><literal type="string">"{0}"</literal></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>submitOrRun</name><parameter_list>(<parameter><decl><type><name>ThreadPoolExecutor</name></type> <name>executor</name></decl></parameter>, <parameter><decl><type><name>Runnable</name></type> <name>action</name></decl></parameter>,
                                    <parameter><decl><type><name>boolean</name></type> <name>syncRun</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>executor</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>future</name> <init>= <expr><call><name><name>executor</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>syncRun</name> <operator>||</operator> <call><name><name>executor</name><operator>.</operator><name>getQueue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>PIPE_LENGTH</name></expr>)</condition> <block>{<block_content>
                    <try>try <block>{<block_content>
                        <expr_stmt><expr><call><name><name>future</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>ignore</name></decl></parameter>)</parameter_list> <block>{<block_content><comment type="block">/**/</comment></block_content>}</block></catch></try>
                </block_content>}</block></if></if_stmt>
                <return>return;</return>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>RejectedExecutionException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <assert>assert <expr><call><name><name>executor</name><operator>.</operator><name>isShutdown</name></name><argument_list>()</argument_list></call></expr>;</assert>
                <expr_stmt><expr><call><name>shutdownExecutor</name><argument_list>(<argument><expr><name>executor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>action</name><operator>.</operator><name>run</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>collectChangedMapRoots</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>lastStoredVersion</name> <init>= <expr><name>version</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>changed</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>RootReference</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rootReference</name> <init>= <expr><call><name><name>map</name><operator>.</operator><name>setWriteVersion</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>rootReference</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>iter</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>map</name><operator>.</operator><name>getCreateVersion</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>version</name> <operator>&amp;&amp;</operator> <comment type="line">// if map was created after storing started, skip it</comment>
                    <operator>!</operator><call><name><name>map</name><operator>.</operator><name>isVolatile</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
                    <call><name><name>map</name><operator>.</operator><name>hasChangesSince</name></name><argument_list>(<argument><expr><name>lastStoredVersion</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <assert>assert <expr><name><name>rootReference</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name>version</name> <operator>:</operator> <name><name>rootReference</name><operator>.</operator><name>version</name></name> <operator>+</operator> <literal type="string">" &gt; "</literal> <operator>+</operator> <name>version</name></expr>;</assert>
                <decl_stmt><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rootPage</name> <init>= <expr><name><name>rootReference</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>rootPage</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call> <operator>||</operator>
                        <comment type="line">// after deletion previously saved leaf</comment>
                        <comment type="line">// may pop up as a root, but we still need</comment>
                        <comment type="line">// to save new root pos in meta</comment>
                        <call><name><name>rootPage</name><operator>.</operator><name>isLeaf</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>changed</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>rootPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>RootReference</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rootReference</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>setWriteVersion</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>meta</name><operator>.</operator><name>hasChangesSince</name></name><argument_list>(<argument><expr><name>lastStoredVersion</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>metaChanged</name></expr>)</condition> <block>{<block_content>
            <assert>assert <expr><name>rootReference</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>rootReference</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name>version</name>
                    <operator>:</operator> <ternary><condition><expr><name>rootReference</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">"null"</literal></expr> </then><else>: <expr><name><name>rootReference</name><operator>.</operator><name>version</name></name> <operator>+</operator> <literal type="string">" &gt; "</literal> <operator>+</operator> <name>version</name></expr></else></ternary></expr>;</assert>
            <decl_stmt><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rootPage</name> <init>= <expr><name><name>rootReference</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>rootPage</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call> <operator>||</operator>
                    <comment type="line">// after deletion previously saved leaf</comment>
                    <comment type="line">// may pop up as a root, but we still need</comment>
                    <comment type="line">// to save new root pos in meta</comment>
                    <call><name><name>rootPage</name><operator>.</operator><name>isLeaf</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>changed</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>rootPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>changed</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>serializeAndStore</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>syncRun</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>reservedLow</name></decl></parameter>, <parameter><decl><type><name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>reservedHighSupplier</name></decl></parameter>,
                                    <parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>changed</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name>createChunk</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>WriteBuffer</name></type> <name>buff</name> <init>= <expr><call><name>getWriteBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>serializeToBuffer</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>changed</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>reservedLow</name></expr></argument>, <argument><expr><name>reservedHighSupplier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>submitOrRun</name><argument_list>(<argument><expr><name>bufferSaveExecutor</name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>storeBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>changed</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>, <argument><expr><name>syncRun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_INTERNAL</name></name></expr></argument>, <argument><expr><literal type="string">"{0}"</literal></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>createChunk</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><name>lastChunkId</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>chunkId</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>chunkId</name> <operator>&amp;=</operator> <name><name>Chunk</name><operator>.</operator><name>MAX_ID</name></name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>lastChunk</name> <init>= <expr><call><name><name>chunks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <assert>assert <expr><call><name><name>lastChunk</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <assert>assert <expr><name><name>lastChunk</name><operator>.</operator><name>version</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>version</name> <operator>:</operator> <name><name>lastChunk</name><operator>.</operator><name>version</name></name> <operator>+</operator> <literal type="string">" "</literal> <operator>+</operator>  <name>version</name></expr>;</assert>
            <comment type="line">// the metadata of the last chunk was not stored so far, and needs to be</comment>
            <comment type="line">// set now (it's better not to update right after storing, because that</comment>
            <comment type="line">// would modify the meta map again)</comment>
            <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>Chunk</name><operator>.</operator><name>getMetaKey</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>lastChunk</name><operator>.</operator><name>asString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// never go backward in time</comment>
            <expr_stmt><expr><name>time</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name><name>lastChunk</name><operator>.</operator><name>time</name></name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>newChunkId</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>newChunkId</name> <operator>=</operator> <operator>++</operator><name>lastChunkId</name> <operator>&amp;</operator> <name><name>Chunk</name><operator>.</operator><name>MAX_ID</name></name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>old</name> <init>= <expr><call><name><name>chunks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>newChunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>old</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>old</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>MVStoreException</name></type> <name>e</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                        <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_INTERNAL</name></name></expr></argument>,
                        <argument><expr><literal type="string">"Last block {0} not stored, possibly due to out-of-memory"</literal></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><operator>new</operator> <call><name>Chunk</name><argument_list>(<argument><expr><name>newChunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>pageCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>pageCountLive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>maxLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>maxLenLive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>layoutRootPos</name></name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>time</name></name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>occupancy</name></name> <operator>=</operator> <operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>c</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>serializeToBuffer</name><parameter_list>(<parameter><decl><type><name>WriteBuffer</name></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>changed</name></decl></parameter>, <parameter><decl><type><name>Chunk</name></type> <name>c</name></decl></parameter>,
                                    <parameter><decl><type><name>long</name></type> <name>reservedLow</name></decl></parameter>, <parameter><decl><type><name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>reservedHighSupplier</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// need to patch the header later</comment>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>writeChunkHeader</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>headerLength</name> <init>= <expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">44</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>headerLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>version</name> <init>= <expr><name><name>c</name><operator>.</operator><name>version</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>toc</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>changed</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>MVMap</name><operator>.</operator><name>getMapRootKey</name></name><argument_list>(<argument><expr><call><name><name>p</name><operator>.</operator><name>getMapId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>p</name><operator>.</operator><name>getTotalCount</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>p</name><operator>.</operator><name>writeUnsavedRecursive</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>root</name> <init>= <expr><call><name><name>p</name><operator>.</operator><name>getPos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name><name>Long</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>acceptChunkOccupancyChanges</name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>time</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>RootReference</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>layoutRootReference</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>setWriteVersion</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>layoutRootReference</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <assert>assert <expr><name><name>layoutRootReference</name><operator>.</operator><name>version</name></name> <operator>==</operator> <name>version</name> <operator>:</operator> <name><name>layoutRootReference</name><operator>.</operator><name>version</name></name> <operator>+</operator> <literal type="string">" != "</literal> <operator>+</operator> <name>version</name></expr>;</assert>
        <expr_stmt><expr><name>metaChanged</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>acceptChunkOccupancyChanges</name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>time</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>onVersionChange</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>layoutRoot</name> <init>= <expr><name><name>layoutRootReference</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>layoutRoot</name><operator>.</operator><name>writeUnsavedRecursive</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>layoutRootPos</name></name> <operator>=</operator> <call><name><name>layoutRoot</name><operator>.</operator><name>getPos</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>changed</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>layoutRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// last allocated map id should be captured after the meta map was saved, because</comment>
        <comment type="line">// this will ensure that concurrently created map, which made it into meta before save,</comment>
        <comment type="line">// will have it's id reflected in mapid field of currently written chunk</comment>
        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>mapId</name></name> <operator>=</operator> <call><name><name>lastMapId</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>c</name><operator>.</operator><name>tocPos</name></name> <operator>=</operator> <call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>tocArray</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><call><name><name>toc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>long</name></type> <name>tocElement</name> <range>: <expr><name>toc</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>tocArray</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tocElement</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>putLong</name></name><argument_list>(<argument><expr><name>tocElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>DataUtils</name><operator>.</operator><name>isLeafPosition</name></name><argument_list>(<argument><expr><name>tocElement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>leafCount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>nonLeafCount</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>chunksToC</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>tocArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>chunkLength</name> <init>= <expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// add the store header and round to the next block</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>roundUpInt</name></name><argument_list>(<argument><expr><name>chunkLength</name> <operator>+</operator>
                <name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></argument>, <argument><expr><name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>limit</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>Long</name></type> <name>reservedHigh</name> <init>= <expr><call><name><name>reservedHighSupplier</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>filePos</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><call><name><name>buff</name><operator>.</operator><name>limit</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>reservedLow</name></expr></argument>, <argument><expr><name>reservedHigh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name><name>buff</name><operator>.</operator><name>limit</name></name><argument_list>()</argument_list></call> <operator>/</operator> <name>BLOCK_SIZE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name>filePos</name> <operator>/</operator> <name>BLOCK_SIZE</name></expr>;</expr_stmt>
            <assert>assert <expr><call><name>validateFileLength</name><argument_list>(<argument><expr><call><name><name>c</name><operator>.</operator><name>asString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</assert>
            <comment type="line">// calculate and set the likely next position</comment>
            <if_stmt><if>if <condition>(<expr><name>reservedLow</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>reservedHigh</name> <operator>==</operator> <name>reservedLow</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>.</operator><name>next</name></name> <operator>=</operator> <call><name><name>fileStore</name><operator>.</operator><name>predictAllocation</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// just after this chunk</comment>
                <expr_stmt><expr><name><name>c</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <assert>assert <expr><name><name>c</name><operator>.</operator><name>pageCountLive</name></name> <operator>==</operator> <name><name>c</name><operator>.</operator><name>pageCount</name></name> <operator>:</operator> <name>c</name></expr>;</assert>
            <assert>assert <expr><call><name><name>c</name><operator>.</operator><name>occupancy</name><operator>.</operator><name>cardinality</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>:</operator> <name>c</name></expr>;</assert>

            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><name><name>c</name><operator>.</operator><name>pageCountLive</name></name> <operator>==</operator> <name><name>c</name><operator>.</operator><name>pageCount</name></name> <operator>:</operator> <name>c</name></expr>;</assert>
            <assert>assert <expr><call><name><name>c</name><operator>.</operator><name>occupancy</name><operator>.</operator><name>cardinality</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>:</operator> <name>c</name></expr>;</assert>
            <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>writeChunkHeader</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>headerLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><call><name><name>buff</name><operator>.</operator><name>limit</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>c</name><operator>.</operator><name>getFooterBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>storeBuffer</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>WriteBuffer</name></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>changed</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>filePos</name> <init>= <expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>filePos</name></expr></argument>, <argument><expr><call><name><name>buff</name><operator>.</operator><name>getBuffer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>releaseWriteBuffer</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// end of the used space is not necessarily the end of the file</comment>
            <decl_stmt><decl><type><name>boolean</name></type> <name>storeAtEndOfFile</name> <init>= <expr><name>filePos</name> <operator>+</operator> <call><name><name>buff</name><operator>.</operator><name>limit</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>fileStore</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>writeStoreHeader</name> <init>= <expr><call><name>isWriteStoreHeader</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>storeAtEndOfFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>lastChunk</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>writeStoreHeader</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>writeStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>storeAtEndOfFile</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// may only shrink after the store header was written</comment>
                <expr_stmt><expr><call><name>shrinkFileIfPossible</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_INTERNAL</name></name></expr></argument>, <argument><expr><literal type="string">"{0}"</literal></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>

        <for>for <control>(<init><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>changed</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>p</name><operator>.</operator><name>releaseSavedPages</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isWriteStoreHeader</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>storeAtEndOfFile</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// whether we need to write the store header</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>writeStoreHeader</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>storeAtEndOfFile</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>lastChunk</name> <init>= <expr><name><name>this</name><operator>.</operator><name>lastChunk</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>lastChunk</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>writeStoreHeader</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lastChunk</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name><name>c</name><operator>.</operator><name>block</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// the last prediction did not matched</comment>
                <expr_stmt><expr><name>writeStoreHeader</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>headerVersion</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>lastChunk</name><operator>.</operator><name>version</name></name> <operator>-</operator> <name>headerVersion</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// we write after at least every 20 versions</comment>
                    <expr_stmt><expr><name>writeStoreHeader</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexInt</name></name><argument_list>(<argument><expr><name>storeHeader</name></expr></argument>, <argument><expr><name>HDR_CHUNK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init>
                            <condition><expr><operator>!</operator><name>writeStoreHeader</name> <operator>&amp;&amp;</operator> <name>chunkId</name> <operator>&lt;=</operator> <name><name>lastChunk</name><operator>.</operator><name>id</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>chunkId</name></expr></incr>)</control> <block>{<block_content>
                        <comment type="line">// one of the chunks in between</comment>
                        <comment type="line">// was removed</comment>
                        <expr_stmt><expr><name>writeStoreHeader</name> <operator>=</operator> <operator>!</operator><call><name><name>chunks</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>storeHeader</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>HDR_CLEAN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>writeStoreHeader</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>writeStoreHeader</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get a buffer for writing. This caller must synchronize on the store
     * before calling the method and until after using the buffer.
     *
     * @return the buffer
     */</comment>
    <function><type><specifier>private</specifier> <name>WriteBuffer</name></type> <name>getWriteBuffer</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>WriteBuffer</name></type> <name>buff</name> <init>= <expr><call><name><name>writeBufferPool</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>buff</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>buff</name> <operator>=</operator> <operator>new</operator> <call><name>WriteBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>buff</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Release a buffer for writing. This caller must synchronize on the store
     * before calling the method and until after using the buffer.
     *
     * @param buff the buffer than can be re-used
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>releaseWriteBuffer</name><parameter_list>(<parameter><decl><type><name>WriteBuffer</name></type> <name>buff</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>buff</name><operator>.</operator><name>capacity</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>writeBufferPool</name><operator>.</operator><name>offer</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>canOverwriteChunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>oldestVersionToKeep</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>c</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>.</operator><name>unusedAtVersion</name></name> <operator>&lt;</operator> <name>oldestVersionToKeep</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isSeasonedChunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunk</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>time</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><name>retentionTime</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>chunk</name><operator>.</operator><name>time</name></name> <operator>+</operator> <name>retentionTime</name> <operator>&lt;=</operator> <name>time</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>getTimeSinceCreation</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>getTimeAbsolute</name><argument_list>()</argument_list></call> <operator>-</operator> <name>creationTime</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>getTimeAbsolute</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>now</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>lastTimeAbsolute</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>now</name> <operator>&lt;</operator> <name>lastTimeAbsolute</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// time seems to have run backwards - this can happen</comment>
            <comment type="line">// when the system time is adjusted, for example</comment>
            <comment type="line">// on a leap second</comment>
            <expr_stmt><expr><name>now</name> <operator>=</operator> <name>lastTimeAbsolute</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>lastTimeAbsolute</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>now</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Apply the freed space to the chunk metadata. The metadata is updated, but
     * completely free chunks are not removed from the set of chunks, and the
     * disk space is not yet marked as free. They are queued instead and wait until
     * their usage is over.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>acceptChunkOccupancyChanges</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>serializationLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <if_stmt><if>if <condition>(<expr><name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>modifiedChunks</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>RemovedPageInfo</name></type> <name>rpi</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>rpi</name> <operator>=</operator> <call><name><name>removedPages</name><operator>.</operator><name>peek</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>rpi</name><operator>.</operator><name>version</name></name> <operator>&lt;</operator> <name>version</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>rpi</name> <operator>=</operator> <call><name><name>removedPages</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// could be different from the peeked one</comment>
                    <assert>assert <expr><name>rpi</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>         <comment type="line">// since nobody else retrieves from queue</comment>
                    <assert>assert <expr><name><name>rpi</name><operator>.</operator><name>version</name></name> <operator>&lt;</operator> <name>version</name> <operator>:</operator> <name>rpi</name> <operator>+</operator> <literal type="string">" &lt; "</literal> <operator>+</operator> <name>version</name></expr>;</assert>
                    <decl_stmt><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><call><name><name>rpi</name><operator>.</operator><name>getPageChunkId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><call><name><name>chunks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <assert>assert <expr><operator>!</operator><call><name>isOpen</name><argument_list>()</argument_list></call> <operator>||</operator> <name>chunk</name> <operator>!=</operator> <literal type="null">null</literal> <operator>:</operator> <name>chunkId</name></expr>;</assert>
                    <if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>modifiedChunks</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>chunk</name><operator>.</operator><name>accountForRemovedPage</name></name><argument_list>(<argument><expr><call><name><name>rpi</name><operator>.</operator><name>getPageNo</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rpi</name><operator>.</operator><name>getPageLength</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>rpi</name><operator>.</operator><name>isPinned</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>time</name></expr></argument>, <argument><expr><name><name>rpi</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name><name>deadChunks</name><operator>.</operator><name>offer</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <if_stmt><if>if <condition>(<expr><call><name><name>modifiedChunks</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><name>modifiedChunks</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>Chunk</name><operator>.</operator><name>getMetaKey</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>chunk</name><operator>.</operator><name>asString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name><name>modifiedChunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Shrink the file if possible, and if at least a given percentage can be
     * saved.
     *
     * @param minPercent the minimum percentage to save
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>shrinkFileIfPossible</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minPercent</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <if_stmt><if>if <condition>(<expr><call><name><name>fileStore</name><operator>.</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>end</name> <init>= <expr><call><name>getFileLengthInUse</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>fileSize</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>fileSize</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>minPercent</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fileSize</name> <operator>-</operator> <name>end</name> <operator>&lt;</operator> <name>BLOCK_SIZE</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>savedPercent</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <operator>(</operator><name>end</name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>fileSize</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>savedPercent</name> <operator>&lt;</operator> <name>minPercent</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isOpenOrStopping</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>truncate</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the position right after the last used byte.
     *
     * @return the position
     */</comment>
    <function><type><specifier>private</specifier> <name>long</name></type> <name>getFileLengthInUse</name><parameter_list>()</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name>long</name></type> <name>result</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>getFileLengthInUse</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>result</name> <operator>==</operator> <call><name>measureFileLengthInUse</name><argument_list>()</argument_list></call> <operator>:</operator> <name>result</name> <operator>+</operator> <literal type="string">" != "</literal> <operator>+</operator> <call><name>measureFileLengthInUse</name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the index of the first block after last occupied one.
     * It marks the beginning of the last (infinite) free space.
     *
     * @return block index
     */</comment>
    <function><type><specifier>private</specifier> <name>long</name></type> <name>getAfterLastBlock</name><parameter_list>()</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><call><name><name>fileStore</name><operator>.</operator><name>getAfterLastBlock</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>measureFileLengthInUse</name><parameter_list>()</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>c</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>+</operator> <name><name>c</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>size</name> <operator>*</operator> <name>BLOCK_SIZE</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check whether there are any unsaved changes.
     *
     * @return if there are any changes
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasUnsavedChanges</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>metaChanged</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>lastStoredVersion</name> <init>= <expr><name>currentVersion</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>m</name> <range>: <expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>m</name><operator>.</operator><name>isClosed</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name><name>m</name><operator>.</operator><name>hasChangesSince</name></name><argument_list>(<argument><expr><name>lastStoredVersion</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>layout</name><operator>.</operator><name>hasChangesSince</name></name><argument_list>(<argument><expr><name>lastStoredVersion</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lastStoredVersion</name> <operator>&gt;</operator> <name>INITIAL_VERSION</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>readChunkHeader</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>p</name> <init>= <expr><name>block</name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>buff</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>Chunk</name><operator>.</operator><name>MAX_HEADER_LENGTH</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>Chunk</name><operator>.</operator><name>readChunkHeader</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>readChunkHeaderOptionally</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><call><name>readChunkHeader</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><ternary><condition><expr><name><name>chunk</name><operator>.</operator><name>block</name></name> <operator>!=</operator> <name>block</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name>chunk</name></expr></else></ternary></expr>;</return>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>ignore</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Chunk</name></type> <name>readChunkHeaderOptionally</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expectedId</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><call><name>readChunkHeaderOptionally</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>chunk</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>chunk</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name>expectedId</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name>chunk</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Compact by moving all chunks next to each other.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>compactMoveChunks</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>compactMoveChunks</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Compact the store by moving all chunks next to each other, if there is
     * free space between chunks. This might temporarily increase the file size.
     * Chunks are overwritten irrespective of the current retention time. Before
     * overwriting chunks and before resizing the file, syncFile() is called.
     *
     * @param targetFillRate do nothing if the file store fill rate is higher
     *            than this
     * @param moveSize the number of bytes to move
     * @return true if any chunks were moved as result of this operation, false otherwise
     */</comment>
    <function><type><name>boolean</name></type> <name>compactMoveChunks</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetFillRate</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>moveSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>res</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// because serializationExecutor is a single-threaded one and</comment>
            <comment type="line">// all task submissions to it are done under storeLock,</comment>
            <comment type="line">// it is guaranteed, that upon this dummy task completion</comment>
            <comment type="line">// there are no pending / in-progress task here</comment>
            <expr_stmt><expr><call><name>submitOrRun</name><argument_list>(<argument><expr><name>serializationExecutor</name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content/>}</block></lambda></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <comment type="line">// similarly, all task submissions to bufferSaveExecutor</comment>
                <comment type="line">// are done under serializationLock, and upon this dummy task completion</comment>
                <comment type="line">// it will be no pending / in-progress task here</comment>
                <expr_stmt><expr><call><name>submitOrRun</name><argument_list>(<argument><expr><name>bufferSaveExecutor</name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content/>}</block></lambda></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <try>try <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>reuseSpace</name> <operator>&amp;&amp;</operator> <call><name>getFillRate</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>targetFillRate</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compactMoveChunks</name><argument_list>(<argument><expr><name>moveSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block> <finally>finally <block>{<block_content>
                    <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></finally></try>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                    <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_INTERNAL</name></name></expr></argument>, <argument><expr><literal type="string">"{0}"</literal></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
        <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>compactMoveChunks</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>moveSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name>dropUnusedChunks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>getFirstFree</name></name><argument_list>()</argument_list></call> <operator>/</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>chunksToMove</name> <init>= <expr><call><name>findChunksToMove</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>moveSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>chunksToMove</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>compactMoveChunks</name><argument_list>(<argument><expr><name>chunksToMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>findChunksToMove</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>startBlock</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>moveSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>maxBlocksToMove</name> <init>= <expr><name>moveSize</name> <operator>/</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>maxBlocksToMove</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>PriorityQueue</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>queue</name> <init>= <expr><operator>new</operator> <call><name><name>PriorityQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>chunks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                    <argument><expr><lambda><parameter_list>(<parameter><decl><name>o1</name></decl></parameter>, <parameter><decl><name>o2</name></decl></parameter>)</parameter_list> -&gt; <block>{<block_content>
                        <comment type="line">// instead of selection just closest to beginning of the file,</comment>
                        <comment type="line">// pick smaller chunk(s) which sit in between bigger holes</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name><name>o2</name><operator>.</operator><name>collectPriority</name></name></expr></argument>, <argument><expr><name><name>o1</name><operator>.</operator><name>collectPriority</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <return>return <expr><name>res</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                        <return>return <expr><call><name><name>Long</name><operator>.</operator><name>signum</name></name><argument_list>(<argument><expr><name><name>o2</name><operator>.</operator><name>block</name></name> <operator>-</operator> <name><name>o1</name><operator>.</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>chunk</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>chunk</name><operator>.</operator><name>block</name></name> <operator>&gt;</operator> <name>startBlock</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>chunk</name><operator>.</operator><name>collectPriority</name></name> <operator>=</operator> <call><name>getMovePriority</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>queue</name><operator>.</operator><name>offer</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>chunk</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                    <while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>maxBlocksToMove</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>Chunk</name></type> <name>removed</name> <init>= <expr><call><name><name>queue</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>removed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>size</name> <operator>-=</operator> <name><name>removed</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                    </block_content>}</block></while>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>queue</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name><name>Chunk</name><operator>.</operator><name>PositionComparator</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getMovePriority</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunk</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>fileStore</name><operator>.</operator><name>getMovePriority</name></name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>chunk</name><operator>.</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>compactMoveChunks</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>move</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><call><name><name>serializationLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <if_stmt><if>if <condition>(<expr><name>move</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// this will ensure better recognition of the last chunk</comment>
            <comment type="line">// in case of power failure, since we are going to move older chunks</comment>
            <comment type="line">// to the end of the file</comment>
            <expr_stmt><expr><call><name>writeStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>iterator</name> <init>= <expr><call><name><name>move</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <decl_stmt><decl><type><name>long</name></type> <name>leftmostBlock</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><name>block</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>originalBlockCount</name> <init>= <expr><call><name>getAfterLastBlock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// we need to ensure that chunks moved within the following loop</comment>
            <comment type="line">// do not overlap with space just released by chunks moved before them,</comment>
            <comment type="line">// hence the need to reserve this area [leftmostBlock, originalBlockCount)</comment>
            <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><name>move</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>moveChunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>leftmostBlock</name></expr></argument>, <argument><expr><name>originalBlockCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <comment type="line">// update the metadata (hopefully within the file)</comment>
            <expr_stmt><expr><call><name>store</name><argument_list>(<argument><expr><name>leftmostBlock</name></expr></argument>, <argument><expr><name>originalBlockCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Chunk</name></type> <name>chunkToMove</name> <init>= <expr><name>lastChunk</name></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>chunkToMove</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <decl_stmt><decl><type><name>long</name></type> <name>postEvacuationBlockCount</name> <init>= <expr><call><name>getAfterLastBlock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>boolean</name></type> <name>chunkToMoveIsAlreadyInside</name> <init>= <expr><name><name>chunkToMove</name><operator>.</operator><name>block</name></name> <operator>&lt;</operator> <name>leftmostBlock</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>movedToEOF</name> <init>= <expr><operator>!</operator><name>chunkToMoveIsAlreadyInside</name></expr></init></decl>;</decl_stmt>
            <comment type="line">// move all chunks, which previously did not fit before reserved area</comment>
            <comment type="line">// now we can re-use previously reserved area [leftmostBlock, originalBlockCount),</comment>
            <comment type="line">// but need to reserve [originalBlockCount, postEvacuationBlockCount)</comment>
            <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><name>move</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>&gt;=</operator> <name>originalBlockCount</name> <operator>&amp;&amp;</operator>
                        <call><name>moveChunk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>originalBlockCount</name></expr></argument>, <argument><expr><name>postEvacuationBlockCount</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <assert>assert <expr><name><name>c</name><operator>.</operator><name>block</name></name> <operator>&lt;</operator> <name>originalBlockCount</name></expr>;</assert>
                    <expr_stmt><expr><name>movedToEOF</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <assert>assert <expr><name>postEvacuationBlockCount</name> <operator>&gt;=</operator> <call><name>getAfterLastBlock</name><argument_list>()</argument_list></call></expr>;</assert>

            <if_stmt><if>if <condition>(<expr><name>movedToEOF</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>boolean</name></type> <name>moved</name> <init>= <expr><call><name>moveChunkInside</name><argument_list>(<argument><expr><name>chunkToMove</name></expr></argument>, <argument><expr><name>originalBlockCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// store a new chunk with updated metadata (hopefully within a file)</comment>
                <expr_stmt><expr><call><name>store</name><argument_list>(<argument><expr><name>originalBlockCount</name></expr></argument>, <argument><expr><name>postEvacuationBlockCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// if chunkToMove did not fit within originalBlockCount (move is</comment>
                <comment type="line">// false), and since now previously reserved area</comment>
                <comment type="line">// [originalBlockCount, postEvacuationBlockCount) also can be</comment>
                <comment type="line">// used, lets try to move that chunk into this area, closer to</comment>
                <comment type="line">// the beginning of the file</comment>
                <decl_stmt><decl><type><name>long</name></type> <name>lastBoundary</name> <init>= <expr><ternary><condition><expr><name>moved</name> <operator>||</operator> <name>chunkToMoveIsAlreadyInside</name></expr> ?</condition><then>
                                        <expr><name>postEvacuationBlockCount</name></expr> </then><else>: <expr><name><name>chunkToMove</name><operator>.</operator><name>block</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>moved</name> <operator>=</operator> <operator>!</operator><name>moved</name> <operator>&amp;&amp;</operator> <call><name>moveChunkInside</name><argument_list>(<argument><expr><name>chunkToMove</name></expr></argument>, <argument><expr><name>lastBoundary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>moveChunkInside</name><argument_list>(<argument><expr><name>lastChunk</name></expr></argument>, <argument><expr><name>lastBoundary</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>moved</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>store</name><argument_list>(<argument><expr><name>lastBoundary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>shrinkFileIfPossible</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>store</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>reservedLow</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>reservedHigh</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><call><name>storeNow</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>reservedLow</name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name>reservedHigh</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>moveChunkInside</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunkToMove</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>boundary</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>res</name> <init>= <expr><name><name>chunkToMove</name><operator>.</operator><name>block</name></name> <operator>&gt;=</operator> <name>boundary</name> <operator>&amp;&amp;</operator>
                <call><name><name>fileStore</name><operator>.</operator><name>predictAllocation</name></name><argument_list>(<argument><expr><name><name>chunkToMove</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>boundary</name> <operator>&amp;&amp;</operator>
                <call><name>moveChunk</name><argument_list>(<argument><expr><name>chunkToMove</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><operator>!</operator><name>res</name> <operator>||</operator> <name><name>chunkToMove</name><operator>.</operator><name>block</name></name> <operator>+</operator> <name><name>chunkToMove</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name>boundary</name></expr>;</assert>
        <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Move specified chunk into free area of the file. "Reserved" area
     * specifies file interval to be avoided, when un-allocated space will be
     * chosen for a new chunk's location.
     *
     * @param chunk to move
     * @param reservedAreaLow low boundary of reserved area, inclusive
     * @param reservedAreaHigh high boundary of reserved area, exclusive
     * @return true if block was moved, false otherwise
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>moveChunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunk</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>reservedAreaLow</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>reservedAreaHigh</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// ignore if already removed during the previous store operations</comment>
        <comment type="line">// those are possible either as explicit commit calls</comment>
        <comment type="line">// or from meta map updates at the end of this method</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>chunks</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><name><name>chunk</name><operator>.</operator><name>block</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>chunk</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>block</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WriteBuffer</name></type> <name>buff</name> <init>= <expr><call><name>getWriteBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>limit</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>readBuff</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>chunkFromFile</name> <init>= <expr><call><name><name>Chunk</name><operator>.</operator><name>readChunkHeader</name></name><argument_list>(<argument><expr><name>readBuff</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>chunkHeaderLen</name> <init>= <expr><call><name><name>readBuff</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>chunkHeaderLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>readBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>reservedAreaLow</name></expr></argument>, <argument><expr><name>reservedAreaHigh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>block</name> <operator>=</operator> <name>pos</name> <operator>/</operator> <name>BLOCK_SIZE</name></expr>;</expr_stmt>
            <comment type="line">// in the absence of a reserved area,</comment>
            <comment type="line">// block should always move closer to the beginning of the file</comment>
            <assert>assert <expr><name>reservedAreaHigh</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>block</name> <operator>&lt;=</operator> <name><name>chunk</name><operator>.</operator><name>block</name></name> <operator>:</operator> <name>block</name> <operator>+</operator> <literal type="string">" "</literal> <operator>+</operator> <name>chunk</name></expr>;</assert>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// can not set chunk's new block/len until it's fully written at new location,</comment>
            <comment type="line">// because concurrent reader can pick it up prematurely,</comment>
            <comment type="line">// also occupancy accounting fields should not leak into header</comment>
            <expr_stmt><expr><name><name>chunkFromFile</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>chunkFromFile</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>chunkFromFile</name><operator>.</operator><name>writeChunkHeader</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>chunkHeaderLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>length</name> <operator>-</operator> <name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>chunkFromFile</name><operator>.</operator><name>getFooterBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name><name>buff</name><operator>.</operator><name>getBuffer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name>releaseWriteBuffer</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
        <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>chunk</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>chunk</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>Chunk</name><operator>.</operator><name>getMetaKey</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>chunk</name><operator>.</operator><name>asString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Force all stored changes to be written to the storage. The default
     * implementation calls FileChannel.force(true).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>sync</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>FileStore</name></type> <name>f</name> <init>= <expr><name>fileStore</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>f</name><operator>.</operator><name>sync</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Compact store file, that is, compact blocks that have a low
     * fill rate, and move chunks next to each other. This will typically
     * shrink the file. Changes are flushed to the file, and old
     * chunks are overwritten.
     *
     * @param maxCompactTime the maximum time in milliseconds to compact
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>compactFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxCompactTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>setRetentionTime</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>stopAt</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>maxCompactTime</name> <operator>*</operator> <literal type="number">1_000_000L</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name>compact</name><argument_list>(<argument><expr><literal type="number">95</literal></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>compactMoveChunks</name><argument_list>(<argument><expr><literal type="number">95</literal></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>stopAt</name> <operator>&gt;</operator> <literal type="number">0L</literal></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Try to increase the fill rate by re-writing partially full chunks. Chunks
     * with a low number of live items are re-written.
     * &lt;p&gt;
     * If the current fill rate is higher than the target fill rate, nothing is
     * done.
     * &lt;p&gt;
     * Please note this method will not necessarily reduce the file size, as
     * empty chunks are not overwritten.
     * &lt;p&gt;
     * Only data of open maps can be moved. For maps that are not open, the old
     * chunk is still referenced. Therefore, it is recommended to open all maps
     * before calling this method.
     *
     * @param targetFillRate the minimum percentage of live entries
     * @param write the minimum number of bytes to write
     * @return if a chunk was re-written
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>compact</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetFillRate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>write</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>reuseSpace</name> <operator>&amp;&amp;</operator> <name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>targetFillRate</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>getChunksFillRate</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>targetFillRate</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// We can't wait forever for the lock here,</comment>
                <comment type="line">// because if called from the background thread,</comment>
                <comment type="line">// it might go into deadlock with concurrent database closure</comment>
                <comment type="line">// and attempt to stop this thread.</comment>
                <try>try <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>storeLock</name><operator>.</operator><name>tryLock</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <try>try <block>{<block_content>
                            <return>return <expr><call><name>rewriteChunks</name><argument_list>(<argument><expr><name>write</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</return>
                        </block_content>}</block> <finally>finally <block>{<block_content>
                            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></finally></try>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></catch></try>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>rewriteChunks</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writeLimit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetFillRate</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>TxCounter</name></type> <name>txCounter</name> <init>= <expr><call><name>registerVersionUsage</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><call><name>acceptChunkOccupancyChanges</name><argument_list>(<argument><expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>old</name> <init>= <expr><call><name>findOldChunks</name><argument_list>(<argument><expr><name>writeLimit</name></expr></argument>, <argument><expr><name>targetFillRate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>old</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>idSet</name> <init>= <expr><call><name>createIdSet</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <return>return <expr><operator>!</operator><call><name><name>idSet</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>compactRewrite</name><argument_list>(<argument><expr><name>idSet</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name>deregisterVersionUsage</name><argument_list>(<argument><expr><name>txCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current fill rate (percentage of used space in the file). Unlike
     * the fill rate of the store, here we only account for chunk data; the fill
     * rate here is how much of the chunk data is live (still referenced). Young
     * chunks are considered live.
     *
     * @return the fill rate, in percent (100 is completely full)
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getChunksFillRate</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getChunksFillRate</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getRewritableChunksFillRate</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getChunksFillRate</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getChunksFillRate</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>maxLengthSum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>maxLengthLiveSum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>time</name> <init>= <expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>all</name> <operator>||</operator> <call><name>isRewritable</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <assert>assert <expr><name><name>c</name><operator>.</operator><name>maxLen</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</assert>
                <expr_stmt><expr><name>maxLengthSum</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLen</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>maxLengthLiveSum</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLenLive</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="line">// the fill rate of all chunks combined</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>fillRate</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <name>maxLengthLiveSum</name> <operator>/</operator> <name>maxLengthSum</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>fillRate</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get data chunks count.
     *
     * @return number of existing chunks in store.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getChunkCount</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>chunks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get data pages count.
     *
     * @return number of existing pages in store.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getPageCount</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>chunk</name><operator>.</operator><name>pageCount</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>count</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get live data pages count.
     *
     * @return number of existing live pages in store.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getLivePageCount</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>chunk</name><operator>.</operator><name>pageCountLive</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>count</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getProjectedFillRate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>thresholdChunkFillRate</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>vacatedBlocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>maxLengthSum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>maxLengthLiveSum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>time</name> <init>= <expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <assert>assert <expr><name><name>c</name><operator>.</operator><name>maxLen</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</assert>
                <if_stmt><if>if <condition>(<expr><call><name>isRewritable</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>c</name><operator>.</operator><name>getFillRate</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>thresholdChunkFillRate</name></expr>)</condition> <block>{<block_content>
                    <assert>assert <expr><name><name>c</name><operator>.</operator><name>maxLen</name></name> <operator>&gt;=</operator> <name><name>c</name><operator>.</operator><name>maxLenLive</name></name></expr>;</assert>
                    <expr_stmt><expr><name>vacatedBlocks</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maxLengthSum</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLen</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maxLengthLiveSum</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLenLive</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <decl_stmt><decl><type><name>int</name></type> <name>additionalBlocks</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>vacatedBlocks</name> <operator>*</operator> <name>maxLengthLiveSum</name> <operator>/</operator> <name>maxLengthSum</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fillRate</name> <init>= <expr><call><name><name>fileStore</name><operator>.</operator><name>getProjectedFillRate</name></name><argument_list>(<argument><expr><name>vacatedBlocks</name> <operator>-</operator> <name>additionalBlocks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>fillRate</name></expr>;</return>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getFillRate</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <return>return <expr><call><name><name>fileStore</name><operator>.</operator><name>getFillRate</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>findOldChunks</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writeLimit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetFillRate</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <decl_stmt><decl><type><name>long</name></type> <name>time</name> <init>= <expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// the queue will contain chunks we want to free up</comment>
        <comment type="line">// the smaller the collectionPriority, the more desirable this chunk's re-write is</comment>
        <comment type="line">// queue will be ordered in descending order of collectionPriority values,</comment>
        <comment type="line">// so most desirable chunks will stay at the tail</comment>
        <decl_stmt><decl><type><name><name>PriorityQueue</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>queue</name> <init>= <expr><operator>new</operator> <call><name><name>PriorityQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>chunks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><lambda><parameter_list>(<parameter><decl><name>o1</name></decl></parameter>, <parameter><decl><name>o2</name></decl></parameter>)</parameter_list> -&gt; <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>comp</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name><name>o2</name><operator>.</operator><name>collectPriority</name></name></expr></argument>, <argument><expr><name><name>o1</name><operator>.</operator><name>collectPriority</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>comp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>comp</name> <operator>=</operator> <call><name><name>Long</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name><name>o2</name><operator>.</operator><name>maxLenLive</name></name></expr></argument>, <argument><expr><name><name>o1</name><operator>.</operator><name>maxLenLive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>comp</name></expr>;</return>
                </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>totalSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>latestVersion</name> <init>= <expr><name><name>lastChunk</name><operator>.</operator><name>version</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>chunk</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <comment type="line">// only look at chunk older than the retention time</comment>
            <comment type="line">// (it's possible to compact chunks earlier, but right</comment>
            <comment type="line">// now we don't do that)</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>fillRate</name> <init>= <expr><call><name><name>chunk</name><operator>.</operator><name>getFillRate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>isRewritable</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>fillRate</name> <operator>&lt;=</operator> <name>targetFillRate</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>age</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>latestVersion</name> <operator>-</operator> <name><name>chunk</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>chunk</name><operator>.</operator><name>collectPriority</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>fillRate</name> <operator>*</operator> <literal type="number">1000</literal> <operator>/</operator> <name>age</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>totalSize</name> <operator>+=</operator> <name><name>chunk</name><operator>.</operator><name>maxLenLive</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>queue</name><operator>.</operator><name>offer</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>totalSize</name> <operator>&gt;</operator> <name>writeLimit</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>removed</name> <init>= <expr><call><name><name>queue</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>removed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>totalSize</name> <operator>-=</operator> <name><name>removed</name><operator>.</operator><name>maxLenLive</name></name></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <return>return <expr><ternary><condition><expr><call><name><name>queue</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name>queue</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isRewritable</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunk</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>time</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>chunk</name><operator>.</operator><name>isRewritable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isSeasonedChunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>compactRewrite</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>set</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><name>currentStoreVersion</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</assert> <comment type="line">// we should be able to do tryCommit() -&gt; store()</comment>
        <expr_stmt><expr><call><name>acceptChunkOccupancyChanges</name><argument_list>(<argument><expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rewrittenPageCount</name> <init>= <expr><call><name>rewriteChunks</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>acceptChunkOccupancyChanges</name><argument_list>(<argument><expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rewrittenPageCount</name> <operator>+=</operator> <call><name>rewriteChunks</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rewrittenPageCount</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>rewriteChunks</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>set</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>secondPass</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rewrittenPageCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>chunkId</name> <range>: <expr><name>set</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><call><name><name>chunks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>toc</name> <init>= <expr><call><name>getToC</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>toc</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>pageNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>pageNo</name> <operator>=</operator> <call><name><name>chunk</name><operator>.</operator><name>occupancy</name><operator>.</operator><name>nextClearBit</name></name><argument_list>(<argument><expr><name>pageNo</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name><name>chunk</name><operator>.</operator><name>pageCount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>pageNo</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>long</name></type> <name>tocElement</name> <init>= <expr><name><name>toc</name><index>[<expr><name>pageNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>mapId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageMapId</name></name><argument_list>(<argument><expr><name>tocElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><ternary><condition><expr><name>mapId</name> <operator>==</operator> <call><name><name>layout</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>layout</name></expr> </then><else>: <expr><ternary><condition><expr><name>mapId</name> <operator>==</operator> <call><name><name>meta</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>meta</name></expr> </then><else>: <expr><call><name>getMap</name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>map</name><operator>.</operator><name>isClosed</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <assert>assert <expr><operator>!</operator><call><name><name>map</name><operator>.</operator><name>isSingleWriter</name></name><argument_list>()</argument_list></call></expr>;</assert>
                        <if_stmt><if>if <condition>(<expr><name>secondPass</name> <operator>||</operator> <call><name><name>DataUtils</name><operator>.</operator><name>isLeafPosition</name></name><argument_list>(<argument><expr><name>tocElement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <decl_stmt><decl><type><name>long</name></type> <name>pagePos</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPagePos</name></name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>, <argument><expr><name>tocElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <try>try <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name><name>map</name><operator>.</operator><name>rewritePage</name></name><argument_list>(<argument><expr><name>pagePos</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                                    <expr_stmt><expr><operator>++</operator><name>rewrittenPageCount</name></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>map</name> <operator>==</operator> <name>meta</name></expr>)</condition> <block>{<block_content>
                                        <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block> <finally>finally <block>{<block_content>
                                <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></finally></try>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>rewrittenPageCount</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>createIdSet</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>toCompact</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>set</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Chunk</name></type> <name>c</name> <range>: <expr><name>toCompact</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>set</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>set</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Read a page.
     *
     * @param &lt;K&gt; key type
     * @param &lt;V&gt; value type
     *
     * @param map the map
     * @param pos the page position
     * @return the page
     */</comment>
    <function><type><parameter_list type="generic">&lt;<parameter><name>K</name></parameter>,<parameter><name>V</name></parameter>&gt;</parameter_list> <name><name>Page</name><argument_list type="generic">&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>readPage</name><parameter_list>(<parameter><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <try>try <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>DataUtils</name><operator>.</operator><name>isPageSaved</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(
                        <argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_FILE_CORRUPT</name></name></expr></argument>, <argument><expr><literal type="string">"Position 0"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>p</name> <init>= <expr><call><name>readPageFromCache</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><call><name>getChunk</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pageOffset</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <try>try <block>{<block_content>
                    <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>buff</name> <init>= <expr><call><name><name>chunk</name><operator>.</operator><name>readBufferForPage</name></name><argument_list>(<argument><expr><name>fileStore</name></expr></argument>, <argument><expr><name>pageOffset</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>Page</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <throw>throw <expr><name>e</name></expr>;</throw>
                </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_FILE_CORRUPT</name></name></expr></argument>,
                            <argument><expr><literal type="string">"Unable to read the page at position {0}, chunk {1}, offset {2}"</literal></expr></argument>,
                            <argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>pageOffset</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></catch></try>
                <expr_stmt><expr><call><name>cachePage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>p</name></expr>;</return>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>recoveryMode</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>map</name><operator>.</operator><name>createEmptyLeaf</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>long</name><index>[]</index></name></type> <name>getToC</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunk</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>.</operator><name>tocPos</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// legacy chunk without table of content</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>toc</name> <init>= <expr><call><name><name>chunksToC</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name><name>chunk</name><operator>.</operator><name>readToC</name></name><argument_list>(<argument><expr><name>fileStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>chunksToC</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>toc</name></expr></argument>, <argument><expr><name><name>toc</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <assert>assert <expr><name><name>toc</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>chunk</name><operator>.</operator><name>pageCount</name></name> <operator>:</operator> <name><name>toc</name><operator>.</operator><name>length</name></name> <operator>+</operator> <literal type="string">" != "</literal> <operator>+</operator> <name><name>chunk</name><operator>.</operator><name>pageCount</name></name></expr>;</assert>
        <return>return <expr><name>toc</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>private</specifier> <parameter_list type="generic">&lt;<parameter><name>K</name></parameter>, <parameter><name>V</name></parameter>&gt;</parameter_list> <name><name>Page</name><argument_list type="generic">&lt;<argument><name>K</name></argument>, <argument><name>V</name></argument>&gt;</argument_list></name></type> <name>readPageFromCache</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>cache</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>(</operator><name><name>Page</name><argument_list type="generic">&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name><operator>)</operator><call><name><name>cache</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Remove a page.
     *  @param pos the position of the page
     * @param version at which page was removed
     * @param pinned whether page is considered pinned
     * @param pageNo sequential page number within chunk
     */</comment>
    <function><type><name>void</name></type> <name>accountForRemovedPage</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>pinned</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageNo</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>DataUtils</name><operator>.</operator><name>isPageSaved</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</assert>
        <if_stmt><if>if <condition>(<expr><name>pageNo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>pageNo</name> <operator>=</operator> <call><name>calculatePageNo</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>RemovedPageInfo</name></type> <name>rpi</name> <init>= <expr><operator>new</operator> <call><name>RemovedPageInfo</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pinned</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>pageNo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>removedPages</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>rpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>calculatePageNo</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>pageNo</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><call><name>getChunk</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>toC</name> <init>= <expr><call><name>getToC</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>toC</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>high</name> <init>= <expr><name><name>toC</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>midVal</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name><name>toC</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>midVal</name> <operator>&lt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>midVal</name> <operator>&gt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>pageNo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>pageNo</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>Compressor</name></type> <name>getCompressorFast</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>compressorFast</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>compressorFast</name> <operator>=</operator> <operator>new</operator> <call><name>CompressLZF</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>compressorFast</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>Compressor</name></type> <name>getCompressorHigh</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>compressorHigh</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>compressorHigh</name> <operator>=</operator> <operator>new</operator> <call><name>CompressDeflate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>compressorHigh</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>int</name></type> <name>getCompressionLevel</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>compressionLevel</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getPageSplitSize</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>pageSplitSize</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getKeysPerPage</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>keysPerPage</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMaxPageSize</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>cache</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr> </then><else>: <expr><call><name><name>cache</name><operator>.</operator><name>getMaxItemSize</name></name><argument_list>()</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getReuseSpace</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>reuseSpace</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Whether empty space in the file should be re-used. If enabled, old data
     * is overwritten (default). If disabled, writes are appended at the end of
     * the file.
     * &lt;p&gt;
     * This setting is specially useful for online backup. To create an online
     * backup, disable this setting, then copy the file (starting at the
     * beginning of the file). In this case, concurrent backup and write
     * operations are possible (obviously the backup process needs to be faster
     * than the write operations).
     *
     * @param reuseSpace the new value
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setReuseSpace</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>reuseSpace</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>reuseSpace</name></name> <operator>=</operator> <name>reuseSpace</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getRetentionTime</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>retentionTime</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * How long to retain old, persisted chunks, in milliseconds. Chunks that
     * are older may be overwritten once they contain no live data.
     * &lt;p&gt;
     * The default value is 45000 (45 seconds) when using the default file
     * store. It is assumed that a file system and hard disk will flush all
     * write buffers within this time. Using a lower value might be dangerous,
     * unless the file system and hard disk flush the buffers earlier. To
     * manually flush the buffers, use
     * &lt;code&gt;MVStore.getFile().force(true)&lt;/code&gt;, however please note that
     * according to various tests this does not always work as expected
     * depending on the operating system and hardware.
     * &lt;p&gt;
     * The retention time needs to be long enough to allow reading old chunks
     * while traversing over the entries of a map.
     * &lt;p&gt;
     * This setting is not persisted.
     *
     * @param ms how many milliseconds to retain old chunks (0 to overwrite them
     *            as early as possible)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRetentionTime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>retentionTime</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * How many versions to retain for in-memory stores. If not set, 5 old
     * versions are retained.
     *
     * @param count the number of versions to keep
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setVersionsToKeep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>versionsToKeep</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the oldest version to retain in memory (for in-memory stores).
     *
     * @return the version
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getVersionsToKeep</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>versionsToKeep</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the oldest version to retain.
     * We keep at least number of previous versions specified by "versionsToKeep"
     * configuration parameter (default 5).
     * Previously it was used only in case of non-persistent MVStore.
     * Now it's honored in all cases (although H2 always sets it to zero).
     * Oldest version determination also takes into account calls (de)registerVersionUsage(),
     * an will not release the version, while version is still in use.
     *
     * @return the version
     */</comment>
    <function><type><name>long</name></type> <name>getOldestVersionToKeep</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>v</name> <init>= <expr><call><name><name>oldestVersionToKeep</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>v</name> <operator>-</operator> <name>versionsToKeep</name></expr></argument>, <argument><expr><name>INITIAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fileStore</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>storeVersion</name> <init>= <expr><call><name>lastChunkVersion</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>storeVersion</name> <operator>!=</operator> <name>INITIAL_VERSION</name> <operator>&amp;&amp;</operator> <name>storeVersion</name> <operator>&lt;</operator> <name>v</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <name>storeVersion</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setOldestVersionToKeep</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>oldestVersionToKeep</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>success</name></decl>;</decl_stmt>
        <do>do <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>current</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>oldestVersionToKeep</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// Oldest version may only advance, never goes back</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>oldestVersionToKeep</name> <operator>&lt;=</operator> <name>current</name> <operator>||</operator>
                        <call><name><name>this</name><operator>.</operator><name>oldestVersionToKeep</name><operator>.</operator><name>compareAndSet</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>oldestVersionToKeep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>;</do>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>lastChunkVersion</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name> <init>= <expr><name>lastChunk</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>chunk</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>INITIAL_VERSION</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>chunk</name><operator>.</operator><name>version</name></name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check whether all data can be read from this version. This requires that
     * all chunks referenced by this version are still available (not
     * overwritten).
     *
     * @param version the version
     * @return true if all data can be read
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isKnownVersion</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>version</name> <operator>&gt;</operator> <name>currentVersion</name> <operator>||</operator> <name>version</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <name>currentVersion</name> <operator>||</operator> <call><name><name>chunks</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// no stored data</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// need to check if a chunk for this version exists</comment>
        <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name>getChunkForVersion</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// also, all chunks referenced by this version</comment>
        <comment type="line">// need to be available in the file</comment>
        <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>oldLayoutMap</name> <init>= <expr><call><name>getLayoutMap</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>oldLayoutMap</name><operator>.</operator><name>keyIterator</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>chunkKey</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>chunkKey</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>layout</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>chunkKey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>oldLayoutMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>chunkKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>c2</name> <init>= <expr><call><name><name>Chunk</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>test</name> <init>= <expr><call><name>readChunkHeaderAndFooter</name><argument_list>(<argument><expr><name><name>c2</name><operator>.</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>c2</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <comment type="line">// the chunk missing where the metadata is stored</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></catch></try>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Adjust amount of "unsaved memory" meaning amount of RAM occupied by pages
     * not saved yet to the file. This is the amount which triggers auto-commit.
     *
     * @param memory adjustment
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>registerUnsavedMemory</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memory</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// this counter was intentionally left unprotected against race</comment>
        <comment type="line">// condition for performance reasons</comment>
        <comment type="line">// TODO: evaluate performance impact of atomic implementation,</comment>
        <comment type="line">//       since updates to unsavedMemory are largely aggregated now</comment>
        <expr_stmt><expr><name>unsavedMemory</name> <operator>+=</operator> <name>memory</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>newValue</name> <init>= <expr><name>unsavedMemory</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>newValue</name> <operator>&gt;</operator> <name>autoCommitMemory</name> <operator>&amp;&amp;</operator> <name>autoCommitMemory</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>saveNeeded</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>boolean</name></type> <name>isSaveNeeded</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>saveNeeded</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * This method is called before writing to a map.
     *
     * @param map the map
     */</comment>
    <function><type><name>void</name></type> <name>beforeWrite</name><parameter_list>(<parameter><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>saveNeeded</name> <operator>&amp;&amp;</operator> <name>fileStore</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name>isOpenOrStopping</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
                <comment type="line">// condition below is to prevent potential deadlock,</comment>
                <comment type="line">// because we should never seek storeLock while holding</comment>
                <comment type="line">// map root lock</comment>
                <operator>(</operator><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>map</name><operator>.</operator><name>getRoot</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isLockedByCurrentThread</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
                <comment type="line">// to avoid infinite recursion via store() -&gt; dropUnusedChunks() -&gt; layout.remove()</comment>
                <name>map</name> <operator>!=</operator> <name>layout</name></expr>)</condition> <block>{<block_content>

            <expr_stmt><expr><name>saveNeeded</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <comment type="line">// check again, because it could have been written by now</comment>
            <if_stmt><if>if <condition>(<expr><name>autoCommitMemory</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>needStore</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// if unsaved memory creation rate is to high,</comment>
                <comment type="line">// some back pressure need to be applied</comment>
                <comment type="line">// to slow things down and avoid OOME</comment>
                <if_stmt><if>if <condition>(<expr><call><name>requireStore</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>map</name><operator>.</operator><name>isSingleWriter</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>commit</name><argument_list>(<argument><expr><name>MVStore</name><operator>::</operator><name>requireStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>tryCommit</name><argument_list>(<argument><expr><name>MVStore</name><operator>::</operator><name>needStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>requireStore</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><literal type="number">3</literal> <operator>*</operator> <name>unsavedMemory</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>*</operator> <name>autoCommitMemory</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>needStore</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>unsavedMemory</name> <operator>&gt;</operator> <name>autoCommitMemory</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the store version. The store version is usually used to upgrade the
     * structure of the store after upgrading the application. Initially the
     * store version is 0, until it is changed.
     *
     * @return the store version
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getStoreVersion</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>x</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"setting.storeVersion"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>x</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseHexInt</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Update the store version.
     *
     * @param version the new store version
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStoreVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"setting.storeVersion"</literal></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Revert to the beginning of the current version, reverting all uncommitted
     * changes.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>rollback</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>rollbackTo</name><argument_list>(<argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Revert to the beginning of the given version. All later changes (stored
     * or not) are forgotten. All maps that were created later are closed. A
     * rollback to a version before the last stored version is immediately
     * persisted. Rollback to version 0 means all data is removed.
     *
     * @param version the version to revert to
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>rollbackTo</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>currentVersion</name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// special case: remove all data</comment>
                <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>setInitialRoot</name></name><argument_list>(<argument><expr><call><name><name>layout</name><operator>.</operator><name>createEmptyLeaf</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INITIAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>setInitialRoot</name></name><argument_list>(<argument><expr><call><name><name>meta</name><operator>.</operator><name>createEmptyLeaf</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INITIAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>META_ID_KEY</name></expr></argument>, <argument><expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>meta</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>deadChunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>removedPages</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clearCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fileStore</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <try>try <block>{<block_content>
                        <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <finally>finally <block>{<block_content>
                        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>lastChunk</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>versions</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setWriteVersion</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>metaChanged</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>m</name> <range>: <expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>m</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>checkArgument</name></name><argument_list>(
                    <argument><expr><call><name>isKnownVersion</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><literal type="string">"Unknown version {0}"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>TxCounter</name></type> <name>txCounter</name></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>txCounter</name> <operator>=</operator> <call><name><name>versions</name><operator>.</operator><name>peekLast</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>txCounter</name><operator>.</operator><name>version</name></name> <operator>&gt;=</operator> <name>version</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>versions</name><operator>.</operator><name>removeLast</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>currentTxCounter</name> <operator>=</operator> <operator>new</operator> <call><name>TxCounter</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>layout</name><operator>.</operator><name>rollbackRoot</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>layoutMap</name> <init>= <expr><call><name>getLayoutMap</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>layout</name><operator>.</operator><name>setInitialRoot</name></name><argument_list>(<argument><expr><call><name><name>layoutMap</name><operator>.</operator><name>getRootPage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>meta</name><operator>.</operator><name>rollbackRoot</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>setRootPos</name></name><argument_list>(<argument><expr><call><name>getRootPos</name><argument_list>(<argument><expr><call><name><name>meta</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>version</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>metaChanged</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>m</name> <range>: <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>m</name><operator>.</operator><name>getCreateVersion</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>version</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>m</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>maps</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>m</name><operator>.</operator><name>rollbackRoot</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>m</name><operator>.</operator><name>setRootPos</name></name><argument_list>(<argument><expr><call><name>getRootPos</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>version</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name><name>deadChunks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>removedPages</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clearCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>keep</name> <init>= <expr><call><name>getChunkForVersion</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>keep</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <try>try <block>{<block_content>
                        <expr_stmt><expr><call><name>setLastChunk</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>storeHeader</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>HDR_CLEAN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>writeStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>readStoreHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <finally>finally <block>{<block_content>
                        <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name><name>serializationLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
            <expr_stmt><expr><call><name>onVersionChange</name><argument_list>(<argument><expr><name>currentVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><operator>!</operator><call><name>hasUnsavedChanges</name><argument_list>()</argument_list></call></expr>;</assert>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>clearCaches</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>cache</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>chunksToC</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>chunksToC</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>getRootPos</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mapId</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>root</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapRootKey</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>root</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseHexLong</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current version of the data. When a new store is created, the
     * version is 0.
     *
     * @return the version
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getCurrentVersion</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>currentVersion</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the file store.
     *
     * @return the file store
     */</comment>
    <function><type><specifier>public</specifier> <name>FileStore</name></type> <name>getFileStore</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>fileStore</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the store header. This data is for informational purposes only. The
     * data is subject to change in future versions. The data should not be
     * modified (doing so may corrupt the store).
     *
     * @return the store header
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>getStoreHeader</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>storeHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>checkOpen</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isOpenOrStopping</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>newMVStoreException</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>ERROR_CLOSED</name></name></expr></argument>,
                    <argument><expr><literal type="string">"This store is closed"</literal></expr></argument>, <argument><expr><name>panicException</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Rename a map.
     *
     * @param map the map
     * @param newName the new name
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>renameMap</name><parameter_list>(<parameter><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>newName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><name>map</name> <operator>!=</operator> <name>layout</name> <operator>&amp;&amp;</operator> <name>map</name> <operator>!=</operator> <name>meta</name></expr></argument>,
                <argument><expr><literal type="string">"Renaming the meta map is not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name><name>map</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>oldName</name> <init>= <expr><call><name>getMapName</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>oldName</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>oldName</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>idHexStr</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// at first create a new name as an "alias"</comment>
            <decl_stmt><decl><type><name>String</name></type> <name>existingIdHexStr</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>newName</name></expr></argument>, <argument><expr><name>idHexStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// we need to cope with the case of previously unfinished rename</comment>
            <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>checkArgument</name></name><argument_list>(
                    <argument><expr><name>existingIdHexStr</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>existingIdHexStr</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>idHexStr</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><literal type="string">"A map named {0} already exists"</literal></expr></argument>, <argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// switch roles of a new and old names - old one is an alias now</comment>
            <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>map</name><operator>.</operator><name>asString</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// get rid of the old name completely</comment>
            <expr_stmt><expr><call><name><name>meta</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>oldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Remove a map from the current version of the store.
     *
     * @param map the map to remove
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeMap</name><parameter_list>(<parameter><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>checkOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><name>layout</name> <operator>!=</operator> <name>meta</name> <operator>&amp;&amp;</operator> <name>map</name> <operator>!=</operator> <name>meta</name></expr></argument>,
                    <argument><expr><literal type="string">"Removing the meta map is not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>RootReference</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rootReference</name> <init>= <expr><call><name><name>map</name><operator>.</operator><name>clearIt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>updateCounter</name> <operator>+=</operator> <name><name>rootReference</name><operator>.</operator><name>updateCounter</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateAttemptCounter</name> <operator>+=</operator> <name><name>rootReference</name><operator>.</operator><name>updateAttemptCounter</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name><name>map</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> <init>= <expr><call><name>getMapName</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>meta</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>meta</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Performs final stage of map removal - delete root location info from the layout table.
     * Map is supposedly closed and anonymous and has no outstanding usage by now.
     *
     * @param mapId to deregister
     */</comment>
    <function><type><name>void</name></type> <name>deregisterMapRoot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mapId</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>layout</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapRootKey</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Remove map by name.
     *
     * @param name the map name
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeMap</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>getMapId</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><name>id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><call><name>getMap</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>map</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>openMap</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>MVStoreTool</name><operator>.</operator><name>getGenericMapBuilder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>removeMap</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the name of the given map.
     *
     * @param id the map id
     * @return the name, or null if not found
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getMapName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>m</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>m</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name><name>DataUtils</name><operator>.</operator><name>getMapName</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getMapId</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>m</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name> <operator>+</operator> <name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>m</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name><name>DataUtils</name><operator>.</operator><name>parseHexInt</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Commit and save all changes, if there are any, and compact the store if
     * needed.
     */</comment>
    <function><type><name>void</name></type> <name>writeInBackground</name><parameter_list>()</parameter_list> <block>{<block_content>
        <try>try <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isOpenOrStopping</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isReadOnly</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// could also commit when there are many unsaved pages,</comment>
            <comment type="line">// but according to a test it doesn't really help</comment>

            <decl_stmt><decl><type><name>long</name></type> <name>time</name> <init>= <expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>time</name> <operator>&gt;</operator> <name>lastCommitTime</name> <operator>+</operator> <name>autoCommitDelay</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tryCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>autoCompactFillRate</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><operator>-</operator><call><name>getTargetFillRate</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>autoCommitMemory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fillRate</name> <init>= <expr><call><name>getFillRate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>fileStore</name><operator>.</operator><name>isFragmented</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>fillRate</name> <operator>&lt;</operator> <name>autoCompactFillRate</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>storeLock</name><operator>.</operator><name>tryLock</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <try>try <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>moveSize</name> <init>= <expr><name>autoCommitMemory</name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name>isIdle</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>moveSize</name> <operator>*=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>compactMoveChunks</name><argument_list>(<argument><expr><literal type="number">101</literal></expr></argument>, <argument><expr><name>moveSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <finally>finally <block>{<block_content>
                        <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fillRate</name> <operator>&gt;=</operator> <name>autoCompactFillRate</name> <operator>&amp;&amp;</operator> <name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>chunksFillRate</name> <init>= <expr><call><name>getRewritableChunksFillRate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>chunksFillRate</name> <operator>=</operator> <ternary><condition><expr><call><name>isIdle</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">100</literal> <operator>-</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>chunksFillRate</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr> </then><else>: <expr><name>chunksFillRate</name></expr></else></ternary></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>chunksFillRate</name> <operator>&lt;</operator> <call><name>getTargetFillRate</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>storeLock</name><operator>.</operator><name>tryLock</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <try>try <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>writeLimit</name> <init>= <expr><name>autoCommitMemory</name> <operator>*</operator> <name>fillRate</name> <operator>/</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>chunksFillRate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isIdle</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><name>writeLimit</name> <operator>/=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <if_stmt><if>if <condition>(<expr><call><name>rewriteChunks</name><argument_list>(<argument><expr><name>writeLimit</name></expr></argument>, <argument><expr><name>chunksFillRate</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><call><name>dropUnusedChunks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block> <finally>finally <block>{<block_content>
                            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></finally></try>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>autoCompactLastFileOpCount</name> <operator>=</operator> <call><name><name>fileStore</name><operator>.</operator><name>getWriteCount</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>fileStore</name><operator>.</operator><name>getReadCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>ignore</name></decl></parameter>)</parameter_list> <block>{<block_content>
        </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>handleException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>backgroundExceptionHandler</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><name>e</name></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>doMaintenance</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetFillRate</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>autoCompactFillRate</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lastChunk</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>reuseSpace</name></expr>)</condition> <block>{<block_content>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>lastProjectedFillRate</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>fillRate</name> <init>= <expr><call><name>getFillRate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>projectedFillRate</name> <init>= <expr><name>fillRate</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fillRate</name> <operator>&gt;</operator> <name>targetFillRate</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>projectedFillRate</name> <operator>=</operator> <call><name>getProjectedFillRate</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>projectedFillRate</name> <operator>&gt;</operator> <name>targetFillRate</name> <operator>||</operator> <name>projectedFillRate</name> <operator>&lt;=</operator> <name>lastProjectedFillRate</name></expr>)</condition> <block>{<block_content>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>lastProjectedFillRate</name> <operator>=</operator> <name>projectedFillRate</name></expr>;</expr_stmt>
                    <comment type="line">// We can't wait forever for the lock here,</comment>
                    <comment type="line">// because if called from the background thread,</comment>
                    <comment type="line">// it might go into deadlock with concurrent database closure</comment>
                    <comment type="line">// and attempt to stop this thread.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>storeLock</name><operator>.</operator><name>tryLock</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <try>try <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>writeLimit</name> <init>= <expr><name>autoCommitMemory</name> <operator>*</operator> <name>targetFillRate</name> <operator>/</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>projectedFillRate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>projectedFillRate</name> <operator>&lt;</operator> <name>fillRate</name></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>rewriteChunks</name><argument_list>(<argument><expr><name>writeLimit</name></expr></argument>, <argument><expr><name>targetFillRate</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dropUnusedChunks</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compactMoveChunks</name><argument_list>(<argument><expr><literal type="number">101</literal></expr></argument>, <argument><expr><name>writeLimit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block> <finally>finally <block>{<block_content>
                        <expr_stmt><expr><call><name>unlockAndCheckPanicCondition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block></for>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getTargetFillRate</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>targetRate</name> <init>= <expr><name>autoCompactFillRate</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// use a lower fill rate if there were any file operations since the last time</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isIdle</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>targetRate</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>targetRate</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isIdle</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>autoCompactLastFileOpCount</name> <operator>==</operator> <call><name><name>fileStore</name><operator>.</operator><name>getWriteCount</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>fileStore</name><operator>.</operator><name>getReadCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleException</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>backgroundExceptionHandler</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <try>try <block>{<block_content>
                <expr_stmt><expr><call><name><name>backgroundExceptionHandler</name><operator>.</operator><name>uncaughtException</name></name><argument_list>(<argument><expr><call><name><name>Thread</name><operator>.</operator><name>currentThread</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ex</name> <operator>!=</operator> <name>e</name></expr>)</condition> <block>{<block_content> <comment type="line">// OOME may be the same</comment>
                    <expr_stmt><expr><call><name><name>ex</name><operator>.</operator><name>addSuppressed</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the read cache size in MB.
     *
     * @param mb the cache size in MB.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCacheSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mb</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>bytes</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator> <name>mb</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>cache</name><operator>.</operator><name>setMaxMemory</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cache</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isOpen</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>state</name> <operator>==</operator> <name>STATE_OPEN</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Determine that store is open, or wait for it to be closed (by other thread)
     * @return true if store is open, false otherwise
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isClosed</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isOpen</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <assert>assert <expr><name>state</name> <operator>==</operator> <name>STATE_CLOSED</name></expr>;</assert>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isOpenOrStopping</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>state</name> <operator>&lt;=</operator> <name>STATE_STOPPING</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>stopBackgroundThread</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>waitForIt</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// Loop here is not strictly necessary, except for case of a spurious failure,</comment>
        <comment type="line">// which should not happen with non-weak flavour of CAS operation,</comment>
        <comment type="line">// but I've seen it, so just to be safe...</comment>
        <decl_stmt><decl><type><name>BackgroundWriterThread</name></type> <name>t</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name><name>backgroundWriterThread</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>backgroundWriterThread</name><operator>.</operator><name>compareAndSet</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// if called from within the thread itself - can not join</comment>
                <if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <call><name><name>Thread</name><operator>.</operator><name>currentThread</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <synchronized>synchronized <init>(<expr><name><name>t</name><operator>.</operator><name>sync</name></name></expr>)</init> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>sync</name><operator>.</operator><name>notifyAll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></synchronized>

                    <if_stmt><if>if <condition>(<expr><name>waitForIt</name></expr>)</condition> <block>{<block_content>
                        <try>try <block>{<block_content>
                            <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                            <comment type="line">// ignore</comment>
                        </block_content>}</block></catch></try>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>shutdownExecutor</name><argument_list>(<argument><expr><name>serializationExecutor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>serializationExecutor</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>shutdownExecutor</name><argument_list>(<argument><expr><name>bufferSaveExecutor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bufferSaveExecutor</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the maximum delay in milliseconds to auto-commit changes.
     * &lt;p&gt;
     * To disable auto-commit, set the value to 0. In this case, changes are
     * only committed when explicitly calling commit.
     * &lt;p&gt;
     * The default is 1000, meaning all changes are committed after at most one
     * second.
     *
     * @param millis the maximum delay
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setAutoCommitDelay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>millis</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>autoCommitDelay</name> <operator>==</operator> <name>millis</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>autoCommitDelay</name> <operator>=</operator> <name>millis</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fileStore</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>fileStore</name><operator>.</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>stopBackgroundThread</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// start the background thread if needed</comment>
        <if_stmt><if>if <condition>(<expr><name>millis</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isOpen</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>sleep</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>millis</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BackgroundWriterThread</name></type> <name>t</name> <init>=
                    <expr><operator>new</operator> <call><name>BackgroundWriterThread</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>sleep</name></expr></argument>,
                            <argument><expr><call><name><name>fileStore</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>backgroundWriterThread</name><operator>.</operator><name>compareAndSet</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>serializationExecutor</name> <operator>=</operator> <call><name>createSingleThreadExecutor</name><argument_list>(<argument><expr><literal type="string">"H2-serialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bufferSaveExecutor</name> <operator>=</operator> <call><name>createSingleThreadExecutor</name><argument_list>(<argument><expr><literal type="string">"H2-save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>ThreadPoolExecutor</name></type> <name>createSingleThreadExecutor</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>threadName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>ThreadPoolExecutor</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>,
                                        <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>r</name></decl></parameter></parameter_list> -&gt; <block>{<block_content>
                                            <decl_stmt><decl><type><name>Thread</name></type> <name>thread</name> <init>= <expr><operator>new</operator> <call><name>Thread</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>threadName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                            <expr_stmt><expr><call><name><name>thread</name><operator>.</operator><name>setDaemon</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <return>return <expr><name>thread</name></expr>;</return>
                                        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isBackgroundThread</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>Thread</name><operator>.</operator><name>currentThread</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>backgroundWriterThread</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the auto-commit delay.
     *
     * @return the delay in milliseconds, or 0 if auto-commit is disabled.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getAutoCommitDelay</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>autoCommitDelay</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the maximum memory (in bytes) used for unsaved pages. If this number
     * is exceeded, unsaved changes are stored to disk.
     *
     * @return the memory in bytes
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getAutoCommitMemory</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>autoCommitMemory</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the estimated memory (in bytes) of unsaved data. If the value exceeds
     * the auto-commit memory, the changes are committed.
     * &lt;p&gt;
     * The returned value is an estimation only.
     *
     * @return the memory in bytes
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getUnsavedMemory</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>unsavedMemory</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Put the page in the cache.
     * @param page the page
     */</comment>
    <function><type><name>void</name></type> <name>cachePage</name><parameter_list>(<parameter><decl><type><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>page</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>cache</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>page</name><operator>.</operator><name>getPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><call><name><name>page</name><operator>.</operator><name>getMemory</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the amount of memory used for caching, in MB.
     * Note that this does not include the page chunk references cache, which is
     * 25% of the size of the page cache.
     *
     * @return the amount of memory used for caching
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCacheSizeUsed</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name><name>cache</name><operator>.</operator><name>getUsedMemory</name></name><argument_list>()</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">20</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the maximum cache size, in MB.
     * Note that this does not include the page chunk references cache, which is
     * 25% of the size of the page cache.
     *
     * @return the cache size
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCacheSize</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name><name>cache</name><operator>.</operator><name>getMaxMemory</name></name><argument_list>()</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">20</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the cache.
     *
     * @return the cache
     */</comment>
    <function><type><specifier>public</specifier> <name><name>CacheLongKeyLIRS</name><argument_list type="generic">&lt;<argument><name><name>Page</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getCache</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>cache</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Whether the store is read-only.
     *
     * @return true if it is
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isReadOnly</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>fileStore</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>fileStore</name><operator>.</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCacheHitRatio</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getCacheHitRatio</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getTocCacheHitRatio</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getCacheHitRatio</name><argument_list>(<argument><expr><name>chunksToC</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getCacheHitRatio</name><parameter_list>(<parameter><decl><type><name><name>CacheLongKeyLIRS</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cache</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cache</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>hits</name> <init>= <expr><call><name><name>cache</name><operator>.</operator><name>getHits</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <name>hits</name> <operator>/</operator> <operator>(</operator><name>hits</name> <operator>+</operator> <call><name><name>cache</name><operator>.</operator><name>getMisses</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getLeafRatio</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>leafCount</name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>leafCount</name> <operator>+</operator> <name>nonLeafCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getUpdateFailureRatio</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>updateCounter</name> <init>= <expr><name><name>this</name><operator>.</operator><name>updateCounter</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>updateAttemptCounter</name> <init>= <expr><name><name>this</name><operator>.</operator><name>updateAttemptCounter</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>RootReference</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rootReference</name> <init>= <expr><call><name><name>layout</name><operator>.</operator><name>getRoot</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>updateCounter</name> <operator>+=</operator> <name><name>rootReference</name><operator>.</operator><name>updateCounter</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>updateAttemptCounter</name> <operator>+=</operator> <name><name>rootReference</name><operator>.</operator><name>updateAttemptCounter</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rootReference</name> <operator>=</operator> <call><name><name>meta</name><operator>.</operator><name>getRoot</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>updateCounter</name> <operator>+=</operator> <name><name>rootReference</name><operator>.</operator><name>updateCounter</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>updateAttemptCounter</name> <operator>+=</operator> <name><name>rootReference</name><operator>.</operator><name>updateAttemptCounter</name></name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>map</name> <range>: <expr><call><name><name>maps</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>RootReference</name><argument_list type="generic">&lt;<argument><name>?</name></argument>,<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>root</name> <init>= <expr><call><name><name>map</name><operator>.</operator><name>getRoot</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>updateCounter</name> <operator>+=</operator> <name><name>root</name><operator>.</operator><name>updateCounter</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateAttemptCounter</name> <operator>+=</operator> <name><name>root</name><operator>.</operator><name>updateAttemptCounter</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><ternary><condition><expr><name>updateAttemptCounter</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>updateCounter</name> <operator>/</operator> <name>updateAttemptCounter</name><operator>)</operator></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Register opened operation (transaction).
     * This would increment usage counter for the current version.
     * This version (and all after it) should not be dropped until all
     * transactions involved are closed and usage counter goes to zero.
     * @return TxCounter to be decremented when operation finishes (transaction closed).
     */</comment>
    <function><type><specifier>public</specifier> <name>TxCounter</name></type> <name>registerVersionUsage</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>TxCounter</name></type> <name>txCounter</name></decl>;</decl_stmt>
        <while>while<condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>txCounter</name> <operator>=</operator> <name>currentTxCounter</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name><name>txCounter</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>txCounter</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// The only way for counter to be negative</comment>
            <comment type="line">// if it was retrieved right before onVersionChange()</comment>
            <comment type="line">// and now onVersionChange() is done.</comment>
            <comment type="line">// This version is eligible for reclamation now</comment>
            <comment type="line">// and should not be used here, so restore count</comment>
            <comment type="line">// not to upset accounting and try again with a new</comment>
            <comment type="line">// version (currentTxCounter should have changed).</comment>
            <assert>assert <expr><name>txCounter</name> <operator>!=</operator> <name>currentTxCounter</name> <operator>:</operator> <name>txCounter</name></expr>;</assert>
            <expr_stmt><expr><call><name><name>txCounter</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * De-register (close) completed operation (transaction).
     * This will decrement usage counter for the corresponding version.
     * If counter reaches zero, that version (and all unused after it)
     * can be dropped immediately.
     *
     * @param txCounter to be decremented, obtained from registerVersionUsage()
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>deregisterVersionUsage</name><parameter_list>(<parameter><decl><type><name>TxCounter</name></type> <name>txCounter</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>txCounter</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name><name>txCounter</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>dropUnusedVersions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>storeLock</name><operator>.</operator><name>tryLock</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <try>try <block>{<block_content>
                        <expr_stmt><expr><call><name>dropUnusedVersions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <finally>finally <block>{<block_content>
                        <expr_stmt><expr><call><name><name>storeLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>onVersionChange</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>TxCounter</name></type> <name>txCounter</name> <init>= <expr><name>currentTxCounter</name></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><call><name><name>txCounter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</assert>
        <expr_stmt><expr><call><name><name>versions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>txCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentTxCounter</name> <operator>=</operator> <operator>new</operator> <call><name>TxCounter</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>txCounter</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dropUnusedVersions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>dropUnusedVersions</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>TxCounter</name></type> <name>txCounter</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>txCounter</name> <operator>=</operator> <call><name><name>versions</name><operator>.</operator><name>peek</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal>
                <operator>&amp;&amp;</operator> <call><name><name>txCounter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>versions</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setOldestVersionToKeep</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>txCounter</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>txCounter</name></expr> </then><else>: <expr><name>currentTxCounter</name></expr></else></ternary><operator>)</operator><operator>.</operator><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>dropUnusedChunks</name><parameter_list>()</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>storeLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>deadChunks</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>oldestVersionToKeep</name> <init>= <expr><call><name>getOldestVersionToKeep</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>time</name> <init>= <expr><call><name>getTimeSinceCreation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>chunk</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>chunk</name> <operator>=</operator> <call><name><name>deadChunks</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator>
                        <operator>(</operator><call><name>isSeasonedChunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>canOverwriteChunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>oldestVersionToKeep</name></expr></argument>)</argument_list></call> <operator>||</operator>
                                <comment type="line">// if chunk is not ready yet, put it back and exit</comment>
                                <comment type="line">// since this deque is unbounded, offerFirst() always return true</comment>
                                <operator>!</operator><call><name><name>deadChunks</name><operator>.</operator><name>offerFirst</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

                    <if_stmt><if>if <condition>(<expr><call><name><name>chunks</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <comment type="line">// purge dead pages from cache</comment>
                        <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>toc</name> <init>= <expr><call><name><name>chunksToC</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>toc</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>cache</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                            <for>for <control>(<init><decl><type><name>long</name></type> <name>tocElement</name> <range>: <expr><name>toc</name></expr></range></decl></init>)</control> <block>{<block_content>
                                <decl_stmt><decl><type><name>long</name></type> <name>pagePos</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPagePos</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>tocElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>cache</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>pagePos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name><name>layout</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>Chunk</name><operator>.</operator><name>getMetaKey</name></name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>markMetaChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>chunk</name><operator>.</operator><name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>freeChunkSpace</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><call><name><name>saveChunkLock</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>count</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>freeChunkSpace</name><parameter_list>(<parameter><decl><type><name>Chunk</name></type> <name>chunk</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><name><name>chunk</name><operator>.</operator><name>block</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>chunk</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>freeFileSpace</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>freeFileSpace</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>fileStore</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <assert>assert <expr><call><name>validateFileLength</name><argument_list>(<argument><expr><name>start</name> <operator>+</operator> <literal type="string">":"</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</assert>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>validateFileLength</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>saveChunkLock</name><operator>.</operator><name>isHeldByCurrentThread</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><call><name><name>fileStore</name><operator>.</operator><name>getFileLengthInUse</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>measureFileLengthInUse</name><argument_list>()</argument_list></call> <operator>:</operator>
                <call><name><name>fileStore</name><operator>.</operator><name>getFileLengthInUse</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" != "</literal> <operator>+</operator> <call><name>measureFileLengthInUse</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" "</literal> <operator>+</operator> <name>msg</name></expr>;</assert>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Class TxCounter is a simple data structure to hold version of the store
     * along with the counter of open transactions,
     * which are still operating on this version.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>TxCounter</name> <block>{

        <comment type="block" format="javadoc">/**
         * Version of a store, this TxCounter is related to
         */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>long</name></type> <name>version</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Counter of outstanding operation on this version of a store
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>AtomicIntegerFieldUpdater</name><argument_list type="generic">&lt;<argument><name>TxCounter</name></argument>&gt;</argument_list></name></type> <name>counterUpdater</name> <init>=
                                        <expr><call><name><name>AtomicIntegerFieldUpdater</name><operator>.</operator><name>newUpdater</name></name><argument_list>(<argument><expr><name><name>TxCounter</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><literal type="string">"counter"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


        <constructor><name>TxCounter</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><name>int</name></type> <name>get</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><name>counter</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Increment and get the counter value.
         *
         * @return the new value
         */</comment>
        <function><type><name>int</name></type> <name>incrementAndGet</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>counterUpdater</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Decrement and get the counter values.
         *
         * @return the new value
         */</comment>
        <function><type><name>int</name></type> <name>decrementAndGet</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>counterUpdater</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><literal type="string">"v="</literal> <operator>+</operator> <name>version</name> <operator>+</operator> <literal type="string">" / cnt="</literal> <operator>+</operator> <name>counter</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * A background writer thread to automatically store changes from time to
     * time.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>BackgroundWriterThread</name> <super_list><extends>extends <super><name>Thread</name></super></extends></super_list> <block>{

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Object</name></type> <name>sync</name> <init>= <expr><operator>new</operator> <call><name>Object</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>MVStore</name></type> <name>store</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>sleep</name></decl>;</decl_stmt>

        <constructor><name>BackgroundWriterThread</name><parameter_list>(<parameter><decl><type><name>MVStore</name></type> <name>store</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sleep</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>fileStoreName</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><literal type="string">"MVStore background writer "</literal> <operator>+</operator> <name>fileStoreName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>store</name></name> <operator>=</operator> <name>store</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sleep</name></name> <operator>=</operator> <name>sleep</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setDaemon</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{<block_content>
            <while>while <condition>(<expr><call><name><name>store</name><operator>.</operator><name>isBackgroundThread</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <synchronized>synchronized <init>(<expr><name>sync</name></expr>)</init> <block>{<block_content>
                    <try>try <block>{<block_content>
                        <expr_stmt><expr><call><name><name>sync</name><operator>.</operator><name>wait</name></name><argument_list>(<argument><expr><name>sleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>ignore</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    </block_content>}</block></catch></try>
                </block_content>}</block></synchronized>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>store</name><operator>.</operator><name>isBackgroundThread</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>store</name><operator>.</operator><name>writeInBackground</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>RemovedPageInfo</name> <super_list><implements>implements <super><name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>RemovedPageInfo</name></argument>&gt;</argument_list></name></super></implements></super_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>version</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>removedPageInfo</name></decl>;</decl_stmt>

        <constructor><name>RemovedPageInfo</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pagePos</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>pinned</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageNo</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>removedPageInfo</name></name> <operator>=</operator> <call><name>createRemovedPageInfo</name><argument_list>(<argument><expr><name>pagePos</name></expr></argument>, <argument><expr><name>pinned</name></expr></argument>, <argument><expr><name>pageNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>int</name></type> <name>compareTo</name><parameter_list>(<parameter><decl><type><name>RemovedPageInfo</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>Long</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>int</name></type> <name>getPageChunkId</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageChunkId</name></name><argument_list>(<argument><expr><name>removedPageInfo</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>int</name></type> <name>getPageNo</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name>removedPageInfo</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>int</name></type> <name>getPageLength</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageMaxLength</name></name><argument_list>(<argument><expr><name>removedPageInfo</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Find out if removed page was pinned (can not be evacuated to a new chunk).
         * @return true if page has been pinned
         */</comment>
        <function><type><name>boolean</name></type> <name>isPinned</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><operator>(</operator><name>removedPageInfo</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Transforms saved page position into removed page info by
         * replacing "page offset" with "page sequential number" and
         * "page type" bit with "pinned page" flag.
         * @param pagePos of the saved page
         * @param isPinned whether page belong to a "single writer" map
         * @param pageNo 0-based sequential page number within containing chunk
         * @return removed page info that contains chunk id, page number, page length and pinned flag
         */</comment>
        <function><type><specifier>private</specifier> <specifier>static</specifier> <name>long</name></type> <name>createRemovedPageInfo</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>pagePos</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isPinned</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageNo</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>pagePos</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><literal type="number">0xFFFFFFFFL</literal> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>pageNo</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFFFFFFL</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>isPinned</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><literal type="string">"RemovedPageInfo{"</literal> <operator>+</operator>
                    <literal type="string">"version="</literal> <operator>+</operator> <name>version</name> <operator>+</operator>
                    <literal type="string">", chunk="</literal> <operator>+</operator> <call><name>getPageChunkId</name><argument_list>()</argument_list></call> <operator>+</operator>
                    <literal type="string">", pageNo="</literal> <operator>+</operator> <call><name>getPageNo</name><argument_list>()</argument_list></call> <operator>+</operator>
                    <literal type="string">", len="</literal> <operator>+</operator> <call><name>getPageLength</name><argument_list>()</argument_list></call> <operator>+</operator>
                    <operator>(</operator><ternary><condition><expr><call><name>isPinned</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">", pinned"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                    <literal type="char">'}'</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * A builder for an MVStore.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>Builder</name> <block>{

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>config</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Builder</name><parameter_list>(<parameter><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>config</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>config</name></name> <operator>=</operator> <name>config</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * Creates new instance of MVStore.Builder.
         */</comment>
        <constructor><specifier>public</specifier> <name>Builder</name><parameter_list>()</parameter_list> <block>{<block_content>
            <expr_stmt><expr><name>config</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>private</specifier> <name>Builder</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name><name>config</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Disable auto-commit, by setting the auto-commit delay and auto-commit
         * buffer size to 0.
         *
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>autoCommitDisabled</name><parameter_list>()</parameter_list> <block>{<block_content>
            <comment type="line">// we have a separate config option so that</comment>
            <comment type="line">// no thread is started if the write delay is 0</comment>
            <comment type="line">// (if we only had a setter in the MVStore,</comment>
            <comment type="line">// the thread would need to be started in any case)</comment>
            <comment type="line">//set("autoCommitBufferSize", 0);</comment>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"autoCommitDelay"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the size of the write buffer, in KB disk space (for file-based
         * stores). Unless auto-commit is disabled, changes are automatically
         * saved if there are more than this amount of changes.
         * &lt;p&gt;
         * The default is 1024 KB.
         * &lt;p&gt;
         * When the value is set to 0 or lower, data is not automatically
         * stored.
         *
         * @param kb the write buffer size, in kilobytes
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>autoCommitBufferSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kb</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"autoCommitBufferSize"</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the auto-compact target fill rate. If the average fill rate (the
         * percentage of the storage space that contains active data) of the
         * chunks is lower, then the chunks with a low fill rate are re-written.
         * Also, if the percentage of empty space between chunks is higher than
         * this value, then chunks at the end of the file are moved. Compaction
         * stops if the target fill rate is reached.
         * &lt;p&gt;
         * The default value is 90 (90%). The value 0 disables auto-compacting.
         * &lt;/p&gt;
         *
         * @param percent the target fill rate
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>autoCompactFillRate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>percent</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"autoCompactFillRate"</literal></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Use the following file name. If the file does not exist, it is
         * automatically created. The parent directory already must exist.
         *
         * @param fileName the file name
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>fileName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"fileName"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Encrypt / decrypt the file using the given password. This method has
         * no effect for in-memory stores. The password is passed as a
         * char array so that it can be cleared as soon as possible. Please note
         * there is still a small risk that password stays in memory (due to
         * Java garbage collection). Also, the hashed encryption key is kept in
         * memory as long as the file is open.
         *
         * @param password the password
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>encryptionKey</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>password</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"encryptionKey"</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Open the file in read-only mode. In this case, a shared lock will be
         * acquired to ensure the file is not concurrently opened in write mode.
         * &lt;p&gt;
         * If this option is not used, the file is locked exclusively.
         * &lt;p&gt;
         * Please note a store may only be opened once in every JVM (no matter
         * whether it is opened in read-only or read-write mode), because each
         * file may be locked only once in a process.
         *
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>readOnly</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"readOnly"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the number of keys per page.
         *
         * @param keyCount the number of keys
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>keysPerPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>keyCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"keysPerPage"</literal></expr></argument>, <argument><expr><name>keyCount</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Open the file in recovery mode, where some errors may be ignored.
         *
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>recoveryMode</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"recoveryMode"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the read cache size in MB. The default is 16 MB.
         *
         * @param mb the cache size in megabytes
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>cacheSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mb</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"cacheSize"</literal></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the read cache concurrency. The default is 16, meaning 16
         * segments are used.
         *
         * @param concurrency the cache concurrency
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>cacheConcurrency</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>concurrency</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"cacheConcurrency"</literal></expr></argument>, <argument><expr><name>concurrency</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Compress data before writing using the LZF algorithm. This will save
         * about 50% of the disk space, but will slow down read and write
         * operations slightly.
         * &lt;p&gt;
         * This setting only affects writes; it is not necessary to enable
         * compression when reading, even if compression was enabled when
         * writing.
         *
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>compress</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"compress"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Compress data before writing using the Deflate algorithm. This will
         * save more disk space, but will slow down read and write operations
         * quite a bit.
         * &lt;p&gt;
         * This setting only affects writes; it is not necessary to enable
         * compression when reading, even if compression was enabled when
         * writing.
         *
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>compressHigh</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"compress"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the amount of memory a page should contain at most, in bytes,
         * before it is split. The default is 16 KB for persistent stores and 4
         * KB for in-memory stores. This is not a limit in the page size, as
         * pages with one entry can get larger. It is just the point where pages
         * that contain more than one entry are split.
         *
         * @param pageSplitSize the page size
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>pageSplitSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageSplitSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"pageSplitSize"</literal></expr></argument>, <argument><expr><name>pageSplitSize</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Set the listener to be used for exceptions that occur when writing in
         * the background thread.
         *
         * @param exceptionHandler the handler
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>backgroundExceptionHandler</name><parameter_list>(
                <parameter><decl><type><name><name>Thread</name><operator>.</operator><name>UncaughtExceptionHandler</name></name></type> <name>exceptionHandler</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"backgroundExceptionHandler"</literal></expr></argument>, <argument><expr><name>exceptionHandler</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Use the provided file store instead of the default one.
         * &lt;p&gt;
         * File stores passed in this way need to be open. They are not closed
         * when closing the store.
         * &lt;p&gt;
         * Please note that any kind of store (including an off-heap store) is
         * considered a "persistence", while an "in-memory store" means objects
         * are not persisted and fully kept in the JVM heap.
         *
         * @param store the file store
         * @return this
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>fileStore</name><parameter_list>(<parameter><decl><type><name>FileStore</name></type> <name>store</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name>set</name><argument_list>(<argument><expr><literal type="string">"fileStore"</literal></expr></argument>, <argument><expr><name>store</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Open the store.
         *
         * @return the opened store
         */</comment>
        <function><type><specifier>public</specifier> <name>MVStore</name></type> <name>open</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>MVStore</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>DataUtils</name><operator>.</operator><name>appendMap</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Read the configuration from a string.
         *
         * @param s the string representation
         * @return the builder
         */</comment>
        <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><block>{<expr><literal type="string">"unchecked"</literal></expr>, <argument><expr><literal type="string">"rawtypes"</literal></expr></argument>, <argument><expr><literal type="string">"unused"</literal></expr></argument>}</block></expr></argument>)</argument_list></annotation>
        <type><specifier>public</specifier> <specifier>static</specifier> <name>Builder</name></type> <name>fromString</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <comment type="line">// Cast from HashMap&lt;String, String&gt; to HashMap&lt;String, Object&gt; is safe</comment>
            <return>return <expr><operator>new</operator> <call><name>Builder</name><argument_list>(<argument><expr><operator>(</operator><name>HashMap</name><operator>)</operator> <call><name><name>DataUtils</name><operator>.</operator><name>parseMap</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>
}</block></class>
</unit>
