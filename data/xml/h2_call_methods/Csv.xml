<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/h2database/h2/src/main/org/h2/tools/Csv.java"><comment type="block">/*
 * Copyright 2004-2022 H2 Group. Multiple-Licensed under the MPL 2.0,
 * and the EPL 1.0 (https://h2database.com/html/license.html).
 * Initial Developer: H2 Group
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>tools</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>BufferedOutputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>BufferedReader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>BufferedWriter</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>OutputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>OutputStreamWriter</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Reader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Writer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>charset</name><operator>.</operator><name>Charset</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>charset</name><operator>.</operator><name>StandardCharsets</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>Connection</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>ResultSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>ResultSetMetaData</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>SQLException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>Statement</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>Types</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>api</name><operator>.</operator><name>ErrorCode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>Constants</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>message</name><operator>.</operator><name>DbException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>DataUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>store</name><operator>.</operator><name>fs</name><operator>.</operator><name>FileUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>IOUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>JdbcUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>StringUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>Utils</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A facility to read from and write to CSV (comma separated values) files. When
 * reading, the BOM (the byte-order-mark) character 0xfeff at the beginning of
 * the file is ignored.
 *
 * @author Thomas Mueller, Sylvain Cuaz
 */</comment>
<class><specifier>public</specifier> class <name>Csv</name> <super_list><implements>implements <super><name>SimpleRowSource</name></super></implements></super_list> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>columnNames</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>characterSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>char</name></type> <name>escapeCharacter</name> <init>= <expr><literal type="char">'\"'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>char</name></type> <name>fieldDelimiter</name> <init>= <expr><literal type="char">'\"'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>char</name></type> <name>fieldSeparatorRead</name> <init>= <expr><literal type="char">','</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>fieldSeparatorWrite</name> <init>= <expr><literal type="string">","</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>caseSensitiveColumnNames</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>preserveWhitespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>writeColumnHeader</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>char</name></type> <name>lineComment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>lineSeparator</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>lineSeparator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>nullString</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>fileName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>BufferedReader</name></type> <name>input</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>char</name><index>[]</index></name></type> <name>inputBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>inputBufferPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>inputBufferStart</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>inputBufferEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Writer</name></type> <name>output</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>endOfLine</name></decl>, <decl><type ref="prev"/><name>endOfFile</name></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>writeResultSet</name><parameter_list>(<parameter><decl><type><name>ResultSet</name></type> <name>rs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ResultSetMetaData</name></type> <name>meta</name> <init>= <expr><call><name><name>rs</name><operator>.</operator><name>getMetaData</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><call><name><name>meta</name><operator>.</operator><name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>row</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>columnCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>meta</name><operator>.</operator><name>getColumnLabel</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>writeColumnHeader</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>writeRow</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <while>while <condition>(<expr><call><name><name>rs</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>rs</name><operator>.</operator><name>getString</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>writeRow</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rows</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rows</name></expr>;</return>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>convertIOException</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>JdbcUtils</name><operator>.</operator><name>closeSilently</name></name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Writes the result set to a file in the CSV format.
     *
     * @param writer the writer
     * @param rs the result set
     * @return the number of rows written
     * @throws SQLException on failure
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>write</name><parameter_list>(<parameter><decl><type><name>Writer</name></type> <name>writer</name></decl></parameter>, <parameter><decl><type><name>ResultSet</name></type> <name>rs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>writer</name></expr>;</expr_stmt>
        <return>return <expr><call><name>writeResultSet</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Writes the result set to a file in the CSV format. The result set is read
     * using the following loop:
     *
     * &lt;pre&gt;
     * while (rs.next()) {
     *     writeRow(row);
     * }
     * &lt;/pre&gt;
     *
     * @param outputFileName the name of the csv file
     * @param rs the result set - the result set must be positioned before the
     *          first row.
     * @param charset the charset or null to use the system default charset
     * @return the number of rows written
     * @throws SQLException on failure
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>write</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>outputFileName</name></decl></parameter>, <parameter><decl><type><name>ResultSet</name></type> <name>rs</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>charset</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>outputFileName</name></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>initWrite</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>writeResultSet</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <throw>throw <expr><call><name>convertException</name><argument_list>(<argument><expr><literal type="string">"IOException writing "</literal> <operator>+</operator> <name>outputFileName</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Writes the result set of a query to a file in the CSV format.
     *
     * @param conn the connection
     * @param outputFileName the file name
     * @param sql the query
     * @param charset the charset or null to use the system default charset
     *          (see system property file.encoding)
     * @return the number of rows written
     * @throws SQLException on failure
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>write</name><parameter_list>(<parameter><decl><type><name>Connection</name></type> <name>conn</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>outputFileName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>sql</name></decl></parameter>,
            <parameter><decl><type><name>String</name></type> <name>charset</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name>Statement</name></type> <name>stat</name> <init>= <expr><call><name><name>conn</name><operator>.</operator><name>createStatement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResultSet</name></type> <name>rs</name> <init>= <expr><call><name><name>stat</name><operator>.</operator><name>executeQuery</name></name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rows</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>outputFileName</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>stat</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rows</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Reads from the CSV file and returns a result set. The rows in the result
     * set are created on demand, that means the file is kept open until all
     * rows are read or the result set is closed.
     *
     * If the columns are read from the CSV file, then the following rules are
     * used: columns names that start with a letter or '_', and only
     * contain letters, '_', and digits, are considered case insensitive
     * and are converted to uppercase. Other column names are considered
     * case sensitive (that means they need to be quoted when accessed).
     *
     * @param inputFileName the file name
     * @param colNames or null if the column names should be read from the CSV
     *          file
     * @param charset the charset or null to use the system default charset
     * @return the result set
     * @throws SQLException on failure
     */</comment>
    <function><type><specifier>public</specifier> <name>ResultSet</name></type> <name>read</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>inputFileName</name></decl></parameter>, <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>colNames</name></decl></parameter>,
            <parameter><decl><type><name>String</name></type> <name>charset</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>inputFileName</name></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <return>return <expr><call><name>readResultSet</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <throw>throw <expr><call><name>convertException</name><argument_list>(<argument><expr><literal type="string">"IOException reading "</literal> <operator>+</operator> <name>inputFileName</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Reads CSV data from a reader and returns a result set. The rows in the
     * result set are created on demand, that means the reader is kept open
     * until all rows are read or the result set is closed.
     *
     * @param reader the reader
     * @param colNames or null if the column names should be read from the CSV
     *            file
     * @return the result set
     * @throws IOException on failure
     */</comment>
    <function><type><specifier>public</specifier> <name>ResultSet</name></type> <name>read</name><parameter_list>(<parameter><decl><type><name>Reader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>colNames</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>input</name></name> <operator>=</operator> <ternary><condition><expr><name>reader</name> <operator>instanceof</operator> <name>BufferedReader</name></expr> ?</condition><then> <expr><operator>(</operator><name>BufferedReader</name><operator>)</operator> <name>reader</name></expr>
                </then><else>: <expr><operator>new</operator> <call><name>BufferedReader</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name><name>Constants</name><operator>.</operator><name>IO_BUFFER_SIZE</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <return>return <expr><call><name>readResultSet</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ResultSet</name></type> <name>readResultSet</name><parameter_list>(<parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>colNames</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>columnNames</name></name> <operator>=</operator> <name>colNames</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initRead</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>SimpleResultSet</name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>SimpleResultSet</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>makeColumnNamesUnique</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>columnName</name> <range>: <expr><name>columnNames</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addColumn</name></name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><name><name>Types</name><operator>.</operator><name>VARCHAR</name></name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>makeColumnNamesUnique</name><parameter_list>()</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>columnNames</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>n</name> <init>= <expr><name><name>columnNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>n</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>y</name> <init>= <expr><name><name>columnNames</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>columnNames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>newFileName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>charset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fileName</name></name> <operator>=</operator> <name>newFileName</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>characterSet</name></name> <operator>=</operator> <name>charset</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>initWrite</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>output</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name>OutputStream</name></type> <name>out</name> <init>= <expr><call><name><name>FileUtils</name><operator>.</operator><name>newOutputStream</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <operator>new</operator> <call><name>BufferedOutputStream</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>Constants</name><operator>.</operator><name>IO_BUFFER_SIZE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>output</name> <operator>=</operator> <operator>new</operator> <call><name>BufferedWriter</name><argument_list>(<argument><expr><ternary><condition><expr><name>characterSet</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then>
                        <expr><operator>new</operator> <call><name>OutputStreamWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>characterSet</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <call><name>OutputStreamWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><call><name>close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <throw>throw <expr><call><name><name>DataUtils</name><operator>.</operator><name>convertToIOException</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeRow</name><parameter_list>(<parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>values</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>values</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>fieldSeparatorWrite</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>fieldSeparatorWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>escapeCharacter</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>fieldDelimiter</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>fieldDelimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><call><name>escape</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fieldDelimiter</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>fieldDelimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nullString</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>nullString</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>nullString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>escape</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>fieldDelimiter</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>escapeCharacter</name> <operator>==</operator> <name>fieldDelimiter</name> <operator>||</operator> <call><name><name>data</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>escapeCharacter</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>data</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fieldDelimiter</name> <operator>||</operator> <name>ch</name> <operator>==</operator> <name>escapeCharacter</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>escapeCharacter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>initRead</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>input</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>input</name> <operator>=</operator> <call><name><name>FileUtils</name><operator>.</operator><name>newBufferedReader</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>characterSet</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>Charset</name><operator>.</operator><name>forName</name></name><argument_list>(<argument><expr><name>characterSet</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>StandardCharsets</name><operator>.</operator><name>UTF_8</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><call><name>close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <throw>throw <expr><name>e</name></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>mark</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bom</name> <init>= <expr><call><name><name>input</name><operator>.</operator><name>read</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>bom</name> <operator>!=</operator> <literal type="number">0xfeff</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// Microsoft Excel compatibility</comment>
            <comment type="line">// ignore pseudo-BOM</comment>
            <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>inputBuffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><name><name>Constants</name><operator>.</operator><name>IO_BUFFER_SIZE</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>columnNames</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>readHeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>readHeader</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>v</name> <init>= <expr><call><name>readValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>endOfLine</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>endOfFile</name> <operator>||</operator> <operator>!</operator><call><name><name>list</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="string">"COLUMN"</literal> <operator>+</operator> <call><name><name>list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>v</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="string">"COLUMN"</literal> <operator>+</operator> <call><name><name>list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>caseSensitiveColumnNames</name> <operator>&amp;&amp;</operator> <call><name>isSimpleColumnName</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>StringUtils</name><operator>.</operator><name>toUpperEnglish</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>endOfLine</name></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>columnNames</name> <operator>=</operator> <call><name><name>list</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isSimpleColumnName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>columnName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>length</name> <init>= <expr><call><name><name>columnName</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>columnName</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Character</name><operator>.</operator><name>isLetter</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Character</name><operator>.</operator><name>isLetterOrDigit</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>columnName</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>pushBack</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>inputBufferPos</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>readChar</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputBufferPos</name> <operator>&gt;=</operator> <name>inputBufferEnd</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>readBuffer</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name><name>inputBuffer</name><index>[<expr><name>inputBufferPos</name><operator>++</operator></expr>]</index></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>readBuffer</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>endOfFile</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>keep</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>inputBufferStart</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>keep</name> <operator>=</operator> <name>inputBufferPos</name> <operator>-</operator> <name>inputBufferStart</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>keep</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>src</name> <init>= <expr><name>inputBuffer</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>keep</name> <operator>+</operator> <name><name>Constants</name><operator>.</operator><name>IO_BUFFER_SIZE</name></name> <operator>&gt;</operator> <name><name>src</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>inputBuffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><name><name>src</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>inputBufferStart</name></expr></argument>, <argument><expr><name>inputBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>inputBufferStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>keep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>inputBufferPos</name> <operator>=</operator> <name>keep</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name><name>input</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>inputBuffer</name></expr></argument>, <argument><expr><name>keep</name></expr></argument>, <argument><expr><name><name>Constants</name><operator>.</operator><name>IO_BUFFER_SIZE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// ensure bufferPos &gt; bufferEnd</comment>
            <comment type="line">// even after pushBack</comment>
            <expr_stmt><expr><name>inputBufferEnd</name> <operator>=</operator> <operator>-</operator><literal type="number">1024</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>endOfFile</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <comment type="line">// ensure the right number of characters are read</comment>
            <comment type="line">// in case the input buffer is still used</comment>
            <expr_stmt><expr><name>inputBufferPos</name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>inputBufferEnd</name> <operator>=</operator> <name>keep</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
        <return>return <expr><name><name>inputBuffer</name><index>[<expr><name>inputBufferPos</name><operator>++</operator></expr>]</index></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>readValue</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><name>endOfLine</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>inputBufferStart</name> <operator>=</operator> <name>inputBufferPos</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><call><name>readChar</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fieldDelimiter</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// delimited value</comment>
                <decl_stmt><decl><type><name>boolean</name></type> <name>containsEscape</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>inputBufferStart</name> <operator>=</operator> <name>inputBufferPos</name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>sep</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>readChar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fieldDelimiter</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>readChar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>!=</operator> <name>fieldDelimiter</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>containsEscape</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>escapeCharacter</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>readChar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>containsEscape</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>inputBuffer</name></expr></argument>,
                        <argument><expr><name>inputBufferStart</name></expr></argument>, <argument><expr><name>inputBufferPos</name> <operator>-</operator> <name>inputBufferStart</name> <operator>-</operator> <name>sep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>containsEscape</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>unEscape</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>inputBufferStart</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fieldSeparatorRead</name></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>ch</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>endOfLine</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>
                        <comment type="line">// ignore</comment>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>pushBack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>readChar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>
                <return>return <expr><name>s</name></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>ch</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>endOfLine</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fieldSeparatorRead</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// null</comment>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// ignore spaces</comment>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lineComment</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>==</operator> <name>lineComment</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// comment until end of line</comment>
                <expr_stmt><expr><name>inputBufferStart</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <do>do <block>{<block_content>
                    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>readChar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition>;</do>
                <expr_stmt><expr><name>endOfLine</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// un-delimited value</comment>
                <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>readChar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fieldSeparatorRead</name></expr>)</condition> <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>ch</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>endOfLine</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>inputBuffer</name></expr></argument>,
                        <argument><expr><name>inputBufferStart</name></expr></argument>, <argument><expr><name>inputBufferPos</name> <operator>-</operator> <name>inputBufferStart</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>preserveWhitespace</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>inputBufferStart</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <comment type="line">// check un-delimited value for nullString</comment>
                <return>return <expr><call><name>readNull</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>readNull</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><call><name><name>s</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>nullString</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>unEscape</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>chars</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>escapeCharacter</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><name>fieldDelimiter</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>chars</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * INTERNAL
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name><name>Object</name><index>[]</index></name></type> <name>readRow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>input</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>row</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name><name>columnNames</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>v</name> <init>= <expr><call><name>readValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>endOfLine</name></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>endOfFile</name></expr>)</condition> <block>{<block_content>
                                <return>return <expr><literal type="null">null</literal></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                            <comment type="line">// empty line</comment>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>row</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>endOfLine</name></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <throw>throw <expr><call><name>convertException</name><argument_list>(<argument><expr><literal type="string">"IOException reading from "</literal> <operator>+</operator> <name>fileName</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
        <return>return <expr><name>row</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>SQLException</name></type> <name>convertException</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>DbException</name><operator>.</operator><name>getJdbcSQLException</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>IO_EXCEPTION_1</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * INTERNAL
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>IOUtils</name><operator>.</operator><name>closeSilently</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>IOUtils</name><operator>.</operator><name>closeSilently</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>output</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * INTERNAL
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>SQLException</name></expr></argument></throws> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>SQLException</name><argument_list>(<argument><expr><literal type="string">"Method is not supported"</literal></expr></argument>, <argument><expr><literal type="string">"CSV"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Override the field separator for writing. The default is ",".
     *
     * @param fieldSeparatorWrite the field separator
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFieldSeparatorWrite</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldSeparatorWrite</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldSeparatorWrite</name></name> <operator>=</operator> <name>fieldSeparatorWrite</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current field separator for writing.
     *
     * @return the field separator
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getFieldSeparatorWrite</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>fieldSeparatorWrite</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Override the case sensitive column names setting. The default is false.
     * If enabled, the case of all column names is always preserved.
     *
     * @param caseSensitiveColumnNames whether column names are case sensitive
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCaseSensitiveColumnNames</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>caseSensitiveColumnNames</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>caseSensitiveColumnNames</name></name> <operator>=</operator> <name>caseSensitiveColumnNames</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current case sensitive column names setting.
     *
     * @return whether column names are case sensitive
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getCaseSensitiveColumnNames</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>caseSensitiveColumnNames</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Override the field separator for reading. The default is ','.
     *
     * @param fieldSeparatorRead the field separator
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFieldSeparatorRead</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>fieldSeparatorRead</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldSeparatorRead</name></name> <operator>=</operator> <name>fieldSeparatorRead</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current field separator for reading.
     *
     * @return the field separator
     */</comment>
    <function><type><specifier>public</specifier> <name>char</name></type> <name>getFieldSeparatorRead</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>fieldSeparatorRead</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the line comment character. The default is character code 0 (line
     * comments are disabled).
     *
     * @param lineCommentCharacter the line comment character
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLineCommentCharacter</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>lineCommentCharacter</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>lineComment</name></name> <operator>=</operator> <name>lineCommentCharacter</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the line comment character.
     *
     * @return the line comment character, or 0 if disabled
     */</comment>
    <function><type><specifier>public</specifier> <name>char</name></type> <name>getLineCommentCharacter</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>lineComment</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the field delimiter. The default is " (a double quote).
     * The value 0 means no field delimiter is used.
     *
     * @param fieldDelimiter the field delimiter
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFieldDelimiter</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>fieldDelimiter</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fieldDelimiter</name></name> <operator>=</operator> <name>fieldDelimiter</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current field delimiter.
     *
     * @return the field delimiter
     */</comment>
    <function><type><specifier>public</specifier> <name>char</name></type> <name>getFieldDelimiter</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>fieldDelimiter</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the escape character. The escape character is used to escape the
     * field delimiter. This is needed if the data contains the field delimiter.
     * The default escape character is " (a double quote), which is the same as
     * the field delimiter. If the field delimiter and the escape character are
     * both " (double quote), and the data contains a double quote, then an
     * additional double quote is added. Example:
     * &lt;pre&gt;
     * Data: He said "Hello".
     * Escape character: "
     * Field delimiter: "
     * CSV file: "He said ""Hello""."
     * &lt;/pre&gt;
     * If the field delimiter is a double quote and the escape character is a
     * backslash, then escaping is done similar to Java (however, only the field
     * delimiter is escaped). Example:
     * &lt;pre&gt;
     * Data: He said "Hello".
     * Escape character: \
     * Field delimiter: "
     * CSV file: "He said \"Hello\"."
     * &lt;/pre&gt;
     * The value 0 means no escape character is used.
     *
     * @param escapeCharacter the escape character
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEscapeCharacter</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>escapeCharacter</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>escapeCharacter</name></name> <operator>=</operator> <name>escapeCharacter</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current escape character.
     *
     * @return the escape character
     */</comment>
    <function><type><specifier>public</specifier> <name>char</name></type> <name>getEscapeCharacter</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>escapeCharacter</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the line separator used for writing. This is usually a line feed (\n
     * or \r\n depending on the system settings). The line separator is written
     * after each row (including the last row), so this option can include an
     * end-of-row marker if needed.
     *
     * @param lineSeparator the line separator
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLineSeparator</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>lineSeparator</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>lineSeparator</name></name> <operator>=</operator> <name>lineSeparator</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the line separator used for writing.
     *
     * @return the line separator
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getLineSeparator</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>lineSeparator</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the value that represents NULL. It is only used for non-delimited
     * values.
     *
     * @param nullString the null
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setNullString</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>nullString</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nullString</name></name> <operator>=</operator> <name>nullString</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current null string.
     *
     * @return the null string.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getNullString</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>nullString</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Enable or disable preserving whitespace in unquoted text.
     *
     * @param value the new value for the setting
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setPreserveWhitespace</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>preserveWhitespace</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Whether whitespace in unquoted text is preserved.
     *
     * @return the current value for the setting
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getPreserveWhitespace</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>preserveWhitespace</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Enable or disable writing the column header.
     *
     * @param value the new value for the setting
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setWriteColumnHeader</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>writeColumnHeader</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Whether the column header is written.
     *
     * @return the current value for the setting
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getWriteColumnHeader</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>writeColumnHeader</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * INTERNAL.
     * Parse and set the CSV options.
     *
     * @param options the options
     * @return the character set
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>setOptions</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>options</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>charset</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>keyValuePairs</name> <init>= <expr><call><name><name>StringUtils</name><operator>.</operator><name>arraySplit</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>pair</name> <range>: <expr><name>keyValuePairs</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>pair</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>pair</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>StringUtils</name><operator>.</operator><name>trim</name></name><argument_list>(<argument><expr><call><name><name>pair</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>value</name> <init>= <expr><call><name><name>pair</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>value</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>, <argument><expr><literal type="string">"esc"</literal></expr></argument>, <argument><expr><literal type="string">"escapeCharacter"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setEscapeCharacter</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"fieldDelimiter"</literal></expr></argument>, <argument><expr><literal type="string">"fieldDelim"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setFieldDelimiter</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"fieldSeparator"</literal></expr></argument>, <argument><expr><literal type="string">"fieldSep"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setFieldSeparatorRead</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setFieldSeparatorWrite</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"lineComment"</literal></expr></argument>, <argument><expr><literal type="string">"lineCommentCharacter"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setLineCommentCharacter</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"lineSeparator"</literal></expr></argument>, <argument><expr><literal type="string">"lineSep"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setLineSeparator</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="string">"nullString"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setNullString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"charset"</literal></expr></argument>, <argument><expr><literal type="string">"characterSet"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>charset</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"preserveWhitespace"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setPreserveWhitespace</name><argument_list>(<argument><expr><call><name><name>Utils</name><operator>.</operator><name>parseBoolean</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"writeColumnHeader"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setWriteColumnHeader</name><argument_list>(<argument><expr><call><name><name>Utils</name><operator>.</operator><name>parseBoolean</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isParam</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"caseSensitiveColumnNames"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setCaseSensitiveColumnNames</name><argument_list>(<argument><expr><call><name><name>Utils</name><operator>.</operator><name>parseBoolean</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getUnsupportedException</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>charset</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isParam</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>String</name><modifier>...</modifier></type> <name>values</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>v</name> <range>: <expr><name>values</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>equalsIgnoreCase</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

}</block></class>
</unit>
