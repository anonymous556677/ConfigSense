<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/h2database/h2/src/main/org/h2/index/IndexCondition.java"><comment type="block">/*
 * Copyright 2004-2022 H2 Group. Multiple-Licensed under the MPL 2.0,
 * and the EPL 1.0 (https://h2database.com/html/license.html).
 * Initial Developer: H2 Group
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>index</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>TreeSet</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>command</name><operator>.</operator><name>query</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>SessionLocal</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>Expression</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>ExpressionColumn</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>ExpressionVisitor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>condition</name><operator>.</operator><name>Comparison</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>message</name><operator>.</operator><name>DbException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>ResultInterface</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>Column</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>TableType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>Value</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A index condition object is made for each condition that can potentially use
 * an index. This class does not extend expression, but in general there is one
 * expression that maps to each index condition.
 *
 * @author Thomas Mueller
 * @author Noel Grandin
 * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888
 */</comment>
<class><specifier>public</specifier> class <name>IndexCondition</name> <block>{

    <comment type="block" format="javadoc">/**
     * A bit of a search mask meaning 'equal'.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>EQUALITY</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A bit of a search mask meaning 'larger or equal'.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>START</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A bit of a search mask meaning 'smaller or equal'.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>END</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A search mask meaning 'between'.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>RANGE</name> <init>= <expr><name>START</name> <operator>|</operator> <name>END</name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A bit of a search mask meaning 'the condition is always false'.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ALWAYS_FALSE</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A bit of a search mask meaning 'spatial intersection'.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SPATIAL_INTERSECTS</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Column</name></type> <name>column</name></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * see constants in {@link Comparison}
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>compareType</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Expression</name></type> <name>expression</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>expressionList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Query</name></type> <name>expressionQuery</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @param compareType the comparison type, see constants in
     *            {@link Comparison}
     */</comment>
    <constructor><specifier>private</specifier> <name>IndexCondition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compareType</name></decl></parameter>, <parameter><decl><type><name>ExpressionColumn</name></type> <name>column</name></decl></parameter>,
            <parameter><decl><type><name>Expression</name></type> <name>expression</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>compareType</name></name> <operator>=</operator> <name>compareType</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>column</name></name> <operator>=</operator> <ternary><condition><expr><name>column</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name><name>column</name><operator>.</operator><name>getColumn</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>expression</name></name> <operator>=</operator> <name>expression</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Create an index condition with the given parameters.
     *
     * @param compareType the comparison type, see constants in
     *            {@link Comparison}
     * @param column the column
     * @param expression the expression
     * @return the index condition
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>IndexCondition</name></type> <name>get</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>compareType</name></decl></parameter>, <parameter><decl><type><name>ExpressionColumn</name></type> <name>column</name></decl></parameter>,
            <parameter><decl><type><name>Expression</name></type> <name>expression</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>IndexCondition</name><argument_list>(<argument><expr><name>compareType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Create an index condition with the compare type IN_LIST and with the
     * given parameters.
     *
     * @param column the column
     * @param list the expression list
     * @return the index condition
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>IndexCondition</name></type> <name>getInList</name><parameter_list>(<parameter><decl><type><name>ExpressionColumn</name></type> <name>column</name></decl></parameter>,
            <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>IndexCondition</name></type> <name>cond</name> <init>= <expr><operator>new</operator> <call><name>IndexCondition</name><argument_list>(<argument><expr><name><name>Comparison</name><operator>.</operator><name>IN_LIST</name></name></expr></argument>, <argument><expr><name>column</name></expr></argument>,
                <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cond</name><operator>.</operator><name>expressionList</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
        <return>return <expr><name>cond</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Create an index condition with the compare type IN_QUERY and with the
     * given parameters.
     *
     * @param column the column
     * @param query the select statement
     * @return the index condition
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>IndexCondition</name></type> <name>getInQuery</name><parameter_list>(<parameter><decl><type><name>ExpressionColumn</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name>Query</name></type> <name>query</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <assert>assert <expr><call><name><name>query</name><operator>.</operator><name>isRandomAccessResult</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name>IndexCondition</name></type> <name>cond</name> <init>= <expr><operator>new</operator> <call><name>IndexCondition</name><argument_list>(<argument><expr><name><name>Comparison</name><operator>.</operator><name>IN_QUERY</name></name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cond</name><operator>.</operator><name>expressionQuery</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
        <return>return <expr><name>cond</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current value of the expression.
     *
     * @param session the session
     * @return the value
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>getCurrentValue</name><parameter_list>(<parameter><decl><type><name>SessionLocal</name></type> <name>session</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>expression</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current value list of the expression. The value list is of the
     * same type as the column, distinct, and sorted.
     *
     * @param session the session
     * @return the value list
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Value</name><index>[]</index></name></type> <name>getCurrentValueList</name><parameter_list>(<parameter><decl><type><name>SessionLocal</name></type> <name>session</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>TreeSet</name><argument_list type="generic">&lt;<argument><name>Value</name></argument>&gt;</argument_list></name></type> <name>valueSet</name> <init>= <expr><operator>new</operator> <call><name><name>TreeSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCompareMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressionList</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>Value</name></type> <name>v</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>column</name><operator>.</operator><name>convert</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>valueSet</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>array</name> <init>= <expr><call><name><name>valueSet</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Value</name><index>[<expr><call><name><name>valueSet</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCompareMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>array</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current result of the expression. The rows may not be of the same
     * type, therefore the rows may not be unique.
     *
     * @return the result
     */</comment>
    <function><type><specifier>public</specifier> <name>ResultInterface</name></type> <name>getCurrentResult</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>expressionQuery</name><operator>.</operator><name>query</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the SQL snippet of this comparison.
     *
     * @param sqlFlags formatting flags
     * @return the SQL snippet
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getSQL</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlFlags</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>compareType</name> <operator>==</operator> <name><name>Comparison</name><operator>.</operator><name>FALSE</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="string">"FALSE"</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>column</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>compareType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL_NULL_SAFE</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>expression</name><operator>.</operator><name>isNullConstant</name></name><argument_list>()</argument_list></call>
                    <operator>||</operator> <call><name><name>column</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValueType</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Value</name><operator>.</operator><name>BOOLEAN</name></name> <operator>&amp;&amp;</operator> <call><name><name>expression</name><operator>.</operator><name>isConstant</name></name><argument_list>()</argument_list></call></expr> <comment type="line">//</comment>
                            ?</condition><then> <expr><literal type="string">" IS "</literal></expr>
                            </then><else>: <expr><literal type="string">" IS NOT DISTINCT FROM "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>BIGGER_EQUAL</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &gt;= "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>BIGGER</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SMALLER_EQUAL</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &lt;= "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SMALLER</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &lt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>IN_LIST</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>Expression</name><operator>.</operator><name>writeExpressions</name></name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" IN("</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expressionList</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>IN_QUERY</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" IN("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>expressionQuery</name><operator>.</operator><name>getPlanSQL</name></name><argument_list>(<argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SPATIAL_INTERSECTS</name></name></expr>:</case>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &amp;&amp; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>(<argument><expr><literal type="string">"type="</literal> <operator>+</operator> <name>compareType</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>expression</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>expression</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>, <argument><expr><name><name>Expression</name><operator>.</operator><name>AUTO_PARENTHESES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the comparison bit mask.
     *
     * @param indexConditions all index conditions
     * @return the mask
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMask</name><parameter_list>(<parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>IndexCondition</name></argument>&gt;</argument_list></name></type> <name>indexConditions</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>compareType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>FALSE</name></name></expr>:</case>
            <return>return <expr><name>ALWAYS_FALSE</name></expr>;</return>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL_NULL_SAFE</name></name></expr>:</case>
            <return>return <expr><name>EQUALITY</name></expr>;</return>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>IN_LIST</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>IN_QUERY</name></name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name><name>indexConditions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>TableType</name><operator>.</operator><name>TABLE</name></name> <operator>!=</operator> <call><name><name>column</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTableType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// if combined with other conditions,</comment>
                    <comment type="line">// IN(..) can only be used for regular tables</comment>
                    <comment type="line">// test case:</comment>
                    <comment type="line">// create table test(a int, b int, primary key(id, name));</comment>
                    <comment type="line">// create unique index c on test(b, a);</comment>
                    <comment type="line">// insert into test values(1, 10), (2, 20);</comment>
                    <comment type="line">// select * from (select * from test)</comment>
                    <comment type="line">// where a=1 and b in(10, 20);</comment>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>EQUALITY</name></expr>;</return>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>BIGGER_EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>BIGGER</name></name></expr>:</case>
            <return>return <expr><name>START</name></expr>;</return>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SMALLER_EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SMALLER</name></name></expr>:</case>
            <return>return <expr><name>END</name></expr>;</return>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SPATIAL_INTERSECTS</name></name></expr>:</case>
            <return>return <expr><name>SPATIAL_INTERSECTS</name></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>(<argument><expr><literal type="string">"type="</literal> <operator>+</operator> <name>compareType</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if the result is always false.
     *
     * @return true if the result will always be false
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isAlwaysFalse</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>compareType</name> <operator>==</operator> <name><name>Comparison</name><operator>.</operator><name>FALSE</name></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if this index condition is of the type column larger or equal to
     * value.
     *
     * @return true if this is a start condition
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isStart</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>compareType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL_NULL_SAFE</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>BIGGER_EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>BIGGER</name></name></expr>:</case>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if this index condition is of the type column smaller or equal to
     * value.
     *
     * @return true if this is a end condition
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEnd</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>compareType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>EQUAL_NULL_SAFE</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SMALLER_EQUAL</name></name></expr>:</case>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SMALLER</name></name></expr>:</case>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if this index condition is of the type spatial column intersects
     * value.
     *
     * @return true if this is a spatial intersects condition
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isSpatialIntersects</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>compareType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name><name>Comparison</name><operator>.</operator><name>SPATIAL_INTERSECTS</name></name></expr>:</case>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCompareType</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>compareType</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the referenced column.
     *
     * @return the column
     */</comment>
    <function><type><specifier>public</specifier> <name>Column</name></type> <name>getColumn</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>column</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get expression.
     *
     * @return Expression.
     */</comment>
    <function><type><specifier>public</specifier> <name>Expression</name></type> <name>getExpression</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>expression</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get expression list.
     *
     * @return Expression list.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>getExpressionList</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>expressionList</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get expression query.
     *
     * @return Expression query.
     */</comment>
    <function><type><specifier>public</specifier> <name>Query</name></type> <name>getExpressionQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>expressionQuery</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if the expression can be evaluated.
     *
     * @return true if it can be evaluated
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEvaluatable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>expression</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>expression</name>
                    <operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name><name>ExpressionVisitor</name><operator>.</operator><name>EVALUATABLE_VISITOR</name></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>expressionList</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressionList</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>e</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name><name>ExpressionVisitor</name><operator>.</operator><name>EVALUATABLE_VISITOR</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>expressionQuery</name>
                <operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name><name>ExpressionVisitor</name><operator>.</operator><name>EVALUATABLE_VISITOR</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><literal type="string">"column="</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">", compareType="</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>compareTypeToString</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>compareType</name></expr></argument>)</argument_list></call>
            <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">", expression="</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call>
            <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">", expressionList="</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>expressionList</name></expr></argument>)</argument_list></call>
            <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">", expressionQuery="</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>expressionQuery</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>StringBuilder</name></type> <name>compareTypeToString</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>f</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <name>EQUALITY</name><operator>)</operator> <operator>==</operator> <name>EQUALITY</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"EQUALITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <name>START</name><operator>)</operator> <operator>==</operator> <name>START</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"START"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <name>END</name><operator>)</operator> <operator>==</operator> <name>END</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"END"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <name>ALWAYS_FALSE</name><operator>)</operator> <operator>==</operator> <name>ALWAYS_FALSE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"ALWAYS_FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <name>SPATIAL_INTERSECTS</name><operator>)</operator> <operator>==</operator> <name>SPATIAL_INTERSECTS</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"SPATIAL_INTERSECTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>builder</name></expr>;</return>
    </block_content>}</block></function>

}</block></class>
</unit>
