<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/h2database/h2/src/main/org/h2/value/Value.java"><comment type="block">/*
 * Copyright 2004-2022 H2 Group. Multiple-Licensed under the MPL 2.0,
 * and the EPL 1.0 (https://h2database.com/html/license.html).
 * Initial Developer: H2 Group
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>ByteArrayInputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>ByteArrayOutputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>InputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Reader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>ref</name><operator>.</operator><name>SoftReference</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>math</name><operator>.</operator><name>BigDecimal</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>math</name><operator>.</operator><name>RoundingMode</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>charset</name><operator>.</operator><name>StandardCharsets</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Iterator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>api</name><operator>.</operator><name>ErrorCode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>api</name><operator>.</operator><name>IntervalQualifier</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>CastDataProvider</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>Mode</name><operator>.</operator><name>CharPadding</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>SysProperties</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>message</name><operator>.</operator><name>DbException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>store</name><operator>.</operator><name>DataHandler</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>Bits</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>DateTimeUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>HasSQL</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>IntervalUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>JdbcUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>MathUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>StringUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>geometry</name><operator>.</operator><name>GeoJsonUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>json</name><operator>.</operator><name>JsonConstructorUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>lob</name><operator>.</operator><name>LobData</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>lob</name><operator>.</operator><name>LobDataDatabase</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>lob</name><operator>.</operator><name>LobDataInMemory</name></name>;</import>

<comment type="block" format="javadoc">/**
 * This is the base class for all value classes.
 * It provides conversion and comparison methods.
 *
 * @author Thomas Mueller
 * @author Noel Grandin
 * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>Value</name> <super_list><extends>extends <super><name><name>VersionedValue</name><argument_list type="generic">&lt;<argument><name>Value</name></argument>&gt;</argument_list></name></super></extends> <implements>implements <super><name>HasSQL</name></super>, <super><name>Typed</name></super></implements></super_list> <block>{

    <comment type="block" format="javadoc">/**
     * The data type is unknown at this time.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>UNKNOWN</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for NULL.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>NULL</name> <init>= <expr><name>UNKNOWN</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for CHARACTER values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CHAR</name> <init>= <expr><name>NULL</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for CHARACTER VARYING values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>VARCHAR</name> <init>= <expr><name>CHAR</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for CHARACTER LARGE OBJECT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CLOB</name> <init>= <expr><name>VARCHAR</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for VARCHAR_IGNORECASE values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>VARCHAR_IGNORECASE</name> <init>= <expr><name>CLOB</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for BINARY values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BINARY</name> <init>= <expr><name>VARCHAR_IGNORECASE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for BINARY VARYING values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>VARBINARY</name> <init>= <expr><name>BINARY</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for BINARY LARGE OBJECT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BLOB</name> <init>= <expr><name>VARBINARY</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for BOOLEAN values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BOOLEAN</name> <init>= <expr><name>BLOB</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for TINYINT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TINYINT</name> <init>= <expr><name>BOOLEAN</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for SMALLINT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SMALLINT</name> <init>= <expr><name>TINYINT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for INTEGER values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTEGER</name> <init>= <expr><name>SMALLINT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for BIGINT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIGINT</name> <init>= <expr><name>INTEGER</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for NUMERIC values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>NUMERIC</name> <init>= <expr><name>BIGINT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for REAL values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>REAL</name> <init>= <expr><name>NUMERIC</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for DOUBLE PRECISION values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DOUBLE</name> <init>= <expr><name>REAL</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for DECFLOAT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DECFLOAT</name> <init>= <expr><name>DOUBLE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for DATE values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DATE</name> <init>= <expr><name>DECFLOAT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for TIME values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TIME</name> <init>= <expr><name>DATE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for TIME WITH TIME ZONE values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TIME_TZ</name> <init>= <expr><name>TIME</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for TIMESTAMP values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TIMESTAMP</name> <init>= <expr><name>TIME_TZ</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for TIMESTAMP WITH TIME ZONE values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TIMESTAMP_TZ</name> <init>= <expr><name>TIMESTAMP</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL YEAR} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_YEAR</name> <init>= <expr><name>TIMESTAMP_TZ</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL MONTH} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_MONTH</name> <init>= <expr><name>INTERVAL_YEAR</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL DAY} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_DAY</name> <init>= <expr><name>INTERVAL_MONTH</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL HOUR} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_HOUR</name> <init>= <expr><name>INTERVAL_DAY</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL MINUTE} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_MINUTE</name> <init>= <expr><name>INTERVAL_HOUR</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL SECOND} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_SECOND</name> <init>= <expr><name>INTERVAL_MINUTE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL YEAR TO MONTH} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_YEAR_TO_MONTH</name> <init>= <expr><name>INTERVAL_SECOND</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL DAY TO HOUR} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_DAY_TO_HOUR</name> <init>= <expr><name>INTERVAL_YEAR_TO_MONTH</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL DAY TO MINUTE} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_DAY_TO_MINUTE</name> <init>= <expr><name>INTERVAL_DAY_TO_HOUR</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL DAY TO SECOND} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_DAY_TO_SECOND</name> <init>= <expr><name>INTERVAL_DAY_TO_MINUTE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL HOUR TO MINUTE} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_HOUR_TO_MINUTE</name> <init>= <expr><name>INTERVAL_DAY_TO_SECOND</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL HOUR TO SECOND} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_HOUR_TO_SECOND</name> <init>= <expr><name>INTERVAL_HOUR_TO_MINUTE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for {@code INTERVAL MINUTE TO SECOND} values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERVAL_MINUTE_TO_SECOND</name> <init>= <expr><name>INTERVAL_HOUR_TO_SECOND</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for JAVA_OBJECT values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>JAVA_OBJECT</name> <init>= <expr><name>INTERVAL_MINUTE_TO_SECOND</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for ENUM values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ENUM</name> <init>= <expr><name>JAVA_OBJECT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for string values with a fixed size.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GEOMETRY</name> <init>= <expr><name>ENUM</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for JSON values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>JSON</name> <init>= <expr><name>GEOMETRY</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for UUID values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>UUID</name> <init>= <expr><name>JSON</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for ARRAY values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ARRAY</name> <init>= <expr><name>UUID</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The value type for ROW values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ROW</name> <init>= <expr><name>ARRAY</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The number of value types.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TYPE_COUNT</name> <init>= <expr><name>ROW</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for untyped NULL data type.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_NULL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for character string data types.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_CHARACTER_STRING</name> <init>= <expr><name>GROUP_NULL</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for binary string data types.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_BINARY_STRING</name> <init>= <expr><name>GROUP_CHARACTER_STRING</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for BINARY data type.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_BOOLEAN</name> <init>= <expr><name>GROUP_BINARY_STRING</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for numeric data types.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_NUMERIC</name> <init>= <expr><name>GROUP_BOOLEAN</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for datetime data types.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_DATETIME</name> <init>= <expr><name>GROUP_NUMERIC</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for year-month interval data types.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_INTERVAL_YM</name> <init>= <expr><name>GROUP_DATETIME</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for day-time interval data types.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_INTERVAL_DT</name> <init>= <expr><name>GROUP_INTERVAL_YM</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for other data types (JAVA_OBJECT, UUID, GEOMETRY, ENUM, JSON).
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_OTHER</name> <init>= <expr><name>GROUP_INTERVAL_DT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Group for collection data types (ARRAY, ROW).
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GROUP_COLLECTION</name> <init>= <expr><name>GROUP_OTHER</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>byte</name></type> <name><name>GROUPS</name><index>[]</index></name> <init>= <expr><block>{
            <comment type="line">// NULL</comment>
            <expr><name>GROUP_NULL</name></expr>,
            <comment type="line">// CHAR, VARCHAR, CLOB, VARCHAR_IGNORECASE</comment>
            <expr><name>GROUP_CHARACTER_STRING</name></expr>, <expr><name>GROUP_CHARACTER_STRING</name></expr>, <expr><name>GROUP_CHARACTER_STRING</name></expr>, <expr><name>GROUP_CHARACTER_STRING</name></expr>,
            <comment type="line">// BINARY, VARBINARY, BLOB</comment>
            <expr><name>GROUP_BINARY_STRING</name></expr>, <expr><name>GROUP_BINARY_STRING</name></expr>, <expr><name>GROUP_BINARY_STRING</name></expr>,
            <comment type="line">// BOOLEAN</comment>
            <expr><name>GROUP_BOOLEAN</name></expr>,
            <comment type="line">// TINYINT, SMALLINT, INTEGER, BIGINT, NUMERIC, REAL, DOUBLE, DECFLOAT</comment>
            <expr><name>GROUP_NUMERIC</name></expr>, <expr><name>GROUP_NUMERIC</name></expr>, <expr><name>GROUP_NUMERIC</name></expr>, <expr><name>GROUP_NUMERIC</name></expr>, <expr><name>GROUP_NUMERIC</name></expr>, <expr><name>GROUP_NUMERIC</name></expr>, <expr><name>GROUP_NUMERIC</name></expr>,
            <expr><name>GROUP_NUMERIC</name></expr>,
            <comment type="line">// DATE, TIME, TIME_TZ, TIMESTAMP, TIMESTAMP_TZ</comment>
            <expr><name>GROUP_DATETIME</name></expr>, <expr><name>GROUP_DATETIME</name></expr>, <expr><name>GROUP_DATETIME</name></expr>, <expr><name>GROUP_DATETIME</name></expr>, <expr><name>GROUP_DATETIME</name></expr>,
            <comment type="line">// INTERVAL_YEAR, INTERVAL_MONTH</comment>
            <expr><name>GROUP_INTERVAL_YM</name></expr>, <expr><name>GROUP_INTERVAL_YM</name></expr>,
            <comment type="line">// INTERVAL_DAY, INTERVAL_HOUR, INTERVAL_MINUTE, INTERVAL_SECOND</comment>
            <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>,
            <comment type="line">// INTERVAL_YEAR_TO_MONTH</comment>
            <expr><name>GROUP_INTERVAL_YM</name></expr>,
            <comment type="line">// INTERVAL_DAY_TO_HOUR, INTERVAL_DAY_TO_MINUTE,</comment>
            <comment type="line">// INTERVAL_DAY_TO_SECOND, INTERVAL_HOUR_TO_MINUTE,</comment>
            <comment type="line">// INTERVAL_HOUR_TO_SECOND, INTERVAL_MINUTE_TO_SECOND</comment>
            <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>, <expr><name>GROUP_INTERVAL_DT</name></expr>,
            <expr><name>GROUP_INTERVAL_DT</name></expr>,
            <comment type="line">// JAVA_OBJECT, ENUM, GEOMETRY, JSON, UUID</comment>
            <expr><name>GROUP_OTHER</name></expr>, <expr><name>GROUP_OTHER</name></expr>, <expr><name>GROUP_OTHER</name></expr>, <expr><name>GROUP_OTHER</name></expr>, <expr><name>GROUP_OTHER</name></expr>,
            <comment type="line">// ARRAY, ROW</comment>
            <expr><name>GROUP_COLLECTION</name></expr>, <expr><name>GROUP_COLLECTION</name></expr>,
            <comment type="line">//</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name><name>NAMES</name><index>[]</index></name> <init>= <expr><block>{
            <expr><literal type="string">"UNKNOWN"</literal></expr>,
            <expr><literal type="string">"NULL"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"CHARACTER"</literal></expr>, <expr><literal type="string">"CHARACTER VARYING"</literal></expr>, <expr><literal type="string">"CHARACTER LARGE OBJECT"</literal></expr>, <expr><literal type="string">"VARCHAR_IGNORECASE"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"BINARY"</literal></expr>, <expr><literal type="string">"BINARY VARYING"</literal></expr>, <expr><literal type="string">"BINARY LARGE OBJECT"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"BOOLEAN"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"TINYINT"</literal></expr>, <expr><literal type="string">"SMALLINT"</literal></expr>, <expr><literal type="string">"INTEGER"</literal></expr>, <expr><literal type="string">"BIGINT"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"NUMERIC"</literal></expr>, <expr><literal type="string">"REAL"</literal></expr>, <expr><literal type="string">"DOUBLE PRECISION"</literal></expr>, <expr><literal type="string">"DECFLOAT"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"DATE"</literal></expr>, <expr><literal type="string">"TIME"</literal></expr>, <expr><literal type="string">"TIME WITH TIME ZONE"</literal></expr>, <expr><literal type="string">"TIMESTAMP"</literal></expr>, <expr><literal type="string">"TIMESTAMP WITH TIME ZONE"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"INTERVAL YEAR"</literal></expr>, <expr><literal type="string">"INTERVAL MONTH"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"INTERVAL DAY"</literal></expr>, <expr><literal type="string">"INTERVAL HOUR"</literal></expr>, <expr><literal type="string">"INTERVAL MINUTE"</literal></expr>, <expr><literal type="string">"INTERVAL SECOND"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"INTERVAL YEAR TO MONTH"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"INTERVAL DAY TO HOUR"</literal></expr>, <expr><literal type="string">"INTERVAL DAY TO MINUTE"</literal></expr>, <expr><literal type="string">"INTERVAL DAY TO SECOND"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"INTERVAL HOUR TO MINUTE"</literal></expr>, <expr><literal type="string">"INTERVAL HOUR TO SECOND"</literal></expr>, <expr><literal type="string">"INTERVAL MINUTE TO SECOND"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"JAVA_OBJECT"</literal></expr>, <expr><literal type="string">"ENUM"</literal></expr>, <expr><literal type="string">"GEOMETRY"</literal></expr>, <expr><literal type="string">"JSON"</literal></expr>, <expr><literal type="string">"UUID"</literal></expr>, <comment type="line">//</comment>
            <expr><literal type="string">"ARRAY"</literal></expr>, <expr><literal type="string">"ROW"</literal></expr>, <comment type="line">//</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Empty array of values.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Value</name><index>[]</index></name></type> <name>EMPTY_VALUES</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name><name>SoftReference</name><argument_list type="generic">&lt;<argument><name><name>Value</name><index>[]</index></name></argument>&gt;</argument_list></name></type> <name>softCache</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>BigDecimal</name></type> <name>MAX_LONG_DECIMAL</name> <init>= <expr><call><name><name>BigDecimal</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The smallest Long value, as a BigDecimal.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>BigDecimal</name></type> <name>MIN_LONG_DECIMAL</name> <init>= <expr><call><name><name>BigDecimal</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>Long</name><operator>.</operator><name>MIN_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type without taking scale and precision
     * into account.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CONVERT_TO</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Cast a value to the specified type. The scale is set if applicable. The
     * value is truncated to a required precision.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CAST_TO</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Cast a value to the specified type for assignment. The scale is set if
     * applicable. If precision is too large an exception is thrown.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ASSIGN_TO</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Returns name of the specified data type.
     *
     * @param valueType
     *            the value type
     * @return the name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getTypeName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>valueType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><name><name>NAMES</name><index>[<expr><name>valueType</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check the range of the parameters.
     *
     * @param zeroBasedOffset the offset (0 meaning no offset)
     * @param length the length of the target
     * @param dataSize the length of the source
     */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>rangeCheck</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>zeroBasedOffset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>dataSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zeroBasedOffset</name> <operator>|</operator> <name>length</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>length</name> <operator>&gt;</operator> <name>dataSize</name> <operator>-</operator> <name>zeroBasedOffset</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>zeroBasedOffset</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>zeroBasedOffset</name> <operator>&gt;</operator> <name>dataSize</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInvalidValueException</name></name><argument_list>(<argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>zeroBasedOffset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInvalidValueException</name></name><argument_list>(<argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function_decl><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <specifier>abstract</specifier> <name>TypeInfo</name></type> <name>getType</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Get the value type.
     *
     * @return the value type
     */</comment>
    <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>int</name></type> <name>getValueType</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Get the memory used by this object.
     *
     * @return the memory used in bytes
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMemory</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="block">/*
         * Java 11 with -XX:-UseCompressedOops for all values up to ValueLong
         * and ValueDouble.
         */</comment>
        <return>return <expr><literal type="number">24</literal></expr>;</return>
    </block_content>}</block></function>

    <function_decl><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <specifier>abstract</specifier> <name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Check if the two values have the same hash code. No data conversion is
     * made; this method returns false if the other object is not of the same
     * class. For some values, compareTo may return 0 even if equals return
     * false. Example: ValueDecimal 0.0 and 0.00.
     *
     * @param other the other value
     * @return true if they are equal
     */</comment>
    <function_decl><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <specifier>abstract</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>other</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Get the higher value order type of two value types. If values need to be
     * converted to match the other operands value type, the value with the
     * lower order is converted to the value with the higher order.
     *
     * @param t1 the first value type
     * @param t2 the second value type
     * @return the higher value type of the two
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>getHigherOrder</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>t2</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>UNKNOWN</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>UNKNOWN_DATA_TYPE_1</name></name></expr></argument>, <argument><expr><literal type="string">"?, ?"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>t1</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>&lt;</operator> <name>t2</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><name>t1</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>t1</name> <operator>=</operator> <name>t2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>t2</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>UNKNOWN</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>UNKNOWN_DATA_TYPE_1</name></name></expr></argument>, <argument><expr><literal type="string">"?, NULL"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>t2</name></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t2</name> <operator>==</operator> <name>UNKNOWN</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>UNKNOWN_DATA_TYPE_1</name></name></expr></argument>, <argument><expr><literal type="string">"NULL, ?"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>t1</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>t1</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>getHigherOrderKnown</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>int</name></type> <name>getHigherOrderKnown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>g1</name> <init>= <expr><name><name>GROUPS</name><index>[<expr><name>t1</name></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>g2</name> <init>= <expr><name><name>GROUPS</name><index>[<expr><name>t2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>g1</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>GROUP_BOOLEAN</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>==</operator> <name>GROUP_BINARY_STRING</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>BOOLEAN</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GROUP_NUMERIC</name></expr>:</case>
            <return>return <expr><call><name>getHigherNumeric</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>g2</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>GROUP_DATETIME</name></expr>:</case>
            <return>return <expr><call><name>getHigherDateTime</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>g2</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>GROUP_INTERVAL_YM</name></expr>:</case>
            <return>return <expr><call><name>getHigherIntervalYearMonth</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>g2</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>GROUP_INTERVAL_DT</name></expr>:</case>
            <return>return <expr><call><name>getHigherIntervalDayTime</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>g2</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>GROUP_OTHER</name></expr>:</case>
            <return>return <expr><call><name>getHigherOther</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>g2</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></switch>
        <return>return <expr><name>t1</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getHigherNumeric</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>g2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>==</operator> <name>GROUP_NUMERIC</name></expr>)</condition> <block>{<block_content>
            <switch>switch <condition>(<expr><name>t1</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>REAL</name></expr>:</case>
                <switch>switch <condition>(<expr><name>t2</name></expr>)</condition> <block>{<block_content>
                <case>case <expr><name>INTEGER</name></expr>:</case>
                    <return>return <expr><name>DOUBLE</name></expr>;</return>
                <case>case <expr><name>BIGINT</name></expr>:</case>
                <case>case <expr><name>NUMERIC</name></expr>:</case>
                    <return>return <expr><name>DECFLOAT</name></expr>;</return>
                </block_content>}</block></switch>
                <break>break;</break>
            <case>case <expr><name>DOUBLE</name></expr>:</case>
                <switch>switch <condition>(<expr><name>t2</name></expr>)</condition> <block>{<block_content>
                <case>case <expr><name>BIGINT</name></expr>:</case>
                <case>case <expr><name>NUMERIC</name></expr>:</case>
                    <return>return <expr><name>DECFLOAT</name></expr>;</return>
                </block_content>}</block></switch>
                <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>g2</name> <operator>==</operator> <name>GROUP_BINARY_STRING</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>t1</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getHigherDateTime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>g2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>==</operator> <name>GROUP_CHARACTER_STRING</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>t1</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>!=</operator> <name>GROUP_DATETIME</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <switch>switch <condition>(<expr><name>t1</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TIME</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>DATE</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>TIMESTAMP</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>TIME_TZ</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>DATE</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>TIMESTAMP_TZ</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>TIME_TZ</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>TIMESTAMP_TZ</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></switch>
        <return>return <expr><name>t1</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getHigherIntervalYearMonth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>g2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>g2</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>GROUP_INTERVAL_YM</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>INTERVAL_MONTH</name> <operator>&amp;&amp;</operator> <name>t2</name> <operator>==</operator> <name>INTERVAL_YEAR</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="line">//$FALL-THROUGH$</comment>
        <case>case <expr><name>GROUP_CHARACTER_STRING</name></expr>:</case>
        <case>case <expr><name>GROUP_NUMERIC</name></expr>:</case>
            <return>return <expr><name>t1</name></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getHigherIntervalDayTime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>g2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>g2</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>GROUP_INTERVAL_DT</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>GROUP_CHARACTER_STRING</name></expr>:</case>
        <case>case <expr><name>GROUP_NUMERIC</name></expr>:</case>
            <return>return <expr><name>t1</name></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <switch>switch <condition>(<expr><name>t1</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
            <return>return <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>;</return>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>INTERVAL_DAY</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>;</return>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>INTERVAL_DAY</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>INTERVAL_HOUR</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>;</return>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>INTERVAL_MINUTE</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>INTERVAL_SECOND</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>INTERVAL_SECOND</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
            <switch>switch <condition>(<expr><name>t2</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
                <return>return <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>;</return>
            <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
                <return>return <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>;</return>
            <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
                <return>return <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>;</return>
            </block_content>}</block></switch>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
            <switch>switch <condition>(<expr><name>t2</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
                <return>return <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>;</return>
            </block_content>}</block></switch>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <switch>switch <condition>(<expr><name>t2</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
            <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
                <return>return <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>;</return>
            <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
            <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
            <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
                <return>return <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>;</return>
            </block_content>}</block></switch>
        </block_content>}</block></switch>
        <return>return <expr><name>t1</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getHigherOther</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>g2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>t1</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>!=</operator> <name>GROUP_BINARY_STRING</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>ENUM</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>!=</operator> <name>GROUP_CHARACTER_STRING</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>g2</name> <operator>!=</operator> <name>GROUP_NUMERIC</name> <operator>||</operator> <name>t2</name> <operator>&gt;</operator> <name>INTEGER</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>GEOMETRY</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>g2</name> <operator>!=</operator> <name>GROUP_CHARACTER_STRING</name> <operator>&amp;&amp;</operator> <name>g2</name> <operator>!=</operator> <name>GROUP_BINARY_STRING</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>JSON</name></expr>:</case>
            <switch>switch <condition>(<expr><name>g2</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>GROUP_DATETIME</name></expr>:</case>
            <case>case <expr><name>GROUP_INTERVAL_YM</name></expr>:</case>
            <case>case <expr><name>GROUP_INTERVAL_DT</name></expr>:</case>
            <case>case <expr><name>GROUP_OTHER</name></expr>:</case>
                <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></switch>
            <break>break;</break>
        <case>case <expr><name>UUID</name></expr>:</case>
            <switch>switch <condition>(<expr><name>g2</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>GROUP_CHARACTER_STRING</name></expr>:</case>
            <case>case <expr><name>GROUP_BINARY_STRING</name></expr>:</case>
                <break>break;</break>
            <case>case <expr><name>GROUP_OTHER</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>==</operator> <name>JAVA_OBJECT</name></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <comment type="line">//$FALL-THROUGH$</comment>
            <default>default:</default>
                <throw>throw <expr><call><name>getDataTypeCombinationException</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></switch>
        </block_content>}</block></switch>
        <return>return <expr><name>t1</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>DbException</name></type> <name>getDataTypeCombinationException</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t2</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr></argument>, <argument><expr><call><name>getTypeName</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">", "</literal> <operator>+</operator> <call><name>getTypeName</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if a value is in the cache that is equal to this value. If yes,
     * this value should be used to save memory. If the value is not in the
     * cache yet, it is added.
     *
     * @param v the value to look for
     * @return the value in the cache or the value passed
     */</comment>
    <function><type><specifier>static</specifier> <name>Value</name></type> <name>cache</name><parameter_list>(<parameter><decl><type><name>Value</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>SysProperties</name><operator>.</operator><name>OBJECT_CACHE</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>hash</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>cache</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>softCache</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>cache</name> <operator>=</operator> <call><name><name>softCache</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>cache</name> <operator>=</operator> <operator>new</operator> <name><name>Value</name><index>[<expr><name><name>SysProperties</name><operator>.</operator><name>OBJECT_CACHE_SIZE</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>softCache</name> <operator>=</operator> <operator>new</operator> <call><name><name>SoftReference</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>hash</name> <operator>&amp;</operator> <operator>(</operator><name><name>SysProperties</name><operator>.</operator><name>OBJECT_CACHE_SIZE</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Value</name></type> <name>cached</name> <init>= <expr><name><name>cache</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cached</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>cached</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>v</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>v</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>cached</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// cacheHit++;</comment>
                    <return>return <expr><name>cached</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// cacheMiss++;</comment>
            <comment type="line">// cache[cacheCleaner] = null;</comment>
            <comment type="line">// cacheCleaner = (cacheCleaner + 1) &amp;</comment>
            <comment type="line">//     (Constants.OBJECT_CACHE_SIZE - 1);</comment>
            <expr_stmt><expr><name><name>cache</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Clear the value cache. Used for testing.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>clearCache</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>softCache</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the value as a string.
     *
     * @return the string
     */</comment>
    <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>String</name></type> <name>getString</name><parameter_list>()</parameter_list>;</function_decl>

    <function><type><specifier>public</specifier> <name>Reader</name></type> <name>getReader</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the reader
     *
     * @param oneBasedOffset the offset (1 means no offset)
     * @param length the requested length
     * @return the new reader
     */</comment>
    <function><type><specifier>public</specifier> <name>Reader</name></type> <name>getReader</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>oneBasedOffset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>string</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>zeroBasedOffset</name> <init>= <expr><name>oneBasedOffset</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>rangeCheck</name><argument_list>(<argument><expr><name>zeroBasedOffset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><call><name><name>string</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>zeroBasedOffset</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><call><name><name>string</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>byte</name><index>[]</index></name></type> <name>getBytes</name><parameter_list>()</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>VARBINARY</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>byte</name><index>[]</index></name></type> <name>getBytesNoCopy</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getBytes</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>getInputStream</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the input stream
     *
     * @param oneBasedOffset the offset (1 means no offset)
     * @param length the requested length
     * @return the new input stream
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>getInputStream</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>oneBasedOffset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>zeroBasedOffset</name> <init>= <expr><name>oneBasedOffset</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>rangeCheck</name><argument_list>(<argument><expr><name>zeroBasedOffset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>bytes</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>zeroBasedOffset</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code boolean} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code BOOLEAN}
     * @return value
     * @see #isTrue()
     * @see #isFalse()
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getBoolean</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertToBoolean</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBoolean</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code byte} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code TINYINT}
     * @return value
     */</comment>
    <function><type><specifier>public</specifier> <name>byte</name></type> <name>getByte</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertToTinyint</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getByte</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code short} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code SMALLINT}
     * @return value
     */</comment>
    <function><type><specifier>public</specifier> <name>short</name></type> <name>getShort</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertToSmallint</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getShort</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code int} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code INTEGER}
     * @return value
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getInt</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertToInt</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getInt</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code long} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code BIGINT}
     * @return value
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getLong</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertToBigint</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getLong</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>BigDecimal</name></type> <name>getBigDecimal</name><parameter_list>()</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>NUMERIC</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code float} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code REAL}
     * @return value
     */</comment>
    <function><type><specifier>public</specifier> <name>float</name></type> <name>getFloat</name><parameter_list>()</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>REAL</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns this value as a Java {@code double} value.
     *
     * @throws DbException
     *             if this value is {@code NULL} or cannot be casted to
     *             {@code DOUBLE PRECISION}
     * @return value
     */</comment>
    <function><type><specifier>public</specifier> <name>double</name></type> <name>getDouble</name><parameter_list>()</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>DOUBLE</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Add a value and return the result.
     *
     * @param v the value to add
     * @return the result
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>add</name><parameter_list>(<parameter><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unused"</literal></expr></argument>)</argument_list></annotation> <name>Value</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getSignum</name><parameter_list>()</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"SIGNUM"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Return -value if this value support arithmetic operations.
     *
     * @return the negative
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>negate</name><parameter_list>()</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"NEG"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Subtract a value and return the result.
     *
     * @param v the value to subtract
     * @return the result
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>subtract</name><parameter_list>(<parameter><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unused"</literal></expr></argument>)</argument_list></annotation> <name>Value</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Divide by a value and return the result.
     *
     * @param v the divisor
     * @param quotientType the type of quotient (used only to read precision and scale
     *            when applicable)
     * @return the result
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>divide</name><parameter_list>(<parameter><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unused"</literal></expr></argument>)</argument_list></annotation> <name>Value</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name></type> <name>quotientType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Multiply with a value and return the result.
     *
     * @param v the value to multiply with
     * @return the result
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>multiply</name><parameter_list>(<parameter><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unused"</literal></expr></argument>)</argument_list></annotation> <name>Value</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Take the modulus with a value and return the result.
     *
     * @param v the value to take the modulus with
     * @return the result
     */</comment>
    <function><type><specifier>public</specifier> <name>Value</name></type> <name>modulus</name><parameter_list>(<parameter><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unused"</literal></expr></argument>)</argument_list></annotation> <name>Value</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name>getUnsupportedExceptionForOperation</name><argument_list>(<argument><expr><literal type="string">"%"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type without taking scale and precision
     * into account.
     *
     * @param targetType the type of the returned value
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>convertTo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type without taking scale and precision
     * into account.
     *
     * @param targetType the type of the returned value
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>convertTo</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>CONVERT_TO</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type without taking scale and precision
     * into account.
     *
     * @param targetType the type of the returned value
     * @param provider the cast information provider
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>convertTo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><name>targetType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ARRAY</name></expr>:</case>
            <return>return <expr><call><name>convertToAnyArray</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>ROW</name></expr>:</case>
            <return>return <expr><call><name>convertToAnyRow</name><argument_list>()</argument_list></call></expr>;</return>
        <default>default:</default>
            <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><call><name><name>TypeInfo</name><operator>.</operator><name>getTypeInfo</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>CONVERT_TO</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type without taking scale and precision
     * into account.
     *
     * @param targetType
     *            the type of the returned value
     * @param provider
     *            the cast information provider
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>convertTo</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>CONVERT_TO</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type without taking scale and precision
     * into account.
     *
     * @param targetType
     *            the type of the returned value
     * @param provider
     *            the cast information provider
     * @param column
     *            the column, used to improve the error message if conversion
     *            fails
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>convertTo</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>CONVERT_TO</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert this value to any ARRAY data type.
     *
     * @param provider
     *            the cast information provider
     * @return a row value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueArray</name></type> <name>convertToAnyArray</name><parameter_list>(<parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Value</name><operator>.</operator><name>ARRAY</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>(</operator><name>ValueArray</name><operator>)</operator> <name>this</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>ValueArray</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>Value</name><index>[]</index></name> <block>{ <expr><name>this</name></expr> }</block></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert this value to any ROW data type.
     *
     * @return a row value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueRow</name></type> <name>convertToAnyRow</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Value</name><operator>.</operator><name>ROW</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>(</operator><name>ValueRow</name><operator>)</operator> <name>this</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>ValueRow</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Value</name><index>[]</index></name> <block>{ <expr><name>this</name></expr> }</block></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Cast a value to the specified type. The scale is set if applicable. The
     * value is truncated to the required precision.
     *
     * @param targetType
     *            the type of the returned value
     * @param provider
     *            the cast information provider
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>castTo</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>CAST_TO</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Cast a value to the specified type for assignment. The scale is set if
     * applicable. If precision is too large an exception is thrown.
     *
     * @param targetType
     *            the type of the returned value
     * @param provider
     *            the cast information provider
     * @param column
     *            the column, used to improve the error message if conversion
     *            fails
     * @return the converted value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>Value</name></type> <name>convertForAssignTo</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>ASSIGN_TO</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a value to the specified type.
     *
     * @param targetType the type of the returned value
     * @param provider the cast information provider
     * @param conversionMode conversion mode
     * @param column the column (if any), used to improve the error message if conversion fails
     * @return the converted value
     */</comment>
    <function><type><specifier>private</specifier> <name>Value</name></type> <name>convertTo</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>valueType</name> <init>= <expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>targetValueType</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>valueType</name> <operator>==</operator> <name>NULL</name>
                <operator>||</operator> <name>valueType</name> <operator>==</operator> <operator>(</operator><name>targetValueType</name> <operator>=</operator> <call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>conversionMode</name> <operator>==</operator> <name>CONVERT_TO</name>
                <operator>&amp;&amp;</operator> <call><name><name>targetType</name><operator>.</operator><name>getExtTypeInfo</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>valueType</name> <operator>!=</operator> <name>CHAR</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <switch>switch <condition>(<expr><name>targetValueType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>NULL</name></expr>:</case>
            <return>return <expr><name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <return>return <expr><call><name>convertToChar</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
            <return>return <expr><call><name>convertToVarchar</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>CLOB</name></expr>:</case>
            <return>return <expr><call><name>convertToClob</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
            <return>return <expr><call><name>convertToVarcharIgnoreCase</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BINARY</name></expr>:</case>
            <return>return <expr><call><name>convertToBinary</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>VARBINARY</name></expr>:</case>
            <return>return <expr><call><name>convertToVarbinary</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BLOB</name></expr>:</case>
            <return>return <expr><call><name>convertToBlob</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <return>return <expr><call><name>convertToBoolean</name><argument_list>()</argument_list></call></expr>;</return>
        <case>case <expr><name>TINYINT</name></expr>:</case>
            <return>return <expr><call><name>convertToTinyint</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
            <return>return <expr><call><name>convertToSmallint</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <return>return <expr><call><name>convertToInt</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BIGINT</name></expr>:</case>
            <return>return <expr><call><name>convertToBigint</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
            <return>return <expr><call><name>convertToNumeric</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>REAL</name></expr>:</case>
            <return>return <expr><call><name>convertToReal</name><argument_list>()</argument_list></call></expr>;</return>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <return>return <expr><call><name>convertToDouble</name><argument_list>()</argument_list></call></expr>;</return>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name>convertToDecfloat</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>DATE</name></expr>:</case>
            <return>return <expr><call><name>convertToDate</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TIME</name></expr>:</case>
            <return>return <expr><call><name>convertToTime</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TIME_TZ</name></expr>:</case>
            <return>return <expr><call><name>convertToTimeTimeZone</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case>
            <return>return <expr><call><name>convertToTimestamp</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case>
            <return>return <expr><call><name>convertToTimestampTimeZone</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>INTERVAL_YEAR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>:</case>
            <return>return <expr><call><name>convertToIntervalYearMonth</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <return>return <expr><call><name>convertToIntervalDayTime</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <return>return <expr><call><name>convertToJavaObject</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>ENUM</name></expr>:</case>
            <return>return <expr><call><name>convertToEnum</name><argument_list>(<argument><expr><operator>(</operator><name>ExtTypeInfoEnum</name><operator>)</operator> <call><name><name>targetType</name><operator>.</operator><name>getExtTypeInfo</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>GEOMETRY</name></expr>:</case>
            <return>return <expr><call><name>convertToGeometry</name><argument_list>(<argument><expr><operator>(</operator><name>ExtTypeInfoGeometry</name><operator>)</operator> <call><name><name>targetType</name><operator>.</operator><name>getExtTypeInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>JSON</name></expr>:</case>
            <return>return <expr><call><name>convertToJson</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>UUID</name></expr>:</case>
            <return>return <expr><call><name>convertToUuid</name><argument_list>()</argument_list></call></expr>;</return>
        <case>case <expr><name>ARRAY</name></expr>:</case>
            <return>return <expr><call><name>convertToArray</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>ROW</name></expr>:</case>
            <return>return <expr><call><name>convertToRow</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>targetValueType</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a CHAR value. May not be called on a NULL value.
     *
     * @return a CHAR value.
     */</comment>
    <function><type><specifier>public</specifier> <name>ValueChar</name></type> <name>convertToChar</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>convertToChar</name><argument_list>(<argument><expr><call><name><name>TypeInfo</name><operator>.</operator><name>getTypeInfo</name></name><argument_list>(<argument><expr><name>CHAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>CONVERT_TO</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueChar</name></type> <name>convertToChar</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <comment type="line">//</comment>
            <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>valueType</name> <init>= <expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>valueType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>BLOB</name></expr>:</case>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>newLength</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <while>while <condition>(<expr><name>newLength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>s</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>newLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>newLength</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>convertLongToInt</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>provider</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>provider</name><operator>.</operator><name>getMode</name></name><argument_list>()</argument_list></call><operator>.</operator><name>charPadding</name> <operator>==</operator> <name><name>CharPadding</name><operator>.</operator><name>ALWAYS</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>newLength</name> <operator>!=</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>newLength</name> <operator>&lt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                        <return>return <expr><call><name><name>ValueChar</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>StringUtils</name><operator>.</operator><name>pad</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>newLength</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <do>do <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><operator>--</operator><name>newLength</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
                                <throw>throw <expr><call><name>getValueTooLongException</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block> while <condition>(<expr><name>newLength</name> <operator>&gt;</operator> <name>p</name></expr>)</condition>;</do>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CAST_TO</name> <operator>&amp;&amp;</operator> <name>newLength</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>newLength</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <while>while <condition>(<expr><name>newLength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>s</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>newLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>newLength</name><operator>--</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>ASSIGN_TO</name> <operator>&amp;&amp;</operator> <name>newLength</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>getValueTooLongException</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <name>newLength</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>valueType</name> <operator>==</operator> <name>CHAR</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>(</operator><name>ValueChar</name><operator>)</operator> <name>this</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>ValueChar</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Value</name></type> <name>convertToVarchar</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>valueType</name> <init>= <expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>valueType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>BLOB</name></expr>:</case>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>convertLongToInt</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>getValueTooLongException</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><call><name><name>ValueVarchar</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><ternary><condition><expr><name>valueType</name> <operator>==</operator> <name><name>Value</name><operator>.</operator><name>VARCHAR</name></name></expr> ?</condition><then> <expr><name>this</name></expr> </then><else>: <expr><call><name><name>ValueVarchar</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueClob</name></type> <name>convertToClob</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueClob</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>CLOB</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueClob</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>BLOB</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>LobData</name></type> <name>data</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ValueBlob</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><name>lobData</name></expr></init></decl>;</decl_stmt>
            <comment type="line">// Try to reuse the array, if possible</comment>
            <if_stmt><if>if <condition>(<expr><name>data</name> <operator>instanceof</operator> <name>LobDataInMemory</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>small</name> <init>= <expr><operator>(</operator><operator>(</operator><name>LobDataInMemory</name><operator>)</operator> <name>data</name><operator>)</operator><operator>.</operator><call><name>getSmall</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>small</name></expr></argument>, <argument><expr><name><name>StandardCharsets</name><operator>.</operator><name>UTF_8</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getBytes</name><argument_list>(<argument><expr><name><name>StandardCharsets</name><operator>.</operator><name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>Arrays</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>small</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>bytes</name> <operator>=</operator> <name>small</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueClob</name><operator>.</operator><name>createSmall</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>data</name> <operator>instanceof</operator> <name>LobDataDatabase</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>data</name><operator>.</operator><name>getDataHandler</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLobStorage</name><argument_list>()</argument_list></call><operator>.</operator><call><name>createClob</name><argument_list>(<argument><expr><call><name>getReader</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="line">//$FALL-THROUGH$</comment>
        <default>default:</default>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueClob</name><operator>.</operator><name>createSmall</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>v</name><operator>.</operator><name>convertPrecision</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>v</name><operator>.</operator><name>charLength</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Value</name></type> <name>convertToVarcharIgnoreCase</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>valueType</name> <init>= <expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>valueType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>BLOB</name></expr>:</case>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>convertLongToInt</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>getValueTooLongException</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><call><name><name>ValueVarcharIgnoreCase</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><ternary><condition><expr><name>valueType</name> <operator>==</operator> <name><name>Value</name><operator>.</operator><name>VARCHAR_IGNORECASE</name></name></expr> ?</condition><then> <expr><name>this</name></expr> </then><else>: <expr><call><name><name>ValueVarcharIgnoreCase</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueBinary</name></type> <name>convertToBinary</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueBinary</name></type> <name>v</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BINARY</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueBinary</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueBinary</name><operator>.</operator><name>getNoCopy</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>DbException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>e</name><operator>.</operator><name>getErrorCode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>BINARY</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <throw>throw <expr><name>e</name></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>value</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getBytesNoCopy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>value</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>convertLongToInt</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>ASSIGN_TO</name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueBinary</name><operator>.</operator><name>getNoCopy</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueVarbinary</name></type> <name>convertToVarbinary</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueVarbinary</name></type> <name>v</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VARBINARY</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueVarbinary</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueVarbinary</name><operator>.</operator><name>getNoCopy</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>value</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getBytesNoCopy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>value</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>convertLongToInt</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueVarbinary</name><operator>.</operator><name>getNoCopy</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueBlob</name></type> <name>convertToBlob</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueBlob</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>BLOB</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueBlob</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CLOB</name></expr>:</case>
            <decl_stmt><decl><type><name>DataHandler</name></type> <name>handler</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ValueLob</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name><name>lobData</name><operator>.</operator><name>getDataHandler</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>handler</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>handler</name><operator>.</operator><name>getLobStorage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>createBlob</name><argument_list>(<argument><expr><call><name>getInputStream</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="line">//$FALL-THROUGH$</comment>
        <default>default:</default>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueBlob</name><operator>.</operator><name>createSmall</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>DbException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>e</name><operator>.</operator><name>getErrorCode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>BLOB</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <throw>throw <expr><name>e</name></expr>;</throw>
            </block_content>}</block></catch></try>
            <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>v</name><operator>.</operator><name>convertPrecision</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>v</name><operator>.</operator><name>octetLength</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a BOOLEAN value. May not be called on a NULL
     * value.
     *
     * @return the BOOLEAN value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueBoolean</name></type> <name>convertToBoolean</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueBoolean</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
            <return>return <expr><call><name><name>ValueBoolean</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
        <case>case <expr><name>BIGINT</name></expr>:</case>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueBoolean</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getSignum</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>BOOLEAN</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a TINYINT value. May not be called on a NULL
     * value.
     *
     * @param column
     *            the column, used for to improve the error message if
     *            conversion fails
     * @return the TINYINT value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueTinyint</name></type> <name>convertToTinyint</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TINYINT</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueTinyint</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <return>return <expr><call><name><name>ValueTinyint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getByte</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>ENUM</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <return>return <expr><call><name><name>ValueTinyint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToByte</name><argument_list>(<argument><expr><call><name>getInt</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BIGINT</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <return>return <expr><call><name><name>ValueTinyint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToByte</name><argument_list>(<argument><expr><call><name>getLong</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueTinyint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToByte</name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <return>return <expr><call><name><name>ValueTinyint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToByte</name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>ValueTinyint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="line">//$FALL-THROUGH$</comment>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>TINYINT</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a SMALLINT value. May not be called on a NULL value.
     *
     * @param column
     *            the column, used for to improve the error message if
     *            conversion fails
     * @return the SMALLINT value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueSmallint</name></type> <name>convertToSmallint</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueSmallint</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
        <case>case <expr><name>TINYINT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueSmallint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getShort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>ENUM</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <return>return <expr><call><name><name>ValueSmallint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToShort</name><argument_list>(<argument><expr><call><name>getInt</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BIGINT</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <return>return <expr><call><name><name>ValueSmallint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToShort</name><argument_list>(<argument><expr><call><name>getLong</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueSmallint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToShort</name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <return>return <expr><call><name><name>ValueSmallint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToShort</name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>ValueSmallint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>(</operator><name>short</name><operator>)</operator> <operator>(</operator><operator>(</operator><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>bytes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="line">//$FALL-THROUGH$</comment>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>SMALLINT</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a INT value. May not be called on a NULL value.
     *
     * @param column
     *            the column, used for to improve the error message if
     *            conversion fails
     * @return the INT value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueInteger</name></type> <name>convertToInt</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueInteger</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>ENUM</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueInteger</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getInt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BIGINT</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <return>return <expr><call><name><name>ValueInteger</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToInt</name><argument_list>(<argument><expr><call><name>getLong</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueInteger</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToInt</name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <return>return <expr><call><name><name>ValueInteger</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToInt</name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>ValueInteger</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>Bits</name><operator>.</operator><name>readInt</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="line">//$FALL-THROUGH$</comment>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>INTEGER</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a BIGINT value. May not be called on a NULL value.
     *
     * @param column
     *            the column, used for to improve the error message if
     *            conversion fails
     * @return the BIGINT value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueBigint</name></type> <name>convertToBigint</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>BIGINT</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueBigint</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>ENUM</name></expr>:</case>
            <return>return <expr><call><name><name>ValueBigint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getLong</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name><name>ValueBigint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <return>return <expr><call><name><name>ValueBigint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>bytes</name> <init>= <expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>bytes</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>ValueBigint</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>Bits</name><operator>.</operator><name>readLong</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="line">//$FALL-THROUGH$</comment>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>BIGINT</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueNumeric</name></type> <name>convertToNumeric</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>,
            <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueNumeric</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueNumeric</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <ternary><condition><expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>ValueNumeric</name><operator>.</operator><name>ONE</name></name></expr> </then><else>: <expr><name><name>ValueNumeric</name><operator>.</operator><name>ZERO</name></name></expr></else></ternary></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default> <block>{<block_content>
            <decl_stmt><decl><type><name>BigDecimal</name></type> <name>value</name> <init>= <expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>targetScale</name> <init>= <expr><call><name><name>targetType</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>scale</name> <init>= <expr><call><name><name>value</name><operator>.</operator><name>scale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>scale</name> <operator>&gt;</operator> <name><name>ValueNumeric</name><operator>.</operator><name>MAXIMUM_SCALE</name></name> <operator>||</operator> <name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name> <operator>&amp;&amp;</operator> <name>scale</name> <operator>!=</operator> <name>targetScale</name>
                    <operator>&amp;&amp;</operator> <operator>(</operator><name>scale</name> <operator>&gt;=</operator> <name>targetScale</name> <operator>||</operator> <operator>!</operator><call><name><name>provider</name><operator>.</operator><name>getMode</name></name><argument_list>()</argument_list></call><operator>.</operator><name>convertOnlyToSmallerScale</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name><name>ValueNumeric</name><operator>.</operator><name>setScale</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>targetScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name>
                    <operator>&amp;&amp;</operator> <call><name><name>value</name><operator>.</operator><name>precision</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>targetScale</name> <operator>+</operator> <call><name><name>value</name><operator>.</operator><name>scale</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getValueTooLongException</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><call><name><name>ValueNumeric</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>targetScale</name> <init>= <expr><call><name><name>targetType</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BigDecimal</name></type> <name>value</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getBigDecimal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>scale</name> <init>= <expr><call><name><name>value</name><operator>.</operator><name>scale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>scale</name> <operator>!=</operator> <name>targetScale</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>scale</name> <operator>&gt;=</operator> <name>targetScale</name> <operator>||</operator> <operator>!</operator><call><name><name>provider</name><operator>.</operator><name>getMode</name></name><argument_list>()</argument_list></call><operator>.</operator><name>convertOnlyToSmallerScale</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueNumeric</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>ValueNumeric</name><operator>.</operator><name>setScale</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>targetScale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>BigDecimal</name></type> <name>bd</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getBigDecimal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>bd</name><operator>.</operator><name>precision</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>targetScale</name> <operator>+</operator> <call><name><name>bd</name><operator>.</operator><name>scale</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a REAL value. May not be called on a NULL value.
     *
     * @return the REAL value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueReal</name></type> <name>convertToReal</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>REAL</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueReal</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <return>return <expr><ternary><condition><expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>ValueReal</name><operator>.</operator><name>ONE</name></name></expr> </then><else>: <expr><name><name>ValueReal</name><operator>.</operator><name>ZERO</name></name></expr></else></ternary></expr>;</return>
        <default>default:</default>
            <return>return <expr><call><name><name>ValueReal</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getFloat</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a DOUBLE value. May not be called on a NULL value.
     *
     * @return the DOUBLE value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueDouble</name></type> <name>convertToDouble</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueDouble</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <return>return <expr><ternary><condition><expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>ValueDouble</name><operator>.</operator><name>ONE</name></name></expr> </then><else>: <expr><name><name>ValueDouble</name><operator>.</operator><name>ZERO</name></name></expr></else></ternary></expr>;</return>
        <default>default:</default>
            <return>return <expr><call><name><name>ValueDouble</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueDecfloat</name></type> <name>convertToDecfloat</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueDecfloat</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueDecfloat</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>value</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>v</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueDecfloat</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>BigDecimal</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>NumberFormatException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <switch>switch <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
                <case>case <expr><literal type="string">"-Infinity"</literal></expr>:</case>
                    <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>NEGATIVE_INFINITY</name></name></expr>;</return>
                <case>case <expr><literal type="string">"Infinity"</literal></expr>:</case>
                <case>case <expr><literal type="string">"+Infinity"</literal></expr>:</case>
                    <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>POSITIVE_INFINITY</name></name></expr>;</return>
                <case>case <expr><literal type="string">"NaN"</literal></expr>:</case>
                <case>case <expr><literal type="string">"-NaN"</literal></expr>:</case>
                <case>case <expr><literal type="string">"+NaN"</literal></expr>:</case>
                    <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>NAN</name></name></expr>;</return>
                <default>default:</default>
                    <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>DECFLOAT</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></switch>
            </block_content>}</block></catch></try>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <ternary><condition><expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>ValueDecfloat</name><operator>.</operator><name>ONE</name></name></expr> </then><else>: <expr><name><name>ValueDecfloat</name><operator>.</operator><name>ZERO</name></name></expr></else></ternary></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REAL</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><call><name>getFloat</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>Float</name><operator>.</operator><name>isFinite</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueDecfloat</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>BigDecimal</name><argument_list>(<argument><expr><call><name><name>Float</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>==</operator> <name><name>Float</name><operator>.</operator><name>POSITIVE_INFINITY</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>POSITIVE_INFINITY</name></name></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>==</operator> <name><name>Float</name><operator>.</operator><name>NEGATIVE_INFINITY</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>NEGATIVE_INFINITY</name></name></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>NAN</name></name></expr>;</return>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>DOUBLE</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>Double</name><operator>.</operator><name>isFinite</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueDecfloat</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>BigDecimal</name><argument_list>(<argument><expr><call><name><name>Double</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>==</operator> <name><name>Double</name><operator>.</operator><name>POSITIVE_INFINITY</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>POSITIVE_INFINITY</name></name></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>==</operator> <name><name>Double</name><operator>.</operator><name>NEGATIVE_INFINITY</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>NEGATIVE_INFINITY</name></name></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><name><name>ValueDecfloat</name><operator>.</operator><name>NAN</name></name></expr>;</return>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block>
        <default>default:</default>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueDecfloat</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>DbException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>e</name><operator>.</operator><name>getErrorCode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>DECFLOAT</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <throw>throw <expr><name>e</name></expr>;</throw>
            </block_content>}</block></catch></try>
            <break>break;</break>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>BigDecimal</name></type> <name>bd</name> <init>= <expr><name><name>v</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>precision</name> <init>= <expr><call><name><name>bd</name><operator>.</operator><name>precision</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>targetPrecision</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>precision</name> <operator>&gt;</operator> <name>targetPrecision</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueDecfloat</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>bd</name><operator>.</operator><name>setScale</name></name><argument_list>(<argument><expr><call><name><name>bd</name><operator>.</operator><name>scale</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>precision</name> <operator>+</operator> <name>targetPrecision</name></expr></argument>, <argument><expr><name><name>RoundingMode</name><operator>.</operator><name>HALF_UP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a DATE value. May not be called on a NULL value.
     *
     * @param provider
     *            the cast information provider
     * @return the DATE value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueDate</name></type> <name>convertToDate</name><parameter_list>(<parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>DATE</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueDate</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case>
            <return>return <expr><call><name><name>ValueDate</name><operator>.</operator><name>fromDateValue</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ValueTimestamp</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimestampTimeZone</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimestampTimeZone</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeNanos</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>epochSeconds</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>getEpochSeconds</name></name><argument_list>(<argument><expr><call><name><name>ts</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>,
                    <argument><expr><call><name><name>ts</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>ValueDate</name><operator>.</operator><name>fromDateValue</name></name><argument_list>(<argument><expr><call><name><name>DateTimeUtils</name>
                    <operator>.</operator><name>dateValueFromLocalSeconds</name></name><argument_list>(<argument><expr><name>epochSeconds</name>
                            <operator>+</operator> <call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetUTC</name><argument_list>(<argument><expr><name>epochSeconds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <return>return <expr><call><name><name>ValueDate</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>DATE</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueTime</name></type> <name>convertToTime</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueTime</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TIME</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueTime</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIME_TZ</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTime</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><call><name>getLocalTimeNanos</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTime</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ValueTimestamp</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getTimeNanos</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimestampTimeZone</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimestampTimeZone</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeNanos</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>epochSeconds</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>getEpochSeconds</name></name><argument_list>(<argument><expr><call><name><name>ts</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>,
                    <argument><expr><call><name><name>ts</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTime</name><operator>.</operator><name>fromNanos</name></name><argument_list>(
                    <argument><expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>nanosFromLocalSeconds</name></name><argument_list>(<argument><expr><name>epochSeconds</name>
                            <operator>+</operator> <call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetUTC</name><argument_list>(<argument><expr><name>epochSeconds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                            <operator>+</operator> <name>timeNanos</name> <operator>%</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_SECOND</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTime</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>targetScale</name> <init>= <expr><call><name><name>targetType</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>targetScale</name> <operator>&lt;</operator> <name><name>ValueTime</name><operator>.</operator><name>MAXIMUM_SCALE</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>n2</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>convertScale</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>targetScale</name></expr></argument>, <argument><expr><name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>!=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTime</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueTimeTimeZone</name></type> <name>convertToTimeTimeZone</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueTimeTimeZone</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TIME_TZ</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueTimeTimeZone</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIME</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimeTimeZone</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ValueTime</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getNanos</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimestamp</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetSeconds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimestamp</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimestamp</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeNanos</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimeTimeZone</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><name>timeNanos</name></expr></argument>,
                    <argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetLocal</name><argument_list>(<argument><expr><call><name><name>ts</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimestampTimeZone</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimestampTimeZone</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimeTimeZone</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><call><name><name>ts</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ts</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimeTimeZone</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>TIME_TZ</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>targetScale</name> <init>= <expr><call><name><name>targetType</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>targetScale</name> <operator>&lt;</operator> <name><name>ValueTime</name><operator>.</operator><name>MAXIMUM_SCALE</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>n2</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>convertScale</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>targetScale</name></expr></argument>, <argument><expr><name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>!=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimeTimeZone</name><operator>.</operator><name>fromNanos</name></name><argument_list>(<argument><expr><name>n2</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueTimestamp</name></type> <name>convertToTimestamp</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueTimestamp</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueTimestamp</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIME</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestamp</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimestamp</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><operator>(</operator><operator>(</operator><name>ValueTime</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getNanos</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIME_TZ</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestamp</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimestamp</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name>getLocalTimeNanos</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DATE</name></expr>:</case>
            <comment type="line">// Scale is always 0</comment>
            <return>return <expr><call><name><name>ValueTimestamp</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ValueDate</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimestampTimeZone</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimestampTimeZone</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeNanos</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>epochSeconds</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>getEpochSeconds</name></name><argument_list>(<argument><expr><call><name><name>ts</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>,
                    <argument><expr><call><name><name>ts</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>epochSeconds</name> <operator>+=</operator> <call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetUTC</name><argument_list>(<argument><expr><name>epochSeconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestamp</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>dateValueFromLocalSeconds</name></name><argument_list>(<argument><expr><name>epochSeconds</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>nanosFromLocalSeconds</name></name><argument_list>(<argument><expr><name>epochSeconds</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>timeNanos</name> <operator>%</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_SECOND</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestamp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>TIMESTAMP</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>targetScale</name> <init>= <expr><call><name><name>targetType</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>targetScale</name> <operator>&lt;</operator> <name><name>ValueTimestamp</name><operator>.</operator><name>MAXIMUM_SCALE</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>dv</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>n2</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>convertScale</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>targetScale</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>dv</name> <operator>==</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>MAX_DATE_VALUE</name></name></expr> ?</condition><then> <expr><name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr> </then><else>: <expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>!=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>&gt;=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>n2</name> <operator>-=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>dv</name> <operator>=</operator> <call><name><name>DateTimeUtils</name><operator>.</operator><name>incrementDateValue</name></name><argument_list>(<argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestamp</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>long</name></type> <name>getLocalTimeNanos</name><parameter_list>(<parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueTimeTimeZone</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimeTimeZone</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>localOffset</name> <init>= <expr><call><name><name>provider</name><operator>.</operator><name>currentTimestamp</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetSeconds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>normalizeNanosOfDay</name></name><argument_list>(<argument><expr><call><name><name>ts</name><operator>.</operator><name>getNanos</name></name><argument_list>()</argument_list></call> <operator>+</operator>
                <operator>(</operator><call><name><name>ts</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>localOffset</name><operator>)</operator> <operator>*</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueTimestampTimeZone</name></type> <name>convertToTimestampTimeZone</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueTimestampTimeZone</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueTimestampTimeZone</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIME</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>dateValue</name> <init>= <expr><call><name><name>provider</name><operator>.</operator><name>currentTimestamp</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeNanos</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ValueTime</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getNanos</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestampTimeZone</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><name>dateValue</name></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>,
                    <argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetLocal</name><argument_list>(<argument><expr><name>dateValue</name></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>TIME_TZ</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimeTimeZone</name></type> <name>t</name> <init>= <expr><operator>(</operator><name>ValueTimeTimeZone</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestampTimeZone</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimestamp</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>t</name><operator>.</operator><name>getNanos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>t</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>DATE</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>dateValue</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ValueDate</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getDateValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// Scale is always 0</comment>
            <return>return <expr><call><name><name>ValueTimestampTimeZone</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><name>dateValue</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>,
                    <argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetLocal</name><argument_list>(<argument><expr><name>dateValue</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueTimestamp</name></type> <name>ts</name> <init>= <expr><operator>(</operator><name>ValueTimestamp</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>dateValue</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeNanos</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestampTimeZone</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><name>dateValue</name></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>,
                    <argument><expr><call><name><name>provider</name><operator>.</operator><name>currentTimeZone</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTimeZoneOffsetLocal</name><argument_list>(<argument><expr><name>dateValue</name></expr></argument>, <argument><expr><name>timeNanos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestampTimeZone</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>TIMESTAMP_TZ</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>targetScale</name> <init>= <expr><call><name><name>targetType</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>targetScale</name> <operator>&lt;</operator> <name><name>ValueTimestamp</name><operator>.</operator><name>MAXIMUM_SCALE</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>dv</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getDateValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getTimeNanos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>n2</name> <init>= <expr><call><name><name>DateTimeUtils</name><operator>.</operator><name>convertScale</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>targetScale</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>dv</name> <operator>==</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>MAX_DATE_VALUE</name></name></expr> ?</condition><then> <expr><name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr> </then><else>: <expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>!=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>&gt;=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>n2</name> <operator>-=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>dv</name> <operator>=</operator> <call><name><name>DateTimeUtils</name><operator>.</operator><name>incrementDateValue</name></name><argument_list>(<argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueTimestampTimeZone</name><operator>.</operator><name>fromDateValueAndNanos</name></name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>getTimeZoneOffsetSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueInterval</name></type> <name>convertToIntervalYearMonth</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueInterval</name></type> <name>v</name> <init>= <expr><call><name>convertToIntervalYearMonth</name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>v</name><operator>.</operator><name>checkPrecision</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueInterval</name></type> <name>convertToIntervalYearMonth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>leading</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>getInt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BIGINT</name></expr>:</case>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>getLong</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>INTERVAL_YEAR_TO_MONTH</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalFromAbsolute</name></name><argument_list>(<argument><expr><name><name>IntervalQualifier</name><operator>.</operator><name>YEAR_TO_MONTH</name></name></expr></argument>, <argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call>
                        <operator>.</operator><call><name>multiply</name><argument_list>(<argument><expr><call><name><name>BigDecimal</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>setScale</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>RoundingMode</name><operator>.</operator><name>HALF_UP</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toBigInteger</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>INTERVAL_YEAR_TO_MONTH</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalFromAbsolute</name></name><argument_list>(<argument><expr><name><name>IntervalQualifier</name><operator>.</operator><name>YEAR_TO_MONTH</name></name></expr></argument>, <argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call>
                        <operator>.</operator><call><name>multiply</name><argument_list>(<argument><expr><call><name><name>BigDecimal</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>setScale</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>RoundingMode</name><operator>.</operator><name>HALF_UP</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toBigInteger</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
                <return>return <expr><operator>(</operator><name>ValueInterval</name><operator>)</operator> <call><name><name>IntervalUtils</name>
                        <operator>.</operator><name>parseFormattedInterval</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call>
                        <operator>.</operator><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>INVALID_DATETIME_CONSTANT_2</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"INTERVAL"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block>
        <case>case <expr><name>INTERVAL_YEAR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MONTH</name></expr>:</case>
        <case>case <expr><name>INTERVAL_YEAR_TO_MONTH</name></expr>:</case>
            <return>return <expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalFromAbsolute</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalToAbsolute</name></name><argument_list>(<argument><expr><operator>(</operator><name>ValueInterval</name><operator>)</operator> <name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <decl_stmt><decl><type><name>boolean</name></type> <name>negative</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>leading</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>negative</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <operator>-</operator><name>leading</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>ValueInterval</name><operator>.</operator><name>from</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>negative</name></expr></argument>, <argument><expr><name>leading</name></expr></argument>,
                <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueInterval</name></type> <name>convertToIntervalDayTime</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueInterval</name></type> <name>v</name> <init>= <expr><call><name>convertToIntervalDayTime</name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>v</name><operator>.</operator><name>setPrecisionAndScale</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueInterval</name></type> <name>convertToIntervalDayTime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>leading</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>getInt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BIGINT</name></expr>:</case>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>getLong</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>&gt;</operator> <name>INTERVAL_MINUTE</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>convertToIntervalDayTime</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getDouble</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>&gt;</operator> <name>INTERVAL_MINUTE</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>convertToIntervalDayTime</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <call><name>convertToLong</name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
                <return>return <expr><operator>(</operator><name>ValueInterval</name><operator>)</operator> <call><name><name>IntervalUtils</name>
                        <operator>.</operator><name>parseFormattedInterval</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call>
                        <operator>.</operator><call><name>convertTo</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>INVALID_DATETIME_CONSTANT_2</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"INTERVAL"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block>
        <case>case <expr><name>INTERVAL_DAY</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <return>return <expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalFromAbsolute</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalToAbsolute</name></name><argument_list>(<argument><expr><operator>(</operator><name>ValueInterval</name><operator>)</operator> <name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <decl_stmt><decl><type><name>boolean</name></type> <name>negative</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>leading</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>negative</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>leading</name> <operator>=</operator> <operator>-</operator><name>leading</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>ValueInterval</name><operator>.</operator><name>from</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>negative</name></expr></argument>, <argument><expr><name>leading</name></expr></argument>,
                <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueInterval</name></type> <name>convertToIntervalDayTime</name><parameter_list>(<parameter><decl><type><name>BigDecimal</name></type> <name>bigDecimal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>multiplier</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>targetType</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>INTERVAL_SECOND</name></expr>:</case>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_SECOND</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_DAY_TO_HOUR</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_DAY_TO_SECOND</name></expr>:</case>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_DAY</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_HOUR_TO_MINUTE</name></expr>:</case>
        <case>case <expr><name>INTERVAL_HOUR_TO_SECOND</name></expr>:</case>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_HOUR</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>INTERVAL_MINUTE_TO_SECOND</name></expr>:</case>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <name><name>DateTimeUtils</name><operator>.</operator><name>NANOS_PER_MINUTE</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <return>return <expr><call><name><name>IntervalUtils</name><operator>.</operator><name>intervalFromAbsolute</name></name><argument_list>(<argument><expr><call><name><name>IntervalQualifier</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>targetType</name> <operator>-</operator> <name>INTERVAL_YEAR</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>bigDecimal</name><operator>.</operator><name>multiply</name></name><argument_list>(<argument><expr><call><name><name>BigDecimal</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>multiplier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>setScale</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>RoundingMode</name><operator>.</operator><name>HALF_UP</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toBigInteger</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a JAVA_OBJECT value. May not be called on a NULL
     * value.
     *
     * @param targetType
     *            the type of the returned value
     * @param conversionMode
     *            conversion mode
     * @param column
     *            the column (if any), used to improve the error message if
     *            conversion fails
     * @return the JAVA_OBJECT value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueJavaObject</name></type> <name>convertToJavaObject</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueJavaObject</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueJavaObject</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case>
        <case>case <expr><name>BLOB</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJavaObject</name><operator>.</operator><name>getNoCopy</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>JAVA_OBJECT</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name> <operator>&amp;&amp;</operator> <call><name><name>v</name><operator>.</operator><name>getBytesNoCopy</name></name><argument_list>()</argument_list></call><operator>.</operator><name>length</name> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to an ENUM value. May not be called on a NULL value.
     *
     * @param extTypeInfo
     *            the extended data type information
     * @param provider
     *            the cast information provider
     * @return the ENUM value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueEnum</name></type> <name>convertToEnum</name><parameter_list>(<parameter><decl><type><name>ExtTypeInfoEnum</name></type> <name>extTypeInfo</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ENUM</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueEnum</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>ValueEnum</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>extTypeInfo</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>getEnumerators</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>v</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
        <case>case <expr><name>BIGINT</name></expr>:</case>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <return>return <expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><call><name>getInt</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>CHAR</name></expr>:</case>
            <return>return <expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a GEOMETRY value. May not be called on a NULL
     * value.
     *
     * @param extTypeInfo
     *            the extended data type information, or null
     * @return the GEOMETRY value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueGeometry</name></type> <name>convertToGeometry</name><parameter_list>(<parameter><decl><type><name>ExtTypeInfoGeometry</name></type> <name>extTypeInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueGeometry</name></type> <name>result</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>GEOMETRY</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ValueGeometry</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case>
        <case>case <expr><name>BLOB</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>ValueGeometry</name><operator>.</operator><name>getFromEWKB</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>JSON</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>srid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>extTypeInfo</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>Integer</name></type> <name>s</name> <init>= <expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getSrid</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>srid</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>ValueGeometry</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>GeoJsonUtils</name><operator>.</operator><name>geoJsonToEwkb</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>srid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>RuntimeException</name></type> <name>ex</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr></argument>, <argument><expr><call><name>getTraceSQL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>CLOB</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>ValueGeometry</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>GEOMETRY</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>extTypeInfo</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Integer</name></type> <name>srid</name> <init>= <expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getSrid</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>result</name><operator>.</operator><name>getTypeAndDimensionSystem</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>type</name> <operator>||</operator> <name>srid</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>result</name><operator>.</operator><name>getSRID</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>srid</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>StringBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>ExtTypeInfoGeometry</name>
                        <operator>.</operator><name>toSQL</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>getTypeAndDimensionSystem</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>getSRID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                        <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">" -&gt; "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>extTypeInfo</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>TRACE_SQL_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr></argument>, <argument><expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueJson</name></type> <name>convertToJson</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueJson</name></type> <name>v</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>JSON</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueJson</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BOOLEAN</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TINYINT</name></expr>:</case>
        <case>case <expr><name>SMALLINT</name></expr>:</case>
        <case>case <expr><name>INTEGER</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getInt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BIGINT</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getLong</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REAL</name></expr>:</case>
        <case>case <expr><name>DOUBLE</name></expr>:</case>
        <case>case <expr><name>NUMERIC</name></expr>:</case>
        <case>case <expr><name>DECFLOAT</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getBigDecimal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case>
        <case>case <expr><name>BLOB</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>fromJson</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>CLOB</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
        <case>case <expr><name>DATE</name></expr>:</case>
        <case>case <expr><name>TIME</name></expr>:</case>
        <case>case <expr><name>TIME_TZ</name></expr>:</case>
        <case>case <expr><name>UUID</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIMESTAMP</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ValueTimestamp</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getISOString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TIMESTAMP_TZ</name></expr>:</case>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ValueTimestampTimeZone</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getISOString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>GEOMETRY</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ValueGeometry</name></type> <name>vg</name> <init>= <expr><operator>(</operator><name>ValueGeometry</name><operator>)</operator> <name>this</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>getInternal</name></name><argument_list>(<argument><expr><call><name><name>GeoJsonUtils</name><operator>.</operator><name>ewkbToGeoJson</name></name><argument_list>(<argument><expr><call><name><name>vg</name><operator>.</operator><name>getBytesNoCopy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vg</name><operator>.</operator><name>getDimensionSystem</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>ARRAY</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>ByteArrayOutputStream</name></type> <name>baos</name> <init>= <expr><operator>new</operator> <call><name>ByteArrayOutputStream</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>baos</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>Value</name></type> <name>e</name> <range>: <expr><operator>(</operator><operator>(</operator><name>ValueArray</name><operator>)</operator> <name>this</name><operator>)</operator><operator>.</operator><call><name>getList</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>JsonConstructorUtils</name><operator>.</operator><name>jsonArrayAppend</name></name><argument_list>(<argument><expr><name>baos</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>baos</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueJson</name><operator>.</operator><name>getInternal</name></name><argument_list>(<argument><expr><call><name><name>baos</name><operator>.</operator><name>toByteArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>JSON</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name> <operator>&amp;&amp;</operator> <call><name><name>v</name><operator>.</operator><name>getBytesNoCopy</name></name><argument_list>()</argument_list></call><operator>.</operator><name>length</name> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Converts this value to a UUID value. May not be called on a NULL value.
     *
     * @return the UUID value
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>ValueUuid</name></type> <name>convertToUuid</name><parameter_list>()</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>UUID</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>ValueUuid</name><operator>)</operator> <name>this</name></expr>;</return>
        <case>case <expr><name>BINARY</name></expr>:</case>
        <case>case <expr><name>VARBINARY</name></expr>:</case>
            <return>return <expr><call><name><name>ValueUuid</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>JAVA_OBJECT</name></expr>:</case>
            <return>return <expr><call><name><name>JdbcUtils</name><operator>.</operator><name>deserializeUuid</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>CHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR</name></expr>:</case>
        <case>case <expr><name>VARCHAR_IGNORECASE</name></expr>:</case>
            <return>return <expr><call><name><name>ValueUuid</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></call></expr>;</throw>
        <case>case <expr><name>NULL</name></expr>:</case>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>ValueArray</name></type> <name>convertToArray</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>,
            <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>TypeInfo</name></type> <name>componentType</name> <init>= <expr><operator>(</operator><name>TypeInfo</name><operator>)</operator> <call><name><name>targetType</name><operator>.</operator><name>getExtTypeInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>valueType</name> <init>= <expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ValueArray</name></type> <name>v</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>valueType</name> <operator>==</operator> <name>ARRAY</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueArray</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>a</name></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>valueType</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>BLOB</name></expr>:</case>
                <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>new</operator> <name><name>Value</name><index>[]</index></name> <block>{ <expr><call><name><name>ValueVarbinary</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> }</block></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CLOB</name></expr>:</case>
                <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>new</operator> <name><name>Value</name><index>[]</index></name> <block>{ <expr><call><name><name>ValueVarchar</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> }</block></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>new</operator> <name><name>Value</name><index>[]</index></name> <block>{ <expr><name>this</name></expr> }</block></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueArray</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>componentType</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>values</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <label><name>loop</name>:</label> <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>Value</name></type> <name>v1</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Value</name></type> <name>v2</name> <init>= <expr><call><name><name>v1</name><operator>.</operator><name>convertTo</name></name><argument_list>(<argument><expr><name>componentType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>v1</name> <operator>!=</operator> <name>v2</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>newValues</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newValues</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>newValues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>length</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>newValues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>convertTo</name><argument_list>(<argument><expr><name>componentType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></while>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueArray</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>componentType</name></expr></argument>, <argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break <name>loop</name>;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>!=</operator> <name>CONVERT_TO</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>values</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>cardinality</name> <init>= <expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>conversionMode</name> <operator>==</operator> <name>CAST_TO</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>MathUtils</name><operator>.</operator><name>convertLongToInt</name></name><argument_list>(<argument><expr><call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>cardinality</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueArray</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>getComponentType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cardinality</name> <operator>&gt;</operator> <call><name><name>targetType</name><operator>.</operator><name>getPrecision</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>v</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Value</name></type> <name>convertToRow</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conversionMode</name></decl></parameter>,
            <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ValueRow</name></type> <name>v</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getValueType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ROW</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>ValueRow</name><operator>)</operator> <name>this</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueRow</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Value</name><index>[]</index></name> <block>{ <expr><name>this</name></expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name>ExtTypeInfoRow</name></type> <name>ext</name> <init>= <expr><operator>(</operator><name>ExtTypeInfoRow</name><operator>)</operator> <call><name><name>targetType</name><operator>.</operator><name>getExtTypeInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ext</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>values</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>values</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>TypeInfo</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>fields</name> <init>= <expr><call><name><name>ext</name><operator>.</operator><name>getFields</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <call><name><name>fields</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>getDataConversionError</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>TypeInfo</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>fields</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <label><name>loop</name>:</label> <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>Value</name></type> <name>v1</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TypeInfo</name></type> <name>componentType</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Value</name></type> <name>v2</name> <init>= <expr><call><name><name>v1</name><operator>.</operator><name>convertTo</name></name><argument_list>(<argument><expr><name>componentType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>v1</name> <operator>!=</operator> <name>v2</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>newValues</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newValues</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>newValues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>length</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>newValues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>convertTo</name><argument_list>(<argument><expr><name>componentType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>conversionMode</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></while>
                    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>ValueRow</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>newValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break <name>loop</name>;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Creates new instance of the DbException for data conversion error.
     *
     * @param targetType Target data type.
     * @return instance of the DbException.
     */</comment>
    <function><type><specifier>final</specifier> <name>DbException</name></type> <name>getDataConversionError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>targetType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr></argument>, <argument><expr><call><name>getTypeName</name><argument_list>(<argument><expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">" to "</literal>
                <operator>+</operator> <call><name>getTypeName</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Creates new instance of the DbException for data conversion error.
     *
     * @param targetType target data type.
     * @return instance of the DbException.
     */</comment>
    <function><type><specifier>final</specifier> <name>DbException</name></type> <name>getDataConversionError</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>DATA_CONVERSION_ERROR_1</name></name></expr></argument>, <argument><expr><call><name>getTypeName</name><argument_list>(<argument><expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">" to "</literal>
                <operator>+</operator> <call><name><name>targetType</name><operator>.</operator><name>getTraceSQL</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>final</specifier> <name>DbException</name></type> <name>getValueTooLongException</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>column</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>targetType</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>TRACE_SQL_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>DbException</name><operator>.</operator><name>getValueTooLongException</name></name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTraceSQL</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPrecision</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Compare this value against another value given that the values are of the
     * same data type.
     *
     * @param v the other value
     * @param mode the compare mode
     * @param provider the cast information provider
     * @return 0 if both values are equal, -1 if the other value is smaller, and
     *         1 otherwise
     */</comment>
    <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>int</name></type> <name>compareTypeSafe</name><parameter_list>(<parameter><decl><type><name>Value</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>CompareMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="javadoc">/**
     * Compare this value against another value using the specified compare
     * mode.
     *
     * @param v the other value
     * @param provider the cast information provider
     * @param compareMode the compare mode
     * @return 0 if both values are equal, -1 if this value is smaller, and
     *         1 otherwise
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>compareTo</name><parameter_list>(<parameter><decl><type><name>Value</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>CompareMode</name></type> <name>compareMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>v</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>compareToNotNullable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>compareMode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>compareToNotNullable</name><parameter_list>(<parameter><decl><type><name>Value</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>, <parameter><decl><type><name>CompareMode</name></type> <name>compareMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>Value</name></type> <name>l</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>leftType</name> <init>= <expr><call><name><name>l</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rightType</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>!=</operator> <name>rightType</name> <operator>||</operator> <name>leftType</name> <operator>==</operator> <name>ENUM</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>dataType</name> <init>= <expr><call><name>getHigherOrder</name><argument_list>(<argument><expr><name>leftType</name></expr></argument>, <argument><expr><name>rightType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>dataType</name> <operator>==</operator> <name>ENUM</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>ExtTypeInfoEnum</name></type> <name>enumerators</name> <init>= <expr><call><name><name>ExtTypeInfoEnum</name><operator>.</operator><name>getEnumeratorsForBinaryOperation</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name><name>l</name><operator>.</operator><name>convertToEnum</name></name><argument_list>(<argument><expr><name>enumerators</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>v</name><operator>.</operator><name>convertToEnum</name></name><argument_list>(<argument><expr><name>enumerators</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>dataType</name> <operator>&lt;=</operator> <name>BLOB</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>dataType</name> <operator>&lt;=</operator> <name>CLOB</name></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>==</operator> <name>CHAR</name> <operator>||</operator> <name>rightType</name> <operator>==</operator> <name>CHAR</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name>CHAR</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dataType</name> <operator>&gt;=</operator> <name>BINARY</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>leftType</name> <operator>==</operator> <name>BINARY</name> <operator>||</operator> <name>rightType</name> <operator>==</operator> <name>BINARY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name>BINARY</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name><name>l</name><operator>.</operator><name>convertTo</name></name><argument_list>(<argument><expr><name>dataType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name><name>v</name><operator>.</operator><name>convertTo</name></name><argument_list>(<argument><expr><name>dataType</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>l</name><operator>.</operator><name>compareTypeSafe</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>compareMode</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Compare this value against another value using the specified compare
     * mode.
     *
     * @param v the other value
     * @param forEquality perform only check for equality
     * @param provider the cast information provider
     * @param compareMode the compare mode
     * @return 0 if both values are equal, -1 if this value is smaller, 1
     *         if other value is larger, {@link Integer#MIN_VALUE} if order is
     *         not defined due to NULL comparison
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>compareWithNull</name><parameter_list>(<parameter><decl><type><name>Value</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>forEquality</name></decl></parameter>, <parameter><decl><type><name>CastDataProvider</name></type> <name>provider</name></decl></parameter>,
            <parameter><decl><type><name>CompareMode</name></type> <name>compareMode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name> <operator>||</operator> <name>v</name> <operator>==</operator> <name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name><name>Integer</name><operator>.</operator><name>MIN_VALUE</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>compareToNotNullable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>provider</name></expr></argument>, <argument><expr><name>compareMode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns true if this value is NULL or contains NULL value.
     *
     * @return true if this value is NULL or contains NULL value
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>containsNull</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>byte</name></type> <name>convertToByte</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name><name>Byte</name><operator>.</operator><name>MAX_VALUE</name></name> <operator>||</operator> <name>x</name> <operator>&lt;</operator> <name><name>Byte</name><operator>.</operator><name>MIN_VALUE</name></name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(
                    <argument><expr><name><name>ErrorCode</name><operator>.</operator><name>NUMERIC_VALUE_OUT_OF_RANGE_2</name></name></expr></argument>, <argument><expr><call><name><name>Long</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getColumnName</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>byte</name><operator>)</operator> <name>x</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>short</name></type> <name>convertToShort</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name><name>Short</name><operator>.</operator><name>MAX_VALUE</name></name> <operator>||</operator> <name>x</name> <operator>&lt;</operator> <name><name>Short</name><operator>.</operator><name>MIN_VALUE</name></name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(
                    <argument><expr><name><name>ErrorCode</name><operator>.</operator><name>NUMERIC_VALUE_OUT_OF_RANGE_2</name></name></expr></argument>, <argument><expr><call><name><name>Long</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getColumnName</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>short</name><operator>)</operator> <name>x</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert to integer, throwing exception if out of range.
     *
     * @param x integer value.
     * @param column Column info.
     * @return x
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>convertToInt</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name> <operator>||</operator> <name>x</name> <operator>&lt;</operator> <name><name>Integer</name><operator>.</operator><name>MIN_VALUE</name></name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(
                    <argument><expr><name><name>ErrorCode</name><operator>.</operator><name>NUMERIC_VALUE_OUT_OF_RANGE_2</name></name></expr></argument>, <argument><expr><call><name><name>Long</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getColumnName</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>long</name></type> <name>convertToLong</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name> <operator>||</operator> <name>x</name> <operator>&lt;</operator> <name><name>Long</name><operator>.</operator><name>MIN_VALUE</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// TODO document that +Infinity, -Infinity throw an exception and</comment>
            <comment type="line">// NaN returns 0</comment>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(
                    <argument><expr><name><name>ErrorCode</name><operator>.</operator><name>NUMERIC_VALUE_OUT_OF_RANGE_2</name></name></expr></argument>, <argument><expr><call><name><name>Double</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getColumnName</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>round</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>long</name></type> <name>convertToLong</name><parameter_list>(<parameter><decl><type><name>BigDecimal</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>x</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>MAX_LONG_DECIMAL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name><name>x</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>MIN_LONG_DECIMAL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(
                    <argument><expr><name><name>ErrorCode</name><operator>.</operator><name>NUMERIC_VALUE_OUT_OF_RANGE_2</name></name></expr></argument>, <argument><expr><call><name><name>x</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getColumnName</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>x</name><operator>.</operator><name>setScale</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>RoundingMode</name><operator>.</operator><name>HALF_UP</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>longValue</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>getColumnName</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>column</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name><name>column</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getTraceSQL</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Create an exception meaning the specified operation is not supported for
     * this data type.
     *
     * @param op the operation
     * @return the exception
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>DbException</name></type> <name>getUnsupportedExceptionForOperation</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>DbException</name><operator>.</operator><name>getUnsupportedException</name></name><argument_list>(<argument><expr><call><name>getTypeName</name><argument_list>(<argument><expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="char">' '</literal> <operator>+</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns length of this value in characters.
     *
     * @return length of this value in characters
     * @throws NullPointerException if this value is {@code NULL}
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>charLength</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getString</name><argument_list>()</argument_list></call><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns length of this value in bytes.
     *
     * @return length of this value in bytes
     * @throws NullPointerException if this value is {@code NULL}
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>octetLength</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>getBytesNoCopy</name><argument_list>()</argument_list></call><operator>.</operator><name>length</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns whether this value {@code IS TRUE}.
     *
     * @return {@code true} if it is. For {@code BOOLEAN} values returns
     *         {@code true} for {@code TRUE} and {@code false} for {@code FALSE}
     *         and {@code UNKNOWN} ({@code NULL}).
     * @see #getBoolean()
     * @see #isFalse()
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isTrue</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>this</name> <operator>!=</operator> <name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name></expr> ?</condition><then> <expr><call><name>getBoolean</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns whether this value {@code IS FALSE}.
     *
     * @return {@code true} if it is. For {@code BOOLEAN} values returns
     *         {@code true} for {@code FALSE} and {@code false} for {@code TRUE}
     *         and {@code UNKNOWN} ({@code NULL}).
     * @see #getBoolean()
     * @see #isTrue()
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isFalse</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>this</name> <operator>!=</operator> <name><name>ValueNull</name><operator>.</operator><name>INSTANCE</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getBoolean</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

}</block></class>
</unit>
