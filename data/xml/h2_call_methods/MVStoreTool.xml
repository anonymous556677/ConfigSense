<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/h2database/h2/src/main/org/h2/mvstore/MVStoreTool.java"><comment type="block">/*
 * Copyright 2004-2022 H2 Group. Multiple-Licensed under the MPL 2.0,
 * and the EPL 1.0 (https://h2database.com/html/license.html).
 * Initial Developer: H2 Group
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>OutputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>PrintWriter</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Writer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>channels</name><operator>.</operator><name>FileChannel</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>charset</name><operator>.</operator><name>StandardCharsets</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>sql</name><operator>.</operator><name>Timestamp</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name><operator>.</operator><name>Entry</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>TreeMap</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>compress</name><operator>.</operator><name>CompressDeflate</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>compress</name><operator>.</operator><name>CompressLZF</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>compress</name><operator>.</operator><name>Compressor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>Constants</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>message</name><operator>.</operator><name>DbException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>tx</name><operator>.</operator><name>TransactionStore</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>type</name><operator>.</operator><name>BasicDataType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mvstore</name><operator>.</operator><name>type</name><operator>.</operator><name>StringDataType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>store</name><operator>.</operator><name>fs</name><operator>.</operator><name>FilePath</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>store</name><operator>.</operator><name>fs</name><operator>.</operator><name>FileUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>Utils</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Utility methods used in combination with the MVStore.
 */</comment>
<class><specifier>public</specifier> class <name>MVStoreTool</name> <block>{

    <comment type="block" format="javadoc">/**
     * Runs this tool.
     * Options are case sensitive. Supported options are:
     * &lt;table&gt;
     * &lt;caption&gt;Command line options&lt;/caption&gt;
     * &lt;tr&gt;&lt;td&gt;[-dump &amp;lt;fileName&amp;gt;]&lt;/td&gt;
     * &lt;td&gt;Dump the contends of the file&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;[-info &amp;lt;fileName&amp;gt;]&lt;/td&gt;
     * &lt;td&gt;Get summary information about a file&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;[-compact &amp;lt;fileName&amp;gt;]&lt;/td&gt;
     * &lt;td&gt;Compact a store&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;[-compress &amp;lt;fileName&amp;gt;]&lt;/td&gt;
     * &lt;td&gt;Compact a store with compression enabled&lt;/td&gt;&lt;/tr&gt;
     * &lt;/table&gt;
     *
     * @param args the command line arguments
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>String</name><modifier>...</modifier></type> <name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>args</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="string">"-dump"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>dump</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"-info"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>info</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"-compact"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"-compress"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"-rollback"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>targetVersion</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>decode</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>rollback</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>targetVersion</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"-repair"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>fileName</name> <init>= <expr><name><name>args</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>repair</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Read the contents of the file and write them to system out.
     *
     * @param fileName the name of the file
     * @param details whether to print details
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>dump</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>details</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>dump</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Read the summary information of the file and write them to system out.
     *
     * @param fileName the name of the file
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>info</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>info</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Read the contents of the file and display them in a human-readable
     * format.
     *
     * @param fileName the name of the file
     * @param writer the print writer
     * @param details print the page details
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>dump</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>, <parameter><decl><type><name>Writer</name></type> <name>writer</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>details</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>PrintWriter</name></type> <name>pw</name> <init>= <expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"File not found: "</literal> <operator>+</operator> <name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><call><name><name>FileUtils</name><operator>.</operator><name>size</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"File %s, %d bytes, %d MB\n"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>/</operator> <literal type="number">1024</literal> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>TreeMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>mapSizesTotal</name> <init>=
                <expr><operator>new</operator> <call><name><name>TreeMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>pageSizeTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name>FileChannel</name></type> <name>file</name> <init>= <expr><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>open</name><argument_list>(<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>fileSize</name> <init>= <expr><call><name><name>file</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name><name>Long</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>fileSize</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>block</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>pageCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>fileSize</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>block</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Bugfix - An MVStoreException that wraps EOFException is</comment>
                <comment type="line">// thrown when partial writes happens in the case of power off</comment>
                <comment type="line">// or file system issues.</comment>
                <comment type="line">// So we should skip the broken block at end of the DB file.</comment>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"ERROR illegal position %d%n"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></catch></try>
                <expr_stmt><expr><call><name><name>block</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>headerType</name> <init>= <expr><call><name><name>block</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>headerType</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name></type> <name>header</name> <init>= <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><call><name><name>block</name><operator>.</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>StandardCharsets</name><operator>.</operator><name>ISO_8859_1</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"%0"</literal> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="string">"x fileHeader %s%n"</literal></expr></argument>,
                            <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>headerType</name> <operator>!=</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>block</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name></decl>;</decl_stmt>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>Chunk</name><operator>.</operator><name>readChunkHeader</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></catch></try>
                <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// not a chunk</comment>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"%n%0"</literal> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="string">"x chunkHeader %s%n"</literal></expr></argument>,
                        <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>chunk</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>block</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name><name>c</name><operator>.</operator><name>pageCount</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>pageCount</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>pageCount</name></name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>TreeMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>mapSizes</name> <init>=
                        <expr><operator>new</operator> <call><name><name>TreeMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pageSizeSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
                    <try>try <block>{<block_content>
                        <expr_stmt><expr><call><name><name>chunk</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IllegalArgumentException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                        <comment type="line">// too far</comment>
                        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"ERROR illegal position %d%n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></catch></try>
                    <decl_stmt><decl><type><name>int</name></type> <name>pageSize</name> <init>= <expr><call><name><name>chunk</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">// check value (ignored)</comment>
                    <expr_stmt><expr><call><name><name>chunk</name><operator>.</operator><name>getShort</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*int pageNo =*/</comment> <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>readVarInt</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>mapId</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readVarInt</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>entries</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readVarInt</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name><name>chunk</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>compressed</name> <init>= <expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name><name>DataUtils</name><operator>.</operator><name>PAGE_COMPRESSED</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>node</name> <init>= <expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name><name>DataUtils</name><operator>.</operator><name>PAGE_TYPE_NODE</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>details</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(
                                <argument><expr><literal type="string">"+%0"</literal> <operator>+</operator> <name>len</name> <operator>+</operator>
                                        <literal type="string">"x %s, map %x, %d entries, %d bytes, maxLen %x%n"</literal></expr></argument>,
                                <argument><expr><name>p</name></expr></argument>,
                                <argument><expr><operator>(</operator><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><literal type="string">"node"</literal></expr> </then><else>: <expr><literal type="string">"leaf"</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                                        <operator>(</operator><ternary><condition><expr><name>compressed</name></expr> ?</condition><then> <expr><literal type="string">" compressed"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                                <argument><expr><name>mapId</name></expr></argument>,
                                <argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><name>entries</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>entries</name></expr></else></ternary></expr></argument>,
                                <argument><expr><name>pageSize</name></expr></argument>,
                                <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageMaxLength</name></name><argument_list>(<argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPagePos</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
                        )</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>pageSize</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>Integer</name></type> <name>mapSize</name> <init>= <expr><call><name><name>mapSizes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>mapSize</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>mapSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>mapSizes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>, <argument><expr><name>mapSize</name> <operator>+</operator> <name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>Long</name></type> <name>total</name> <init>= <expr><call><name><name>mapSizesTotal</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>total</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>mapSizesTotal</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>, <argument><expr><name>total</name> <operator>+</operator> <name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pageSizeSum</name> <operator>+=</operator> <name>pageSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pageSizeTotal</name> <operator>+=</operator> <name>pageSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>children</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>long</name><index>[]</index></name></type> <name>counts</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>children</name> <operator>=</operator> <operator>new</operator> <name><name>long</name><index>[<expr><name>entries</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                            <expr_stmt><expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>chunk</name><operator>.</operator><name>getLong</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><name>counts</name> <operator>=</operator> <operator>new</operator> <name><name>long</name><index>[<expr><name>entries</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                            <decl_stmt><decl><type><name>long</name></type> <name>s</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readVarLong</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>keys</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>entries</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>mapId</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>details</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>data</name></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>compressed</name></expr>)</condition> <block>{<block_content>
                            <decl_stmt><decl><type><name>boolean</name></type> <name>fast</name> <init>= <expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name><name>DataUtils</name><operator>.</operator><name>PAGE_COMPRESSED_HIGH</name></name><operator>)</operator> <operator>!=</operator> <name><name>DataUtils</name><operator>.</operator><name>PAGE_COMPRESSED_HIGH</name></name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Compressor</name></type> <name>compressor</name> <init>= <expr><call><name>getCompressor</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>int</name></type> <name>lenAdd</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readVarInt</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>int</name></type> <name>compLen</name> <init>= <expr><name>pageSize</name> <operator>+</operator> <name>start</name> <operator>-</operator> <call><name><name>chunk</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>comp</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>newBytes</name></name><argument_list>(<argument><expr><name>compLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>chunk</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name>compLen</name> <operator>+</operator> <name>lenAdd</name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>compressor</name><operator>.</operator><name>expand</name></name><argument_list>(<argument><expr><name>comp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>compLen</name></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><name>data</name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                            <decl_stmt><decl><type><name>String</name></type> <name>k</name> <init>= <expr><call><name><name>StringDataType</name><operator>.</operator><name>INSTANCE</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
                            <comment type="line">// meta map node</comment>
                            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                                <decl_stmt><decl><type><name>long</name></type> <name>cp</name> <init>= <expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"    %d children &lt; %s @ "</literal> <operator>+</operator>
                                                <literal type="string">"chunk %x +%0"</literal> <operator>+</operator>
                                                <name>len</name> <operator>+</operator> <literal type="string">"x%n"</literal></expr></argument>,
                                        <argument><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageChunkId</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>
                            <decl_stmt><decl><type><name>long</name></type> <name>cp</name> <init>= <expr><name><name>children</name><index>[<expr><name>entries</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"    %d children &gt;= %s @ chunk %x +%0"</literal> <operator>+</operator>
                                            <name>len</name> <operator>+</operator> <literal type="string">"x%n"</literal></expr></argument>,
                                    <argument><expr><name><name>counts</name><index>[<expr><name>entries</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><ternary><condition><expr><name><name>keys</name><operator>.</operator><name>length</name></name> <operator>&gt;=</operator> <name>entries</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name><name>keys</name><index>[<expr><name>entries</name></expr>]</index></name></expr></else></ternary></expr></argument>,
                                    <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageChunkId</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <comment type="line">// meta map leaf</comment>
                            <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>values</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>entries</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                                <decl_stmt><decl><type><name>String</name></type> <name>v</name> <init>= <expr><call><name><name>StringDataType</name><operator>.</operator><name>INSTANCE</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
                            </block_content>}</block></for>
                            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"    "</literal> <operator>+</operator> <name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator>
                                        <literal type="string">" = "</literal> <operator>+</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name>details</name></expr>)</condition> <block>{<block_content>
                            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                                <decl_stmt><decl><type><name>long</name></type> <name>cp</name> <init>= <expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"    %d children @ chunk %x +%0"</literal> <operator>+</operator>
                                                <name>len</name> <operator>+</operator> <literal type="string">"x%n"</literal></expr></argument>,
                                        <argument><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageChunkId</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>DataUtils</name><operator>.</operator><name>getPageOffset</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>pageSizeSum</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pageSizeSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>Integer</name></type> <name>mapId</name> <range>: <expr><call><name><name>mapSizes</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>percent</name> <init>= <expr><literal type="number">100</literal> <operator>*</operator> <call><name><name>mapSizes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>pageSizeSum</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"map %x: %d bytes, %d%%%n"</literal></expr></argument>, <argument><expr><name>mapId</name></expr></argument>, <argument><expr><call><name><name>mapSizes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <decl_stmt><decl><type><name>int</name></type> <name>footerPos</name> <init>= <expr><call><name><name>chunk</name><operator>.</operator><name>limit</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></init></decl>;</decl_stmt>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><call><name><name>chunk</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>footerPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(
                            <argument><expr><literal type="string">"+%0"</literal> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="string">"x chunkFooter %s%n"</literal></expr></argument>,
                            <argument><expr><name>footerPos</name></expr></argument>,
                            <argument><expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><call><name><name>chunk</name><operator>.</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>chunk</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>Chunk</name><operator>.</operator><name>FOOTER_LENGTH</name></name></expr></argument>, <argument><expr><name><name>StandardCharsets</name><operator>.</operator><name>ISO_8859_1</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IllegalArgumentException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <comment type="line">// too far</comment>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"ERROR illegal footer position %d%n"</literal></expr></argument>, <argument><expr><name>footerPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></catch></try>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"%n%0"</literal> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="string">"x eof%n"</literal></expr></argument>, <argument><expr><name>fileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pageCount</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pageCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"page size total: %d bytes, page count: %d, average page size: %d bytes\n"</literal></expr></argument>,
                    <argument><expr><name>pageSizeTotal</name></expr></argument>, <argument><expr><name>pageCount</name></expr></argument>, <argument><expr><name>pageSizeTotal</name> <operator>/</operator> <name>pageCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pageSizeTotal</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pageSizeTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>Integer</name></type> <name>mapId</name> <range>: <expr><call><name><name>mapSizesTotal</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>percent</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <call><name><name>mapSizesTotal</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>pageSizeTotal</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"map %x: %d bytes, %d%%%n"</literal></expr></argument>, <argument><expr><name>mapId</name></expr></argument>, <argument><expr><call><name><name>mapSizesTotal</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>mapId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"ERROR: "</literal> <operator>+</operator> <name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>(<argument><expr><name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
        <comment type="line">// ignore</comment>
        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Compressor</name></type> <name>getCompressor</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>fast</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>fast</name></expr> ?</condition><then> <expr><operator>new</operator> <call><name>CompressLZF</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <call><name>CompressDeflate</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Read the summary information of the file and write them to system out.
     *
     * @param fileName the name of the file
     * @param writer the print writer
     * @return null if successful (if there was no error), otherwise the error
     *         message
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>info</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>, <parameter><decl><type><name>Writer</name></type> <name>writer</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>PrintWriter</name></type> <name>pw</name> <init>= <expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"File not found: "</literal> <operator>+</operator> <name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="string">"File not found: "</literal> <operator>+</operator> <name>fileName</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>fileLength</name> <init>= <expr><call><name><name>FileUtils</name><operator>.</operator><name>size</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name>MVStore</name></type> <name>store</name> <init>= <expr><operator>new</operator> <call><name><name>MVStore</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator>
                <call><name>fileName</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>recoveryMode</name><argument_list>()</argument_list></call><operator>.</operator>
                <call><name>readOnly</name><argument_list>()</argument_list></call><operator>.</operator><call><name>open</name><argument_list>()</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
            <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>layout</name> <init>= <expr><call><name><name>store</name><operator>.</operator><name>getLayoutMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>header</name> <init>= <expr><call><name><name>store</name><operator>.</operator><name>getStoreHeader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>fileCreated</name> <init>= <expr><call><name><name>DataUtils</name><operator>.</operator><name>readHexLong</name></name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"created"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>TreeMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>chunks</name> <init>= <expr><operator>new</operator> <call><name><name>TreeMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>chunkLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>maxLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>maxLengthLive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>maxLengthNotEmpty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>e</name> <range>: <expr><call><name><name>layout</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>k</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>k</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_CHUNK</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name><name>Chunk</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>chunks</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>chunkLength</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maxLength</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLen</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maxLengthLive</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLenLive</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>maxLenLive</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>maxLengthNotEmpty</name> <operator>+=</operator> <name><name>c</name><operator>.</operator><name>maxLen</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Created: %s\n"</literal></expr></argument>, <argument><expr><call><name>formatTimestamp</name><argument_list>(<argument><expr><name>fileCreated</name></expr></argument>, <argument><expr><name>fileCreated</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Last modified: %s\n"</literal></expr></argument>,
                    <argument><expr><call><name>formatTimestamp</name><argument_list>(<argument><expr><call><name><name>FileUtils</name><operator>.</operator><name>lastModified</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fileCreated</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"File length: %d\n"</literal></expr></argument>, <argument><expr><name>fileLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"The last chunk is not listed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Chunk length: %d\n"</literal></expr></argument>, <argument><expr><name>chunkLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Chunk count: %d\n"</literal></expr></argument>, <argument><expr><call><name><name>chunks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Used space: %d%%\n"</literal></expr></argument>, <argument><expr><call><name>getPercent</name><argument_list>(<argument><expr><name>chunkLength</name></expr></argument>, <argument><expr><name>fileLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Chunk fill rate: %d%%\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>maxLength</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>:
                <expr><call><name>getPercent</name><argument_list>(<argument><expr><name>maxLengthLive</name></expr></argument>, <argument><expr><name>maxLength</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"Chunk fill rate excluding empty chunks: %d%%\n"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><name>maxLengthNotEmpty</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>:
                <expr><call><name>getPercent</name><argument_list>(<argument><expr><name>maxLengthLive</name></expr></argument>, <argument><expr><name>maxLengthNotEmpty</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Chunk</name></argument>&gt;</argument_list></name></type> <name>e</name> <range>: <expr><call><name><name>chunks</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>created</name> <init>= <expr><name>fileCreated</name> <operator>+</operator> <name><name>c</name><operator>.</operator><name>time</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"  Chunk %d: %s, %d%% used, %d blocks"</literal></expr></argument>,
                        <argument><expr><name><name>c</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>formatTimestamp</name><argument_list>(<argument><expr><name>created</name></expr></argument>, <argument><expr><name>fileCreated</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>getPercent</name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>maxLenLive</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>maxLen</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>c</name><operator>.</operator><name>len</name></name></expr></argument>
                        )</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>maxLenLive</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">", unused: %s"</literal></expr></argument>,
                            <argument><expr><call><name>formatTimestamp</name><argument_list>(<argument><expr><name>fileCreated</name> <operator>+</operator> <name><name>c</name><operator>.</operator><name>unused</name></name></expr></argument>, <argument><expr><name>fileCreated</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>printf</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"ERROR: "</literal> <operator>+</operator> <name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>(<argument><expr><name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></catch></try>
        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>formatTimestamp</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>x</name> <init>= <expr><operator>new</operator> <call><name>Timestamp</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>x</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="string">" (+"</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>t</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>+</operator> <literal type="string">" s)"</literal></expr>;</expr_stmt>
        <return>return <expr><name>s</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getPercent</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>==</operator> <name>max</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">100</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">98</literal> <operator>*</operator> <name>value</name> <operator>/</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Compress the store by creating a new file and copying the live pages
     * there. Temporarily, a file with the suffix ".tempFile" is created. This
     * file is then renamed, replacing the original file, if possible. If not,
     * the new file is renamed to ".newFile", then the old file is removed, and
     * the new file is renamed. This might be interrupted, so it's better to
     * compactCleanUp before opening a store, in case this method was used.
     *
     * @param fileName the file name
     * @param compress whether to compress the data
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>compact</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>compress</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>tempName</name> <init>= <expr><name>fileName</name> <operator>+</operator> <name><name>Constants</name><operator>.</operator><name>SUFFIX_MV_STORE_TEMP_FILE</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><name>tempName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>tempName</name></expr></argument>, <argument><expr><name>compress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>moveAtomicReplace</name></name><argument_list>(<argument><expr><name>tempName</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>DbException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>newName</name> <init>= <expr><name>fileName</name> <operator>+</operator> <name><name>Constants</name><operator>.</operator><name>SUFFIX_MV_STORE_NEW_FILE</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>move</name></name><argument_list>(<argument><expr><name>tempName</name></expr></argument>, <argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>move</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Clean up if needed, in a case a compact operation was interrupted due to
     * killing the process or a power failure. This will delete temporary files
     * (if any), and in case atomic file replacements were not used, rename the
     * new file.
     *
     * @param fileName the file name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>compactCleanUp</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>tempName</name> <init>= <expr><name>fileName</name> <operator>+</operator> <name><name>Constants</name><operator>.</operator><name>SUFFIX_MV_STORE_TEMP_FILE</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>FileUtils</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><name>tempName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><name>tempName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>newName</name> <init>= <expr><name>fileName</name> <operator>+</operator> <name><name>Constants</name><operator>.</operator><name>SUFFIX_MV_STORE_NEW_FILE</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>FileUtils</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>FileUtils</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>move</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Copy all live pages from the source store to the target store.
     *
     * @param sourceFileName the name of the source store
     * @param targetFileName the name of the target store
     * @param compress whether to compress the data
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>compact</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>sourceFileName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>targetFileName</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>compress</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <try>try <init>(<decl><type><name>MVStore</name></type> <name>source</name> <init>= <expr><operator>new</operator> <call><name><name>MVStore</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator>
                <call><name>fileName</name><argument_list>(<argument><expr><name>sourceFileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>readOnly</name><argument_list>()</argument_list></call><operator>.</operator><call><name>open</name><argument_list>()</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
            <comment type="line">// Bugfix - Add double "try-finally" statements to close source and target stores for</comment>
            <comment type="line">//releasing lock and file resources in these stores even if OOM occurs.</comment>
            <comment type="line">// Fix issues such as "Cannot delete file "/h2/data/test.mv.db.tempFile" [90025-197]"</comment>
            <comment type="line">//when client connects to this server and reopens this store database in this process.</comment>
            <comment type="line">// @since 2018-09-13 little-pan</comment>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><name>targetFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>MVStore</name><operator>.</operator><name>Builder</name></name></type> <name>b</name> <init>= <expr><operator>new</operator> <call><name><name>MVStore</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator>
                <call><name>fileName</name><argument_list>(<argument><expr><name>targetFileName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>compress</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>b</name><operator>.</operator><name>compress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <try>try <init>(<decl><type><name>MVStore</name></type> <name>target</name> <init>= <expr><call><name><name>b</name><operator>.</operator><name>open</name></name><argument_list>()</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
                <expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></try>
        </block_content>}</block></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Copy all live pages from the source store to the target store.
     *
     * @param source the source store
     * @param target the target store
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>compact</name><parameter_list>(<parameter><decl><type><name>MVStore</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>MVStore</name></type> <name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>autoCommitDelay</name> <init>= <expr><call><name><name>target</name><operator>.</operator><name>getAutoCommitDelay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>reuseSpace</name> <init>= <expr><call><name><name>target</name><operator>.</operator><name>getReuseSpace</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>setReuseSpace</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// disable unused chunks collection</comment>
            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>setAutoCommitDelay</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// disable autocommit</comment>
            <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sourceMeta</name> <init>= <expr><call><name><name>source</name><operator>.</operator><name>getMetaMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>targetMeta</name> <init>= <expr><call><name><name>target</name><operator>.</operator><name>getMetaMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>m</name> <range>: <expr><call><name><name>sourceMeta</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_MAP</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// ignore</comment>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>DataUtils</name><operator>.</operator><name>META_NAME</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// ignore</comment>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name><name>targetMeta</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <comment type="line">// We are going to cheat a little bit in the copyFrom() by employing "incomplete" pages,</comment>
            <comment type="line">// which would be spared of saving, but save completed pages underneath,</comment>
            <comment type="line">// and those may appear as dead (non-reachable).</comment>
            <comment type="line">// That's why it is important to preserve all chunks</comment>
            <comment type="line">// created in the process, especially if retention time</comment>
            <comment type="line">// is set to a lower value, or even 0.</comment>
            <for>for <control>(<init><decl><type><name>String</name></type> <name>mapName</name> <range>: <expr><call><name><name>source</name><operator>.</operator><name>getMapNames</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name><name>MVMap</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></name></type> <name>mp</name> <init>= <expr><call><name>getGenericMapBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// This is a hack to preserve chunks occupancy rate accounting.</comment>
                <comment type="line">// It exposes design deficiency flaw in MVStore related to lack of</comment>
                <comment type="line">// map's type metadata.</comment>
                <comment type="line">// TODO: Introduce type metadata which will allow to open any store</comment>
                <comment type="line">// TODO: without prior knowledge of keys / values types and map implementation</comment>
                <comment type="line">// TODO: (MVMap vs MVRTreeMap, regular vs. singleWriter etc.)</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>mapName</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>TransactionStore</name><operator>.</operator><name>UNDO_LOG_NAME_PREFIX</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>mp</name><operator>.</operator><name>singleWriter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>sourceMap</name> <init>= <expr><call><name><name>source</name><operator>.</operator><name>openMap</name></name><argument_list>(<argument><expr><name>mapName</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>MVMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>targetMap</name> <init>= <expr><call><name><name>target</name><operator>.</operator><name>openMap</name></name><argument_list>(<argument><expr><name>mapName</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>targetMap</name><operator>.</operator><name>copyFrom</name></name><argument_list>(<argument><expr><name>sourceMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>targetMeta</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><call><name><name>targetMap</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>sourceMeta</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>MVMap</name><operator>.</operator><name>getMapKey</name></name><argument_list>(<argument><expr><call><name><name>sourceMap</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <comment type="line">// this will end hacky mode of operation with incomplete pages</comment>
            <comment type="line">// end ensure that all pages are saved</comment>
            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>setAutoCommitDelay</name></name><argument_list>(<argument><expr><name>autoCommitDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>setReuseSpace</name></name><argument_list>(<argument><expr><name>reuseSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Repair a store by rolling back to the newest good version.
     *
     * @param fileName the file name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>repair</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>PrintWriter</name></type> <name>pw</name> <init>= <expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>version</name> <init>= <expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OutputStream</name></type> <name>ignore</name> <init>= <expr><operator>new</operator> <class><super><name>OutputStream</name></super><argument_list>()</argument_list> <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <comment type="line">// ignore</comment>
            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>version</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>version</name> <operator>==</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr> ?</condition><then> <expr><literal type="string">"Trying latest version"</literal></expr>
                    </then><else>: <expr><operator>(</operator><literal type="string">"Trying version "</literal> <operator>+</operator> <name>version</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>rollback</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>ignore</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>error</name> <init>= <expr><call><name>info</name><argument_list>(<argument><expr><name>fileName</name> <operator>+</operator> <literal type="string">".temp"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>ignore</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>moveTo</name><argument_list>(<argument><expr><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name> <operator>+</operator> <literal type="string">".back"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name> <operator>+</operator> <literal type="string">".temp"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>moveTo</name><argument_list>(<argument><expr><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"    ... failed: "</literal> <operator>+</operator> <name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Fail: "</literal> <operator>+</operator> <call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
            <expr_stmt><expr><name>version</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Roll back to a given revision into a file called *.temp.
     *
     * @param fileName the file name
     * @param targetVersion the version to roll back to (Long.MAX_VALUE for the
     *            latest version)
     * @param writer the log writer
     * @return the version rolled back to (-1 if no version)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>rollback</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fileName</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>targetVersion</name></decl></parameter>, <parameter><decl><type><name>Writer</name></type> <name>writer</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>newestVersion</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PrintWriter</name></type> <name>pw</name> <init>= <expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"File not found: "</literal> <operator>+</operator> <name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>newestVersion</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>FileChannel</name></type> <name>file</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FileChannel</name></type> <name>target</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr></init></decl>;</decl_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><name>file</name> <operator>=</operator> <call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>open</name><argument_list>(<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name> <operator>+</operator> <literal type="string">".temp"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>delete</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>target</name> <operator>=</operator> <call><name><name>FilePath</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fileName</name> <operator>+</operator> <literal type="string">".temp"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>open</name><argument_list>(<argument><expr><literal type="string">"rw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>fileSize</name> <init>= <expr><call><name><name>file</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>block</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Chunk</name></type> <name>newestChunk</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>fileSize</name></expr>;</condition><incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>block</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>block</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>headerType</name> <init>= <expr><call><name><name>block</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>headerType</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>block</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>headerType</name> <operator>!=</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name>Chunk</name></type> <name>c</name></decl>;</decl_stmt>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>Chunk</name><operator>.</operator><name>readChunkHeader</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>MVStoreException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></catch></try>
                <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// not a chunk</comment>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>blockSize</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>c</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>chunk</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <name>targetVersion</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// newer than the requested version</comment>
                    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>chunk</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>newestChunk</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>c</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <name><name>newestChunk</name><operator>.</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>newestChunk</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newestVersion</name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>newestChunk</name><operator>.</operator><name>len</name></name> <operator>*</operator> <name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>chunk</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocate</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>DataUtils</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>newestChunk</name><operator>.</operator><name>block</name></name> <operator>*</operator> <name><name>MVStore</name><operator>.</operator><name>BLOCK_SIZE</name></name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>chunk</name><operator>.</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>fileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"ERROR: "</literal> <operator>+</operator> <name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>(<argument><expr><name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch> <finally>finally <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>file</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <comment type="line">// ignore</comment>
                </block_content>}</block></catch></try>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                    <comment type="line">// ignore</comment>
                </block_content>}</block></catch></try>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></finally></try>
        <expr_stmt><expr><call><name><name>pw</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>newestVersion</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><block>{<expr><literal type="string">"rawtypes"</literal></expr>,<argument><expr><literal type="string">"unchecked"</literal></expr></argument>}</block></expr></argument>)</argument_list></annotation>
    <type><specifier>static</specifier> <name><name>MVMap</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>,<argument><name>Object</name></argument>&gt;</argument_list></name></name></type> <name>getGenericMapBuilder</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><operator>(</operator><name><name>MVMap</name><operator>.</operator><name>Builder</name></name><operator>)</operator><operator>new</operator> <call><name><name>MVMap</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;<argument><name><name>byte</name><index>[]</index></name></argument>,<argument><name><name>byte</name><index>[]</index></name></argument>&gt;</argument_list></name></name><argument_list>()</argument_list></call><operator>.</operator>
                <call><name>keyType</name><argument_list>(<argument><expr><name><name>GenericDataType</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>)</argument_list></call><operator>.</operator>
                <call><name>valueType</name><argument_list>(<argument><expr><name><name>GenericDataType</name><operator>.</operator><name>INSTANCE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * A data type that can read any data that is persisted, and converts it to
     * a byte array.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>GenericDataType</name> <super_list><extends>extends <super><name><name>BasicDataType</name><argument_list type="generic">&lt;<argument><name><name>byte</name><index>[]</index></name></argument>&gt;</argument_list></name></super></extends></super_list> <block>{
        <decl_stmt><decl><type><specifier>static</specifier> <name>GenericDataType</name></type> <name>INSTANCE</name> <init>= <expr><operator>new</operator> <call><name>GenericDataType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>GenericDataType</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>boolean</name></type> <name>isMemoryEstimationAllowed</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>int</name></type> <name>getMemory</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><ternary><condition><expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>obj</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">8</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name><name>byte</name><index>[]</index><index>[]</index></name></type> <name>createStorage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>size</name></expr>]</index><index>[]</index></name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>write</name><parameter_list>(<parameter><decl><type><name>WriteBuffer</name></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name><name>byte</name><index>[]</index></name></type> <name>read</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buff</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name><name>buff</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>data</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>data</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>
}</block></class>
</unit>
