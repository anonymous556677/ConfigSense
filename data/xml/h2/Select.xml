<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/h2database/h2/src/main/org/h2/command/query/Select.java"><comment type="block">/*
 * Copyright 2004-2022 H2 Group. Multiple-Licensed under the MPL 2.0,
 * and the EPL 1.0 (https://h2database.com/html/license.html).
 * Initial Developer: H2 Group
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>command</name><operator>.</operator><name>query</name></name>;</package>

<import>import static <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>Expression</name><operator>.</operator><name>WITHOUT_PARENTHESES</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>HasSQL</name><operator>.</operator><name>ADD_PLAN_INFORMATION</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>HasSQL</name><operator>.</operator><name>DEFAULT_SQL_FLAGS</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>BitSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedHashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name><operator>.</operator><name>Entry</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>api</name><operator>.</operator><name>ErrorCode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>api</name><operator>.</operator><name>Trigger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>Constants</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>Database</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>Mode</name><operator>.</operator><name>ExpressionNames</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>engine</name><operator>.</operator><name>SessionLocal</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>Alias</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>Expression</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>ExpressionColumn</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>ExpressionList</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>ExpressionVisitor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>Parameter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>Wildcard</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>analysis</name><operator>.</operator><name>DataAnalysisOperation</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Window</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>condition</name><operator>.</operator><name>Comparison</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>condition</name><operator>.</operator><name>ConditionAndOr</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>condition</name><operator>.</operator><name>ConditionLocalAndGlobal</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>expression</name><operator>.</operator><name>function</name><operator>.</operator><name>CoalesceFunction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>index</name><operator>.</operator><name>Cursor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>index</name><operator>.</operator><name>Index</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>index</name><operator>.</operator><name>ViewIndex</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>message</name><operator>.</operator><name>DbException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>mode</name><operator>.</operator><name>DefaultNullOrdering</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>LazyResult</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>LocalResult</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>ResultInterface</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>ResultTarget</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>Row</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>SearchRow</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>result</name><operator>.</operator><name>SortOrder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>Column</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>ColumnResolver</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>IndexColumn</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>Table</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>TableFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>TableType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>table</name><operator>.</operator><name>TableView</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>ParserUtil</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>StringUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>util</name><operator>.</operator><name>Utils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>DataType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>Value</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>h2</name><operator>.</operator><name>value</name><operator>.</operator><name>ValueRow</name></name>;</import>

<comment type="block" format="javadoc">/**
 * This class represents a simple SELECT statement.
 *
 * For each select statement,
 * visibleColumnCount &amp;lt;= distinctColumnCount &amp;lt;= expressionCount.
 * The expression list count could include ORDER BY and GROUP BY expressions
 * that are not in the select list.
 *
 * The call sequence is init(), mapColumns() if it's a subquery, prepare().
 *
 * @author Thomas Mueller
 * @author Joel Turkel (Group sorted query)
 */</comment>
<class><specifier>public</specifier> class <name>Select</name> <super_list><extends>extends <super><name>Query</name></super></extends></super_list> <block>{

    <comment type="block" format="javadoc">/**
     * The main (top) table filter.
     */</comment>
    <decl_stmt><decl><type><name>TableFilter</name></type> <name>topTableFilter</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>TableFilter</name></argument>&gt;</argument_list></name></type> <name>filters</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>newSmallArrayList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>TableFilter</name></argument>&gt;</argument_list></name></type> <name>topFilters</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>newSmallArrayList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Parent select for selects in table filters.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Select</name></type> <name>parentSelect</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * WHERE condition.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Expression</name></type> <name>condition</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * HAVING condition.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Expression</name></type> <name>having</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * QUALIFY condition.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Expression</name></type> <name>qualify</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * {@code DISTINCT ON(...)} expressions.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Expression</name><index>[]</index></name></type> <name>distinctExpressions</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>distinctIndexes</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>group</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The indexes of the group-by columns.
     */</comment>
    <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>groupIndex</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether a column in the expression list is part of a group-by.
     */</comment>
    <decl_stmt><decl><type><name><name>boolean</name><index>[]</index></name></type> <name>groupByExpression</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Grouped data for aggregates.
     */</comment>
    <decl_stmt><decl><type><name>SelectGroups</name></type> <name>groupData</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>havingIndex</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>qualifyIndex</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>groupByCopies</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Whether this SELECT is an explicit table (TABLE tableName). It is used in
     * {@link #getPlanSQL(int)} to generate SQL similar to original query.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isExplicitTable</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * This flag is set when SELECT statement contains (non-window) aggregate
     * functions, GROUP BY clause or HAVING clause.
     */</comment>
    <decl_stmt><decl><type><name>boolean</name></type> <name>isGroupQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isGroupSortedQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isWindowQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isForUpdate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>double</name></type> <name>cost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isQuickAggregateQuery</name></decl>, <decl><type ref="prev"/><name>isDistinctQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>sortUsingIndex</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isGroupWindowStage2</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Window</name></argument>&gt;</argument_list></name></type> <name>windows</name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>Select</name><parameter_list>(<parameter><decl><type><name>SessionLocal</name></type> <name>session</name></decl></parameter>, <parameter><decl><type><name>Select</name></type> <name>parentSelect</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>parentSelect</name></name> <operator>=</operator> <name>parentSelect</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>isUnion</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Add a table to the query.
     *
     * @param filter the table to add
     * @param isTop if the table can be the first table in the query plan
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addTableFilter</name><parameter_list>(<parameter><decl><type><name>TableFilter</name></type> <name>filter</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isTop</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// Oracle doesn't check on duplicate aliases</comment>
        <comment type="line">// String alias = filter.getAlias();</comment>
        <comment type="line">// if (filterNames.contains(alias)) {</comment>
        <comment type="line">//     throw Message.getSQLException(</comment>
        <comment type="line">//         ErrorCode.DUPLICATE_TABLE_ALIAS, alias);</comment>
        <comment type="line">// }</comment>
        <comment type="line">// filterNames.add(alias);</comment>
        <expr_stmt><expr><call><name><name>filters</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isTop</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>topFilters</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>TableFilter</name></argument>&gt;</argument_list></name></type> <name>getTopFilters</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>topFilters</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setExpressions</name><parameter_list>(<parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>expressions</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>expressions</name></name> <operator>=</operator> <name>expressions</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Convert this SELECT to an explicit table (TABLE tableName).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setExplicitTable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>setWildcard</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isExplicitTable</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Sets a wildcard expression as in "SELECT * FROM TEST".
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setWildcard</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>expressions</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Wildcard</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set when SELECT statement contains (non-window) aggregate functions,
     * GROUP BY clause or HAVING clause.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setGroupQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>isGroupQuery</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Called if this query contains window functions.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setWindowQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>isWindowQuery</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setGroupBy</name><parameter_list>(<parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>group</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Expression</name></argument>&gt;</argument_list></name></type> <name>getGroupBy</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>group</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the group data if there is currently a group-by active.
     *
     * @param window is this a window function
     * @return the grouped data
     */</comment>
    <function><type><specifier>public</specifier> <name>SelectGroups</name></type> <name>getGroupDataIfCurrent</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>window</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>groupData</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>window</name> <operator>||</operator> <call><name><name>groupData</name><operator>.</operator><name>isCurrentGroup</name></name><argument_list>()</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>groupData</name></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the distinct flag.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDistinct</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getUnsupportedException</name></name><argument_list>(<argument><expr><literal type="string">"DISTINCT ON together with DISTINCT"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>distinct</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set the DISTINCT ON expressions.
     *
     * @param distinctExpressions array of expressions
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDistinct</name><parameter_list>(<parameter><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>distinctExpressions</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>distinct</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getUnsupportedException</name></name><argument_list>(<argument><expr><literal type="string">"DISTINCT ON together with DISTINCT"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>distinctExpressions</name></name> <operator>=</operator> <name>distinctExpressions</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>isAnyDistinct</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>distinct</name> <operator>||</operator> <name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Adds a named window definition.
     *
     * @param name name
     * @param window window definition
     * @return true if a new definition was added, false if old definition was replaced
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>addWindow</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>Window</name></type> <name>window</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>windows</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>windows</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>windows</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>window</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a window with specified name, or null.
     *
     * @param name name of the window
     * @return the window with specified name, or null
     */</comment>
    <function><type><specifier>public</specifier> <name>Window</name></type> <name>getWindow</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>windows</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>windows</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Add a condition to the list of conditions.
     *
     * @param cond the condition to add
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addCondition</name><parameter_list>(<parameter><decl><type><name>Expression</name></type> <name>cond</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>cond</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>condition</name> <operator>=</operator> <operator>new</operator> <call><name>ConditionAndOr</name><argument_list>(<argument><expr><name><name>ConditionAndOr</name><operator>.</operator><name>AND</name></name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>condition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Expression</name></type> <name>getCondition</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>condition</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>LazyResult</name></type> <name>queryGroupSorted</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>ResultTarget</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>LazyResultGroupSorted</name></type> <name>lazyResult</name> <init>= <expr><operator>new</operator> <call><name>LazyResultGroupSorted</name><argument_list>(<argument><expr><name>expressionArray</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>skipOffset</name><argument_list>(<argument><expr><name>lazyResult</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>lazyResult</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <while>while <condition>(<expr><call><name><name>lazyResult</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addRow</name></name><argument_list>(<argument><expr><call><name><name>lazyResult</name><operator>.</operator><name>currentRow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Create a row with the current values, for queries with group-sort.
     *
     * @param keyValues the key values
     * @param columnCount the number of columns
     * @return the row
     */</comment>
    <function><type><name><name>Value</name><index>[]</index></name></type> <name>createGroupSortedRow</name><parameter_list>(<parameter><decl><type><name><name>Value</name><index>[]</index></name></type> <name>keyValues</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><call><name>constructGroupResultRow</name><argument_list>(<argument><expr><name>keyValues</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isHavingNullOrFalse</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>rowForResult</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Removes HAVING and QUALIFY columns from the row.
     *
     * @param row
     *            the complete row
     * @param columnCount
     *            the number of columns to keep
     * @return the same or the truncated row
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Value</name><index>[]</index></name></type> <name>rowForResult</name><parameter_list>(<parameter><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>columnCount</name> <operator>==</operator> <name>resultColumnCount</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>row</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>resultColumnCount</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isHavingNullOrFalse</name><parameter_list>(<parameter><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><name>havingIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>row</name><index>[<expr><name>havingIndex</name></expr>]</index></name><operator>.</operator><call><name>isTrue</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Index</name></type> <name>getGroupSortedIndex</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>groupIndex</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>groupByExpression</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getIndexes</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>indexes</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><name>indexes</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>getIndexType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isScan</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>getIndexType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isHash</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// does not allow scanning entries</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>isGroupSortedIndex</name><argument_list>(<argument><expr><name>topTableFilter</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><name>index</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isGroupSortedIndex</name><parameter_list>(<parameter><decl><type><name>TableFilter</name></type> <name>tableFilter</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// check that all the GROUP BY expressions are part of the index</comment>
        <decl_stmt><decl><type><name><name>Column</name><index>[]</index></name></type> <name>indexColumns</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// also check that the first columns in the index are grouped</comment>
        <decl_stmt><decl><type><name><name>boolean</name><index>[]</index></name></type> <name>grouped</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><name><name>indexColumns</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <label><name>outerLoop</name>:</label>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>groupByExpression</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getNonAliasExpression</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>expr</name> <operator>instanceof</operator> <name>ExpressionColumn</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>ExpressionColumn</name></type> <name>exprCol</name> <init>= <expr><operator>(</operator><name>ExpressionColumn</name><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>indexColumns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>tableFilter</name> <operator>==</operator> <call><name><name>exprCol</name><operator>.</operator><name>getTableFilter</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>indexColumns</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>exprCol</name><operator>.</operator><name>getColumn</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>grouped</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <continue>continue <name>outerLoop</name>;</continue>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <comment type="line">// We didn't find a matching index column</comment>
            <comment type="line">// for one group by expression</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></for>
        <comment type="line">// check that the first columns in the index are grouped</comment>
        <comment type="line">// good: index(a, b, c); group by b, a</comment>
        <comment type="line">// bad: index(a, b, c); group by a, c</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>grouped</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>grouped</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>grouped</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>boolean</name></type> <name>isConditionMetForUpdate</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isConditionMet</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name><name>filters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>notChanged</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>TableFilter</name></type> <name>tableFilter</name> <init>= <expr><call><name><name>filters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>tableFilter</name><operator>.</operator><name>isJoinOuter</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>tableFilter</name><operator>.</operator><name>isJoinOuterIndirect</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Row</name></type> <name>row</name> <init>= <expr><call><name><name>tableFilter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>tableFilter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">// Views, function tables, links, etc. do not support locks</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>table</name><operator>.</operator><name>isRowLockable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>Row</name></type> <name>lockedRow</name> <init>= <expr><call><name><name>table</name><operator>.</operator><name>lockRow</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>lockedRow</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>row</name><operator>.</operator><name>hasSharedData</name></name><argument_list>(<argument><expr><name>lockedRow</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name><name>tableFilter</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>lockedRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>notChanged</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <return>return <expr><name>notChanged</name> <operator>||</operator> <call><name>isConditionMet</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>boolean</name></type> <name>isConditionMet</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>condition</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>condition</name><operator>.</operator><name>getBooleanValue</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>queryWindow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>LocalResult</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>initGroupData</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>gatherGroup</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_WINDOW</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>processGroupResult</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>queryGroupWindow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>LocalResult</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>initGroupData</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>gatherGroup</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_GROUP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try <block>{<block_content>
                <expr_stmt><expr><name>isGroupWindowStage2</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <while>while <condition>(<expr><call><name><name>groupData</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>havingIndex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>havingIndex</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getBooleanValue</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>updateAgg</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_WINDOW</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>done</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>processGroupResult</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>, <comment type="block">/* Having was performed earlier */</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <finally>finally <block>{<block_content>
                <expr_stmt><expr><name>isGroupWindowStage2</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>queryGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>LocalResult</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>initGroupData</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><call><name>gatherGroup</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_GROUP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>processGroupResult</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>initGroupData</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>groupData</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>setGroupData</name><argument_list>(<argument><expr><call><name><name>SelectGroups</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>expressions</name></expr></argument>, <argument><expr><name>isGroupQuery</name></expr></argument>, <argument><expr><name>groupIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>updateAgg</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_RESET</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>setGroupData</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>SelectGroups</name></type> <name>groupData</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>groupData</name></name> <operator>=</operator> <name>groupData</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>visit</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>f</name></decl></parameter></parameter_list> -&gt; <block>{<block_content>
            <decl_stmt><decl><type><name>Select</name></type> <name>s</name> <init>= <expr><call><name><name>f</name><operator>.</operator><name>getSelect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>s</name><operator>.</operator><name>groupData</name></name> <operator>=</operator> <name>groupData</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>gatherGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>rowNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>topTableFilter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><name>rowNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>isForUpdate</name></expr> ?</condition><then> <expr><call><name>isConditionMetForUpdate</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>isConditionMet</name><argument_list>()</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rowNumber</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>nextSource</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>updateAgg</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>done</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Update any aggregate expressions with the query stage.
     * @param columnCount number of columns
     * @param stage see STAGE_RESET/STAGE_GROUP/STAGE_WINDOW in DataAnalysisOperation
     */</comment>
    <function><type><name>void</name></type> <name>updateAgg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>groupByExpression</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><name><name>groupByExpression</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator>
                    <operator>&amp;&amp;</operator> <operator>(</operator><name>groupByCopies</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>groupByCopies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>expr</name><operator>.</operator><name>updateAggregate</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>processGroupResult</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>LocalResult</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>,
            <parameter><decl><type><name>boolean</name></type> <name>withHaving</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>ValueRow</name></type> <name>currentGroupsKey</name></decl>;</init> <condition><expr><operator>(</operator><name>currentGroupsKey</name> <operator>=</operator> <call><name><name>groupData</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><call><name>constructGroupResultRow</name><argument_list>(<argument><expr><call><name><name>currentGroupsKey</name><operator>.</operator><name>getList</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>withHaving</name> <operator>&amp;&amp;</operator> <call><name>isHavingNullOrFalse</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>qualifyIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>row</name><index>[<expr><name>qualifyIndex</name></expr>]</index></name><operator>.</operator><call><name>isTrue</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>quickOffset</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>offset</name><operator>--</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addRow</name></name><argument_list>(<argument><expr><call><name>rowForResult</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Value</name><index>[]</index></name></type> <name>constructGroupResultRow</name><parameter_list>(<parameter><decl><type><name><name>Value</name><index>[]</index></name></type> <name>keyValues</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><name>columnCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>groupIndex</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>l</name> <init>= <expr><name><name>groupIndex</name><operator>.</operator><name>length</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>row</name><index>[<expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>keyValues</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>groupByExpression</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>groupByExpression</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>groupByCopies</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>original</name> <init>= <expr><name><name>groupByCopies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>original</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>row</name><index>[<expr><name>original</name></expr>]</index></name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getValue</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>row</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Get the index that matches the ORDER BY list, if one exists. This is to
     * avoid running a separate ORDER BY if an index can be used. This is
     * specially important for large result sets, if only the first few rows are
     * important (LIMIT is used)
     *
     * @return the index if one is found
     */</comment>
    <function><type><specifier>private</specifier> <name>Index</name></type> <name>getSortIndex</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>sort</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Column</name></argument>&gt;</argument_list></name></type> <name>sortColumns</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>newSmallArrayList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>queryColumnIndexes</name> <init>= <expr><call><name><name>sort</name><operator>.</operator><name>getQueryColumnIndexes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>queryIndexesLength</name> <init>= <expr><name><name>queryColumnIndexes</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>sortIndex</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>queryIndexesLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>queryIndexesLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>queryColumnIndexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx</name> <operator>&gt;=</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInvalidValueException</name></name><argument_list>(<argument><expr><literal type="string">"ORDER BY"</literal></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getNonAliasExpression</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>expr</name><operator>.</operator><name>isConstant</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>expr</name> <operator>instanceof</operator> <name>ExpressionColumn</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>ExpressionColumn</name></type> <name>exprCol</name> <init>= <expr><operator>(</operator><name>ExpressionColumn</name><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>exprCol</name><operator>.</operator><name>getTableFilter</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>topTableFilter</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>sortColumns</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>exprCol</name><operator>.</operator><name>getColumn</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortIndex</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>Column</name><index>[]</index></name></type> <name>sortCols</name> <init>= <expr><call><name><name>sortColumns</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Column</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sortCols</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// sort just on constants - can use scan index</comment>
            <return>return <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScanIndex</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getIndexes</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>sortTypes</name> <init>= <expr><call><name><name>sort</name><operator>.</operator><name>getSortTypesWithNullOrdering</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>DefaultNullOrdering</name></type> <name>defaultNullOrdering</name> <init>= <expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDefaultNullOrdering</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <label><name>loop</name>:</label> <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><name>list</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>getCreateSQL</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// can't use the scan index</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>getIndexType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isHash</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name><name>IndexColumn</name><index>[]</index></name></type> <name>indexCols</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>indexCols</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name><name>sortCols</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sortCols</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <comment type="line">// the index and the sort order must start</comment>
                    <comment type="line">// with the exact same columns</comment>
                    <decl_stmt><decl><type><name>IndexColumn</name></type> <name>idxCol</name> <init>= <expr><name><name>indexCols</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Column</name></type> <name>sortCol</name> <init>= <expr><name><name>sortCols</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>idxCol</name><operator>.</operator><name>column</name></name> <operator>!=</operator> <name>sortCol</name></expr>)</condition> <block>{<block_content>
                        <continue>continue <name>loop</name>;</continue>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sortType</name> <init>= <expr><name><name>sortTypes</name><index>[<expr><name><name>sortIndex</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name><name>sortCol</name><operator>.</operator><name>isNullable</name></name><argument_list>()</argument_list></call></expr>
                            ?</condition><then> <expr><call><name><name>defaultNullOrdering</name><operator>.</operator><name>addExplicitNullOrdering</name></name><argument_list>(<argument><expr><name><name>idxCol</name><operator>.</operator><name>sortType</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sortType</name></expr>
                            </then><else>: <expr><operator>(</operator><name><name>idxCol</name><operator>.</operator><name>sortType</name></name> <operator>&amp;</operator> <name><name>SortOrder</name><operator>.</operator><name>DESCENDING</name></name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>sortType</name> <operator>&amp;</operator> <name><name>SortOrder</name><operator>.</operator><name>DESCENDING</name></name><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>
                        <continue>continue <name>loop</name>;</continue>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <return>return <expr><name>index</name></expr>;</return>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sortCols</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>sortCols</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getColumnId</name><argument_list>()</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// special case: order by _ROWID_</comment>
            <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScanIndex</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>isRowIdIndex</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>index</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>queryDistinct</name><parameter_list>(<parameter><decl><type><name>ResultTarget</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>limitRows</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>withTies</name></decl></parameter>,
            <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>limitRows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>limitRows</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>limitRows</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// Overflow</comment>
                <expr_stmt><expr><name>limitRows</name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>rowNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SearchRow</name></type> <name>first</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getColumns</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><call><name>getColumnId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quickOffset</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><operator>++</operator><name>rowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Cursor</name></type> <name>cursor</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>findNext</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cursor</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>SearchRow</name></type> <name>found</name> <init>= <expr><call><name><name>cursor</name><operator>.</operator><name>getSearchRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Value</name></type> <name>value</name> <init>= <expr><call><name><name>found</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <call><name><name>index</name><operator>.</operator><name>getRowFactory</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>createRow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>first</name><operator>.</operator><name>setValue</name></name><argument_list>(<argument><expr><name>columnIndex</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>offset</name><operator>--</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addRow</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sort</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>sortUsingIndex</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>limitRows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rowNumber</name> <operator>&gt;=</operator> <name>limitRows</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>withTies</name></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>LazyResult</name></type> <name>queryFlat</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>ResultTarget</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>limitRows</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>withTies</name></decl></parameter>,
            <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>limitRows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>quickOffset</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>limitRows</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>limitRows</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// Overflow</comment>
                <expr_stmt><expr><name>limitRows</name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>LazyResultQueryFlat</name></type> <name>lazyResult</name> <init>= <expr><operator>new</operator> <call><name>LazyResultQueryFlat</name><argument_list>(<argument><expr><name>expressionArray</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>isForUpdate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>skipOffset</name><argument_list>(<argument><expr><name>lazyResult</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>lazyResult</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>limitRows</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sort</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>sortUsingIndex</name> <operator>||</operator> <name>withTies</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quickOffset</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>limitRows</name> <operator>=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>result</name><operator>.</operator><name>getRowCount</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>limitRows</name> <operator>&amp;&amp;</operator> <call><name><name>lazyResult</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>row</name> <operator>=</operator> <call><name><name>lazyResult</name><operator>.</operator><name>currentRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>limitRows</name> <operator>!=</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name> <operator>&amp;&amp;</operator> <name>withTies</name> <operator>&amp;&amp;</operator> <name>sort</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>row</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>expected</name> <init>= <expr><name>row</name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>lazyResult</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>row</name> <operator>=</operator> <call><name><name>lazyResult</name><operator>.</operator><name>currentRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>sort</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>limitsWereApplied</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>skipOffset</name><parameter_list>(<parameter><decl><type><name>LazyResultSelect</name></type> <name>lazyResult</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quickOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>quickOffset</name></expr>)</condition> <block>{<block_content>
            <while>while <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>lazyResult</name><operator>.</operator><name>skip</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>offset</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>queryQuick</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>ResultTarget</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipResult</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><name>columnCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipResult</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>ResultInterface</name></type> <name>queryWithoutCache</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>maxRows</name></decl></parameter>, <parameter><decl><type><name>ResultTarget</name></type> <name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>disableLazyForJoinSubqueries</name><argument_list>(<argument><expr><name>topTableFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>OffsetFetch</name></type> <name>offsetFetch</name> <init>= <expr><call><name>getOffsetFetch</name><argument_list>(<argument><expr><name>maxRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>offset</name> <init>= <expr><name><name>offsetFetch</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>fetch</name> <init>= <expr><name><name>offsetFetch</name><operator>.</operator><name>fetch</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>fetchPercent</name> <init>= <expr><name><name>offsetFetch</name><operator>.</operator><name>fetchPercent</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>lazy</name> <init>= <expr><call><name><name>session</name><operator>.</operator><name>isLazyQueryExecution</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
                <name>target</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isForUpdate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isQuickAggregateQuery</name> <operator>&amp;&amp;</operator>
                <name>fetch</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>fetchPercent</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>withTies</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isReadOnly</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LocalResult</name></type> <name>result</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lazy</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>target</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator>
                <operator>!</operator><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSettings</name><argument_list>()</argument_list></call><operator>.</operator><name>optimizeInsertFromSelect</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createLocalResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// Do not add rows before OFFSET to result if possible</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>quickOffset</name> <init>= <expr><operator>!</operator><name>fetchPercent</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>sort</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>sortUsingIndex</name> <operator>||</operator> <call><name>isAnyDistinct</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createLocalResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>setSortOrder</name></name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sortUsingIndex</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>quickOffset</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>distinct</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isDistinctQuery</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>quickOffset</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createLocalResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>setDistinct</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>quickOffset</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createLocalResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>setDistinct</name></name><argument_list>(<argument><expr><name>distinctIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>isWindowQuery</name> <operator>||</operator> <name>isGroupQuery</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isGroupSortedQuery</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createLocalResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lazy</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>fetch</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createLocalResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>startQuery</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>lock</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ResultTarget</name></type> <name>to</name> <init>= <expr><ternary><condition><expr><name>result</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>result</name></expr> </then><else>: <expr><name>target</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>lazy</name> <operator>&amp;=</operator> <name>to</name> <operator>==</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LazyResult</name></type> <name>lazyResult</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fetch</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// Cannot apply limit now if percent is specified</comment>
            <decl_stmt><decl><type><name>long</name></type> <name>limit</name> <init>= <expr><ternary><condition><expr><name>fetchPercent</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>fetch</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>isQuickAggregateQuery</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>queryQuick</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>quickOffset</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isWindowQuery</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>isGroupQuery</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>queryGroupWindow</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>queryWindow</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isGroupQuery</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>isGroupSortedQuery</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>lazyResult</name> <operator>=</operator> <call><name>queryGroupSorted</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>queryGroup</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isDistinctQuery</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>queryDistinct</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>withTies</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>lazyResult</name> <operator>=</operator> <call><name>queryFlat</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>withTies</name></expr></argument>, <argument><expr><name>quickOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>quickOffset</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <assert>assert <expr><name>lazy</name> <operator>==</operator> <operator>(</operator><name>lazyResult</name> <operator>!=</operator> <literal type="null">null</literal><operator>)</operator> <operator>:</operator> <name>lazy</name></expr>;</assert>
        <if_stmt><if>if <condition>(<expr><name>lazyResult</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>fetch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>lazyResult</name><operator>.</operator><name>setLimit</name></name><argument_list>(<argument><expr><name>fetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>randomAccessResult</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>convertToDistinct</name><argument_list>(<argument><expr><name>lazyResult</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><name>lazyResult</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>finishResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>fetch</name></expr></argument>, <argument><expr><name>fetchPercent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>disableLazyForJoinSubqueries</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>TableFilter</name></type> <name>top</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>session</name><operator>.</operator><name>isLazyQueryExecution</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>top</name><operator>.</operator><name>visit</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>f</name></decl></parameter></parameter_list> -&gt; <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>top</name> <operator>&amp;&amp;</operator> <call><name><name>f</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTableType</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>TableType</name><operator>.</operator><name>VIEW</name></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>ViewIndex</name></type> <name>idx</name> <init>= <expr><operator>(</operator><name>ViewIndex</name><operator>)</operator> <call><name><name>f</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>idx</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>idx</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>setNeverLazy</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>LocalResult</name></type> <name>createLocalResult</name><parameter_list>(<parameter><decl><type><name>LocalResult</name></type> <name>old</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>old</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>old</name></expr> </then><else>: <expr><operator>new</operator> <call><name>LocalResult</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>expressionArray</name></expr></argument>, <argument><expr><name>visibleColumnCount</name></expr></argument>, <argument><expr><name>resultColumnCount</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>expandColumnList</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// the expressions may change within the loop</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>expr</name> <operator>instanceof</operator> <name>Wildcard</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Wildcard</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>Wildcard</name><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>tableAlias</name> <init>= <expr><call><name><name>w</name><operator>.</operator><name>getTableAlias</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>hasExceptColumns</name> <init>= <expr><call><name><name>w</name><operator>.</operator><name>getExceptColumns</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Column</name></argument>, <argument><name>ExpressionColumn</name></argument>&gt;</argument_list></name></type> <name>exceptTableColumns</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>tableAlias</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>hasExceptColumns</name></expr>)</condition> <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>filter</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>mapColumns</name></name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>Expression</name><operator>.</operator><name>MAP_INITIAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><name>exceptTableColumns</name> <operator>=</operator> <call><name><name>w</name><operator>.</operator><name>mapExceptColumns</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>filter</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>expandColumnList</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>exceptTableColumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>Database</name></type> <name>db</name> <init>= <expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>schemaName</name> <init>= <expr><call><name><name>w</name><operator>.</operator><name>getSchemaName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TableFilter</name></type> <name>filter</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>tableAlias</name></expr></argument>, <argument><expr><call><name><name>f</name><operator>.</operator><name>getTableAlias</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><call><name><name>f</name><operator>.</operator><name>getSchemaName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>hasExceptColumns</name></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>mapColumns</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>Expression</name><operator>.</operator><name>MAP_INITIAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>exceptTableColumns</name> <operator>=</operator> <call><name><name>w</name><operator>.</operator><name>mapExceptColumns</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>filter</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>filter</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>TABLE_OR_VIEW_NOT_FOUND_1</name></name></expr></argument>, <argument><expr><name>tableAlias</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>expandColumnList</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>exceptTableColumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>expandColumnList</name><parameter_list>(<parameter><decl><type><name>TableFilter</name></type> <name>filter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>forAlias</name></decl></parameter>,
            <parameter><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Column</name></argument>, <argument><name>ExpressionColumn</name></argument>&gt;</argument_list></name></type> <name>except</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>schema</name> <init>= <expr><call><name><name>filter</name><operator>.</operator><name>getSchemaName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>alias</name> <init>= <expr><call><name><name>filter</name><operator>.</operator><name>getTableAlias</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>forAlias</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>Column</name></type> <name>c</name> <range>: <expr><call><name><name>filter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getColumns</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>addExpandedColumn</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>except</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name><name>LinkedHashMap</name><argument_list type="generic">&lt;<argument><name>Column</name></argument>, <argument><name>Column</name></argument>&gt;</argument_list></name></type> <name>commonJoinColumns</name> <init>= <expr><call><name><name>filter</name><operator>.</operator><name>getCommonJoinColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>commonJoinColumns</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>TableFilter</name></type> <name>replacementFilter</name> <init>= <expr><call><name><name>filter</name><operator>.</operator><name>getCommonJoinColumnsFilter</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>replacementSchema</name> <init>= <expr><call><name><name>replacementFilter</name><operator>.</operator><name>getSchemaName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>replacementAlias</name> <init>= <expr><call><name><name>replacementFilter</name><operator>.</operator><name>getTableAlias</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Column</name></argument>, <argument><name>Column</name></argument>&gt;</argument_list></name></type> <name>entry</name> <range>: <expr><call><name><name>commonJoinColumns</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>Column</name></type> <name>left</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>filter</name><operator>.</operator><name>isCommonJoinColumnToExclude</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call>
                            <operator>&amp;&amp;</operator> <operator>(</operator><name>except</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>except</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>except</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>Database</name></type> <name>database</name> <init>= <expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Expression</name></type> <name>e</name></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>left</name> <operator>==</operator> <name>right</name>
                                <operator>||</operator> <call><name><name>DataType</name><operator>.</operator><name>hasTotalOrdering</name></name><argument_list>(<argument><expr><call><name><name>left</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                                <operator>&amp;&amp;</operator> <call><name><name>DataType</name><operator>.</operator><name>hasTotalOrdering</name></name><argument_list>(<argument><expr><call><name><name>right</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>new</operator> <call><name>ExpressionColumn</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>replacementSchema</name></expr></argument>, <argument><expr><name>replacementAlias</name></expr></argument>,
                                    <argument><expr><call><name><name>replacementFilter</name><operator>.</operator><name>getColumnName</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>new</operator> <call><name>Alias</name><argument_list>(<argument><expr><operator>new</operator> <call><name>CoalesceFunction</name><argument_list>(<argument><expr><name><name>CoalesceFunction</name><operator>.</operator><name>COALESCE</name></name></expr></argument>,
                                    <argument><expr><operator>new</operator> <call><name>ExpressionColumn</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><call><name><name>filter</name><operator>.</operator><name>getColumnName</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><operator>new</operator> <call><name>ExpressionColumn</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>replacementSchema</name></expr></argument>, <argument><expr><name>replacementAlias</name></expr></argument>,
                                            <argument><expr><call><name><name>replacementFilter</name><operator>.</operator><name>getColumnName</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <comment type="line">//</comment>
                                    <argument><expr><call><name><name>left</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>index</name><operator>++</operator></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>Column</name></type> <name>c</name> <range>: <expr><call><name><name>filter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getColumns</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>commonJoinColumns</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>commonJoinColumns</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>filter</name><operator>.</operator><name>isCommonJoinColumnToExclude</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>addExpandedColumn</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>except</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>index</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>addExpandedColumn</name><parameter_list>(<parameter><decl><type><name>TableFilter</name></type> <name>filter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Column</name></argument>, <argument><name>ExpressionColumn</name></argument>&gt;</argument_list></name></type> <name>except</name></decl></parameter>,
            <parameter><decl><type><name>String</name></type> <name>schema</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>alias</name></decl></parameter>, <parameter><decl><type><name>Column</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>except</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>except</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>c</name><operator>.</operator><name>getVisible</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ExpressionColumn</name></type> <name>ec</name> <init>= <expr><operator>new</operator> <call><name>ExpressionColumn</name><argument_list>(<argument><expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><call><name><name>filter</name><operator>.</operator><name>getColumnName</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>index</name><operator>++</operator></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>index</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>checkInit</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>filters</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name><name>TableFilter</name><operator>.</operator><name>ORDER_IN_FROM_COMPARATOR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>expandColumnList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>visibleColumnCount</name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&gt;</operator> <name><name>Constants</name><operator>.</operator><name>MAX_COLUMNS</name></name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>TOO_MANY_COLUMNS_1</name></name></expr></argument>, <argument><expr><literal type="string">""</literal> <operator>+</operator> <name><name>Constants</name><operator>.</operator><name>MAX_COLUMNS</name></name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>expressionSQL</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>orderList</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>group</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>expressionSQL</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>visibleColumnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>visibleColumnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getNonAliasExpression</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>expressionSQL</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>expr</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>DEFAULT_SQL_FLAGS</name></expr></argument>, <argument><expr><name>WITHOUT_PARENTHESES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>expressionSQL</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>BitSet</name></type> <name>set</name> <init>= <expr><operator>new</operator> <call><name>BitSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>distinctExpressions</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>set</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name>initExpression</name><argument_list>(<argument><expr><name>expressionSQL</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>filters</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>cnt</name> <init>= <expr><call><name><name>set</name><operator>.</operator><name>cardinality</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>distinctIndexes</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name>cnt</name></expr>]</index></name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name><name>set</name><operator>.</operator><name>nextSetBit</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>distinctIndexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>orderList</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>initOrder</name><argument_list>(<argument><expr><name>expressionSQL</name></expr></argument>, <argument><expr><call><name>isAnyDistinct</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>filters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>resultColumnCount</name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>having</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>having</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>havingIndex</name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>having</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>havingIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>qualify</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>qualify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>qualifyIndex</name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>qualify</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>qualifyIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>withTies</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasOrder</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>WITH_TIES_WITHOUT_ORDER_BY</name></name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>Database</name></type> <name>db</name> <init>= <expr><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// first the select list (visible columns),</comment>
        <comment type="line">// then 'ORDER BY' expressions,</comment>
        <comment type="line">// then 'HAVING' expressions,</comment>
        <comment type="line">// and 'GROUP BY' expressions at the end</comment>
        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>group</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>expSize</name> <init>= <expr><call><name><name>expressionSQL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fullExpSize</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fullExpSize</name> <operator>&gt;</operator> <name>expSize</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>expressionSQL</name><operator>.</operator><name>ensureCapacity</name></name><argument_list>(<argument><expr><name>fullExpSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>expSize</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fullExpSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>expressionSQL</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getSQL</name><argument_list>(<argument><expr><name>DEFAULT_SQL_FLAGS</name></expr></argument>, <argument><expr><name>WITHOUT_PARENTHESES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>groupIndex</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>group</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>sql</name> <init>= <expr><call><name><name>expr</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>DEFAULT_SQL_FLAGS</name></expr></argument>, <argument><expr><name>WITHOUT_PARENTHESES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>expSize</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name></type> <name>s2</name> <init>= <expr><call><name><name>expressionSQL</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>mergeGroupByExpressions</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>expressionSQL</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// special case: GROUP BY a column alias</comment>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>expSize</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <decl_stmt><decl><type><name>Expression</name></type> <name>e</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>getAlias</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>mergeGroupByExpressions</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>expressionSQL</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getAlias</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>getAlias</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>mergeGroupByExpressions</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>expressionSQL</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>found</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <label><name>checkUsed</name>:</label> <if_stmt><if>if <condition>(<expr><name>groupByCopies</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <range>: <expr><name>groupByCopies</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <break>break <name>checkUsed</name>;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>groupByCopies</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>groupByExpression</name> <operator>=</operator> <operator>new</operator> <name><name>boolean</name><index>[<expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>gi</name> <range>: <expr><name>groupIndex</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>groupByExpression</name><index>[<expr><name>gi</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>group</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// map columns in select list and condition</comment>
        <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>mapColumns</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>mapCondition</name><argument_list>(<argument><expr><name>havingIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mapCondition</name><argument_list>(<argument><expr><name>qualifyIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>checkInit</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>mapCondition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SelectListColumnResolver</name></type> <name>res</name> <init>= <expr><operator>new</operator> <call><name>SelectListColumnResolver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>expr</name><operator>.</operator><name>mapColumns</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>Expression</name><operator>.</operator><name>MAP_INITIAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>mergeGroupByExpressions</name><parameter_list>(<parameter><decl><type><name>Database</name></type> <name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>expressionSQL</name></decl></parameter>, <comment type="line">//</comment>
            <parameter><decl><type><name>boolean</name></type> <name>scanPrevious</name></decl></parameter>)</parameter_list> <block>{<block_content>

        <comment type="block">/*
         * -1: uniqueness of expression is not known yet
         *
         * -2: expression that is used as a source for a copy or does not have
         * copies
         *
         * &gt;=0: expression is a copy of expression at this index
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>groupByCopies</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>groupByCopies</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>c</name></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>index</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>groupByCopies</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><call><name><name>expressionSQL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>groupByCopies</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>sql</name> <init>= <expr><call><name><name>expressionSQL</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>scanPrevious</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/*
             * If expression was matched using an alias previous expressions may
             * be identical.
             */</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>index</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><call><name><name>expressionSQL</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name><name>expressionSQL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>db</name><operator>.</operator><name>equalsIdentifiers</name></name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><call><name><name>expressionSQL</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>groupByCopies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>groupByCopies</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <return>return <expr><name>index</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>prepare</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isPrepared</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// sometimes a subquery is prepared twice (CREATE TABLE AS SELECT)</comment>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>checkInit</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>getInternalError</name></name><argument_list>(<argument><expr><literal type="string">"not initialized"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>orderList</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>prepareOrder</name><argument_list>(<argument><expr><name>orderList</name></expr></argument>, <argument><expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>ExpressionNames</name></type> <name>expressionNames</name> <init>= <expr><call><name><name>session</name><operator>.</operator><name>getMode</name></name><argument_list>()</argument_list></call><operator>.</operator><name>expressionNames</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>expressionNames</name> <operator>==</operator> <name><name>ExpressionNames</name><operator>.</operator><name>ORIGINAL_SQL</name></name> <operator>||</operator> <name>expressionNames</name> <operator>==</operator> <name><name>ExpressionNames</name><operator>.</operator><name>POSTGRESQL_STYLE</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>optimizeExpressionsAndPreserveAliases</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>optimize</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>sort</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>cleanupOrder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>condition</name> <operator>=</operator> <call><name><name>condition</name><operator>.</operator><name>optimizeCondition</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <comment type="line">// outer joins: must not add index conditions such as</comment>
                    <comment type="line">// "c is null" - example:</comment>
                    <comment type="line">// create table parent(p int primary key) as select 1;</comment>
                    <comment type="line">// create table child(c int primary key, pc int);</comment>
                    <comment type="line">// insert into child values(2, 1);</comment>
                    <comment type="line">// select p, c from parent</comment>
                    <comment type="line">// left outer join child on p = pc where c is null;</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>f</name><operator>.</operator><name>isJoinOuter</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>f</name><operator>.</operator><name>isJoinOuterIndirect</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>condition</name><operator>.</operator><name>createIndexConditions</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>isGroupQuery</name> <operator>&amp;&amp;</operator> <name>groupIndex</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>havingIndex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>qualifyIndex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>condition</name> <operator>==</operator> <literal type="null">null</literal>
                <operator>&amp;&amp;</operator> <call><name><name>filters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>isQuickAggregateQuery</name> <operator>=</operator> <call><name>isEverything</name><argument_list>(<argument><expr><call><name><name>ExpressionVisitor</name><operator>.</operator><name>getOptimizableVisitor</name></name><argument_list>(<argument><expr><call><name><name>filters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getTable</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>cost</name> <operator>=</operator> <call><name>preparePlan</name><argument_list>(<argument><expr><call><name><name>session</name><operator>.</operator><name>isParsingCreateView</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>distinct</name> <operator>&amp;&amp;</operator> <call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSettings</name><argument_list>()</argument_list></call><operator>.</operator><name>optimizeDistinct</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><name>isGroupQuery</name> <operator>&amp;&amp;</operator> <call><name><name>filters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>condition</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getNonAliasExpression</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>instanceof</operator> <name>ExpressionColumn</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>Column</name></type> <name>column</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ExpressionColumn</name><operator>)</operator> <name>expr</name><operator>)</operator><operator>.</operator><call><name>getColumn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>selectivity</name> <init>= <expr><call><name><name>column</name><operator>.</operator><name>getSelectivity</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Index</name></type> <name>columnIndex</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator>
                        <call><name>getIndexForColumn</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>columnIndex</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator>
                        <name>selectivity</name> <operator>!=</operator> <name><name>Constants</name><operator>.</operator><name>SELECTIVITY_DEFAULT</name></name> <operator>&amp;&amp;</operator>
                        <name>selectivity</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>Index</name></type> <name>current</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">// if another index is faster</comment>
                    <if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>current</name><operator>.</operator><name>getIndexType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isScan</name><argument_list>()</argument_list></call> <operator>||</operator> <name>columnIndex</name> <operator>==</operator> <name>current</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>setIndex</name></name><argument_list>(<argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>isDistinctQuery</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>sort</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isQuickAggregateQuery</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isGroupQuery</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name>getSortIndex</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Index</name></type> <name>current</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>current</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>getIndexType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isScan</name><argument_list>()</argument_list></call> <operator>||</operator> <name>current</name> <operator>==</operator> <name>index</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>setIndex</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>topTableFilter</name><operator>.</operator><name>hasInComparisons</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// in(select ...) and in(1,2,3) may return the key in</comment>
                        <comment type="line">// another order</comment>
                        <expr_stmt><expr><name>sortUsingIndex</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>getIndexColumns</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal>
                        <operator>&amp;&amp;</operator> <call><name><name>index</name><operator>.</operator><name>getIndexColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><name>length</name> <operator>&gt;=</operator> <call><name><name>current</name>
                                <operator>.</operator><name>getIndexColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><name>length</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name><name>IndexColumn</name><index>[]</index></name></type> <name>sortColumns</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>IndexColumn</name><index>[]</index></name></type> <name>currentColumns</name> <init>= <expr><call><name><name>current</name><operator>.</operator><name>getIndexColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>swapIndex</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>currentColumns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>sortColumns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>column</name> <operator>!=</operator> <name><name>currentColumns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>column</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>swapIndex</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>sortColumns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortType</name> <operator>!=</operator> <name><name>currentColumns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortType</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>swapIndex</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <if_stmt><if>if <condition>(<expr><name>swapIndex</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>setIndex</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>sortUsingIndex</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>sortUsingIndex</name> <operator>&amp;&amp;</operator> <name>isForUpdate</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>topTableFilter</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isRowIdIndex</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>sortUsingIndex</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isQuickAggregateQuery</name> <operator>&amp;&amp;</operator> <name>isGroupQuery</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name>getGroupSortedIndex</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>Index</name></type> <name>current</name> <init>= <expr><call><name><name>topTableFilter</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>current</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>current</name><operator>.</operator><name>getIndexType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isScan</name><argument_list>()</argument_list></call> <operator>||</operator> <name>current</name> <operator>==</operator> <name>index</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>setIndex</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>isGroupSortedQuery</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>expressionArray</name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Expression</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isPrepared</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>optimizeExpressionsAndPreserveAliases</name><parameter_list>()</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>Expression</name></type> <name>e</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>alias</name> <init>= <expr><call><name><name>e</name><operator>.</operator><name>getAlias</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name><name>e</name><operator>.</operator><name>optimize</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>e</name><operator>.</operator><name>getAlias</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>new</operator> <call><name>Alias</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>expressions</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>double</name></type> <name>getCost</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>cost</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>getTables</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>set</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>filter</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>set</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>filter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>set</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>fireBeforeSelectTriggers</name><parameter_list>()</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>filter</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>filter</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>fire</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name><name>Trigger</name><operator>.</operator><name>SELECT</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>double</name></type> <name>preparePlan</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>parse</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>TableFilter</name><index>[]</index></name></type> <name>topArray</name> <init>= <expr><call><name><name>topFilters</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>TableFilter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>t</name> <range>: <expr><name>topArray</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>createIndexConditions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>setFullCondition</name></name><argument_list>(<argument><expr><name>condition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name>Optimizer</name></type> <name>optimizer</name> <init>= <expr><operator>new</operator> <call><name>Optimizer</name><argument_list>(<argument><expr><name>topArray</name></expr></argument>, <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>optimizer</name><operator>.</operator><name>optimize</name></name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>topTableFilter</name> <operator>=</operator> <call><name><name>optimizer</name><operator>.</operator><name>getTopFilter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>planCost</name> <init>= <expr><call><name><name>optimizer</name><operator>.</operator><name>getCost</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>setEvaluatableRecursive</name><argument_list>(<argument><expr><name>topTableFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parse</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>prepare</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>planCost</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setEvaluatableRecursive</name><parameter_list>(<parameter><decl><type><name>TableFilter</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init>;</init> <condition><expr><name>f</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <call><name><name>f</name><operator>.</operator><name>getJoin</name></name><argument_list>()</argument_list></call></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>f</name><operator>.</operator><name>setEvaluatable</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>condition</name><operator>.</operator><name>setEvaluatable</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>TableFilter</name></type> <name>n</name> <init>= <expr><call><name><name>f</name><operator>.</operator><name>getNestedJoin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setEvaluatableRecursive</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>Expression</name></type> <name>on</name> <init>= <expr><call><name><name>f</name><operator>.</operator><name>getJoinCondition</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>on</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>on</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name><name>ExpressionVisitor</name><operator>.</operator><name>EVALUATABLE_VISITOR</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// need to check that all added are bound to a table</comment>
                    <expr_stmt><expr><name>on</name> <operator>=</operator> <call><name><name>on</name><operator>.</operator><name>optimize</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>f</name><operator>.</operator><name>isJoinOuter</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>f</name><operator>.</operator><name>isJoinOuterIndirect</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>f</name><operator>.</operator><name>removeJoinCondition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>addCondition</name><argument_list>(<argument><expr><name>on</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>on</name> <operator>=</operator> <call><name><name>f</name><operator>.</operator><name>getFilterCondition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>on</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>on</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name><name>ExpressionVisitor</name><operator>.</operator><name>EVALUATABLE_VISITOR</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>f</name><operator>.</operator><name>removeFilterCondition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>addCondition</name><argument_list>(<argument><expr><name>on</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// this is only important for subqueries, so they know</comment>
            <comment type="line">// the result columns are evaluatable</comment>
            <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressions</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>setEvaluatable</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>getPlanSQL</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlFlags</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// can not use the field sqlStatement because the parameter</comment>
        <comment type="line">// indexes may be incorrect: ? may be in fact ?2 for a subquery</comment>
        <comment type="line">// but indexes may be set manually as well</comment>
        <decl_stmt><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>exprList</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Expression</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>topFilters</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>Table</name></type> <name>t</name> <init>= <expr><call><name><name>f</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TableView</name></type> <name>tableView</name> <init>= <expr><ternary><condition><expr><name>t</name> <operator>instanceof</operator> <name>TableView</name></expr> ?</condition><then> <expr><operator>(</operator><name>TableView</name><operator>)</operator> <name>t</name></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>tableView</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>tableView</name><operator>.</operator><name>isRecursive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>tableView</name><operator>.</operator><name>isTableExpression</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>tableView</name><operator>.</operator><name>isTemporary</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// skip the generation of plan SQL for this already recursive persistent CTEs,</comment>
                    <comment type="line">// since using a with statement will re-create the common table expression</comment>
                    <comment type="line">// views.</comment>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"WITH RECURSIVE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>ParserUtil</name><operator>.</operator><name>quoteIdentifier</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><call><name><name>t</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>Column</name><operator>.</operator><name>writeColumns</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><call><name><name>t</name><operator>.</operator><name>getColumns</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">") AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>getSQL</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>isExplicitTable</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>filters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getPlanSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>isAnyDistinct</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" DISTINCT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>Expression</name><operator>.</operator><name>writeExpressions</name></name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" ON("</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>distinctExpressions</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>visibleColumnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>StringUtils</name><operator>.</operator><name>indent</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name><name>exprList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getSQL</name><argument_list>(<argument><expr><name>sqlFlags</name></expr></argument>, <argument><expr><name>WITHOUT_PARENTHESES</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <decl_stmt><decl><type><name>TableFilter</name></type> <name>filter</name> <init>= <expr><name>topTableFilter</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>filter</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name><name>topFilters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name><name>topFilters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNoFromClauseFilter</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\nFROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>isJoin</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <expr_stmt><expr><name>isJoin</name> <operator>=</operator> <call><name>getPlanFromFilter</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>, <argument><expr><call><name><name>topFilters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name><name>filter</name><operator>.</operator><name>isNoFromClauseFilter</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>getPlanFromFilter</name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\nFROM "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>getFilterSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE "</literal></expr></argument>, <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>groupIndex</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\nGROUP BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>l</name> <init>= <expr><name><name>groupIndex</name><operator>.</operator><name>length</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>exprList</name><index>[<expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><call><name>getNonAliasExpression</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getUnenclosedSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>group</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\nGROUP BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>l</name> <init>= <expr><call><name><name>group</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>group</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getUnenclosedSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <label><name>emptyGroupingSet</name>:</label> <if_stmt><if>if <condition>(<expr><name>isGroupQuery</name> <operator>&amp;&amp;</operator> <name>having</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>havingIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>visibleColumnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>containsAggregate</name><argument_list>(<argument><expr><name><name>exprList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <break>break <name>emptyGroupingSet</name>;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\nGROUP BY ()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>getFilterSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><literal type="string">"\nHAVING "</literal></expr></argument>, <argument><expr><name>exprList</name></expr></argument>, <argument><expr><name>having</name></expr></argument>, <argument><expr><name>havingIndex</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>getFilterSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><literal type="string">"\nQUALIFY "</literal></expr></argument>, <argument><expr><name>exprList</name></expr></argument>, <argument><expr><name>qualify</name></expr></argument>, <argument><expr><name>qualifyIndex</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>appendEndOfQueryToSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isForUpdate</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\nFOR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sqlFlags</name> <operator>&amp;</operator> <name>ADD_PLAN_INFORMATION</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isQuickAggregateQuery</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n/* direct lookup */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>isDistinctQuery</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n/* distinct */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>sortUsingIndex</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n/* index sorted */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>isGroupQuery</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>isGroupSortedQuery</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n/* group sorted */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// builder.append("\n/* cost: " + cost + " */");</comment>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>getPlanFromFilter</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqlFlags</name></decl></parameter>, <parameter><decl><type><name>TableFilter</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isJoin</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <do>do <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isJoin</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>f</name><operator>.</operator><name>getPlanSQL</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>isJoin</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isJoin</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>(</operator><name>f</name> <operator>=</operator> <call><name><name>f</name><operator>.</operator><name>getJoin</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>;</do>
        <return>return <expr><name>isJoin</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>getFilterSQL</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>sql</name></decl></parameter>, <parameter><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>exprList</name></decl></parameter>, <parameter><decl><type><name>Expression</name></type> <name>condition</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>conditionIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqlFlags</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>getFilterSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>conditionIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>getFilterSQL</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name><name>exprList</name><index>[<expr><name>conditionIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>getFilterSQL</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>sql</name></decl></parameter>, <parameter><decl><type><name>Expression</name></type> <name>condition</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqlFlags</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>condition</name><operator>.</operator><name>getUnenclosedSQL</name></name><argument_list>(<argument><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sqlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>containsAggregate</name><parameter_list>(<parameter><decl><type><name>Expression</name></type> <name>expression</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>expression</name> <operator>instanceof</operator> <name>DataAnalysisOperation</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>DataAnalysisOperation</name><operator>)</operator> <name>expression</name><operator>)</operator><operator>.</operator><call><name>isAggregate</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>l</name> <init>= <expr><call><name><name>expression</name><operator>.</operator><name>getSubexpressionCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>containsAggregate</name><argument_list>(<argument><expr><call><name><name>expression</name><operator>.</operator><name>getSubexpression</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setHaving</name><parameter_list>(<parameter><decl><type><name>Expression</name></type> <name>having</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>having</name></name> <operator>=</operator> <name>having</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Expression</name></type> <name>getHaving</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>having</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setQualify</name><parameter_list>(<parameter><decl><type><name>Expression</name></type> <name>qualify</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qualify</name></name> <operator>=</operator> <name>qualify</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Expression</name></type> <name>getQualify</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>qualify</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TableFilter</name></type> <name>getTopTableFilter</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>topTableFilter</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>setForUpdate</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>b</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>isAnyDistinct</name><argument_list>()</argument_list></call> <operator>||</operator> <name>isGroupQuery</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>DbException</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>FOR_UPDATE_IS_NOT_ALLOWED_IN_DISTINCT_OR_GROUPED_SELECT</name></name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isForUpdate</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>mapColumns</name><parameter_list>(<parameter><decl><type><name>ColumnResolver</name></type> <name>resolver</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressions</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>mapColumns</name></name><argument_list>(<argument><expr><name>resolver</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name><name>Expression</name><operator>.</operator><name>MAP_INITIAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>condition</name><operator>.</operator><name>mapColumns</name></name><argument_list>(<argument><expr><name>resolver</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name><name>Expression</name><operator>.</operator><name>MAP_INITIAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>setEvaluatable</name><parameter_list>(<parameter><decl><type><name>TableFilter</name></type> <name>tableFilter</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressions</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>setEvaluatable</name></name><argument_list>(<argument><expr><name>tableFilter</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>condition</name><operator>.</operator><name>setEvaluatable</name></name><argument_list>(<argument><expr><name>tableFilter</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if this is an aggregate query with direct lookup, for example a
     * query of the type SELECT COUNT(*) FROM TEST or
     * SELECT MAX(ID) FROM TEST.
     *
     * @return true if a direct lookup is possible
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isQuickAggregateQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>isQuickAggregateQuery</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if this query is a group query.
     *
     * @return whether this query is a group query.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isGroupQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>isGroupQuery</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if this query contains window functions.
     *
     * @return whether this query contains window functions
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isWindowQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>isWindowQuery</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if window stage of group window query is performed. If true,
     * column resolver may not be used.
     *
     * @return true if window stage of group window query is performed
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isGroupWindowStage2</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>isGroupWindowStage2</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>addGlobalCondition</name><parameter_list>(<parameter><decl><type><name>Parameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>comparisonType</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>addParameter</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Expression</name></type> <name>comp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expression</name></type> <name>col</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>columnId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>col</name> <operator>=</operator> <call><name><name>col</name><operator>.</operator><name>getNonAliasExpression</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>col</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name><name>ExpressionVisitor</name><operator>.</operator><name>QUERY_COMPARABLE_VISITOR</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>comp</name> <operator>=</operator> <operator>new</operator> <call><name>Comparison</name><argument_list>(<argument><expr><name>comparisonType</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// this condition will always evaluate to true, but need to</comment>
            <comment type="line">// add the parameter, so it can be set later</comment>
            <expr_stmt><expr><name>comp</name> <operator>=</operator> <operator>new</operator> <call><name>Comparison</name><argument_list>(<argument><expr><name><name>Comparison</name><operator>.</operator><name>EQUAL_NULL_SAFE</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>comp</name> <operator>=</operator> <call><name><name>comp</name><operator>.</operator><name>optimize</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isWindowQuery</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>qualify</name> <operator>=</operator> <call><name>addGlobalCondition</name><argument_list>(<argument><expr><name>qualify</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isGroupQuery</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>groupIndex</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>groupIndex</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>columnId</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>condition</name> <operator>=</operator> <call><name>addGlobalCondition</name><argument_list>(<argument><expr><name>condition</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>havingIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>having</name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>havingIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>having</name> <operator>=</operator> <call><name>addGlobalCondition</name><argument_list>(<argument><expr><name>having</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>condition</name> <operator>=</operator> <call><name>addGlobalCondition</name><argument_list>(<argument><expr><name>condition</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Expression</name></type> <name>addGlobalCondition</name><parameter_list>(<parameter><decl><type><name>Expression</name></type> <name>condition</name></decl></parameter>, <parameter><decl><type><name>Expression</name></type> <name>additional</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>condition</name> <operator>instanceof</operator> <name>ConditionLocalAndGlobal</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>ConditionLocalAndGlobal</name><argument_list>(<argument><expr><name>condition</name></expr></argument>, <argument><expr><name>additional</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>Expression</name></type> <name>oldLocal</name></decl>, <decl><type ref="prev"/><name>oldGlobal</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>condition</name><operator>.</operator><name>getSubexpressionCount</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>oldLocal</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldGlobal</name> <operator>=</operator> <call><name><name>condition</name><operator>.</operator><name>getSubexpression</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>oldLocal</name> <operator>=</operator> <call><name><name>condition</name><operator>.</operator><name>getSubexpression</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldGlobal</name> <operator>=</operator> <call><name><name>condition</name><operator>.</operator><name>getSubexpression</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><operator>new</operator> <call><name>ConditionLocalAndGlobal</name><argument_list>(<argument><expr><name>oldLocal</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>ConditionAndOr</name><argument_list>(<argument><expr><name><name>ConditionAndOr</name><operator>.</operator><name>AND</name></name></expr></argument>, <argument><expr><name>oldGlobal</name></expr></argument>, <argument><expr><name>additional</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>updateAggregate</name><parameter_list>(<parameter><decl><type><name>SessionLocal</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressions</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>updateAggregate</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>condition</name><operator>.</operator><name>updateAggregate</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>having</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>having</name><operator>.</operator><name>updateAggregate</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>qualify</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>qualify</name><operator>.</operator><name>updateAggregate</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>isEverything</name><parameter_list>(<parameter><decl><type><name>ExpressionVisitor</name></type> <name>visitor</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name><name>visitor</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><name><name>ExpressionVisitor</name><operator>.</operator><name>DETERMINISTIC</name></name></expr>:</case> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isForUpdate</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>f</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isDeterministic</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name><name>ExpressionVisitor</name><operator>.</operator><name>SET_MAX_DATA_MODIFICATION_ID</name></name></expr>:</case> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>long</name></type> <name>m</name> <init>= <expr><call><name><name>f</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMaxDataModificationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>visitor</name><operator>.</operator><name>addDataModificationId</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name><name>ExpressionVisitor</name><operator>.</operator><name>EVALUATABLE</name></name></expr>:</case> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>session</name><operator>.</operator><name>getDatabase</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSettings</name><argument_list>()</argument_list></call><operator>.</operator><name>optimizeEvaluatableSubqueries</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name><name>ExpressionVisitor</name><operator>.</operator><name>GET_DEPENDENCIES</name></name></expr>:</case> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>TableFilter</name></type> <name>f</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>f</name><operator>.</operator><name>getTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>visitor</name><operator>.</operator><name>addDependency</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>table</name><operator>.</operator><name>addDependencies</name></name><argument_list>(<argument><expr><call><name><name>visitor</name><operator>.</operator><name>getDependencies</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <break>break;</break>
        </block_content>}</block>
        <default>default:</default>
        </block_content>}</block></switch>
        <decl_stmt><decl><type><name>ExpressionVisitor</name></type> <name>v2</name> <init>= <expr><call><name><name>visitor</name><operator>.</operator><name>incrementQueryLevel</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Expression</name></type> <name>e</name> <range>: <expr><name>expressions</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>e</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>condition</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>condition</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>having</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>having</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>qualify</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>qualify</name><operator>.</operator><name>isEverything</name></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>


    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>isCacheable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><operator>!</operator><name>isForUpdate</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>allowGlobalConditions</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>offsetExpr</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>fetchExpr</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>distinctExpressions</name> <operator>==</operator> <literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>SortOrder</name></type> <name>getSortOrder</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>sort</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns parent select, or null.
     *
     * @return parent select, or null
     */</comment>
    <function><type><specifier>public</specifier> <name>Select</name></type> <name>getParentSelect</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>parentSelect</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>isConstantQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>super</name><operator>.</operator><name>isConstantQuery</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>distinctExpressions</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>condition</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>isGroupQuery</name>
                <operator>||</operator> <name>isWindowQuery</name> <operator>||</operator> <operator>!</operator><call><name>isNoFromClause</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>visibleColumnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isConstant</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>Expression</name></type> <name>getIfSingleRow</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>offsetExpr</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>fetchExpr</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>condition</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name>isGroupQuery</name> <operator>||</operator> <name>isWindowQuery</name>
                <operator>||</operator> <operator>!</operator><call><name>isNoFromClause</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>visibleColumnCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>array</name> <init>= <expr><operator>new</operator> <name><name>Expression</name><index>[<expr><name>visibleColumnCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>visibleColumnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><operator>new</operator> <call><name>ExpressionList</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isNoFromClause</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>topTableFilter</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>topTableFilter</name><operator>.</operator><name>isNoFromClauseFilter</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>topFilters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>topFilters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNoFromClauseFilter</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Lazy execution for this select.
     */</comment>
    <class><specifier>private</specifier> <specifier>abstract</specifier> class <name>LazyResultSelect</name> <super_list><extends>extends <super><name>LazyResult</name></super></extends></super_list> <block>{

        <decl_stmt><decl><type><name>long</name></type> <name>rowNumber</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name></decl>;</decl_stmt>

        <constructor><name>LazyResultSelect</name><parameter_list>(<parameter><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>expressions</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><call><name>getSession</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>expressions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>columnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getVisibleColumnCount</name><parameter_list>()</parameter_list> <block>{<block_content>
            <return>return <expr><name>visibleColumnCount</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>topTableFilter</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rowNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Lazy execution for a flat query.
     */</comment>
    <class><specifier>private</specifier> <specifier>final</specifier> class <name>LazyResultQueryFlat</name> <super_list><extends>extends <super><name>LazyResultSelect</name></super></extends></super_list> <block>{

        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>forUpdate</name></decl>;</decl_stmt>

        <constructor><name>LazyResultQueryFlat</name><parameter_list>(<parameter><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>expressions</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>forUpdate</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>expressions</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>forUpdate</name></name> <operator>=</operator> <name>forUpdate</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name><name>Value</name><index>[]</index></name></type> <name>fetchNextRow</name><parameter_list>()</parameter_list> <block>{<block_content>
            <while>while <condition>(<expr><call><name><name>topTableFilter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><name>rowNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// This method may lock rows</comment>
                <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>forUpdate</name></expr> ?</condition><then> <expr><call><name>isConditionMetForUpdate</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>isConditionMet</name><argument_list>()</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>++</operator><name>rowNumber</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><name>columnCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><call><name>getSession</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <return>return <expr><name>row</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>boolean</name></type> <name>skipNextRow</name><parameter_list>()</parameter_list> <block>{<block_content>
            <while>while <condition>(<expr><call><name><name>topTableFilter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><name>rowNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// This method does not lock rows</comment>
                <if_stmt><if>if <condition>(<expr><call><name>isConditionMet</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>++</operator><name>rowNumber</name></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></function>

    }</block></class>

    <comment type="block" format="javadoc">/**
     * Lazy execution for a group sorted query.
     */</comment>
    <class><specifier>private</specifier> <specifier>final</specifier> class <name>LazyResultGroupSorted</name> <super_list><extends>extends <super><name>LazyResultSelect</name></super></extends></super_list> <block>{

        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Value</name><index>[]</index></name></type> <name>previousKeyValues</name></decl>;</decl_stmt>

        <constructor><name>LazyResultGroupSorted</name><parameter_list>(<parameter><decl><type><name><name>Expression</name><index>[]</index></name></type> <name>expressions</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnCount</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>expressions</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>groupData</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setGroupData</name><argument_list>(<argument><expr><call><name><name>SelectGroups</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><call><name>getSession</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Select</name><operator>.</operator><name>this</name><operator>.</operator><name>expressions</name></name></expr></argument>, <argument><expr><name>isGroupQuery</name></expr></argument>,
                        <argument><expr><name>groupIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>updateAgg</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_RESET</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>resetLazy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>resetLazy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>previousKeyValues</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name><name>Value</name><index>[]</index></name></type> <name>fetchNextRow</name><parameter_list>()</parameter_list> <block>{<block_content>
            <while>while <condition>(<expr><call><name><name>topTableFilter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>setCurrentRowNumber</name><argument_list>(<argument><expr><name>rowNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>isConditionMet</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>rowNumber</name><operator>++</operator></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>groupSize</name> <init>= <expr><name><name>groupIndex</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>keyValues</name> <init>= <expr><operator>new</operator> <name><name>Value</name><index>[<expr><name>groupSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <comment type="line">// update group</comment>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>groupSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Expression</name></type> <name>expr</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>keyValues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>expr</name><operator>.</operator><name>getValue</name></name><argument_list>(<argument><expr><call><name>getSession</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>

                    <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>previousKeyValues</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>previousKeyValues</name> <operator>=</operator> <name>keyValues</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>nextLazyGroup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <decl_stmt><decl><type><name>SessionLocal</name></type> <name>session</name> <init>= <expr><call><name>getSession</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>groupSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name><name>session</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name><name>previousKeyValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>keyValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>createGroupSortedRow</name><argument_list>(<argument><expr><name>previousKeyValues</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>previousKeyValues</name> <operator>=</operator> <name>keyValues</name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>nextLazyGroup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><call><name><name>groupData</name><operator>.</operator><name>nextLazyRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>updateAgg</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>DataAnalysisOperation</name><operator>.</operator><name>STAGE_GROUP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>row</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                        <return>return <expr><name>row</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
            <decl_stmt><decl><type><name><name>Value</name><index>[]</index></name></type> <name>row</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>previousKeyValues</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>createGroupSortedRow</name><argument_list>(<argument><expr><name>previousKeyValues</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>previousKeyValues</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>row</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

}</block></class>
</unit>
