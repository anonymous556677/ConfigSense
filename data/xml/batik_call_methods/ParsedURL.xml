<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/xmlgraphics-batik/batik-util/src/main/java/org/apache/batik/util/ParsedURL.java"><comment type="block">/*

   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>batik</name><operator>.</operator><name>util</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>InputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>net</name><operator>.</operator><name>URL</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Iterator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>batik</name><operator>.</operator><name>Version</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A {@link java.net.URL}-like class that supports custom URI schemes
 * and GZIP encoding.
 * &lt;p&gt;
 *   This class is used as a replacement for {@link java.net.URL}.
 *   This is done for several reasons.  First, unlike {@link java.net.URL}
 *   this class will accept and parse as much of a URL as possible, without
 *   throwing a {@link java.net.MalformedURLException}.  This makes it useful
 *   for simply parsing a URL string (hence its name).
 * &lt;/p&gt;
 * &lt;p&gt;
 *   Second, it allows for extension of the URI schemes supported by the
 *   parser.  Batik uses this to support the
 *   &lt;a href='http://www.ietf.org/rfc/rfc2397'&gt;&lt;code&gt;data:&lt;/code&gt; URL scheme (RFC2397)&lt;/a&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 *   Third, by default it checks the streams that it opens to see if they
 *   are GZIP compressed, and if so it automatically uncompresses them
 *   (avoiding opening the stream twice in the process).
 * &lt;/p&gt;
 * &lt;p&gt;
 *   It is worth noting that most real work is defered to the
 *   {@link ParsedURLData} class to which most methods are forwarded.
 *   This is done because it allows a constructor interface to {@link ParsedURL}
 *   (mostly for compatability with core {@link URL}), in spite of the fact that
 *   the real implemenation uses the protocol handlers as factories for protocol
 *   specific instances of the {@link ParsedURLData} class.
 * &lt;/p&gt;
 *
 * @author &lt;a href="mailto:deweese@apache.org"&gt;Thomas DeWeese&lt;/a&gt;
 * @version $Id$
 */</comment>
<class><specifier>public</specifier> class <name>ParsedURL</name> <block>{

    <comment type="block" format="javadoc">/**
     * The data class we defer most things to.
     */</comment>
    <decl_stmt><decl><type><name>ParsedURLData</name></type> <name>data</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The user agent to associate with this URL
     */</comment>
    <decl_stmt><decl><type><name>String</name></type> <name>userAgent</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * This maps between protocol names and ParsedURLProtocolHandler instances.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>Map</name></type> <name>handlersMap</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The default protocol handler.  This handler is used when
     * other handlers fail or no match for a protocol can be
     * found.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>ParsedURLProtocolHandler</name></type> <name>defaultHandler</name>
        <init>= <expr><operator>new</operator> <call><name>ParsedURLDefaultProtocolHandler</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>globalUserAgent</name> <init>= <expr><literal type="string">"Batik/"</literal><operator>+</operator><call><name><name>Version</name><operator>.</operator><name>getVersion</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getGlobalUserAgent</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>globalUserAgent</name></expr>;</return> </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>setGlobalUserAgent</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>userAgent</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>globalUserAgent</name> <operator>=</operator> <name>userAgent</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the shared instance of HandlersMap.  This method is
     * also responsible for initializing the handler map if this is
     * the first time it has been requested since the class was
     * loaded.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>Map</name></type> <name>getHandlersMap</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>handlersMap</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>handlersMap</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>handlersMap</name> <operator>=</operator> <operator>new</operator> <call><name>HashMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>registerHandler</name><argument_list>(<argument><expr><operator>new</operator> <call><name>ParsedURLDataProtocolHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>registerHandler</name><argument_list>(<argument><expr><operator>new</operator> <call><name>ParsedURLJarProtocolHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Iterator</name></type> <name>iter</name> <init>= <expr><call><name><name>Service</name><operator>.</operator><name>providers</name></name><argument_list>(<argument><expr><name><name>ParsedURLProtocolHandler</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ParsedURLProtocolHandler</name></type> <name>handler</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>handler</name> <operator>=</operator> <operator>(</operator><name>ParsedURLProtocolHandler</name><operator>)</operator><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// System.out.println("Handler: " + handler);</comment>
            <expr_stmt><expr><call><name>registerHandler</name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>


        <return>return <expr><name>handlersMap</name></expr>;</return>

    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the handler for a particular protocol.  If protocol is
     * &lt;code&gt;null&lt;/code&gt; or no match is found in the handlers map it
     * returns the default protocol handler.
     * @param protocol The protocol to get a handler for.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>ParsedURLProtocolHandler</name></type> <name>getHandler</name>
        <parameter_list>(<parameter><decl><type><name>String</name></type> <name>protocol</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>protocol</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>defaultHandler</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>Map</name></type> <name>handlers</name> <init>= <expr><call><name>getHandlersMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParsedURLProtocolHandler</name></type> <name>ret</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ParsedURLProtocolHandler</name><operator>)</operator><call><name><name>handlers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>defaultHandler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Registers a Protocol handler by adding it to the handlers map.
     * If the given protocol handler returns &lt;code&gt;null&lt;/code&gt; as it's
     * supported protocol then it is registered as the default
     * protocol handler.
     * @param handler the new Protocol Handler to register
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>registerHandler</name>
        <parameter_list>(<parameter><decl><type><name>ParsedURLProtocolHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>handler</name><operator>.</operator><name>getProtocolHandled</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>defaultHandler</name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>Map</name></type> <name>handlers</name> <init>= <expr><call><name>getHandlersMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>handlers</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>handler</name><operator>.</operator><name>getProtocolHandled</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * This is a utility function others can call that checks if
     * is is a GZIP stream if so it returns a GZIPInputStream that
     * will decode the contents, otherwise it returns (or a
     * buffered version of is) untouched.
     * @param is Stream that may potentially be a GZIP stream.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>InputStream</name></type> <name>checkGZIP</name><parameter_list>(<parameter><decl><type><name>InputStream</name></type> <name>is</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <return>return <expr><call><name><name>ParsedURLData</name><operator>.</operator><name>checkGZIP</name></name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Construct a ParsedURL from the given url string.
     * @param urlStr The string to try and parse as a URL
     */</comment>
    <constructor><specifier>public</specifier> <name>ParsedURL</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>userAgent</name> <operator>=</operator> <call><name>getGlobalUserAgent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name>      <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Construct a ParsedURL from the given java.net.URL instance.
     * This is useful if you already have a valid java.net.URL
     * instance.  This bypasses most of the parsing and hence is
     * quicker and less prone to reinterpretation than converting the
     * URL to a string before construction.
     *
     * @param url The URL to "mimic".
     */</comment>
    <constructor><specifier>public</specifier> <name>ParsedURL</name><parameter_list>(<parameter><decl><type><name>URL</name></type> <name>url</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>userAgent</name> <operator>=</operator> <call><name>getGlobalUserAgent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name>      <operator>=</operator> <operator>new</operator> <call><name>ParsedURLData</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Construct a sub URL from two strings.
     * @param baseStr The 'parent' URL.  Should be complete.
     * @param urlStr The 'sub' URL may be complete or partial.
     *               the missing pieces will be taken from the baseStr.
     */</comment>
    <constructor><specifier>public</specifier> <name>ParsedURL</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>baseStr</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>userAgent</name> <operator>=</operator> <call><name>getGlobalUserAgent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>baseStr</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><name>baseStr</name></expr></argument>, <argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Construct a sub URL from a base URL and a string for the sub url.
     * @param baseURL The 'parent' URL.
     * @param urlStr The 'sub' URL may be complete or partial.
     *               the missing pieces will be taken from the baseURL.
     */</comment>
    <constructor><specifier>public</specifier> <name>ParsedURL</name><parameter_list>(<parameter><decl><type><name>URL</name></type> <name>baseURL</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>userAgent</name> <operator>=</operator> <call><name>getGlobalUserAgent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>baseURL</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><operator>new</operator> <call><name>ParsedURL</name><argument_list>(<argument><expr><name>baseURL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Construct a sub URL from a base ParsedURL and a string for the sub url.
     * @param baseURL The 'parent' URL.
     * @param urlStr The 'sub' URL may be complete or partial.
     *               the missing pieces will be taken from the baseURL.
     */</comment>
    <constructor><specifier>public</specifier> <name>ParsedURL</name><parameter_list>(<parameter><decl><type><name>ParsedURL</name></type> <name>baseURL</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>baseURL</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>userAgent</name> <operator>=</operator> <call><name><name>baseURL</name><operator>.</operator><name>getUserAgent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><name>baseURL</name></expr></argument>, <argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>parseURL</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Return a string rep of the URL (can be passed back into the
     * constructor if desired).
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the URL that was ultimately used to fetch the resource
     * represented by this &lt;code&gt;ParsedURL&lt;/code&gt;.  For HTTP URLs,
     * this will result in the post-redirect URL being returned.
     * If there was no redirect, or if this isn't an HTTP URL, the
     * original URL is returned (the same string as {@link #toString()}).
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getPostConnectionURL</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getPostConnectionURL</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Implement Object.equals.
     * Relies heavily on the contained ParsedURLData's implementation
     * of equals.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>obj</name> <operator>instanceof</operator> <name>ParsedURL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>ParsedURL</name></type> <name>purl</name> <init>= <expr><operator>(</operator><name>ParsedURL</name><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>purl</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Implement Object.hashCode.
     * Relies on the contained ParsedURLData's implementation
     * of hashCode.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns true if the URL looks well formed and complete.
     * This does not guarantee that the stream can be opened but
     * is a good indication that things aren't totally messed up.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>complete</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>complete</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Return the user agent current associated with this url (or
     * null if none).
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getUserAgent</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>userAgent</name></expr>;</return>
    </block_content>}</block></function>
    <comment type="block" format="javadoc">/**
     * Sets the user agent associated with this url (null clears
     * any associated user agent).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setUserAgent</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>userAgent</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>userAgent</name></name> <operator>=</operator> <name>userAgent</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the protocol for this URL.
     * The protocol is everything upto the first ':'.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getProtocol</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>protocol</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name><name>data</name><operator>.</operator><name>protocol</name></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the host for this URL, if any, &lt;code&gt;null&lt;/code&gt; if there isn't
     * one or it doesn't make sense for the protocol.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getHost</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>host</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name><name>data</name><operator>.</operator><name>host</name></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the port on the host to connect to, if it was specified
     * in the url that was parsed, otherwise returns -1.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type>    <name>getPort</name><parameter_list>()</parameter_list>     <block>{<block_content> <return>return <expr><name><name>data</name><operator>.</operator><name>port</name></name></expr>;</return> </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the path for this URL, if any (where appropriate for
     * the protocol this also includes the file, not just directory).
     * Note that getPath appears in JDK 1.3 as a synonym for getFile
     * from JDK 1.2.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getPath</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>path</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name><name>data</name><operator>.</operator><name>path</name></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the 'fragment' reference in the URL.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getRef</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>ref</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name><name>data</name><operator>.</operator><name>ref</name></name></expr>;</return>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Returns the URL up to and include the port number on
     * the host.  Does not include the path or fragment pieces.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getPortStr</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getPortStr</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the content type if available.  This is only available
     * for some protocols.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getContentType</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getContentType</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the content type's type/subtype, if available.  This is
     * only available for some protocols.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getContentTypeMediaType</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getContentTypeMediaType</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the content type's charset parameter, if available.  This is
     * only available for some protocols.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getContentTypeCharset</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getContentTypeCharset</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns whether the Content-Type header has the given parameter.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasContentTypeParameter</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>hasContentTypeParameter</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the content encoding if available.  This is only available
     * for some protocols.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getContentEncoding</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getContentEncoding</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream checking for common compression
     * types, and automatically decompressing them if found.
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStream</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStream</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream checking for common compression
     * types, and automatically decompressing them if found.
     * @param mimeType The expected mime type of the content
     *        in the returned InputStream (mapped to Http accept
     *        header among other possibilities).
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStream</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>mimeType</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name>List</name></type> <name>mt</name> <init>= <expr><operator>new</operator> <call><name>ArrayList</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mt</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>mimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStream</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><call><name><name>mt</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream checking for common compression
     * types, and automatically decompressing them if found.
     * @param mimeTypes The expected mime types of the content
     *        in the returned InputStream (mapped to Http accept
     *        header among other possabilities).
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStream</name><parameter_list>(<parameter><decl><type><name><name>String</name> <index>[]</index></name></type> <name>mimeTypes</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name>List</name></type> <name>mt</name> <init>= <expr><operator>new</operator> <call><name>ArrayList</name><argument_list>(<argument><expr><name><name>mimeTypes</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>mimeType</name> <range>: <expr><name>mimeTypes</name></expr></range></decl></init>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>mt</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>mimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStream</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><call><name><name>mt</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream checking for common compression
     * types, and automatically decompressing them if found.
     * @param mimeTypes The expected mime types of the content
     *        in the returned InputStream (mapped to Http accept
     *        header among other possabilities).  The elements of
     *        the iterator must be strings.
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStream</name><parameter_list>(<parameter><decl><type><name>Iterator</name></type> <name>mimeTypes</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStream</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><name>mimeTypes</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream, does no checking for compression
     * types.
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStreamRaw</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStreamRaw</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream, does no checking for compression
     * types.
     * @param mimeType The expected mime type of the content
     *        in the returned InputStream (mapped to Http accept
     *        header among other possabilities).
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStreamRaw</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>mimeType</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name>List</name></type> <name>mt</name> <init>= <expr><operator>new</operator> <call><name>ArrayList</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mt</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>mimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStreamRaw</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><call><name><name>mt</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream, does no checking for comression
     * types.
     * @param mimeTypes The expected mime types of the content
     *        in the returned InputStream (mapped to Http accept
     *        header among other possabilities).
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStreamRaw</name><parameter_list>(<parameter><decl><type><name><name>String</name> <index>[]</index></name></type> <name>mimeTypes</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name>List</name></type> <name>mt</name> <init>= <expr><operator>new</operator> <call><name>ArrayList</name><argument_list>(<argument><expr><name><name>mimeTypes</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mt</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>mimeTypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStreamRaw</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><call><name><name>mt</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to open the stream, does no checking for comression
     * types.
     * @param mimeTypes The expected mime types of the content
     *        in the returned InputStream (mapped to Http accept
     *        header among other possabilities).  The elements of
     *        the iterator must be strings.
     */</comment>
    <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>openStreamRaw</name><parameter_list>(<parameter><decl><type><name>Iterator</name></type> <name>mimeTypes</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>openStreamRaw</name></name><argument_list>(<argument><expr><name>userAgent</name></expr></argument>, <argument><expr><name>mimeTypes</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>sameFile</name><parameter_list>(<parameter><decl><type><name>ParsedURL</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>sameFile</name></name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Parse out the protocol from a url string. Used internally to
     * select the proper handler, all other parsing is done by
     * the selected protocol handler.
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>String</name></type> <name>getProtocol</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>urlStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name><name>urlStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// Protocol is only allowed to include -+.a-zA-Z</comment>
        <comment type="line">// So as soon as we hit something else we know we</comment>
        <comment type="line">// are done (if it is a ':' then we have protocol otherwise</comment>
        <comment type="line">// we don't.</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>urlStr</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>||</operator>                      <comment type="line">// todo this might be more efficient with a long mask</comment>
               <operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>||</operator>                      <comment type="line">// which has a bit set for each valid char.</comment>
               <operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator> <operator>||</operator>                      <comment type="line">// check feasability</comment>
               <operator>(</operator><operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ch</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
               <operator>(</operator><operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ch</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name>len</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ch</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name><name>urlStr</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// Has a protocol spec...</comment>
            <return>return <expr><call><name><name>urlStr</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toLowerCase</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Factory method to construct an appropriate subclass of  ParsedURLData
     * @param urlStr the string to parse.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ParsedURLData</name></type> <name>parseURL</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>urlStr</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>urlStr</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>urlStr</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"#"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// an URL needs a protocol; default to file:// if none set</comment>
            <expr_stmt><expr><name>urlStr</name> <operator>=</operator> <literal type="string">"file:"</literal> <operator>+</operator> <name>urlStr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>ParsedURLProtocolHandler</name></type> <name>handler</name> <init>= <expr><call><name>getHandler</name><argument_list>(<argument><expr><call><name>getProtocol</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>handler</name><operator>.</operator><name>parseURL</name></name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Factory method to construct an appropriate subclass of  ParsedURLData,
     * for a sub url.
     * @param baseStr The base URL string to parse.
     * @param urlStr the sub URL string to parse.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ParsedURLData</name></type> <name>parseURL</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>baseStr</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>baseStr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>parseURL</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>ParsedURL</name></type> <name>purl</name> <init>= <expr><operator>new</operator> <call><name>ParsedURL</name><argument_list>(<argument><expr><name>baseStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>parseURL</name><argument_list>(<argument><expr><name>purl</name></expr></argument>, <argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Factory method to construct an appropriate subclass of  ParsedURLData,
     * for a sub url.
     * @param baseURL The base ParsedURL to parse.
     * @param urlStr the sub URL string to parse.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ParsedURLData</name></type> <name>parseURL</name><parameter_list>(<parameter><decl><type><name>ParsedURL</name></type> <name>baseURL</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>urlStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>baseURL</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>parseURL</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>String</name></type> <name>protocol</name> <init>= <expr><call><name>getProtocol</name><argument_list>(<argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>protocol</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>protocol</name> <operator>=</operator> <call><name><name>baseURL</name><operator>.</operator><name>getProtocol</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>ParsedURLProtocolHandler</name></type> <name>handler</name> <init>= <expr><call><name>getHandler</name><argument_list>(<argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>handler</name><operator>.</operator><name>parseURL</name></name><argument_list>(<argument><expr><name>baseURL</name></expr></argument>, <argument><expr><name>urlStr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
}</block></class>
</unit>
