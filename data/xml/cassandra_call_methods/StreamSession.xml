<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/streaming/StreamSession.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>EOFException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>net</name><operator>.</operator><name>SocketTimeoutException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ScheduledExecutors</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>RangesAtEndpoint</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>channel</name><operator>.</operator><name>Channel</name></name>;</import>
<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>channel</name><operator>.</operator><name>ChannelId</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>ColumnFamilyStore</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>Keyspace</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Range</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>gms</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>InetAddressAndPort</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>Replica</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>StreamingMetrics</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>net</name><operator>.</operator><name>OutboundConnectionSettings</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>TableId</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>async</name><operator>.</operator><name>NettyStreamingMessageSender</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>messages</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>JVMStabilityInspector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>NoSpamLogger</name></name>;</import>

<import>import static <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name><operator>.</operator><name>all</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>net</name><operator>.</operator><name>MessagingService</name><operator>.</operator><name>current_version</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Handles the streaming a one or more streams to and from a specific remote node.
 *&lt;p/&gt;
 * Both this node and the remote one will create a similar symmetrical {@link StreamSession}. A streaming
 * session has the following life-cycle:
 *&lt;pre&gt;
 * 1. Session Initialization
 *
 *   (a) A node (the initiator in the following) create a new {@link StreamSession},
 *       initialize it {@link #init(StreamResultFuture)}, and then start it ({@link #start()}).
 *       Starting a session causes a {@link StreamInitMessage} to be sent.
 *   (b) Upon reception of that {@link StreamInitMessage}, the follower creates its own {@link StreamSession},
 *       and initializes it if it still does not exist.
 *   (c) After the initiator sends the {@link StreamInitMessage}, it invokes
 *       {@link StreamSession#onInitializationComplete()} to start the streaming prepare phase.
 *
 * 2. Streaming preparation phase
 *
 *   (a) A {@link PrepareSynMessage} is sent that includes a) what files/sections this node will stream to the follower
 *       (stored locally in a {@link StreamTransferTask}, one for each table) and b) what the follower needs to
 *       stream back (stored locally in a {@link StreamReceiveTask}, one for each table).
 *   (b) Upon reception of the {@link PrepareSynMessage}, the follower records which files/sections it will receive
 *       and send back a {@link PrepareSynAckMessage}, which contains a summary of the files/sections that will be sent to
 *       the initiator.
 *   (c) When the initiator receives the {@link PrepareSynAckMessage}, it records which files/sections it will
 *       receive, and then goes to it's Streaming phase (see next section). If the intiator is to receive files,
 *       it sends a {@link PrepareAckMessage} to the follower to indicate that it can start streaming to the initiator.
 *   (d) (Optional) If the follower receives a {@link PrepareAckMessage}, it enters it's Streaming phase.
 *
 * 3. Streaming phase
 *
 *   (a) The streaming phase is started at each node by calling {@link StreamSession#startStreamingFiles(boolean)}.
 *       This will send, sequentially on each outbound streaming connection (see {@link NettyStreamingMessageSender}),
 *       an {@link OutgoingStreamMessage} for each stream in each of the {@link StreamTransferTask}.
 *       Each {@link OutgoingStreamMessage} consists of a {@link StreamMessageHeader} that contains metadata about
 *       the stream, followed by the stream content itself. Once all the files for a {@link StreamTransferTask} are sent,
 *       the task is marked complete {@link StreamTransferTask#complete(int)}.
 *   (b) On the receiving side, the incoming data is written to disk, and once the stream is fully received,
 *       it will be marked as complete ({@link StreamReceiveTask#received(IncomingStream)}). When all streams
 *       for the {@link StreamReceiveTask} have been received, the data is added to the CFS (and 2ndary indexes/MV are built),
 *        and the task is marked complete ({@link #taskCompleted(StreamReceiveTask)}).
 *   (b) If during the streaming of a particular stream an error occurs on the receiving end of a stream
 *       (it may be either the initiator or the follower), the node will send a {@link SessionFailedMessage}
 *       to the sender and close the stream session.
 *   (c) When all transfer and receive tasks for a session are complete, the session moves to the Completion phase
 *       ({@link #maybeCompleted()}).
 *
 * 4. Completion phase
 *
 *   (a) When the initiator finishes streaming, it enters the {@link StreamSession.State#WAIT_COMPLETE} state, and waits
 *       for the follower to send a {@link CompleteMessage} once it finishes streaming too. Once the {@link CompleteMessage}
 *       is received, initiator sets its own state to {@link StreamSession.State#COMPLETE} and closes all channels attached
 *       to this session.
 *
 * &lt;/pre&gt;
 *
 * In brief, the message passing looks like this (I for initiator, F for follwer):
 * &lt;pre&gt;
 * (session init)
 * I: StreamInitMessage
 * (session prepare)
 * I: PrepareSynMessage
 * F: PrepareSynAckMessage
 * I: PrepareAckMessage
 * (stream - this can happen in both directions)
 * I: OutgoingStreamMessage
 * F: ReceivedMessage
 * (completion)
 * F: CompleteMessage
 *&lt;/pre&gt;
 *
 * All messages which derive from {@link StreamMessage} are sent by the standard internode messaging
 * (via {@link org.apache.cassandra.net.MessagingService}, while the actual files themselves are sent by a special
 * "streaming" connection type. See {@link NettyStreamingMessageSender} for details. Because of the asynchronous
 */</comment>
<class><specifier>public</specifier> class <name>StreamSession</name> <super_list><implements>implements <super><name>IEndpointStateChangeSubscriber</name></super></implements></super_list>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>StreamSession</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// for test purpose to record received message and state transition</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>volatile</specifier> <specifier>static</specifier> <name>MessageStateSink</name></type> <name>sink</name> <init>= <expr><name><name>MessageStateSink</name><operator>.</operator><name>NONE</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>StreamOperation</name></type> <name>streamOperation</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Streaming endpoint.
     *
     * Each {@code StreamSession} is identified by this InetAddressAndPort which is broadcast address of the node streaming.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>InetAddressAndPort</name></type> <name>peer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>OutboundConnectionSettings</name></type> <name>template</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>index</name></decl>;</decl_stmt>

    <comment type="line">// should not be null when session is started</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>StreamResultFuture</name></type> <name>streamResult</name></decl>;</decl_stmt>

    <comment type="line">// stream requests to send to the peer</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>StreamRequest</name></argument>&gt;</argument_list></name></type> <name>requests</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>newConcurrentHashSet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// streaming tasks are created and managed per ColumnFamily ID</comment>
    <decl_stmt><decl><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>protected</specifier> <specifier>final</specifier> <name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;<argument><name>TableId</name></argument>, <argument><name>StreamTransferTask</name></argument>&gt;</argument_list></name></type> <name>transfers</name> <init>= <expr><operator>new</operator> <call><name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// data receivers, filled after receiving prepare message</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>TableId</name></argument>, <argument><name>StreamReceiveTask</name></argument>&gt;</argument_list></name></type> <name>receivers</name> <init>= <expr><operator>new</operator> <call><name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>StreamingMetrics</name></type> <name>metrics</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>transferredRangesPerKeyspace</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isFollower</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>NettyStreamingMessageSender</name></type> <name>messageSender</name></decl>;</decl_stmt>
    <comment type="line">// contains both inbound and outbound channels</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ConcurrentMap</name><argument_list type="generic">&lt;<argument><name>ChannelId</name></argument>, <argument><name>Channel</name></argument>&gt;</argument_list></name></type> <name>channels</name> <init>= <expr><operator>new</operator> <call><name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// "maybeCompleted()" should be executed at most once. Because it can be executed asynchronously by IO</comment>
    <comment type="line">// threads(serialization/deserialization) and stream messaging processing thread, causing connection closed before</comment>
    <comment type="line">// receiving peer's CompleteMessage.</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>maybeCompleted</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>closeFuture</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>UUID</name></type> <name>pendingRepair</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>PreviewKind</name></type> <name>previewKind</name></decl>;</decl_stmt>

<comment type="block" format="javadoc">/**
 * State Transition:
 *
 * &lt;pre&gt;
 *  +------------------+-----&gt; FAILED | ABORTED &lt;---------------+
 *  |                  |              ^                         |
 *  |                  |              |       initiator         |
 *  INITIALIZED --&gt; PREPARING --&gt; STREAMING ------------&gt; WAIT_COMPLETE ----&gt; COMPLETED
 *  |                  |              |                         ^                 ^
 *  |                  |              |       follower          |                 |
 *  |                  |              +-------------------------)-----------------+
 *  |                  |                                        |                 |
 *  |                  |         if preview                     |                 |
 *  |                  +----------------------------------------+                 |
 *  |               nothing to request or to transfer                             |
 *  +-----------------------------------------------------------------------------+
 *                  nothing to request or to transfer
 *
 *  &lt;/pre&gt;
 */</comment>
    <enum><specifier>public</specifier> enum <name>State</name>
    <block>{
        <decl><name>INITIALIZED</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>,
        <decl><name>PREPARING</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>,
        <decl><name>STREAMING</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>,
        <decl><name>WAIT_COMPLETE</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>,
        <decl><name>COMPLETE</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></decl>,
        <decl><name>FAILED</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></decl>,
        <decl><name>ABORTED</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></decl>;

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>finalState</name></decl>;</decl_stmt>

        <constructor><name>State</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>finalState</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>finalState</name></name> <operator>=</operator> <name>finalState</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * @return true if current state is final, either COMPLETE, FAILED, or ABORTED.
         */</comment>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFinalState</name><parameter_list>()</parameter_list>
        <block>{<block_content>
             <return>return <expr><name>finalState</name></expr>;</return>
        </block_content>}</block></function>
    }</block></enum>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>State</name></type> <name>state</name> <init>= <expr><name><name>State</name><operator>.</operator><name>INITIALIZED</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Create new streaming session with the peer.
     */</comment>
    <constructor><specifier>public</specifier> <name>StreamSession</name><parameter_list>(<parameter><decl><type><name>StreamOperation</name></type> <name>streamOperation</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>peer</name></decl></parameter>, <parameter><decl><type><name>StreamConnectionFactory</name></type> <name>factory</name></decl></parameter>,
                         <parameter><decl><type><name>boolean</name></type> <name>isFollower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>, <parameter><decl><type><name>PreviewKind</name></type> <name>previewKind</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>streamOperation</name></name> <operator>=</operator> <name>streamOperation</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>peer</name></name> <operator>=</operator> <name>peer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>template</name></name> <operator>=</operator> <operator>new</operator> <call><name>OutboundConnectionSettings</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isFollower</name></name> <operator>=</operator> <name>isFollower</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>messageSender</name></name> <operator>=</operator> <operator>new</operator> <call><name>NettyStreamingMessageSender</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>template</name></expr></argument>, <argument><expr><name>factory</name></expr></argument>, <argument><expr><name>current_version</name></expr></argument>, <argument><expr><call><name><name>previewKind</name><operator>.</operator><name>isPreview</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>metrics</name></name> <operator>=</operator> <call><name><name>StreamingMetrics</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>pendingRepair</name></name> <operator>=</operator> <name>pendingRepair</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>previewKind</name></name> <operator>=</operator> <name>previewKind</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Creating stream session to {} as {}"</literal></expr></argument>, <argument><expr><name>template</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isFollower</name></expr> ?</condition><then> <expr><literal type="string">"follower"</literal></expr> </then><else>: <expr><literal type="string">"initiator"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFollower</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>isFollower</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>UUID</name></type> <name>planId</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>streamResult</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name><name>streamResult</name><operator>.</operator><name>planId</name></name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>sessionIndex</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>index</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>StreamOperation</name></type> <name>streamOperation</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>streamResult</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><name><name>streamResult</name><operator>.</operator><name>streamOperation</name></name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>StreamOperation</name></type> <name>getStreamOperation</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>streamOperation</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>UUID</name></type> <name>getPendingRepair</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>pendingRepair</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isPreview</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>previewKind</name><operator>.</operator><name>isPreview</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>PreviewKind</name></type> <name>getPreviewKind</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>previewKind</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>StreamReceiver</name></type> <name>getAggregator</name><parameter_list>(<parameter><decl><type><name>TableId</name></type> <name>tableId</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name><name>receivers</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call> <operator>:</operator> <literal type="string">"Missing tableId "</literal> <operator>+</operator> <name>tableId</name></expr>;</assert>
        <return>return <expr><call><name><name>receivers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getReceiver</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Bind this session to report to specific {@link StreamResultFuture} and
     * perform pre-streaming initialization.
     *
     * @param streamResult result to report to
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>StreamResultFuture</name></type> <name>streamResult</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>streamResult</name></name> <operator>=</operator> <name>streamResult</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>StreamHook</name><operator>.</operator><name>instance</name><operator>.</operator><name>reportStreamFuture</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>streamResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attach a channel to this session upon receiving the first inbound message.
     *
     * @param channel The channel to attach.
     * @param isControlChannel If the channel is the one to send control messages to.
     * @return False if the channel was already attached, true otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>boolean</name></type> <name>attachInbound</name><parameter_list>(<parameter><decl><type><name>Channel</name></type> <name>channel</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isControlChannel</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>failIfFinished</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>messageSender</name><operator>.</operator><name>hasControlChannel</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>isControlChannel</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>injectControlMessageChannel</name></name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>channel</name><operator>.</operator><name>closeFuture</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>addListener</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ignored</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>onChannelClose</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>channels</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><call><name><name>channel</name><operator>.</operator><name>id</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Attach a channel to this session upon sending the first outbound message.
     *
     * @param channel The channel to attach.
     * @return False if the channel was already attached, true otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>boolean</name></type> <name>attachOutbound</name><parameter_list>(<parameter><decl><type><name>Channel</name></type> <name>channel</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>failIfFinished</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>channel</name><operator>.</operator><name>closeFuture</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>addListener</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ignored</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>onChannelClose</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>channels</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><call><name><name>channel</name><operator>.</operator><name>id</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * On channel closing, if no channels are left just close the message sender; this must be closed last to ensure
     * keep alive messages are sent until the very end of the streaming session.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>onChannelClose</name><parameter_list>(<parameter><decl><type><name>Channel</name></type> <name>channel</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>channels</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>channel</name><operator>.</operator><name>id</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>channels</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * invoked by the node that begins the stream session (it may be sending files, receiving files, or both)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>start</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>requests</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>transfers</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Session does not have any tasks."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Starting streaming to {}{}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>,
                                                                   <argument><expr><name>peer</name></expr></argument>,
                                                                   <argument><expr><ternary><condition><expr><name><name>template</name><operator>.</operator><name>connectTo</name></name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" through "</literal> <operator>+</operator> <name><name>template</name><operator>.</operator><name>connectTo</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>onInitializationComplete</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>JVMStabilityInspector</name><operator>.</operator><name>inspectThrowable</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>onError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Request data fetch task to this session.
     *
     * Here, we have to encode both _local_ range transientness (encoded in Replica itself, in RangesAtEndpoint)
     * and _remote_ (source) range transientmess, which is encoded by splitting ranges into full and transient.
     *
     * @param keyspace Requesting keyspace
     * @param fullRanges Ranges to retrieve data that will return full data from the source
     * @param transientRanges Ranges to retrieve data that will return transient data from the source
     * @param columnFamilies ColumnFamily names. Can be empty if requesting all CF under the keyspace.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addStreamRequest</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>fullRanges</name></decl></parameter>, <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>transientRanges</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>columnFamilies</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">//It should either be a dummy address for repair or if it's a bootstrap/move/rebuild it should be this node</comment>
        <assert>assert <expr><call><name>all</name><argument_list>(<argument><expr><name>fullRanges</name></expr></argument>, <argument><expr><name>Replica</name><operator>::</operator><name>isSelf</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>RangesAtEndpoint</name><operator>.</operator><name>isDummyList</name></name><argument_list>(<argument><expr><name>fullRanges</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name><name>fullRanges</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><call><name>all</name><argument_list>(<argument><expr><name>transientRanges</name></expr></argument>, <argument><expr><name>Replica</name><operator>::</operator><name>isSelf</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>RangesAtEndpoint</name><operator>.</operator><name>isDummyList</name></name><argument_list>(<argument><expr><name>transientRanges</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name><name>transientRanges</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <expr_stmt><expr><call><name><name>requests</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>StreamRequest</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>fullRanges</name></expr></argument>, <argument><expr><name>transientRanges</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set up transfer for specific keyspace/ranges/CFs
     *
     * @param keyspace Transfer keyspace
     * @param replicas Transfer ranges
     * @param columnFamilies Transfer ColumnFamilies
     * @param flushTables flush tables?
     */</comment>
    <function><type><specifier>synchronized</specifier> <name>void</name></type> <name>addTransferRanges</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>replicas</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>columnFamilies</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>flushTables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>failIfFinished</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>stores</name> <init>= <expr><call><name>getColumnFamilyStores</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>flushTables</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>flushSSTables</name><argument_list>(<argument><expr><name>stores</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">//Was it safe to remove this normalize, sorting seems not to matter, merging? Maybe we should have?</comment>
        <comment type="line">//Do we need to unwrap here also or is that just making it worse?</comment>
        <comment type="line">//Range and if it's transient</comment>
        <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>unwrappedRanges</name> <init>= <expr><call><name><name>replicas</name><operator>.</operator><name>unwrap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>OutgoingStream</name></argument>&gt;</argument_list></name></type> <name>streams</name> <init>= <expr><call><name>getOutgoingStreamsForRanges</name><argument_list>(<argument><expr><name>unwrappedRanges</name></expr></argument>, <argument><expr><name>stores</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><name>previewKind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addTransferStreams</name><argument_list>(<argument><expr><name>streams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toBeUpdated</name> <init>= <expr><call><name><name>transferredRangesPerKeyspace</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>toBeUpdated</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>toBeUpdated</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>toBeUpdated</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>replicas</name><operator>.</operator><name>ranges</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>transferredRangesPerKeyspace</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>toBeUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>failIfFinished</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>state</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isFinalState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Stream %s is finished with state %s"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>state</name><argument_list>()</argument_list></call><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>getColumnFamilyStores</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>columnFamilies</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>stores</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// if columnfamilies are not specified, we add all cf under the keyspace</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>columnFamilies</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>stores</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnFamilyStores</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>String</name></type> <name>cf</name> <range>: <expr><name>columnFamilies</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>stores</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>stores</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>OutgoingStream</name></argument>&gt;</argument_list></name></type> <name>getOutgoingStreamsForRanges</name><parameter_list>(<parameter><decl><type><name>RangesAtEndpoint</name></type> <name>replicas</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>stores</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>, <parameter><decl><type><name>PreviewKind</name></type> <name>previewKind</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>OutgoingStream</name></argument>&gt;</argument_list></name></type> <name>streams</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name><range>: <expr><name>stores</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>streams</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>getStreamManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>createOutgoingStreams</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><name>previewKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>streams</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><name>OutgoingStream</name><operator>::</operator><name>finish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>t</name></expr>;</throw>
        </block_content>}</block></catch></try>
        <return>return <expr><name>streams</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>synchronized</specifier> <name>void</name></type> <name>addTransferStreams</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>OutgoingStream</name></argument>&gt;</argument_list></name></type> <name>streams</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>failIfFinished</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>OutgoingStream</name></type> <name>stream</name><range>: <expr><name>streams</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TableId</name></type> <name>tableId</name> <init>= <expr><call><name><name>stream</name><operator>.</operator><name>getTableId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StreamTransferTask</name></type> <name>task</name> <init>= <expr><call><name><name>transfers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">//guarantee atomicity</comment>
                <decl_stmt><decl><type><name>StreamTransferTask</name></type> <name>newTask</name> <init>= <expr><operator>new</operator> <call><name>StreamTransferTask</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>task</name> <operator>=</operator> <call><name><name>transfers</name><operator>.</operator><name>putIfAbsent</name></name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>newTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>task</name> <operator>=</operator> <name>newTask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>addTransferStream</name></name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>closeSession</name><parameter_list>(<parameter><decl><type><name>State</name></type> <name>finalState</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// it's session is already closed</comment>
        <if_stmt><if>if <condition>(<expr><name>closeFuture</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>closeFuture</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name>finalState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// ensure aborting the tasks do not happen on the network IO thread (read: netty event loop)</comment>
        <comment type="line">// as we don't want any blocking disk IO to stop the network thread</comment>
        <if_stmt><if>if <condition>(<expr><name>finalState</name> <operator>==</operator> <name><name>State</name><operator>.</operator><name>FAILED</name></name> <operator>||</operator> <name>finalState</name> <operator>==</operator> <name><name>State</name><operator>.</operator><name>ABORTED</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>ScheduledExecutors</name><operator>.</operator><name>nonPeriodicTasks</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><name>this</name><operator>::</operator><name>abortTasks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Channels should only be closed by the initiator; but, if this session closed</comment>
        <comment type="line">// due to failure, channels should be always closed regardless, even if this is not the initator.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFollower</name> <operator>||</operator> <name>state</name> <operator>!=</operator> <name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Will close attached channels {}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>channels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>channels</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>channel</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>channel</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>sink</name><operator>.</operator><name>onClose</name></name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>streamResult</name><operator>.</operator><name>handleSessionComplete</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>closeFuture</name> <operator>=</operator> <call><name><name>FBUtilities</name><operator>.</operator><name>allOf</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>closeFuture</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>abortTasks</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>receivers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>StreamReceiveTask</name><operator>::</operator><name>abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>transfers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>StreamTransferTask</name><operator>::</operator><name>abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] failed to abort some streaming tasks"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Set current state to {@code newState}.
     *
     * @param newState new state to set
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>state</name><parameter_list>(<parameter><decl><type><name>State</name></type> <name>newState</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Changing session state from {} to {}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>sink</name><operator>.</operator><name>recordState</name></name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>state</name> <operator>=</operator> <name>newState</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return current state
     */</comment>
    <function><type><specifier>public</specifier> <name>State</name></type> <name>state</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>state</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>NettyStreamingMessageSender</name></type> <name>getMessageSender</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>messageSender</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Return if this session completed successfully.
     *
     * @return true if session completed successfully.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isSuccess</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>state</name> <operator>==</operator> <name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>messageReceived</name><parameter_list>(<parameter><decl><type><name>StreamMessage</name></type> <name>message</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>message</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name><name>StreamMessage</name><operator>.</operator><name>Type</name><operator>.</operator><name>KEEP_ALIVE</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>failIfFinished</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>sink</name><operator>.</operator><name>recordMessage</name></name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name><name>message</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>message</name><operator>.</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>STREAM_INIT</name></expr>:</case>
                <comment type="line">// at follower, nop</comment>
                <break>break;</break>
            <case>case <expr><name>PREPARE_SYN</name></expr>:</case>
                <comment type="line">// at follower</comment>
                <decl_stmt><decl><type><name>PrepareSynMessage</name></type> <name>msg</name> <init>= <expr><operator>(</operator><name>PrepareSynMessage</name><operator>)</operator> <name>message</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>prepare</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>requests</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>summaries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PREPARE_SYNACK</name></expr>:</case>
                <comment type="line">// at initiator</comment>
                <expr_stmt><expr><call><name>prepareSynAck</name><argument_list>(<argument><expr><operator>(</operator><name>PrepareSynAckMessage</name><operator>)</operator> <name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PREPARE_ACK</name></expr>:</case>
                <comment type="line">// at follower</comment>
                <expr_stmt><expr><call><name>prepareAck</name><argument_list>(<argument><expr><operator>(</operator><name>PrepareAckMessage</name><operator>)</operator> <name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>STREAM</name></expr>:</case>
                <expr_stmt><expr><call><name>receive</name><argument_list>(<argument><expr><operator>(</operator><name>IncomingStreamMessage</name><operator>)</operator> <name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RECEIVED</name></expr>:</case>
                <decl_stmt><decl><type><name>ReceivedMessage</name></type> <name>received</name> <init>= <expr><operator>(</operator><name>ReceivedMessage</name><operator>)</operator> <name>message</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>received</name><argument_list>(<argument><expr><name><name>received</name><operator>.</operator><name>tableId</name></name></expr></argument>, <argument><expr><name><name>received</name><operator>.</operator><name>sequenceNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>COMPLETE</name></expr>:</case>
                <comment type="line">// at initiator</comment>
                <expr_stmt><expr><call><name>complete</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>KEEP_ALIVE</name></expr>:</case>
                <comment type="line">// NOP - we only send/receive the KEEP_ALIVE to force the TCP connection to remain open</comment>
                <break>break;</break>
            <case>case <expr><name>SESSION_FAILED</name></expr>:</case>
                <expr_stmt><expr><call><name>sessionFailed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>(<argument><expr><literal type="string">"unhandled StreamMessage type: "</literal> <operator>+</operator> <call><name><name>message</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Call back when connection initialization is complete to start the prepare phase.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>onInitializationComplete</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// send prepare message</comment>
        <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>PREPARING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PrepareSynMessage</name></type> <name>prepare</name> <init>= <expr><operator>new</operator> <call><name>PrepareSynMessage</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>prepare</name><operator>.</operator><name>requests</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>requests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>StreamTransferTask</name></type> <name>task</name> <range>: <expr><call><name><name>transfers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>prepare</name><operator>.</operator><name>summaries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>task</name><operator>.</operator><name>getSummary</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><name>prepare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Signal an error to this stream session: if it's an EOF exception, it tries to understand if the socket was closed
     * after completion or because the peer was down, otherwise sends a {@link SessionFailedMessage} and closes
     * the session as {@link State#FAILED}.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>onError</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>isEofException</name> <init>= <expr><name>e</name> <operator>instanceof</operator> <name>EOFException</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>isEofException</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>finalState</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Socket closed after session completed with state {}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Socket closed before session completion, peer {} is probably down."</literal></expr></argument>,
                             <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><call><name><name>peer</name><operator>.</operator><name>getHostAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>FAILED</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>logError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>messageSender</name><operator>.</operator><name>connected</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>FAILED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// make sure subsequent error handling sees the session in a final state</comment>
            <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>SessionFailedMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>FAILED</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>logError</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>e</name> <operator>instanceof</operator> <name>SocketTimeoutException</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Did not receive response from peer {}{} for {} secs. Is peer down? "</literal> <operator>+</operator>
                         <literal type="string">"If not, maybe try increasing streaming_keep_alive_period_in_secs."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>peer</name><operator>.</operator><name>getHostAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><ternary><condition><expr><name><name>template</name><operator>.</operator><name>connectTo</name></name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" through "</literal> <operator>+</operator> <call><name><name>template</name><operator>.</operator><name>connectTo</name><operator>.</operator><name>getHostAddressAndPort</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
                         <argument><expr><literal type="number">2</literal> <operator>*</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getStreamingKeepAlivePeriod</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Streaming error occurred on session with peer {}{}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>peer</name><operator>.</operator><name>getHostAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><ternary><condition><expr><name><name>template</name><operator>.</operator><name>connectTo</name></name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" through "</literal> <operator>+</operator> <call><name><name>template</name><operator>.</operator><name>connectTo</name><operator>.</operator><name>getHostAddressAndPort</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
                         <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Prepare this session for sending/receiving files.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>prepare</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>StreamRequest</name></argument>&gt;</argument_list></name></type> <name>requests</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>StreamSummary</name></argument>&gt;</argument_list></name></type> <name>summaries</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// prepare tasks</comment>
        <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>PREPARING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ScheduledExecutors</name><operator>.</operator><name>nonPeriodicTasks</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><call><name>prepareAsync</name><argument_list>(<argument><expr><name>requests</name></expr></argument>, <argument><expr><name>summaries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>onError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Finish preparing the session. This method is blocking (memtables are flushed in {@link #addTransferRanges}),
     * so the logic should not execute on the main IO thread (read: netty event loop).
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>prepareAsync</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>StreamRequest</name></argument>&gt;</argument_list></name></type> <name>requests</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>StreamSummary</name></argument>&gt;</argument_list></name></type> <name>summaries</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>StreamRequest</name></type> <name>request</name> <range>: <expr><name>requests</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addTransferRanges</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>keyspace</name></name></expr></argument>, <argument><expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>full</name></name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>transientReplicas</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>columnFamilies</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> <comment type="line">// always flush on stream request</comment>
        <for>for <control>(<init><decl><type><name>StreamSummary</name></type> <name>summary</name> <range>: <expr><name>summaries</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>prepareReceiving</name><argument_list>(<argument><expr><name>summary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <decl_stmt><decl><type><name>PrepareSynAckMessage</name></type> <name>prepareSynAck</name> <init>= <expr><operator>new</operator> <call><name>PrepareSynAckMessage</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>peer</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><decl><type><name>StreamTransferTask</name></type> <name>task</name> <range>: <expr><call><name><name>transfers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>prepareSynAck</name><operator>.</operator><name>summaries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>task</name><operator>.</operator><name>getSummary</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><name>prepareSynAck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>streamResult</name><operator>.</operator><name>handleSessionPrepared</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>isPreview</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>completePreview</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>maybeCompleted</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>prepareSynAck</name><parameter_list>(<parameter><decl><type><name>PrepareSynAckMessage</name></type> <name>msg</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>msg</name><operator>.</operator><name>summaries</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>StreamSummary</name></type> <name>summary</name> <range>: <expr><name><name>msg</name><operator>.</operator><name>summaries</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>prepareReceiving</name><argument_list>(<argument><expr><name>summary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <comment type="line">// only send the (final) ACK if we are expecting the peer to send this node (the initiator) some files</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isPreview</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>PrepareAckMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>isPreview</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>completePreview</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>startStreamingFiles</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>prepareAck</name><parameter_list>(<parameter><decl><type><name>PrepareAckMessage</name></type> <name>msg</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isPreview</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #%s] Cannot receive PrepareAckMessage for preview session"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>startStreamingFiles</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Call back after sending StreamMessageHeader.
     *
     * @param message sent stream message
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>streamSent</name><parameter_list>(<parameter><decl><type><name>OutgoingStreamMessage</name></type> <name>message</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>headerSize</name> <init>= <expr><call><name><name>message</name><operator>.</operator><name>stream</name><operator>.</operator><name>getEstimatedSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>StreamingMetrics</name><operator>.</operator><name>totalOutgoingBytes</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>metrics</name><operator>.</operator><name>outgoingBytes</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>StreamOperation</name><operator>.</operator><name>REPAIR</name></name> <operator>==</operator> <call><name>getStreamOperation</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>StreamingMetrics</name><operator>.</operator><name>totalOutgoingRepairBytes</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>StreamingMetrics</name><operator>.</operator><name>totalOutgoingRepairSSTables</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><call><name><name>message</name><operator>.</operator><name>stream</name><operator>.</operator><name>getNumFiles</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// schedule timeout for receiving ACK</comment>
        <decl_stmt><decl><type><name>StreamTransferTask</name></type> <name>task</name> <init>= <expr><call><name><name>transfers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>tableId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>task</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>scheduleTimeout</name></name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>sequenceNumber</name></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>HOURS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Call back after receiving a stream.
     *
     * @param message received stream
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>receive</name><parameter_list>(<parameter><decl><type><name>IncomingStreamMessage</name></type> <name>message</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isPreview</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #%s] Cannot receive files for preview session"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>headerSize</name> <init>= <expr><call><name><name>message</name><operator>.</operator><name>stream</name><operator>.</operator><name>getSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>StreamingMetrics</name><operator>.</operator><name>totalIncomingBytes</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>metrics</name><operator>.</operator><name>incomingBytes</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// send back file received message</comment>
        <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>ReceivedMessage</name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>tableId</name></name></expr></argument>, <argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>sequenceNumber</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>StreamHook</name><operator>.</operator><name>instance</name><operator>.</operator><name>reportIncomingStream</name></name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>tableId</name></name></expr></argument>, <argument><expr><name><name>message</name><operator>.</operator><name>stream</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>sequenceNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>receivedStartNanos</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>receivers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>header</name><operator>.</operator><name>tableId</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>received</name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>latencyNanos</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>receivedStartNanos</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>metrics</name><operator>.</operator><name>incomingProcessTime</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><name>latencyNanos</name></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>NANOSECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>latencyMs</name> <init>= <expr><call><name><name>TimeUnit</name><operator>.</operator><name>NANOSECONDS</name><operator>.</operator><name>toMillis</name></name><argument_list>(<argument><expr><name>latencyNanos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getInternodeStreamingTcpUserTimeoutInMS</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>latencyMs</name> <operator>&gt;</operator> <name>timeout</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>NoSpamLogger</name><operator>.</operator><name>log</name></name><argument_list>(<argument><expr><name>logger</name></expr></argument>, <argument><expr><name><name>NoSpamLogger</name><operator>.</operator><name>Level</name><operator>.</operator><name>WARN</name></name></expr></argument>,
                                 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MINUTES</name></name></expr></argument>,
                                 <argument><expr><literal type="string">"The time taken ({} ms) for processing the incoming stream message ({})"</literal> <operator>+</operator>
                                 <literal type="string">" exceeded internode streaming TCP user timeout ({} ms).\n"</literal> <operator>+</operator>
                                 <literal type="string">"The streaming connection might be closed due to tcp user timeout.\n"</literal> <operator>+</operator>
                                 <literal type="string">"Try to increase the internode_streaming_tcp_user_timeout_in_ms"</literal> <operator>+</operator>
                                 <literal type="string">" or set it to 0 to use system defaults."</literal></expr></argument>,
                                 <argument><expr><name>latencyMs</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>progress</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name><name>ProgressInfo</name><operator>.</operator><name>Direction</name></name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>total</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ProgressInfo</name></type> <name>progress</name> <init>= <expr><operator>new</operator> <call><name>ProgressInfo</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>streamResult</name><operator>.</operator><name>handleProgress</name></name><argument_list>(<argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>received</name><parameter_list>(<parameter><decl><type><name>TableId</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sequenceNumber</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>transfers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>complete</name><argument_list>(<argument><expr><name>sequenceNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Check if session is completed on receiving {@code StreamMessage.Type.COMPLETE} message.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>complete</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] handling Complete message, state = {}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFollower</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name><name>State</name><operator>.</operator><name>WAIT_COMPLETE</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>WAIT_COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// pre-4.0 nodes should not be connected via streaming, see {@link MessagingService#accept_streaming}</comment>
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #%s] Complete message can be only received by the initiator!"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Synchronize both {@link #complete()} and {@link #maybeCompleted()} to avoid racing
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>boolean</name></type> <name>maybeCompleted</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>receivers</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>transfers</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// if already executed once, skip it</comment>
        <if_stmt><if>if <condition>(<expr><name>maybeCompleted</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>maybeCompleted</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFollower</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name><name>State</name><operator>.</operator><name>WAIT_COMPLETE</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>WAIT_COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>CompleteMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Call back on receiving {@code StreamMessage.Type.SESSION_FAILED} message.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>sessionFailed</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Remote peer {} failed stream session."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>peer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>FAILED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return Current snapshot of this session info.
     */</comment>
    <function><type><specifier>public</specifier> <name>SessionInfo</name></type> <name>getSessionInfo</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>StreamSummary</name></argument>&gt;</argument_list></name></type> <name>receivingSummaries</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>StreamTask</name></type> <name>receiver</name> <range>: <expr><call><name><name>receivers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>receivingSummaries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>receiver</name><operator>.</operator><name>getSummary</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>StreamSummary</name></argument>&gt;</argument_list></name></type> <name>transferSummaries</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>StreamTask</name></type> <name>transfer</name> <range>: <expr><call><name><name>transfers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>transferSummaries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>transfer</name><operator>.</operator><name>getSummary</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <comment type="line">// TODO: the connectTo treatment here is peculiar, and needs thinking about - since the connection factory can change it</comment>
        <return>return <expr><operator>new</operator> <call><name>SessionInfo</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>template</name><operator>.</operator><name>connectTo</name></name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>peer</name></expr> </then><else>: <expr><name><name>template</name><operator>.</operator><name>connectTo</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>receivingSummaries</name></expr></argument>, <argument><expr><name>transferSummaries</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>taskCompleted</name><parameter_list>(<parameter><decl><type><name>StreamReceiveTask</name></type> <name>completedTask</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>receivers</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>completedTask</name><operator>.</operator><name>tableId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>maybeCompleted</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>taskCompleted</name><parameter_list>(<parameter><decl><type><name>StreamTransferTask</name></type> <name>completedTask</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>transfers</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>completedTask</name><operator>.</operator><name>tableId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>maybeCompleted</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onRemove</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Session failed because remote peer {} has left."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>peer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>FAILED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onRestart</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>, <parameter><decl><type><name>EndpointState</name></type> <name>epState</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Session failed because remote peer {} was restarted."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>peer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>FAILED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>completePreview</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>WAIT_COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>COMPLETE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <comment type="line">// aborting the tasks here needs to be the last thing we do so that we accurately report</comment>
            <comment type="line">// expected streaming, but don't leak any resources held by the task</comment>
            <for>for <control>(<init><decl><type><name>StreamTask</name></type> <name>task</name> <range>: <expr><call><name><name>Iterables</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><call><name><name>receivers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>transfers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>abort</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Flushes matching column families from the given keyspace, or all columnFamilies
     * if the cf list is empty.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>flushSSTables</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>stores</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>flushes</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>stores</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>flushes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>forceFlush</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>flushes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>prepareReceiving</name><parameter_list>(<parameter><decl><type><name>StreamSummary</name></type> <name>summary</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>failIfFinished</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>summary</name><operator>.</operator><name>files</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>receivers</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>summary</name><operator>.</operator><name>tableId</name></name></expr></argument>, <argument><expr><operator>new</operator> <call><name>StreamReceiveTask</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>summary</name><operator>.</operator><name>tableId</name></name></expr></argument>, <argument><expr><name><name>summary</name><operator>.</operator><name>files</name></name></expr></argument>, <argument><expr><name><name>summary</name><operator>.</operator><name>totalSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>startStreamingFiles</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>notifyPrepared</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>notifyPrepared</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>streamResult</name><operator>.</operator><name>handleSessionPrepared</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>STREAMING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>StreamTransferTask</name></type> <name>task</name> <range>: <expr><call><name><name>transfers</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>OutgoingStreamMessage</name></argument>&gt;</argument_list></name></type> <name>messages</name> <init>= <expr><call><name><name>task</name><operator>.</operator><name>getFileMessages</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>messages</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>OutgoingStreamMessage</name></type> <name>ofm</name> <range>: <expr><name>messages</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <comment type="line">// pass the session planId/index to the OFM (which is only set at init(), after the transfers have already been created)</comment>
                    <expr_stmt><expr><call><name><name>ofm</name><operator>.</operator><name>header</name><operator>.</operator><name>addSessionInfo</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>messageSender</name><operator>.</operator><name>sendMessage</name></name><argument_list>(<argument><expr><name>ofm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>taskCompleted</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// there are no files to send</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>maybeCompleted</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>int</name></type> <name>getNumRequests</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>requests</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>int</name></type> <name>getNumTransfers</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>transferredRangesPerKeyspace</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <interface><annotation>@<name>VisibleForTesting</name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> interface <name>MessageStateSink</name>
    <block>{
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>MessageStateSink</name></type> <name>NONE</name> <init>= <expr><operator>new</operator> <class><super><name>MessageStateSink</name></super><argument_list>()</argument_list> <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>recordState</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>State</name></type> <name>state</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>recordMessage</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name><name>StreamMessage</name><operator>.</operator><name>Type</name></name></type> <name>message</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>onClose</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>from</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * @param from peer that is connected in the stream session
         * @param state new state to change to
         */</comment>
        <function_decl><type><specifier>public</specifier> <name>void</name></type> <name>recordState</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name><name>StreamSession</name><operator>.</operator><name>State</name></name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

        <comment type="block" format="javadoc">/**
         * @param from peer that sends the given message
         * @param message stream message sent by peer
         */</comment>
        <function_decl><type><specifier>public</specifier> <name>void</name></type> <name>recordMessage</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name><name>StreamMessage</name><operator>.</operator><name>Type</name></name></type> <name>message</name></decl></parameter>)</parameter_list>;</function_decl>

        <comment type="block" format="javadoc">/**
         *
         * @param from peer that is being disconnected
         */</comment>
        <function_decl><type><specifier>public</specifier> <name>void</name></type> <name>onClose</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>from</name></decl></parameter>)</parameter_list>;</function_decl>
    }</block></interface>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>abort</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>isFinalState</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Stream session with peer {} is already in a final state on abort."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Aborting stream session with peer {}..."</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getMessageSender</name><argument_list>()</argument_list></call><operator>.</operator><call><name>connected</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>getMessageSender</name><argument_list>()</argument_list></call><operator>.</operator><call><name>sendMessage</name><argument_list>(<argument><expr><operator>new</operator> <call><name>SessionFailedMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name>closeSession</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>ABORTED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"[Stream #{}] Error aborting stream session with peer {}"</literal></expr></argument>, <argument><expr><call><name>planId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>
}</block></class>
</unit>
