<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/locator/ReplicaLayout.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name></name>;</package>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>Keyspace</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>PartitionPosition</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>AbstractBounds</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>gms</name><operator>.</operator><name>FailureDetector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>StorageService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>FBUtilities</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Predicate</name></name>;</import>

<comment type="block" format="javadoc">/**
 * The relevant replicas for an operation over a given range or token.
 *
 * @param &lt;E&gt;
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name><name>ReplicaLayout</name><parameter_list>&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><parameter_list>&lt;<parameter><name>E</name></parameter>&gt;</parameter_list></name></extends></parameter>&gt;</parameter_list></name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>E</name></type> <name>natural</name></decl>;</decl_stmt>
    <comment type="line">// the snapshot of the replication strategy that corresponds to the replica layout</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl>;</decl_stmt>

    <constructor><name>ReplicaLayout</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>natural</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>replicationStrategy</name></name> <operator>=</operator> <name>replicationStrategy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>natural</name></name> <operator>=</operator> <name>natural</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * The 'natural' owners of the ring position(s), as implied by the current ring layout.
     * This excludes any pending owners, i.e. those that are in the process of taking ownership of a range, but
     * have not yet finished obtaining their view of the range.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>E</name></type> <name>natural</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>natural</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>replicationStrategy</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * All relevant owners of the ring position(s) for this operation, as implied by the current ring layout.
     * For writes, this will include pending owners, and for reads it will be equivalent to natural()
     */</comment>
    <function><type><specifier>public</specifier> <name>E</name></type> <name>all</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>natural</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="string">"ReplicaLayout [ natural: "</literal> <operator>+</operator> <name>natural</name> <operator>+</operator> <literal type="string">" ]"</literal></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ForTokenRead</name> <super_list><extends>extends <super><name><name>ReplicaLayout</name><argument_list type="generic">&lt;<argument><name>EndpointsForToken</name></argument>&gt;</argument_list></name></super></extends> <implements>implements <super><name>ForToken</name></super></implements></super_list>
    <block>{
        <constructor><specifier>public</specifier> <name>ForTokenRead</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Token</name></type> <name>token</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>natural</name><argument_list>()</argument_list></call><operator>.</operator><call><name>token</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenRead</name></name></type> <name>filter</name><parameter_list>(<parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Replica</name></argument>&gt;</argument_list></name></type> <name>filter</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>filtered</name> <init>= <expr><call><name>natural</name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// AbstractReplicaCollection.filter returns itself if all elements match the filter</comment>
            <if_stmt><if>if <condition>(<expr><name>filtered</name> <operator>==</operator> <call><name>natural</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><operator>new</operator> <call><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenRead</name></name><argument_list>(<argument><expr><call><name>replicationStrategy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>filtered</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ForRangeRead</name> <super_list><extends>extends <super><name><name>ReplicaLayout</name><argument_list type="generic">&lt;<argument><name>EndpointsForRange</name></argument>&gt;</argument_list></name></super></extends> <implements>implements <super><name>ForRange</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>ForRangeRead</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>, <parameter><decl><type><name>EndpointsForRange</name></type> <name>natural</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>range</name></name> <operator>=</operator> <name>range</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>range</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>filter</name><parameter_list>(<parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Replica</name></argument>&gt;</argument_list></name></type> <name>filter</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>filtered</name> <init>= <expr><call><name>natural</name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// AbstractReplicaCollection.filter returns itself if all elements match the filter</comment>
            <if_stmt><if>if <condition>(<expr><name>filtered</name> <operator>==</operator> <call><name>natural</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><operator>new</operator> <call><name><name>ReplicaLayout</name><operator>.</operator><name>ForRangeRead</name></name><argument_list>(<argument><expr><call><name>replicationStrategy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>range</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>filtered</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name><name>ForWrite</name><parameter_list>&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><parameter_list>&lt;<parameter><name>E</name></parameter>&gt;</parameter_list></name></extends></parameter>&gt;</parameter_list></name> <super_list><extends>extends <super><name><name>ReplicaLayout</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>E</name></type> <name>all</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>E</name></type> <name>pending</name></decl>;</decl_stmt>

        <constructor><name>ForWrite</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>pending</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>all</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><name>pending</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>haveWriteConflicts</name><argument_list>(<argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</assert>
            <if_stmt><if>if <condition>(<expr><name>all</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>all</name> <operator>=</operator> <call><name><name>Endpoints</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>all</name></name> <operator>=</operator> <name>all</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>pending</name></name> <operator>=</operator> <name>pending</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>E</name></type> <name>all</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>all</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>E</name></type> <name>pending</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>pending</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="string">"ReplicaLayout [ natural: "</literal> <operator>+</operator> <call><name>natural</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">", pending: "</literal> <operator>+</operator> <name>pending</name> <operator>+</operator> <literal type="string">" ]"</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ForTokenWrite</name> <super_list><extends>extends <super><name><name>ForWrite</name><argument_list type="generic">&lt;<argument><name>EndpointsForToken</name></argument>&gt;</argument_list></name></super></extends> <implements>implements <super><name>ForToken</name></super></implements></super_list>
    <block>{
        <constructor><specifier>public</specifier> <name>ForTokenWrite</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>pending</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>
        <constructor><specifier>public</specifier> <name>ForTokenWrite</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>pending</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>all</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Token</name></type> <name>token</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>natural</name><argument_list>()</argument_list></call><operator>.</operator><call><name>token</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>filter</name><parameter_list>(<parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Replica</name></argument>&gt;</argument_list></name></type> <name>filter</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>filtered</name> <init>= <expr><call><name>all</name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// AbstractReplicaCollection.filter returns itself if all elements match the filter</comment>
            <if_stmt><if>if <condition>(<expr><name>filtered</name> <operator>==</operator> <call><name>all</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>
            <comment type="line">// unique by endpoint, so can for efficiency filter only on endpoint</comment>
            <return>return <expr><operator>new</operator> <call><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name><argument_list>(
                    <argument><expr><call><name>replicationStrategy</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name>natural</name><argument_list>()</argument_list></call><operator>.</operator><call><name>keep</name><argument_list>(<argument><expr><call><name><name>filtered</name><operator>.</operator><name>endpoints</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>pending</name><argument_list>()</argument_list></call><operator>.</operator><call><name>keep</name><argument_list>(<argument><expr><call><name><name>filtered</name><operator>.</operator><name>endpoints</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>filtered</name></expr></argument>
            )</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <interface><specifier>public</specifier> interface <name>ForRange</name>
    <block>{
        <function_decl><type><specifier>public</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name><parameter_list>()</parameter_list>;</function_decl>
    }</block></interface>

    <interface><specifier>public</specifier> interface <name>ForToken</name>
    <block>{
        <function_decl><type><specifier>public</specifier> <name>Token</name></type> <name>token</name><parameter_list>()</parameter_list>;</function_decl>
    }</block></interface>

    <comment type="block" format="javadoc">/**
     * Gets the 'natural' and 'pending' replicas that own a given token, with no filtering or processing.
     *
     * Since a write is intended for all nodes (except, unless necessary, transient replicas), this method's
     * only responsibility is to fetch the 'natural' and 'pending' replicas, then resolve any conflicts
     * {@link ReplicaLayout#haveWriteConflicts(Endpoints, Endpoints)}
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forTokenWriteLiveAndDown</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// TODO: these should be cached, not the natural replicas</comment>
        <comment type="line">// TODO: race condition to fetch these. implications??</comment>
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getReplicationStrategy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>natural</name> <init>= <expr><call><name><name>replicationStrategy</name><operator>.</operator><name>getNaturalReplicasForToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>pending</name> <init>= <expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTokenMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>pendingEndpointsForToken</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>forTokenWrite</name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name></type> <name>forTokenWrite</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>pending</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>haveWriteConflicts</name><argument_list>(<argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>natural</name> <operator>=</operator> <call><name>resolveWriteConflictsInNatural</name><argument_list>(<argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pending</name> <operator>=</operator> <call><name>resolveWriteConflictsInPending</name><argument_list>(<argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenWrite</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Detect if we have any endpoint in both pending and full; this can occur either due to races (there is no isolation)
     * or because an endpoint is transitioning between full and transient replication status.
     *
     * We essentially always prefer the full version for writes, because this is stricter.
     *
     * For transient-&gt;full transitions:
     *
     *   Since we always write to any pending transient replica, effectively upgrading it to full for the transition duration,
     *   it might at first seem to be OK to continue treating the conflict replica as its 'natural' transient form,
     *   as there is always a quorum of nodes receiving the write.  However, ring ownership changes are not atomic or
     *   consistent across the cluster, and it is possible for writers to see different ring states.
     *
     *   Furthermore, an operator would expect that the full node has received all writes, with no extra need for repair
     *   (as the normal contract dictates) when it completes its transition.
     *
     *   While we cannot completely eliminate risks due to ring inconsistencies, this approach is the most conservative
     *   available to us today to mitigate, and (we think) the easiest to reason about.
     *
     * For full-&gt;transient transitions:
     *
     *   In this case, things are dicier, because in theory we can trigger this change instantly.  All we need to do is
     *   drop some data, surely?
     *
     *   Ring movements can put us in a pickle; any other node could believe us to be full when we have become transient,
     *   and perform a full data request to us that we believe ourselves capable of answering, but that we are not.
     *   If the ring is inconsistent, it's even feasible that a transient request would be made to the node that is losing
     *   its transient status, that also does not know it has yet done so, resulting in all involved nodes being unaware
     *   of the data inconsistency.
     *
     *   This happens because ring ownership changes are implied by a single node; not all owning nodes get a say in when
     *   the transition takes effect.  As such, a node can hold an incorrect belief about its own ownership ranges.
     *
     *   This race condition is somewhat inherent in present day Cassandra, and there's actually a limit to what we can do about it.
     *   It is a little more dangerous with transient replication, however, because we can completely answer a request without
     *   ever touching a digest, meaning we are less likely to attempt to repair any inconsistency.
     *
     *   We aren't guaranteed to contact any different nodes for the data requests, of course, though we at least have a chance.
     *
     * Note: If we have any pending transient-&gt;full movement, we need to move the full replica to our 'natural' bucket
     * to avoid corrupting our count.  This is fine for writes, all we're doing is ensuring we always write to the node,
     * instead of selectively.
     *
     * @param natural
     * @param pending
     * @param &lt;E&gt;
     * @return
     */</comment>
    <function><type><specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name><name>Endpoints</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>boolean</name></type> <name>haveWriteConflicts</name><parameter_list>(<parameter><decl><type><name>E</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>E</name></type> <name>pending</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>naturalEndpoints</name> <init>= <expr><call><name><name>natural</name><operator>.</operator><name>endpoints</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>pendingEndpoint</name> <range>: <expr><call><name><name>pending</name><operator>.</operator><name>endpoints</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>naturalEndpoints</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>pendingEndpoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * MUST APPLY FIRST
     * See {@link ReplicaLayout#haveWriteConflicts}
     * @return a 'natural' replica collection, that has had its conflicts with pending repaired
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>static</specifier> <name>EndpointsForToken</name></type> <name>resolveWriteConflictsInNatural</name><parameter_list>(<parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>pending</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>EndpointsForToken</name><operator>.</operator><name>Builder</name></name></type> <name>resolved</name> <init>= <expr><call><name><name>natural</name><operator>.</operator><name>newBuilder</name></name><argument_list>(<argument><expr><call><name><name>natural</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><name>natural</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// always prefer the full natural replica, if there is a conflict</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>replica</name><operator>.</operator><name>isTransient</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Replica</name></type> <name>conflict</name> <init>= <expr><call><name><name>pending</name><operator>.</operator><name>byEndpoint</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><call><name><name>replica</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>conflict</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// it should not be possible to have conflicts of the same replication type for the same range</comment>
                    <assert>assert <expr><call><name><name>conflict</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call></expr>;</assert>
                    <comment type="line">// If we have any pending transient-&gt;full movement, we need to move the full replica to our 'natural' bucket</comment>
                    <comment type="line">// to avoid corrupting our count</comment>
                    <expr_stmt><expr><call><name><name>resolved</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>resolved</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>resolved</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * MUST APPLY SECOND
     * See {@link ReplicaLayout#haveWriteConflicts}
     * @return a 'pending' replica collection, that has had its conflicts with natural repaired
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>static</specifier> <name>EndpointsForToken</name></type> <name>resolveWriteConflictsInPending</name><parameter_list>(<parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>pending</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>pending</name><operator>.</operator><name>without</name></name><argument_list>(<argument><expr><call><name><name>natural</name><operator>.</operator><name>endpoints</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return the read layout for a token - this includes only live natural replicas, i.e. those that are not pending
     * and not marked down by the failure detector. these are reverse sorted by the badness score of the configured snitch
     */</comment>
    <function><type><specifier>static</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenRead</name></name></type> <name>forTokenReadLiveSorted</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>replicas</name> <init>= <expr><call><name><name>replicationStrategy</name><operator>.</operator><name>getNaturalReplicasForToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>replicas</name> <operator>=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>sortedByProximity</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>replicas</name> <operator>=</operator> <call><name><name>replicas</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name><name>FailureDetector</name><operator>.</operator><name>isReplicaAlive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaLayout</name><operator>.</operator><name>ForTokenRead</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * TODO: we should really double check that the provided range does not overlap multiple token ring regions
     * @return the read layout for a range - this includes only live natural replicas, i.e. those that are not pending
     * and not marked down by the failure detector. these are reverse sorted by the badness score of the configured snitch
     */</comment>
    <function><type><specifier>static</specifier> <name><name>ReplicaLayout</name><operator>.</operator><name>ForRangeRead</name></name></type> <name>forRangeReadLiveSorted</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>replicationStrategy</name></decl></parameter>, <parameter><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>replicas</name> <init>= <expr><call><name><name>replicationStrategy</name><operator>.</operator><name>getNaturalReplicas</name></name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>replicas</name> <operator>=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>sortedByProximity</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>replicas</name> <operator>=</operator> <call><name><name>replicas</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name><name>FailureDetector</name><operator>.</operator><name>isReplicaAlive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>new</operator> <call><name><name>ReplicaLayout</name><operator>.</operator><name>ForRangeRead</name></name><argument_list>(<argument><expr><name>replicationStrategy</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

}</block></class>
</unit>
