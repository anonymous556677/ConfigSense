<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/db/compaction/CompactionIterator.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>compaction</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>LongPredicate</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>ImmutableSet</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Ordering</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>TableMetadata</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>transform</name><operator>.</operator><name>DuplicateRowChecker</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>filter</name><operator>.</operator><name>ColumnFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>PurgeFunction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>UnfilteredPartitionIterator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>UnfilteredPartitionIterators</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>rows</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>transform</name><operator>.</operator><name>Transformation</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>transactions</name><operator>.</operator><name>CompactionTransaction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>ISSTableScanner</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>CompactionParams</name><operator>.</operator><name>TombstoneOption</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Merge multiple iterators over the content of sstable into a "compacted" iterator.
 * &lt;p&gt;
 * On top of the actual merging the source iterators, this class:
 * &lt;ul&gt;
 *   &lt;li&gt;purge gc-able tombstones if possible (see PurgeIterator below).&lt;/li&gt;
 *   &lt;li&gt;update 2ndary indexes if necessary (as we don't read-before-write on index updates, index entries are
 *       not deleted on deletion of the base table data, which is ok because we'll fix index inconsistency
 *       on reads. This however mean that potentially obsolete index entries could be kept a long time for
 *       data that is not read often, so compaction "pro-actively" fix such index entries. This is mainly
 *       an optimization).&lt;/li&gt;
 *   &lt;li&gt;invalidate cached partitions that are empty post-compaction. This avoids keeping partitions with
 *       only purgable tombstones in the row cache.&lt;/li&gt;
 *   &lt;li&gt;keep tracks of the compaction progress.&lt;/li&gt;
 * &lt;/ul&gt;
 */</comment>
<class><specifier>public</specifier> class <name>CompactionIterator</name> <super_list><extends>extends <super><name><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name></super></extends> <implements>implements <super><name>UnfilteredPartitionIterator</name></super></implements></super_list>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>UNFILTERED_TO_UPDATE_PROGRESS</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>OperationType</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AbstractCompactionController</name></type> <name>controller</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ISSTableScanner</name></argument>&gt;</argument_list></name></type> <name>scanners</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ImmutableSet</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>nowInSec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>UUID</name></type> <name>compactionId</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>totalBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>bytesRead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>totalSourceCQLRows</name></decl>;</decl_stmt>

    <comment type="block">/*
     * counters for merged rows.
     * array index represents (number of merged rows - 1), so index 0 is counter for no merge (1 row),
     * index 1 is counter for 2 rows merged, and so on.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>mergeCounters</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>UnfilteredPartitionIterator</name></type> <name>compacted</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>CompactionIterator</name><parameter_list>(<parameter><decl><type><name>OperationType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ISSTableScanner</name></argument>&gt;</argument_list></name></type> <name>scanners</name></decl></parameter>, <parameter><decl><type><name>AbstractCompactionController</name></type> <name>controller</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>compactionId</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>scanners</name></expr></argument>, <argument><expr><name>controller</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><name>compactionId</name></expr></argument>, <argument><expr><name><name>ActiveCompactionsTracker</name><operator>.</operator><name>NOOP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <constructor><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// We make sure to close mergedIterator in close() and CompactionIterator is itself an AutoCloseable</comment>
    <specifier>public</specifier> <name>CompactionIterator</name><parameter_list>(<parameter><decl><type><name>OperationType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ISSTableScanner</name></argument>&gt;</argument_list></name></type> <name>scanners</name></decl></parameter>, <parameter><decl><type><name>AbstractCompactionController</name></type> <name>controller</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>compactionId</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>controller</name></name> <operator>=</operator> <name>controller</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>scanners</name></name> <operator>=</operator> <name>scanners</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nowInSec</name></name> <operator>=</operator> <name>nowInSec</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>compactionId</name></name> <operator>=</operator> <name>compactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>bytesRead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ISSTableScanner</name></type> <name>scanner</name> <range>: <expr><name>scanners</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>bytes</name> <operator>+=</operator> <call><name><name>scanner</name><operator>.</operator><name>getLengthInBytes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>totalBytes</name></name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>mergeCounters</name></name> <operator>=</operator> <operator>new</operator> <name><name>long</name><index>[<expr><call><name><name>scanners</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <comment type="line">// note that we leak `this` from the constructor when calling beginCompaction below, this means we have to get the sstables before</comment>
        <comment type="line">// calling that to avoid a NPE.</comment>
        <expr_stmt><expr><name>sstables</name> <operator>=</operator> <call><name><name>scanners</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>ISSTableScanner</name><operator>::</operator><name>getBackingSSTables</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>flatMap</name><argument_list>(<argument><expr><name>Collection</name><operator>::</operator><name>stream</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>ImmutableSet</name><operator>.</operator><name>toImmutableSet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>activeCompactions</name></name> <operator>=</operator> <ternary><condition><expr><name>activeCompactions</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name><name>ActiveCompactionsTracker</name><operator>.</operator><name>NOOP</name></name></expr> </then><else>: <expr><name>activeCompactions</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// note that CompactionTask also calls this, but CT only creates CompactionIterator with a NOOP ActiveCompactions</comment>

        <decl_stmt><decl><type><name>UnfilteredPartitionIterator</name></type> <name>merged</name> <init>= <expr><ternary><condition><expr><call><name><name>scanners</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>
                                           ?</condition><then> <expr><call><name><name>EmptyIterators</name><operator>.</operator><name>unfilteredPartition</name></name><argument_list>(<argument><expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>
                                           </then><else>: <expr><call><name><name>UnfilteredPartitionIterators</name><operator>.</operator><name>merge</name></name><argument_list>(<argument><expr><name>scanners</name></expr></argument>, <argument><expr><call><name>listener</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>merged</name> <operator>=</operator> <call><name><name>Transformation</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>GarbageSkipper</name><argument_list>(<argument><expr><name>controller</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>merged</name> <operator>=</operator> <call><name><name>Transformation</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>Purger</name><argument_list>(<argument><expr><name>controller</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>merged</name> <operator>=</operator> <call><name><name>DuplicateRowChecker</name><operator>.</operator><name>duringCompaction</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>compacted</name> <operator>=</operator> <call><name><name>Transformation</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>AbortableUnfilteredPartitionTransformation</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <name>TableMetadata</name></type> <name>metadata</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>CompactionInfo</name></type> <name>getCompactionInfo</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>CompactionInfo</name><argument_list>(<argument><expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr></argument>,
                                  <argument><expr><name>type</name></expr></argument>,
                                  <argument><expr><name>bytesRead</name></expr></argument>,
                                  <argument><expr><name>totalBytes</name></expr></argument>,
                                  <argument><expr><name>compactionId</name></expr></argument>,
                                  <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isGlobal</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>updateCounterFor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rows</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>rows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rows</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>mergeCounters</name><operator>.</operator><name>length</name></name></expr>;</assert>
        <expr_stmt><expr><name><name>mergeCounters</name><index>[<expr><name>rows</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>long</name><index>[]</index></name></type> <name>getMergedRowCounts</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>mergeCounters</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalSourceCQLRows</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>totalSourceCQLRows</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>UnfilteredPartitionIterators</name><operator>.</operator><name>MergeListener</name></name></type> <name>listener</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <class><super><name><name>UnfilteredPartitionIterators</name><operator>.</operator><name>MergeListener</name></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name><name>UnfilteredRowIterators</name><operator>.</operator><name>MergeListener</name></name></type> <name>getRowMergeListener</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>partitionKey</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>UnfilteredRowIterator</name></argument>&gt;</argument_list></name></type> <name>versions</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>merged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>isize</name><init>=<expr><call><name><name>versions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>isize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
                    <type><name>UnfilteredRowIterator</name></type> <name>iter</name> <init>= <expr><call><name><name>versions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>iter</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>merged</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>

                <assert>assert <expr><name>merged</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>

                <expr_stmt><expr><call><name><name>CompactionIterator</name><operator>.</operator><name>this</name><operator>.</operator><name>updateCounterFor</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name><name>OperationType</name><operator>.</operator><name>COMPACTION</name></name> <operator>||</operator> <operator>!</operator><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>hasIndexes</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><name>Columns</name></type> <name>statics</name> <init>= <expr><name><name>Columns</name><operator>.</operator><name>NONE</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Columns</name></type> <name>regulars</name> <init>= <expr><name><name>Columns</name><operator>.</operator><name>NONE</name></name></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>isize</name><init>=<expr><call><name><name>versions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>isize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
                    <type><name>UnfilteredRowIterator</name></type> <name>iter</name> <init>= <expr><call><name><name>versions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>iter</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>statics</name> <operator>=</operator> <call><name><name>statics</name><operator>.</operator><name>mergeTo</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>.</operator><name>columns</name></name><argument_list>()</argument_list></call><operator>.</operator><name>statics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>regulars</name> <operator>=</operator> <call><name><name>regulars</name><operator>.</operator><name>mergeTo</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>.</operator><name>columns</name></name><argument_list>()</argument_list></call><operator>.</operator><name>regulars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <decl_stmt><decl><type><specifier>final</specifier> <name>RegularAndStaticColumns</name></type> <name>regularAndStaticColumns</name> <init>= <expr><operator>new</operator> <call><name>RegularAndStaticColumns</name><argument_list>(<argument><expr><name>statics</name></expr></argument>, <argument><expr><name>regulars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If we have a 2ndary index, we must update it with deleted/shadowed cells.</comment>
                <comment type="line">// we can reuse a single CleanupTransaction for the duration of a partition.</comment>
                <comment type="line">// Currently, it doesn't do any batching of row updates, so every merge event</comment>
                <comment type="line">// for a single partition results in a fresh cycle of:</comment>
                <comment type="line">// * Get new Indexer instances</comment>
                <comment type="line">// * Indexer::start</comment>
                <comment type="line">// * Indexer::onRowMerge (for every row being merged by the compaction)</comment>
                <comment type="line">// * Indexer::commit</comment>
                <comment type="line">// A new OpOrder.Group is opened in an ARM block wrapping the commits</comment>
                <comment type="line">// TODO: this should probably be done asynchronously and batched.</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>CompactionTransaction</name></type> <name>indexTransaction</name> <init>=
                    <expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>newCompactionTransaction</name></name><argument_list>(<argument><expr><name>partitionKey</name></expr></argument>,
                                                                         <argument><expr><name>regularAndStaticColumns</name></expr></argument>,
                                                                         <argument><expr><call><name><name>versions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                         <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <class><super><name><name>UnfilteredRowIterators</name><operator>.</operator><name>MergeListener</name></name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onMergedPartitionLevelDeletion</name><parameter_list>(<parameter><decl><type><name>DeletionTime</name></type> <name>mergedDeletion</name></decl></parameter>, <parameter><decl><type><name><name>DeletionTime</name><index>[]</index></name></type> <name>versions</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
                    </block_content>}</block></function>

                    <function><type><specifier>public</specifier> <name>Row</name></type> <name>onMergedRows</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name><name>Row</name><index>[]</index></name></type> <name>versions</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>onRowMerge</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>, <argument><expr><name>versions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>merged</name></expr>;</return>
                    </block_content>}</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onMergedRangeTombstoneMarkers</name><parameter_list>(<parameter><decl><type><name>RangeTombstoneMarker</name></type> <name>mergedMarker</name></decl></parameter>, <parameter><decl><type><name><name>RangeTombstoneMarker</name><index>[]</index></name></type> <name>versions</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
                    </block_content>}</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list>
                    <block>{<block_content>
                    </block_content>}</block></function>
                }</block></class></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list>
            <block>{<block_content>
            </block_content>}</block></function>
        }</block></class></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>updateBytesRead</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ISSTableScanner</name></type> <name>scanner</name> <range>: <expr><name>scanners</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name><name>scanner</name><operator>.</operator><name>getCurrentPosition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name>bytesRead</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasNext</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compacted</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>UnfilteredRowIterator</name></type> <name>next</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compacted</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>remove</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>compacted</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>private</specifier> class <name>Purger</name> <super_list><extends>extends <super><name>PurgeFunction</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AbstractCompactionController</name></type> <name>controller</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>DecoratedKey</name></type> <name>currentKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>LongPredicate</name></type> <name>purgeEvaluator</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>compactedUnfiltered</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Purger</name><parameter_list>(<parameter><decl><type><name>AbstractCompactionController</name></type> <name>controller</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><name><name>controller</name><operator>.</operator><name>gcBefore</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name><name>controller</name><operator>.</operator><name>compactingRepaired</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr> </then><else>: <expr><name><name>Integer</name><operator>.</operator><name>MIN_VALUE</name></name></expr></else></ternary></expr></argument>,
                  <argument><expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>onlyPurgeRepairedTombstones</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>enforceStrictLiveness</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>controller</name></name> <operator>=</operator> <name>controller</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>void</name></type> <name>onEmptyPartitionPostPurge</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name><name>OperationType</name><operator>.</operator><name>COMPACTION</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>controller</name><operator>.</operator><name>cfs</name><operator>.</operator><name>invalidateCachedPartition</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>void</name></type> <name>onNewPartition</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>currentKey</name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>purgeEvaluator</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>void</name></type> <name>updateProgress</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>totalSourceCQLRows</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>compactedUnfiltered</name><operator>)</operator> <operator>%</operator> <name>UNFILTERED_TO_UPDATE_PROGRESS</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>updateBytesRead</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <comment type="block">/*
         * Evaluates whether a tombstone with the given deletion timestamp can be purged. This is the minimum
         * timestamp for any sstable containing `currentKey` outside of the set of sstables involved in this compaction.
         * This is computed lazily on demand as we only need this if there is tombstones and this a bit expensive
         * (see #8914).
         */</comment>
        <function><type><specifier>protected</specifier> <name>LongPredicate</name></type> <name>getPurgeEvaluator</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>purgeEvaluator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>purgeEvaluator</name> <operator>=</operator> <call><name><name>controller</name><operator>.</operator><name>getPurgeEvaluator</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>purgeEvaluator</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Unfiltered row iterator that removes deleted data as provided by a "tombstone source" for the partition.
     * The result produced by this iterator is such that when merged with tombSource it produces the same output
     * as the merge of dataSource and tombSource.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>GarbageSkippingUnfilteredRowIterator</name> <super_list><extends>extends <super><name>WrappingUnfilteredRowIterator</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>UnfilteredRowIterator</name></type> <name>tombSource</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>DeletionTime</name></type> <name>partitionLevelDeletion</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Row</name></type> <name>staticRow</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ColumnFilter</name></type> <name>cf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>TableMetadata</name></type> <name>metadata</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>cellLevelGC</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>DeletionTime</name></type> <name>tombOpenDeletionTime</name> <init>= <expr><name><name>DeletionTime</name><operator>.</operator><name>LIVE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DeletionTime</name></type> <name>dataOpenDeletionTime</name> <init>= <expr><name><name>DeletionTime</name><operator>.</operator><name>LIVE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DeletionTime</name></type> <name>openDeletionTime</name> <init>= <expr><name><name>DeletionTime</name><operator>.</operator><name>LIVE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DeletionTime</name></type> <name>partitionDeletionTime</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DeletionTime</name></type> <name>activeDeletionTime</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Unfiltered</name></type> <name>tombNext</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Unfiltered</name></type> <name>dataNext</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Unfiltered</name></type> <name>next</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * Construct an iterator that filters out data shadowed by the provided "tombstone source".
         *
         * @param dataSource The input row. The result is a filtered version of this.
         * @param tombSource Tombstone source, i.e. iterator used to identify deleted data in the input row.
         * @param cellLevelGC If false, the iterator will only look at row-level deletion times and tombstones.
         *                    If true, deleted or overwritten cells within a surviving row will also be removed.
         */</comment>
        <constructor><specifier>protected</specifier> <name>GarbageSkippingUnfilteredRowIterator</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>dataSource</name></decl></parameter>, <parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>tombSource</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>cellLevelGC</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>dataSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tombSource</name></name> <operator>=</operator> <name>tombSource</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>cellLevelGC</name></name> <operator>=</operator> <name>cellLevelGC</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name><name>dataSource</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name><name>ColumnFilter</name><operator>.</operator><name>all</name></name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>activeDeletionTime</name> <operator>=</operator> <name>partitionDeletionTime</name> <operator>=</operator> <call><name><name>tombSource</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Only preserve partition level deletion if not shadowed. (Note: Shadowing deletion must not be copied.)</comment>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>partitionLevelDeletion</name></name> <operator>=</operator> <ternary><condition><expr><call><name><name>dataSource</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>supersedes</name><argument_list>(<argument><expr><call><name><name>tombSource</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then>
                    <expr><call><name><name>dataSource</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call></expr> </then><else>:
                    <expr><name><name>DeletionTime</name><operator>.</operator><name>LIVE</name></name></expr></else></ternary></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Row</name></type> <name>dataStaticRow</name> <init>= <expr><call><name>garbageFilterRow</name><argument_list>(<argument><expr><call><name><name>dataSource</name><operator>.</operator><name>staticRow</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>tombSource</name><operator>.</operator><name>staticRow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>staticRow</name></name> <operator>=</operator> <ternary><condition><expr><name>dataStaticRow</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>dataStaticRow</name></expr> </then><else>: <expr><name><name>Rows</name><operator>.</operator><name>EMPTY_STATIC_ROW</name></name></expr></else></ternary></expr>;</expr_stmt>

            <expr_stmt><expr><name>tombNext</name> <operator>=</operator> <call><name>advance</name><argument_list>(<argument><expr><name>tombSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dataNext</name> <operator>=</operator> <call><name>advance</name><argument_list>(<argument><expr><name>dataSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Unfiltered</name></type> <name>advance</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>source</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><call><name><name>source</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>source</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>DeletionTime</name></type> <name>partitionLevelDeletion</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>partitionLevelDeletion</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tombSource</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Row</name></type> <name>staticRow</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>staticRow</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>boolean</name></type> <name>hasNext</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <comment type="line">// Produce the next element. This may consume multiple elements from both inputs until we find something</comment>
            <comment type="line">// from dataSource that is still live. We track the currently open deletion in both sources, as well as the</comment>
            <comment type="line">// one we have last issued to the output. The tombOpenDeletionTime is used to filter out content; the others</comment>
            <comment type="line">// to decide whether or not a tombstone is superseded, and to be able to surface (the rest of) a deletion</comment>
            <comment type="line">// range from the input when a suppressing deletion ends.</comment>
            <while>while <condition>(<expr><name>next</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>dataNext</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><ternary><condition><expr><name>tombNext</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name><name>metadata</name><operator>.</operator><name>comparator</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>dataNext</name></expr></argument>, <argument><expr><name>tombNext</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>dataNext</name><operator>.</operator><name>isRow</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Row</name><operator>)</operator> <name>dataNext</name><operator>)</operator><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>activeDeletionTime</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>processDataMarker</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>dataNext</name><operator>.</operator><name>isRow</name></name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>garbageFilterRow</name><argument_list>(<argument><expr><operator>(</operator><name>Row</name><operator>)</operator> <name>dataNext</name></expr></argument>, <argument><expr><operator>(</operator><name>Row</name><operator>)</operator> <name>tombNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>tombOpenDeletionTime</name> <operator>=</operator> <call><name>updateOpenDeletionTime</name><argument_list>(<argument><expr><name>tombOpenDeletionTime</name></expr></argument>, <argument><expr><name>tombNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>activeDeletionTime</name> <operator>=</operator> <call><name><name>Ordering</name><operator>.</operator><name>natural</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>max</name><argument_list>(<argument><expr><name>partitionDeletionTime</name></expr></argument>,
                                                                    <argument><expr><name>tombOpenDeletionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>processDataMarker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else <comment type="line">// (cmp &gt; 0)</comment>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>tombNext</name><operator>.</operator><name>isRangeTombstoneMarker</name></name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>tombOpenDeletionTime</name> <operator>=</operator> <call><name>updateOpenDeletionTime</name><argument_list>(<argument><expr><name>tombOpenDeletionTime</name></expr></argument>, <argument><expr><name>tombNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>activeDeletionTime</name> <operator>=</operator> <call><name><name>Ordering</name><operator>.</operator><name>natural</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>max</name><argument_list>(<argument><expr><name>partitionDeletionTime</name></expr></argument>,
                                                                    <argument><expr><name>tombOpenDeletionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>boolean</name></type> <name>supersededBefore</name> <init>= <expr><call><name><name>openDeletionTime</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>boolean</name></type> <name>supersededAfter</name> <init>= <expr><operator>!</operator><call><name><name>dataOpenDeletionTime</name><operator>.</operator><name>supersedes</name></name><argument_list>(<argument><expr><name>activeDeletionTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <comment type="line">// If a range open was not issued because it was superseded and the deletion isn't superseded any more, we need to open it now.</comment>
                        <if_stmt><if>if <condition>(<expr><name>supersededBefore</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>supersededAfter</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>new</operator> <call><name>RangeTombstoneBoundMarker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RangeTombstoneMarker</name><operator>)</operator> <name>tombNext</name><operator>)</operator><operator>.</operator><call><name>closeBound</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>invert</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>dataOpenDeletionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <comment type="line">// If the deletion begins to be superseded, we don't close the range yet. This can save us a close/open pair if it ends after the superseding range.</comment>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>next</name> <operator>instanceof</operator> <name>RangeTombstoneMarker</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>openDeletionTime</name> <operator>=</operator> <call><name>updateOpenDeletionTime</name><argument_list>(<argument><expr><name>openDeletionTime</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>dataNext</name> <operator>=</operator> <call><name>advance</name><argument_list>(<argument><expr><name>wrapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tombNext</name> <operator>=</operator> <call><name>advance</name><argument_list>(<argument><expr><name>tombSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></while>
            <return>return <expr><name>next</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>protected</specifier> <name>Row</name></type> <name>garbageFilterRow</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>dataRow</name></decl></parameter>, <parameter><decl><type><name>Row</name></type> <name>tombRow</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cellLevelGC</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><call><name><name>Rows</name><operator>.</operator><name>removeShadowedCells</name></name><argument_list>(<argument><expr><name>dataRow</name></expr></argument>, <argument><expr><name>tombRow</name></expr></argument>, <argument><expr><name>activeDeletionTime</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>DeletionTime</name></type> <name>deletion</name> <init>= <expr><call><name><name>Ordering</name><operator>.</operator><name>natural</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>max</name><argument_list>(<argument><expr><call><name><name>tombRow</name><operator>.</operator><name>deletion</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>time</name><argument_list>()</argument_list></call></expr></argument>,
                                                               <argument><expr><name>activeDeletionTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><call><name><name>dataRow</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>deletion</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Decide how to act on a tombstone marker from the input iterator. We can decide what to issue depending on
         * whether or not the ranges before and after the marker are superseded/live -- if none are, we can reuse the
         * marker; if both are, the marker can be ignored; otherwise we issue a corresponding start/end marker.
         */</comment>
        <function><type><specifier>private</specifier> <name>RangeTombstoneMarker</name></type> <name>processDataMarker</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>dataOpenDeletionTime</name> <operator>=</operator> <call><name>updateOpenDeletionTime</name><argument_list>(<argument><expr><name>dataOpenDeletionTime</name></expr></argument>, <argument><expr><name>dataNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>supersededBefore</name> <init>= <expr><call><name><name>openDeletionTime</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>supersededAfter</name> <init>= <expr><operator>!</operator><call><name><name>dataOpenDeletionTime</name><operator>.</operator><name>supersedes</name></name><argument_list>(<argument><expr><name>activeDeletionTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeTombstoneMarker</name></type> <name>marker</name> <init>= <expr><operator>(</operator><name>RangeTombstoneMarker</name><operator>)</operator> <name>dataNext</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>supersededBefore</name></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>supersededAfter</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>marker</name></expr>;</return></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <return>return <expr><operator>new</operator> <call><name>RangeTombstoneBoundMarker</name><argument_list>(<argument><expr><call><name><name>marker</name><operator>.</operator><name>closeBound</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>marker</name><operator>.</operator><name>closeDeletionTime</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt></block_content></block></if>
            <if type="elseif">else
                if <condition>(<expr><operator>!</operator><name>supersededAfter</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><operator>new</operator> <call><name>RangeTombstoneBoundMarker</name><argument_list>(<argument><expr><call><name><name>marker</name><operator>.</operator><name>openBound</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>marker</name><operator>.</operator><name>openDeletionTime</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Unfiltered</name></type> <name>next</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasNext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>()</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>Unfiltered</name></type> <name>v</name> <init>= <expr><name>next</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            <return>return <expr><name>v</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>DeletionTime</name></type> <name>updateOpenDeletionTime</name><parameter_list>(<parameter><decl><type><name>DeletionTime</name></type> <name>openDeletionTime</name></decl></parameter>, <parameter><decl><type><name>Unfiltered</name></type> <name>next</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTombstoneMarker</name></type> <name>marker</name> <init>= <expr><operator>(</operator><name>RangeTombstoneMarker</name><operator>)</operator> <name>next</name></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><call><name><name>openDeletionTime</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call> <operator>==</operator> <operator>!</operator><call><name><name>marker</name><operator>.</operator><name>isClose</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</assert>
            <assert>assert <expr><call><name><name>openDeletionTime</name><operator>.</operator><name>isLive</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>openDeletionTime</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>marker</name><operator>.</operator><name>closeDeletionTime</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</assert>
            <return>return <expr><ternary><condition><expr><call><name><name>marker</name><operator>.</operator><name>isOpen</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name><name>marker</name><operator>.</operator><name>openDeletionTime</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>DeletionTime</name><operator>.</operator><name>LIVE</name></name></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Partition transformation applying GarbageSkippingUnfilteredRowIterator, obtaining tombstone sources for each
     * partition using the controller's shadowSources method.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>GarbageSkipper</name> <super_list><extends>extends <super><name><name>Transformation</name><argument_list type="generic">&lt;<argument><name>UnfilteredRowIterator</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>AbstractCompactionController</name></type> <name>controller</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>cellLevelGC</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>GarbageSkipper</name><parameter_list>(<parameter><decl><type><name>AbstractCompactionController</name></type> <name>controller</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>controller</name></name> <operator>=</operator> <name>controller</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cellLevelGC</name> <operator>=</operator> <name><name>controller</name><operator>.</operator><name>tombstoneOption</name></name> <operator>==</operator> <name><name>TombstoneOption</name><operator>.</operator><name>CELL</name></name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>UnfilteredRowIterator</name></type> <name>applyToPartition</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>UnfilteredRowIterator</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>controller</name><operator>.</operator><name>shadowSources</name></name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>!</operator><name>cellLevelGC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>sources</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>partition</name></expr>;</return></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>UnfilteredRowIterator</name></argument>&gt;</argument_list></name></type> <name>iters</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>UnfilteredRowIterator</name></type> <name>iter</name> <range>: <expr><name>sources</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>iter</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>iters</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>iter</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><call><name><name>iters</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>partition</name></expr>;</return></block_content></block></if></if_stmt>

            <return>return <expr><operator>new</operator> <call><name>GarbageSkippingUnfilteredRowIterator</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><call><name><name>UnfilteredRowIterators</name><operator>.</operator><name>merge</name></name><argument_list>(<argument><expr><name>iters</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cellLevelGC</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>AbortableUnfilteredPartitionTransformation</name> <super_list><extends>extends <super><name><name>Transformation</name><argument_list type="generic">&lt;<argument><name>UnfilteredRowIterator</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AbortableUnfilteredRowTransformation</name></type> <name>abortableIter</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>AbortableUnfilteredPartitionTransformation</name><parameter_list>(<parameter><decl><type><name>CompactionIterator</name></type> <name>iter</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>abortableIter</name></name> <operator>=</operator> <operator>new</operator> <call><name>AbortableUnfilteredRowTransformation</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>UnfilteredRowIterator</name></type> <name>applyToPartition</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>abortableIter</name><operator>.</operator><name>iter</name><operator>.</operator><name>isStopRequested</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>CompactionInterruptedException</name><argument_list>(<argument><expr><call><name><name>abortableIter</name><operator>.</operator><name>iter</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
            <return>return <expr><call><name><name>Transformation</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>abortableIter</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>AbortableUnfilteredRowTransformation</name> <super_list><extends>extends <super><name>Transformation</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CompactionIterator</name></type> <name>iter</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>AbortableUnfilteredRowTransformation</name><parameter_list>(<parameter><decl><type><name>CompactionIterator</name></type> <name>iter</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>iter</name></name> <operator>=</operator> <name>iter</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>Row</name></type> <name>applyToRow</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>iter</name><operator>.</operator><name>isStopRequested</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>CompactionInterruptedException</name><argument_list>(<argument><expr><call><name><name>iter</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
            <return>return <expr><name>row</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>
}</block></class>
</unit>
