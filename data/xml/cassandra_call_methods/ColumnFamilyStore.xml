<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/db/ColumnFamilyStore.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>File</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>PrintStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>reflect</name><operator>.</operator><name>Constructor</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>reflect</name><operator>.</operator><name>InvocationTargetException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>file</name><operator>.</operator><name>Files</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Objects</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicReference</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
<import>import <name><name>javax</name><operator>.</operator><name>management</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>javax</name><operator>.</operator><name>management</name><operator>.</operator><name>openmbean</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Throwables</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cache</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>commitlog</name><operator>.</operator><name>CommitLog</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>commitlog</name><operator>.</operator><name>CommitLogPosition</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>compaction</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>filter</name><operator>.</operator><name>ClusteringIndexFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>filter</name><operator>.</operator><name>DataLimits</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>streaming</name><operator>.</operator><name>CassandraStreamManager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>repair</name><operator>.</operator><name>CassandraTableRepairManager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>view</name><operator>.</operator><name>TableViews</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>CachedPartition</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>PartitionUpdate</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>rows</name><operator>.</operator><name>CellPath</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Range</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>StartupException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>SecondaryIndexManager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>internal</name><operator>.</operator><name>CassandraIndex</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>transactions</name><operator>.</operator><name>UpdateTransaction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>FSReadError</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>FSWriteError</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>Component</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>Descriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>SSTableMultiWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataCollector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>util</name><operator>.</operator><name>FileUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>Sampler</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>Sampler</name><operator>.</operator><name>Sample</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>Sampler</name><operator>.</operator><name>SamplerType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>TableMetrics</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>repair</name><operator>.</operator><name>TableRepairManager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>repair</name><operator>.</operator><name>consistent</name><operator>.</operator><name>admin</name><operator>.</operator><name>CleanupSummary</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>repair</name><operator>.</operator><name>consistent</name><operator>.</operator><name>admin</name><operator>.</operator><name>PendingStat</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>CompactionParams</name><operator>.</operator><name>TombstoneOption</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>ActiveRepairService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>CacheService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>StorageService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>TableStreamManager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>OpOrder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Refs</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>memory</name><operator>.</operator><name>MemtableAllocator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>json</name><operator>.</operator><name>simple</name><operator>.</operator><name>JSONArray</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>json</name><operator>.</operator><name>simple</name><operator>.</operator><name>JSONObject</name></name>;</import>

<import>import static <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>TimeUnit</name><operator>.</operator><name>NANOSECONDS</name></name>;</import>

<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Throwables</name><operator>.</operator><name>maybeFail</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Throwables</name><operator>.</operator><name>merge</name></name>;</import>

<class><specifier>public</specifier> class <name>ColumnFamilyStore</name> <super_list><implements>implements <super><name>ColumnFamilyStoreMBean</name></super></implements></super_list>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
    We keep a pool of threads for each data directory, size of each pool is memtable_flush_writers.
    When flushing we start a Flush runnable in the flushExecutor. Flush calculates how to split the
    memtable ranges over the existing data directories and creates a FlushRunnable for each of the directories.
    The FlushRunnables are executed in the perDiskflushExecutors and the Flush will block until all FlushRunnables
    are finished. By having flushExecutor size the same size as each of the perDiskflushExecutors we make sure we can
    have that many flushes going at the same time.
    */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ThreadPoolExecutor</name></type> <name>flushExecutor</name> <init>= <expr><operator>new</operator> <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getFlushWriters</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                             <argument><expr><name><name>Stage</name><operator>.</operator><name>KEEP_ALIVE_SECONDS</name></name></expr></argument>,
                                                                                             <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>,
                                                                                             <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                             <argument><expr><operator>new</operator> <call><name>NamedThreadFactory</name><argument_list>(<argument><expr><literal type="string">"MemtableFlushWriter"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                                                             <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>PerDiskFlushExecutors</name></type> <name>perDiskflushExecutors</name> <init>= <expr><operator>new</operator> <call><name>PerDiskFlushExecutors</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getFlushWriters</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                                 <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getNonLocalSystemKeyspacesDataFileLocations</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                                 <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>useSpecificLocationForLocalSystemData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// post-flush executor is single threaded to provide guarantee that any flush Future on a CF will never return until prior flushes have completed</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ThreadPoolExecutor</name></type> <name>postFlushExecutor</name> <init>= <expr><operator>new</operator> <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                                                                                                 <argument><expr><name><name>Stage</name><operator>.</operator><name>KEEP_ALIVE_SECONDS</name></name></expr></argument>,
                                                                                                 <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>,
                                                                                                 <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                                 <argument><expr><operator>new</operator> <call><name>NamedThreadFactory</name><argument_list>(<argument><expr><literal type="string">"MemtablePostFlush"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                                                                 <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ThreadPoolExecutor</name></type> <name>reclaimExecutor</name> <init>= <expr><operator>new</operator> <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                                                                                               <argument><expr><name><name>Stage</name><operator>.</operator><name>KEEP_ALIVE_SECONDS</name></name></expr></argument>,
                                                                                               <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>,
                                                                                               <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                               <argument><expr><operator>new</operator> <call><name>NamedThreadFactory</name><argument_list>(<argument><expr><literal type="string">"MemtableReclaimMemory"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                                                               <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>COUNTER_NAMES</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"table"</literal></expr>, <expr><literal type="string">"count"</literal></expr>, <expr><literal type="string">"error"</literal></expr>, <expr><literal type="string">"value"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>COUNTER_DESCS</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[]</index></name>
    <block>{ <expr><literal type="string">"keyspace.tablename"</literal></expr>,
      <expr><literal type="string">"number of occurances"</literal></expr>,
      <expr><literal type="string">"error bounds"</literal></expr>,
      <expr><literal type="string">"value"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>CompositeType</name></type> <name>COUNTER_COMPOSITE_TYPE</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>SAMPLING_RESULTS_NAME</name> <init>= <expr><literal type="string">"SAMPLING_RESULTS"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>SNAPSHOT_TRUNCATE_PREFIX</name> <init>= <expr><literal type="string">"truncated"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>SNAPSHOT_DROP_PREFIX</name> <init>= <expr><literal type="string">"dropped"</literal></expr></init></decl>;</decl_stmt>

    <static>static
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name><name>OpenType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>counterTypes</name> <init>= <expr><operator>new</operator> <name><name>OpenType</name><index>[]</index></name> <block>{ <expr><name><name>SimpleType</name><operator>.</operator><name>STRING</name></name></expr>, <expr><name><name>SimpleType</name><operator>.</operator><name>LONG</name></name></expr>, <expr><name><name>SimpleType</name><operator>.</operator><name>LONG</name></name></expr>, <expr><name><name>SimpleType</name><operator>.</operator><name>STRING</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>COUNTER_COMPOSITE_TYPE</name> <operator>=</operator> <operator>new</operator> <call><name>CompositeType</name><argument_list>(<argument><expr><name>SAMPLING_RESULTS_NAME</name></expr></argument>, <argument><expr><name>SAMPLING_RESULTS_NAME</name></expr></argument>, <argument><expr><name>COUNTER_NAMES</name></expr></argument>, <argument><expr><name>COUNTER_DESCS</name></expr></argument>, <argument><expr><name>counterTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>OpenDataException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></static>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Keyspace</name></type> <name>keyspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>TableMetadataRef</name></type> <name>metadata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>mbeanName</name></decl>;</decl_stmt>
    <decl_stmt><decl><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>oldMBeanName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>valid</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Memtables and SSTables on disk for this column family.
     *
     * We synchronize on the Tracker to ensure isolation when we want to make sure
     * that the memtable we're acting on doesn't change out from under us.  I.e., flush
     * syncronizes on it to make sure it can submit on both executors atomically,
     * so anyone else who wants to make sure flush doesn't interfere should as well.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Tracker</name></type> <name>data</name></decl>;</decl_stmt>

    <comment type="block">/* The read order, used to track accesses to off-heap memtable storage */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>OpOrder</name></type> <name>readOrdering</name> <init>= <expr><operator>new</operator> <call><name>OpOrder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* This is used to generate the next index for a SSTable */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>fileIndexGenerator</name> <init>= <expr><operator>new</operator> <call><name>AtomicInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>SecondaryIndexManager</name></type> <name>indexManager</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>TableViews</name></type> <name>viewManager</name></decl>;</decl_stmt>

    <comment type="block">/* These are locally held copies to be changed from the config during runtime */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>minCompactionThreshold</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>maxCompactionThreshold</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><name>Double</name></argument>&gt;</argument_list></name></type> <name>crcCheckChance</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CompactionStrategyManager</name></type> <name>compactionStrategyManager</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Directories</name></type> <name>directories</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>TableMetrics</name></type> <name>metric</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>volatile</specifier> <name>long</name></type> <name>sampleReadLatencyNanos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>volatile</specifier> <name>long</name></type> <name>additionalWriteLatencyNanos</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CassandraTableWriteHandler</name></type> <name>writeHandler</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CassandraStreamManager</name></type> <name>streamManager</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>TableRepairManager</name></type> <name>repairManager</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>SSTableImporter</name></type> <name>sstableImporter</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>compactionSpaceCheck</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>final</specifier> <name>DiskBoundaryManager</name></type> <name>diskBoundaryManager</name> <init>= <expr><operator>new</operator> <call><name>DiskBoundaryManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>neverPurgeTombstones</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>shutdownPostFlushExecutor</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>postFlushExecutor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>postFlushExecutor</name><operator>.</operator><name>awaitTermination</name></name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>shutdownExecutorsAndWait</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>TimeUnit</name></type> <name>unit</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>TimeoutException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ExecutorService</name></argument>&gt;</argument_list></name></type> <name>executors</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>executors</name></expr></argument>, <argument><expr><name>reclaimExecutor</name></expr></argument>, <argument><expr><name>postFlushExecutor</name></expr></argument>, <argument><expr><name>flushExecutor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>perDiskflushExecutors</name><operator>.</operator><name>appendAllExecutors</name></name><argument_list>(<argument><expr><name>executors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ExecutorUtils</name><operator>.</operator><name>shutdownAndWait</name></name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>executors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>reload</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// metadata object has been mutated directly. make all the members jibe with new settings.</comment>

        <comment type="line">// only update these runtime-modifiable settings if they have not been modified.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>minCompactionThreshold</name><operator>.</operator><name>isModified</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cfs</name><operator>.</operator><name>minCompactionThreshold</name></name> <operator>=</operator> <operator>new</operator> <call><name>DefaultValue</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>compaction</name><operator>.</operator><name>minCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>maxCompactionThreshold</name><operator>.</operator><name>isModified</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cfs</name><operator>.</operator><name>maxCompactionThreshold</name></name> <operator>=</operator> <operator>new</operator> <call><name>DefaultValue</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>compaction</name><operator>.</operator><name>maxCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>crcCheckChance</name><operator>.</operator><name>isModified</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cfs</name><operator>.</operator><name>crcCheckChance</name></name> <operator>=</operator> <operator>new</operator> <call><name>DefaultValue</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>crcCheckChance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>maybeReload</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>scheduleFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>indexManager</name><operator>.</operator><name>reload</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If the CF comparator has changed, we need to change the memtable,</comment>
        <comment type="line">// because the old one still aliases the previous comparator.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call><operator>.</operator><name>initialComparator</name> <operator>!=</operator> <call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name>comparator</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>switchMemtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>scheduleFlush</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>period</name> <init>= <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>memtableFlushPeriodInMs</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>period</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"scheduling flush in {} ms"</literal></expr></argument>, <argument><expr><name>period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>WrappedRunnable</name></type> <name>runnable</name> <init>= <expr><operator>new</operator> <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list>
                <block>{<block_content>
                    <synchronized>synchronized <init>(<expr><name>data</name></expr>)</init>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Memtable</name></type> <name>current</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <comment type="line">// if we're not expired, we've been hit by a scheduled flush for an already flushed memtable, so ignore</comment>
                        <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>isExpired</name></name><argument_list>()</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>isClean</name></name><argument_list>()</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// if we're still clean, instead of swapping just reschedule a flush for later</comment>
                                <expr_stmt><expr><call><name>scheduleFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <comment type="line">// we'll be rescheduled by the constructor of the Memtable.</comment>
                                <expr_stmt><expr><call><name>forceFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></synchronized>
                </block_content>}</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ScheduledExecutors</name><operator>.</operator><name>scheduledTasks</name><operator>.</operator><name>schedule</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><name>period</name></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Runnable</name></type> <name>getBackgroundCompactionTaskSubmitter</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
            <for>for <control>(<init><decl><type><name>Keyspace</name></type> <name>keyspace</name> <range>: <expr><call><name><name>Keyspace</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>keyspace</name><operator>.</operator><name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>submitBackground</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
        </block_content>}</block></lambda></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getCompactionParameters</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>getCompactionParams</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>asMap</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getCompactionParametersJson</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>FBUtilities</name><operator>.</operator><name>json</name></name><argument_list>(<argument><expr><call><name>getCompactionParameters</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionParameters</name><parameter_list>(<parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>CompactionParams</name></type> <name>compactionParams</name> <init>= <expr><call><name><name>CompactionParams</name><operator>.</operator><name>fromMap</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>compactionParams</name><operator>.</operator><name>validate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>setNewLocalCompactionStrategy</name></name><argument_list>(<argument><expr><name>compactionParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Could not set new local compaction strategy"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// dont propagate the ConfigurationException over jmx, user will only see a ClassNotFoundException</comment>
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Could not set new local compaction strategy: "</literal><operator>+</operator><call><name><name>t</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionParametersJson</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>setCompactionParameters</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>fromJsonMap</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getCompressionParameters</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>metadata</name><operator>.</operator><name>getLocal</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>compression</name><operator>.</operator><name>asMap</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getCompressionParametersJson</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>FBUtilities</name><operator>.</operator><name>json</name></name><argument_list>(<argument><expr><call><name>getCompressionParameters</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompressionParameters</name><parameter_list>(<parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>opts</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>CompressionParams</name></type> <name>params</name> <init>= <expr><call><name><name>CompressionParams</name><operator>.</operator><name>fromMap</name></name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>params</name><operator>.</operator><name>validate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>metadata</name><operator>.</operator><name>setLocalOverrides</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name>unbuild</name><argument_list>()</argument_list></call><operator>.</operator><call><name>compression</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompressionParametersJson</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>setCompressionParameters</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>fromJsonMap</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <constructor><annotation>@<name>VisibleForTesting</name></annotation>
    <specifier>public</specifier> <name>ColumnFamilyStore</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>,
                             <parameter><decl><type><name>String</name></type> <name>columnFamilyName</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>generation</name></decl></parameter>,
                             <parameter><decl><type><name>TableMetadataRef</name></type> <name>metadata</name></decl></parameter>,
                             <parameter><decl><type><name>Directories</name></type> <name>directories</name></decl></parameter>,
                             <parameter><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></parameter>,
                             <parameter><decl><type><name>boolean</name></type> <name>registerBookeeping</name></decl></parameter>,
                             <parameter><decl><type><name>boolean</name></type> <name>offline</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>directories</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <assert>assert <expr><name>metadata</name> <operator>!=</operator> <literal type="null">null</literal> <operator>:</operator> <literal type="string">"null metadata for "</literal> <operator>+</operator> <name>keyspace</name> <operator>+</operator> <literal type="char">':'</literal> <operator>+</operator> <name>columnFamilyName</name></expr>;</assert>

        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keyspace</name></name> <operator>=</operator> <name>keyspace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>metadata</name></name> <operator>=</operator> <name>metadata</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>directories</name></name> <operator>=</operator> <name>directories</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>name</name> <operator>=</operator> <name>columnFamilyName</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>minCompactionThreshold</name> <operator>=</operator> <operator>new</operator> <call><name><name>DefaultValue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>compaction</name><operator>.</operator><name>minCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxCompactionThreshold</name> <operator>=</operator> <operator>new</operator> <call><name><name>DefaultValue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>compaction</name><operator>.</operator><name>maxCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>crcCheckChance</name> <operator>=</operator> <operator>new</operator> <call><name><name>DefaultValue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>crcCheckChance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>viewManager</name> <operator>=</operator> <call><name><name>keyspace</name><operator>.</operator><name>viewManager</name><operator>.</operator><name>forTable</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>fileIndexGenerator</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sampleReadLatencyNanos</name> <operator>=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getReadRpcTimeout</name></name><argument_list>(<argument><expr><name>NANOSECONDS</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>additionalWriteLatencyNanos</name> <operator>=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getWriteRpcTimeout</name></name><argument_list>(<argument><expr><name>NANOSECONDS</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Initializing {}.{}"</literal></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create Memtable only on online</comment>
        <decl_stmt><decl><type><name>Memtable</name></type> <name>initialMemtable</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>isDaemonInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>initialMemtable</name> <operator>=</operator> <operator>new</operator> <call><name>Memtable</name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>AtomicReference</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>CommitLog</name><operator>.</operator><name>instance</name><operator>.</operator><name>getCurrentPosition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>new</operator> <call><name>Tracker</name><argument_list>(<argument><expr><name>initialMemtable</name></expr></argument>, <argument><expr><name>loadSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Note that this needs to happen before we load the first sstables, or the global sstable tracker will not</comment>
        <comment type="line">// be notified on the initial loading.</comment>
        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>subscribe</name></name><argument_list>(<argument><expr><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>sstablesTracker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// scan for sstables corresponding to this cf and load them</comment>
        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>loadsstables</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Directories</name><operator>.</operator><name>SSTableLister</name></name></type> <name>sstableFiles</name> <init>= <expr><call><name><name>directories</name><operator>.</operator><name>sstableLister</name></name><argument_list>(<argument><expr><name><name>Directories</name><operator>.</operator><name>OnTxnErr</name><operator>.</operator><name>IGNORE</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>skipTemporary</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>sstables</name> <operator>=</operator> <call><name><name>SSTableReader</name><operator>.</operator><name>openAll</name></name><argument_list>(<argument><expr><call><name><name>sstableFiles</name><operator>.</operator><name>list</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>entrySet</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>addInitialSSTablesWithoutUpdatingSize</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// compaction strategy should be created after the CFS has been prepared</comment>
        <expr_stmt><expr><name>compactionStrategyManager</name> <operator>=</operator> <operator>new</operator> <call><name>CompactionStrategyManager</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>maxCompactionThreshold</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>minCompactionThreshold</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Disabling compaction strategy by setting compaction thresholds to 0 is deprecated, set the compaction option 'enabled' to 'false' instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>compactionStrategyManager</name><operator>.</operator><name>disable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// create the private ColumnFamilyStores for the secondary column indexes</comment>
        <expr_stmt><expr><name>indexManager</name> <operator>=</operator> <operator>new</operator> <call><name>SecondaryIndexManager</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>IndexMetadata</name></type> <name>info</name> <range>: <expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><name>indexes</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>indexManager</name><operator>.</operator><name>addIndex</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>metric</name> <operator>=</operator> <operator>new</operator> <call><name>TableMetrics</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>loadsstables</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>updateInitialSSTableSize</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>registerBookeeping</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// register the mbean</comment>
            <expr_stmt><expr><name>mbeanName</name> <operator>=</operator> <call><name>getTableMBeanName</name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>isIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldMBeanName</name> <operator>=</operator> <call><name>getColumnFamilieMBeanName</name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>isIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>objectNames</name> <init>= <expr><block>{<expr><name>mbeanName</name></expr>, <expr><name>oldMBeanName</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>String</name></type> <name>objectName</name> <range>: <expr><name>objectNames</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>MBeanWrapper</name><operator>.</operator><name>instance</name><operator>.</operator><name>registerMBean</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>mbeanName</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldMBeanName</name><operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>writeHandler</name> <operator>=</operator> <operator>new</operator> <call><name>CassandraTableWriteHandler</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>streamManager</name> <operator>=</operator> <operator>new</operator> <call><name>CassandraStreamManager</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>repairManager</name> <operator>=</operator> <operator>new</operator> <call><name>CassandraTableRepairManager</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sstableImporter</name> <operator>=</operator> <operator>new</operator> <call><name>SSTableImporter</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getTableMBeanName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>ks</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isIndex</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"org.apache.cassandra.db:type=%s,keyspace=%s,table=%s"</literal></expr></argument>,
                      <argument><expr><ternary><condition><expr><name>isIndex</name></expr> ?</condition><then> <expr><literal type="string">"IndexTables"</literal></expr> </then><else>: <expr><literal type="string">"Tables"</literal></expr></else></ternary></expr></argument>,
                      <argument><expr><name>ks</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getColumnFamilieMBeanName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>ks</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isIndex</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
       <return>return <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"org.apache.cassandra.db:type=%s,keyspace=%s,columnfamily=%s"</literal></expr></argument>,
                            <argument><expr><ternary><condition><expr><name>isIndex</name></expr> ?</condition><then> <expr><literal type="string">"IndexColumnFamilies"</literal></expr> </then><else>: <expr><literal type="string">"ColumnFamilies"</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><name>ks</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateSpeculationThreshold</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><name>sampleReadLatencyNanos</name> <operator>=</operator> <call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>speculativeRetry</name><operator>.</operator><name>calculateThreshold</name></name><argument_list>(<argument><expr><call><name><name>metric</name><operator>.</operator><name>coordinatorReadLatency</name><operator>.</operator><name>getSnapshot</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sampleReadLatencyNanos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>additionalWriteLatencyNanos</name> <operator>=</operator> <call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>additionalWritePolicy</name><operator>.</operator><name>calculateThreshold</name></name><argument_list>(<argument><expr><call><name><name>metric</name><operator>.</operator><name>coordinatorWriteLatency</name><operator>.</operator><name>getSnapshot</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>additionalWriteLatencyNanos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Exception caught while calculating speculative retry threshold for {}: {}"</literal></expr></argument>, <argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TableWriteHandler</name></type> <name>getWriteHandler</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>writeHandler</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TableStreamManager</name></type> <name>getStreamManager</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>streamManager</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TableRepairManager</name></type> <name>getRepairManager</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>repairManager</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TableMetadata</name></type> <name>metadata</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Directories</name></type> <name>getDirectories</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>directories</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getDataPaths</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>dataPaths</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>File</name></type> <name>dataPath</name> <range>: <expr><call><name><name>directories</name><operator>.</operator><name>getCFDirectories</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>dataPaths</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>dataPath</name><operator>.</operator><name>getCanonicalPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><name>dataPaths</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>SSTableMultiWriter</name></type> <name>createSSTableMultiWriter</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>keyCount</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>repairedAt</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isTransient</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sstableLevel</name></decl></parameter>, <parameter><decl><type><name>SerializationHeader</name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>LifecycleNewTracker</name></type> <name>lifecycleNewTracker</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MetadataCollector</name></type> <name>collector</name> <init>= <expr><operator>new</operator> <call><name>MetadataCollector</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name>comparator</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>sstableLevel</name><argument_list>(<argument><expr><name>sstableLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>createSSTableMultiWriter</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>keyCount</name></expr></argument>, <argument><expr><name>repairedAt</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><name>isTransient</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>lifecycleNewTracker</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>SSTableMultiWriter</name></type> <name>createSSTableMultiWriter</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>keyCount</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>repairedAt</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isTransient</name></decl></parameter>, <parameter><decl><type><name>MetadataCollector</name></type> <name>metadataCollector</name></decl></parameter>, <parameter><decl><type><name>SerializationHeader</name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>LifecycleNewTracker</name></type> <name>lifecycleNewTracker</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getCompactionStrategyManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>createSSTableMultiWriter</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>keyCount</name></expr></argument>, <argument><expr><name>repairedAt</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><name>isTransient</name></expr></argument>, <argument><expr><name>metadataCollector</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><call><name><name>indexManager</name><operator>.</operator><name>listIndexes</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lifecycleNewTracker</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>supportsEarlyOpen</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>supportsEarlyOpen</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** call when dropping or renaming a CF. Performs mbean housekeeping and invalidates CFS to other operations */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidate</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>invalidate</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidate</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>expectMBean</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// disable and cancel in-progress compactions before invalidating</comment>
        <expr_stmt><expr><name>valid</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name>unregisterMBean</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>expectMBean</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>JVMStabilityInspector</name><operator>.</operator><name>inspectThrowable</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// this shouldn't block anything.</comment>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Failed unregistering mbean: {}"</literal></expr></argument>, <argument><expr><name>mbeanName</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></catch></try>

        <expr_stmt><expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>removeTruncationRecord</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>dropSSTables</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>LifecycleTransaction</name><operator>.</operator><name>waitForDeletions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>indexManager</name><operator>.</operator><name>dropAllIndexes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>invalidateCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Removes every SSTable in the directory from the Tracker's view.
     * @param directory the unreadable directory, possibly with SSTables in it, but not necessarily.
     */</comment>
    <function><type><name>void</name></type> <name>maybeRemoveUnreadableSSTables</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>directory</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>removeUnreadableSSTables</name></name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>unregisterMBean</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>MalformedObjectNameException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>ObjectName</name><index>[]</index></name></type> <name>objectNames</name> <init>= <expr><block>{<expr><operator>new</operator> <call><name>ObjectName</name><argument_list>(<argument><expr><name>mbeanName</name></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>ObjectName</name><argument_list>(<argument><expr><name>oldMBeanName</name></expr></argument>)</argument_list></call></expr>}</block></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ObjectName</name></type> <name>objectName</name> <range>: <expr><name>objectNames</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>MBeanWrapper</name><operator>.</operator><name>instance</name><operator>.</operator><name>isRegistered</name></name><argument_list>(<argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>MBeanWrapper</name><operator>.</operator><name>instance</name><operator>.</operator><name>unregisterMBean</name></name><argument_list>(<argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// unregister metrics</comment>
        <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>


    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamilyStore</name></type> <name>createColumnFamilyStore</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>, <parameter><decl><type><name>TableMetadataRef</name></type> <name>metadata</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>createColumnFamilyStore</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>loadSSTables</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>ColumnFamilyStore</name></type> <name>createColumnFamilyStore</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>,
                                                                         <parameter><decl><type><name>String</name></type> <name>columnFamily</name></decl></parameter>,
                                                                         <parameter><decl><type><name>TableMetadataRef</name></type> <name>metadata</name></decl></parameter>,
                                                                         <parameter><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Directories</name></type> <name>directories</name> <init>= <expr><operator>new</operator> <call><name>Directories</name><argument_list>(<argument><expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>createColumnFamilyStore</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>directories</name></expr></argument>, <argument><expr><name>loadSSTables</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** This is only directly used by offline tools */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>ColumnFamilyStore</name></type> <name>createColumnFamilyStore</name><parameter_list>(<parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>,
                                                                         <parameter><decl><type><name>String</name></type> <name>columnFamily</name></decl></parameter>,
                                                                         <parameter><decl><type><name>TableMetadataRef</name></type> <name>metadata</name></decl></parameter>,
                                                                         <parameter><decl><type><name>Directories</name></type> <name>directories</name></decl></parameter>,
                                                                         <parameter><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></parameter>,
                                                                         <parameter><decl><type><name>boolean</name></type> <name>registerBookkeeping</name></decl></parameter>,
                                                                         <parameter><decl><type><name>boolean</name></type> <name>offline</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// get the max generation number, to prevent generation conflicts</comment>
        <decl_stmt><decl><type><name><name>Directories</name><operator>.</operator><name>SSTableLister</name></name></type> <name>lister</name> <init>= <expr><call><name><name>directories</name><operator>.</operator><name>sstableLister</name></name><argument_list>(<argument><expr><name><name>Directories</name><operator>.</operator><name>OnTxnErr</name><operator>.</operator><name>IGNORE</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>includeBackups</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>generations</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>lister</name><operator>.</operator><name>list</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>generations</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>generation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>desc</name><operator>.</operator><name>isCompatible</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Incompatible SSTable found. Current version %s is unable to read file: %s. Please run upgradesstables."</literal></expr></argument>,
                                                         <argument><expr><call><name><name>desc</name><operator>.</operator><name>getFormat</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLatestVersion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>generations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name><name>generations</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><call><name><name>generations</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>generations</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <return>return <expr><operator>new</operator> <call><name>ColumnFamilyStore</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>directories</name></expr></argument>, <argument><expr><name>loadSSTables</name></expr></argument>, <argument><expr><name>registerBookkeeping</name></expr></argument>, <argument><expr><name>offline</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Removes unnecessary files from the cf directory at startup: these include temp files, orphans, zero-length files
     * and compacted sstables. Files that cannot be recognized will be ignored.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type>  <name>scrubDataDirectories</name><parameter_list>(<parameter><decl><type><name>TableMetadata</name></type> <name>metadata</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>StartupException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Directories</name></type> <name>directories</name> <init>= <expr><operator>new</operator> <call><name>Directories</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>File</name></argument>&gt;</argument_list></name></type> <name>cleanedDirectories</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// clear ephemeral snapshots that were not properly cleared last session (CASSANDRA-7357)</comment>
        <expr_stmt><expr><call><name>clearEphemeralSnapshots</name><argument_list>(<argument><expr><name>directories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>directories</name><operator>.</operator><name>removeTemporaryDirectories</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Removing temporary or obsoleted files from unfinished operations for table {}"</literal></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>LifecycleTransaction</name><operator>.</operator><name>removeUnfinishedLeftovers</name></name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>StartupException</name><argument_list>(<argument><expr><name><name>StartupException</name><operator>.</operator><name>ERR_WRONG_DISK_STATE</name></name></expr></argument>,
                                       <argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Cannot remove temporary or obsoleted files for %s due to a problem with transaction "</literal> <operator>+</operator>
                                                     <literal type="string">"log files. Please check records with problems in the log messages above and fix them. "</literal> <operator>+</operator>
                                                     <literal type="string">"Refer to the 3.0 upgrading instructions in NEWS.txt "</literal> <operator>+</operator>
                                                     <literal type="string">"for a description of transaction log files."</literal></expr></argument>, <argument><expr><call><name><name>metadata</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Further extra check for orphan sstable files for {}"</literal></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>,<argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>sstableFiles</name> <range>: <expr><call><name><name>directories</name><operator>.</operator><name>sstableLister</name></name><argument_list>(<argument><expr><name><name>Directories</name><operator>.</operator><name>OnTxnErr</name><operator>.</operator><name>IGNORE</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>list</name><argument_list>()</argument_list></call><operator>.</operator><call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr><call><name><name>sstableFiles</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>File</name></type> <name>directory</name> <init>= <expr><name><name>desc</name><operator>.</operator><name>directory</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name> <init>= <expr><call><name><name>sstableFiles</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cleanedDirectories</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>cleanedDirectories</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>File</name></type> <name>tmpFile</name> <range>: <expr><call><name><name>desc</name><operator>.</operator><name>getTemporaryFiles</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Removing unfinished temporary file {}"</literal></expr></argument>, <argument><expr><name>tmpFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>tmpFile</name><operator>.</operator><name>delete</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>File</name></type> <name>dataFile</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>desc</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>components</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DATA</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>dataFile</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <comment type="line">// everything appears to be in order... moving on.</comment>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// missing the DATA file! all components are orphaned</comment>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Removing orphans for {}: {}"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>components</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>Component</name></type> <name>component</name> <range>: <expr><name>components</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>File</name></type> <name>file</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>desc</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>file</name><operator>.</operator><name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>deleteWithConfirm</name></name><argument_list>(<argument><expr><call><name><name>desc</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// cleanup incomplete saved caches</comment>
        <decl_stmt><decl><type><name>Pattern</name></type> <name>tmpCacheFilePattern</name> <init>= <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>keyspace</name></name> <operator>+</operator> <literal type="char">'-'</literal> <operator>+</operator> <name><name>metadata</name><operator>.</operator><name>name</name></name> <operator>+</operator> <literal type="string">"-(Key|Row)Cache.*\\.tmp$"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>File</name></type> <name>dir</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getSavedCachesLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>dir</name><operator>.</operator><name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <assert>assert <expr><call><name><name>dir</name><operator>.</operator><name>isDirectory</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <for>for <control>(<init><decl><type><name>File</name></type> <name>file</name> <range>: <expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><call><name><name>dir</name><operator>.</operator><name>listFiles</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>tmpCacheFilePattern</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><call><name><name>file</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>file</name><operator>.</operator><name>delete</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"could not delete {}"</literal></expr></argument>, <argument><expr><call><name><name>file</name><operator>.</operator><name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// also clean out any index leftovers.</comment>
        <for>for <control>(<init><decl><type><name>IndexMetadata</name></type> <name>index</name> <range>: <expr><name><name>metadata</name><operator>.</operator><name>indexes</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>index</name><operator>.</operator><name>isCustom</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TableMetadata</name></type> <name>indexMetadata</name> <init>= <expr><call><name><name>CassandraIndex</name><operator>.</operator><name>indexCfsMetadata</name></name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>scrubDataDirectories</name><argument_list>(<argument><expr><name>indexMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt></block_content></block></for>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * See #{@code StorageService.importNewSSTables} for more info
     *
     * @param ksName The keyspace name
     * @param cfName The columnFamily name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>loadNewSSTables</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>ksName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>cfName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="block">/* ks/cf existence checks will be done by open and getCFS methods for us */</comment>
        <decl_stmt><decl><type><name>Keyspace</name></type> <name>keyspace</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>keyspace</name><operator>.</operator><name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>loadNewSSTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>loadNewSSTables</name><parameter_list>()</parameter_list>
    <block>{<block_content>

        <decl_stmt><decl><type><name><name>SSTableImporter</name><operator>.</operator><name>Options</name></name></type> <name>options</name> <init>= <expr><call><name><name>SSTableImporter</name><operator>.</operator><name>Options</name><operator>.</operator><name>options</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>resetLevel</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sstableImporter</name><operator>.</operator><name>importNewSSTables</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * #{@inheritDoc}
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>importNewSSTables</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>srcPaths</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>resetLevel</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>clearRepaired</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>verifySSTables</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>verifyTokens</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>invalidateCaches</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>extendedVerify</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>copyData</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>SSTableImporter</name><operator>.</operator><name>Options</name></name></type> <name>options</name> <init>= <expr><call><name><name>SSTableImporter</name><operator>.</operator><name>Options</name><operator>.</operator><name>options</name></name><argument_list>(<argument><expr><name>srcPaths</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>resetLevel</name><argument_list>(<argument><expr><name>resetLevel</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>clearRepaired</name><argument_list>(<argument><expr><name>clearRepaired</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>verifySSTables</name><argument_list>(<argument><expr><name>verifySSTables</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>verifyTokens</name><argument_list>(<argument><expr><name>verifyTokens</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>invalidateCaches</name><argument_list>(<argument><expr><name>invalidateCaches</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>extendedVerify</name><argument_list>(<argument><expr><name>extendedVerify</name></expr></argument>)</argument_list></call>
                                                                 <operator>.</operator><call><name>copyData</name><argument_list>(<argument><expr><name>copyData</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name><name>sstableImporter</name><operator>.</operator><name>importNewSSTables</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>importNewSSTables</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>srcPaths</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>resetLevel</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>clearRepaired</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>verifySSTables</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>verifyTokens</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>invalidateCaches</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>extendedVerify</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>importNewSSTables</name><argument_list>(<argument><expr><name>srcPaths</name></expr></argument>, <argument><expr><name>resetLevel</name></expr></argument>, <argument><expr><name>clearRepaired</name></expr></argument>, <argument><expr><name>verifySSTables</name></expr></argument>, <argument><expr><name>verifyTokens</name></expr></argument>, <argument><expr><name>invalidateCaches</name></expr></argument>, <argument><expr><name>extendedVerify</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>Descriptor</name></type> <name>getUniqueDescriptorFor</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></parameter>, <parameter><decl><type><name>File</name></type> <name>targetDirectory</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Descriptor</name></type> <name>newDescriptor</name></decl>;</decl_stmt>
        <do>do
        <block>{<block_content>
            <expr_stmt><expr><name>newDescriptor</name> <operator>=</operator> <operator>new</operator> <call><name>Descriptor</name><argument_list>(<argument><expr><name><name>descriptor</name><operator>.</operator><name>version</name></name></expr></argument>,
                                           <argument><expr><name>targetDirectory</name></expr></argument>,
                                           <argument><expr><name><name>descriptor</name><operator>.</operator><name>ksname</name></name></expr></argument>,
                                           <argument><expr><name><name>descriptor</name><operator>.</operator><name>cfname</name></name></expr></argument>,
                                           <comment type="line">// Increment the generation until we find a filename that doesn't exist. This is needed because the new</comment>
                                           <comment type="line">// SSTables that are being loaded might already use these generation numbers.</comment>
                                           <argument><expr><call><name><name>fileIndexGenerator</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><name><name>descriptor</name><operator>.</operator><name>formatType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>newDescriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition>;</do>
        <return>return <expr><name>newDescriptor</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rebuildSecondaryIndex</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>idxName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>rebuildSecondaryIndex</name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>idxName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>rebuildSecondaryIndex</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>ksName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>cfName</name></decl></parameter>, <parameter><decl><type><name>String</name><modifier>...</modifier></type> <name>idxNames</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"User Requested secondary index re-build for {}/{} indexes: {}"</literal></expr></argument>, <argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>, <argument><expr><call><name><name>Joiner</name><operator>.</operator><name>on</name></name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>join</name><argument_list>(<argument><expr><name>idxNames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>rebuildIndexesBlocking</name></name><argument_list>(<argument><expr><call><name><name>Sets</name><operator>.</operator><name>newHashSet</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>idxNames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AbstractCompactionStrategy</name></type> <name>createCompactionStrategyInstance</name><parameter_list>(<parameter><decl><type><name>CompactionParams</name></type> <name>compactionParams</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Constructor</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>AbstractCompactionStrategy</name></extends></argument>&gt;</argument_list></name></type> <name>constructor</name> <init>=
                <expr><call><name><name>compactionParams</name><operator>.</operator><name>klass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getConstructor</name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><name><name>Map</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>constructor</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name><name>compactionParams</name><operator>.</operator><name>options</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>NoSuchMethodException</name></type> | <type><name>IllegalAccessException</name></type> | <type><name>InvocationTargetException</name></type> | <type><name>InstantiationException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>getColumnFamilyName</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getTableName</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getTableName</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>name</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Descriptor</name></type> <name>newSSTableDescriptor</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>directory</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>newSSTableDescriptor</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><call><name><name>SSTableFormat</name><operator>.</operator><name>Type</name><operator>.</operator><name>current</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>info</name><operator>.</operator><name>getLatestVersion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SSTableFormat</name><operator>.</operator><name>Type</name><operator>.</operator><name>current</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Descriptor</name></type> <name>newSSTableDescriptor</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>directory</name></decl></parameter>, <parameter><decl><type><name><name>SSTableFormat</name><operator>.</operator><name>Type</name></name></type> <name>format</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>newSSTableDescriptor</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><call><name><name>format</name><operator>.</operator><name>info</name><operator>.</operator><name>getLatestVersion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Descriptor</name></type> <name>newSSTableDescriptor</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>directory</name></decl></parameter>, <parameter><decl><type><name>Version</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name><name>SSTableFormat</name><operator>.</operator><name>Type</name></name></type> <name>format</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>Descriptor</name><argument_list>(<argument><expr><name>version</name></expr></argument>,
                              <argument><expr><name>directory</name></expr></argument>,
                              <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>,
                              <argument><expr><name>name</name></expr></argument>,
                              <argument><expr><call><name><name>fileIndexGenerator</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>,
                              <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Switches the memtable iff the live memtable is the one provided
     *
     * @param memtable
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>switchMemtableIfCurrent</name><parameter_list>(<parameter><decl><type><name>Memtable</name></type> <name>memtable</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <synchronized>synchronized <init>(<expr><name>data</name></expr>)</init>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call> <operator>==</operator> <name>memtable</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>switchMemtable</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></synchronized>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Memtable is no longer current, returning future that completes when current flushing operation completes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>waitForFlushes</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
     * switchMemtable puts Memtable.getSortedContents on the writer executor.  When the write is complete,
     * we turn the writer into an SSTableReader and add it to ssTables where it is available for reads.
     * This method does not block except for synchronizing on Tracker, but the Future it returns will
     * not complete until the Memtable (and all prior Memtables) have been successfully flushed, and the CL
     * marked clean up to the position owned by the Memtable.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>switchMemtable</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <synchronized>synchronized <init>(<expr><name>data</name></expr>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name>logFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Flush</name></type> <name>flush</name> <init>= <expr><operator>new</operator> <call><name>Flush</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>flushExecutor</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>postFlushExecutor</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name><name>flush</name><operator>.</operator><name>postFlushTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>flush</name><operator>.</operator><name>postFlushTask</name></name></expr>;</return>
        </block_content>}</block></synchronized>
    </block_content>}</block></function>

    <comment type="line">// print out size of all memtables we're enqueuing</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>logFlush</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// reclaiming includes that which we are GC-ing;</comment>
        <decl_stmt><decl><type><name>float</name></type> <name>onHeapRatio</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offHeapRatio</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>onHeapTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offHeapTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Memtable</name></type> <name>memtable</name> <init>= <expr><call><name>getTracker</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getView</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>onHeapRatio</name> <operator>+=</operator>  <call><name><name>memtable</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>onHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offHeapRatio</name> <operator>+=</operator> <call><name><name>memtable</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>offHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>onHeapTotal</name> <operator>+=</operator> <call><name><name>memtable</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>onHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>owns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offHeapTotal</name> <operator>+=</operator> <call><name><name>memtable</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>offHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>owns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>indexCfs</name> <range>: <expr><call><name><name>indexManager</name><operator>.</operator><name>getAllIndexColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemtableAllocator</name></type> <name>allocator</name> <init>= <expr><call><name><name>indexCfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getView</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAllocator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>onHeapRatio</name> <operator>+=</operator> <call><name><name>allocator</name><operator>.</operator><name>onHeap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offHeapRatio</name> <operator>+=</operator> <call><name><name>allocator</name><operator>.</operator><name>offHeap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>onHeapTotal</name> <operator>+=</operator> <call><name><name>allocator</name><operator>.</operator><name>onHeap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>owns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offHeapTotal</name> <operator>+=</operator> <call><name><name>allocator</name><operator>.</operator><name>offHeap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>owns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Enqueuing flush of {}: {}"</literal></expr></argument>,
                     <argument><expr><name>name</name></expr></argument>,
                     <argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"%s (%.0f%%) on-heap, %s (%.0f%%) off-heap"</literal></expr></argument>,
                                   <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>onHeapTotal</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>onHeapRatio</name> <operator>*</operator> <literal type="number">100</literal></expr></argument>,
                                   <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>offHeapTotal</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>offHeapRatio</name> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Flush if there is unflushed data in the memtables
     *
     * @return a Future yielding the commit log position that can be guaranteed to have been successfully written
     *         to sstables for this table once the future completes
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>forceFlush</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <synchronized>synchronized <init>(<expr><name>data</name></expr>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Memtable</name></type> <name>current</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cfs</name><operator>.</operator><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isClean</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><call><name>switchMemtableIfCurrent</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
            <return>return <expr><call><name>waitForFlushes</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></synchronized>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Flush if there is unflushed data that was written to the CommitLog before @param flushIfDirtyBefore
     * (inclusive).
     *
     * @return a Future yielding the commit log position that can be guaranteed to have been successfully written
     *         to sstables for this table once the future completes
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>forceFlush</name><parameter_list>(<parameter><decl><type><name>CommitLogPosition</name></type> <name>flushIfDirtyBefore</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// we don't loop through the remaining memtables since here we only care about commit log dirtiness</comment>
        <comment type="line">// and this does not vary between a table and its table-backed indexes</comment>
        <decl_stmt><decl><type><name>Memtable</name></type> <name>current</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>mayContainDataBefore</name></name><argument_list>(<argument><expr><name>flushIfDirtyBefore</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>switchMemtableIfCurrent</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><call><name>waitForFlushes</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return a Future yielding the commit log position that can be guaranteed to have been successfully written
     *         to sstables for this table once the future completes
     */</comment>
    <function><type><specifier>private</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>waitForFlushes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// we grab the current memtable; once any preceding memtables have flushed, we know its</comment>
        <comment type="line">// commitLogLowerBound has been set (as this it is set with the upper bound of the preceding memtable)</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Memtable</name></type> <name>current</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>ListenableFutureTask</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>task</name> <init>= <expr><call><name><name>ListenableFutureTask</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"forceFlush requested but everything is clean in {}"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>current</name><operator>.</operator><name>getCommitLogLowerBound</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>postFlushExecutor</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>task</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>CommitLogPosition</name></type> <name>forceBlockingFlush</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFuture</name></name><argument_list>(<argument><expr><call><name>forceFlush</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Both synchronises custom secondary indexes and provides ordering guarantees for futures on switchMemtable/flush
     * etc, which expect to be able to wait until the flush (and all prior flushes) requested have completed.
     */</comment>
    <class><specifier>private</specifier> <specifier>final</specifier> class <name>PostFlush</name> <super_list><implements>implements <super><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr><operator>new</operator> <call><name>CountDownLatch</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>Throwable</name></type> <name>flushFailure</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>PostFlush</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>memtables</name></name> <operator>=</operator> <name>memtables</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>CommitLogPosition</name></type> <name>call</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <try>try
            <block>{<block_content>
                <comment type="line">// we wait on the latch for the commitLogUpperBound to be set, and so that waiters</comment>
                <comment type="line">// on this task can rely on all prior flushes being complete</comment>
                <expr_stmt><expr><call><name><name>latch</name><operator>.</operator><name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>()</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>

            <decl_stmt><decl><type><name>CommitLogPosition</name></type> <name>commitLogUpperBound</name> <init>= <expr><name><name>CommitLogPosition</name><operator>.</operator><name>NONE</name></name></expr></init></decl>;</decl_stmt>
            <comment type="line">// If a flush errored out but the error was ignored, make sure we don't discard the commit log.</comment>
            <if_stmt><if>if <condition>(<expr><name>flushFailure</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>memtables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Memtable</name></type> <name>memtable</name> <init>= <expr><call><name><name>memtables</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>commitLogUpperBound</name> <operator>=</operator> <call><name><name>memtable</name><operator>.</operator><name>getCommitLogUpperBound</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>CommitLog</name><operator>.</operator><name>instance</name><operator>.</operator><name>discardCompletedSegments</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><call><name><name>memtable</name><operator>.</operator><name>getCommitLogLowerBound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>commitLogUpperBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>pendingFlushes</name><operator>.</operator><name>dec</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>flushFailure</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name><name>Throwables</name><operator>.</operator><name>propagate</name></name><argument_list>(<argument><expr><name>flushFailure</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <return>return <expr><name>commitLogUpperBound</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Should only be constructed/used from switchMemtable() or truncate(), with ownership of the Tracker monitor.
     * In the constructor the current memtable(s) are swapped, and a barrier on outstanding writes is issued;
     * when run by the flushWriter the barrier is waited on to ensure all outstanding writes have completed
     * before all memtables are immediately written, and the CL is either immediately marked clean or, if
     * there are custom secondary indexes, the post flush clean up is left to update those indexes and mark
     * the CL clean
     */</comment>
    <class><specifier>private</specifier> <specifier>final</specifier> class <name>Flush</name> <super_list><implements>implements <super><name>Runnable</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>OpOrder</name><operator>.</operator><name>Barrier</name></name></type> <name>writeBarrier</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>ListenableFutureTask</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>postFlushTask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>PostFlush</name></type> <name>postFlush</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>truncate</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Flush</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>truncate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Creating flush task {}@{}"</literal></expr></argument>, <argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="line">// if true, we won't flush, we'll just wait for any outstanding writes, switch the memtable, and discard</comment>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>truncate</name></name> <operator>=</operator> <name>truncate</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>pendingFlushes</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * To ensure correctness of switch without blocking writes, run() needs to wait for all write operations
             * started prior to the switch to complete. We do this by creating a Barrier on the writeOrdering
             * that all write operations register themselves with, and assigning this barrier to the memtables,
             * after which we *.issue()* the barrier. This barrier is used to direct write operations started prior
             * to the barrier.issue() into the memtable we have switched out, and any started after to its replacement.
             * In doing so it also tells the write operations to update the commitLogUpperBound of the memtable, so
             * that we know the CL position we are dirty to, which can be marked clean when we complete.
             */</comment>
            <expr_stmt><expr><name>writeBarrier</name> <operator>=</operator> <call><name><name>Keyspace</name><operator>.</operator><name>writeOrder</name><operator>.</operator><name>newBarrier</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// submit flushes for the memtable for any indexed sub-cfses, and our own</comment>
            <decl_stmt><decl><type><name><name>AtomicReference</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>commitLogUpperBound</name> <init>= <expr><operator>new</operator> <call><name><name>AtomicReference</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <comment type="line">// switch all memtables, regardless of their dirty status, setting the barrier</comment>
                <comment type="line">// so that we can reach a coordinated decision about cleanliness once they</comment>
                <comment type="line">// are no longer possible to be modified</comment>
                <decl_stmt><decl><type><name>Memtable</name></type> <name>newMemtable</name> <init>= <expr><operator>new</operator> <call><name>Memtable</name><argument_list>(<argument><expr><name>commitLogUpperBound</name></expr></argument>, <argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Memtable</name></type> <name>oldMemtable</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>data</name><operator>.</operator><name>switchMemtable</name></name><argument_list>(<argument><expr><name>truncate</name></expr></argument>, <argument><expr><name>newMemtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>oldMemtable</name><operator>.</operator><name>setDiscarding</name></name><argument_list>(<argument><expr><name>writeBarrier</name></expr></argument>, <argument><expr><name>commitLogUpperBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>memtables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>oldMemtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">// we then ensure an atomic decision is made about the upper bound of the continuous range of commit log</comment>
            <comment type="line">// records owned by this memtable</comment>
            <expr_stmt><expr><call><name>setCommitLogUpperBound</name><argument_list>(<argument><expr><name>commitLogUpperBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// we then issue the barrier; this lets us wait for all operations started prior to the barrier to complete;</comment>
            <comment type="line">// since this happens after wiring up the commitLogUpperBound, we also know all operations with earlier</comment>
            <comment type="line">// commit log segment position have also completed, i.e. the memtables are done and ready to flush</comment>
            <expr_stmt><expr><call><name><name>writeBarrier</name><operator>.</operator><name>issue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>postFlush</name> <operator>=</operator> <operator>new</operator> <call><name>PostFlush</name><argument_list>(<argument><expr><name>memtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>postFlushTask</name> <operator>=</operator> <call><name><name>ListenableFutureTask</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>postFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Flush task {}@{} starts executing, waiting on barrier"</literal></expr></argument>, <argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// mark writes older than the barrier as blocking progress, permitting them to exceed our memory limit</comment>
            <comment type="line">// if they are stuck waiting on it, then wait for them all to complete</comment>
            <expr_stmt><expr><call><name><name>writeBarrier</name><operator>.</operator><name>markBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>writeBarrier</name><operator>.</operator><name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Flush task for task {}@{} waited {} ms at the barrier"</literal></expr></argument>, <argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>TimeUnit</name><operator>.</operator><name>NANOSECONDS</name><operator>.</operator><name>toMillis</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// mark all memtables as flushing, removing them from the live memtable list</comment>
            <for>for <control>(<init><decl><type><name>Memtable</name></type> <name>memtable</name> <range>: <expr><name>memtables</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>memtable</name><operator>.</operator><name>cfs</name><operator>.</operator><name>data</name><operator>.</operator><name>markFlushing</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>memtableSwitchCount</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <try>try
            <block>{<block_content>
                <comment type="line">// Flush "data" memtable with non-cf 2i first;</comment>
                <expr_stmt><expr><call><name>flushMemtable</name><argument_list>(<argument><expr><call><name><name>memtables</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>memtables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>flushMemtable</name><argument_list>(<argument><expr><call><name><name>memtables</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>JVMStabilityInspector</name><operator>.</operator><name>inspectThrowable</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>postFlush</name><operator>.</operator><name>flushFailure</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
            </block_content>}</block></catch></try>

            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Flush task {}@{} signaling post flush task"</literal></expr></argument>, <argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// signal the post-flush we've done our work</comment>
            <expr_stmt><expr><call><name><name>postFlush</name><operator>.</operator><name>latch</name><operator>.</operator><name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Flush task task {}@{} finished"</literal></expr></argument>, <argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>flushMemtable</name><parameter_list>(<parameter><decl><type><name>Memtable</name></type> <name>memtable</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>flushNonCf2i</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Flush task task {}@{} flushing memtable {}"</literal></expr></argument>, <argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>memtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>memtable</name><operator>.</operator><name>isClean</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>truncate</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>memtable</name><operator>.</operator><name>cfs</name><operator>.</operator><name>replaceFlushed</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>reclaim</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>SSTableMultiWriter</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>totalBytesOnDisk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>maxBytesOnDisk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>minBytesOnDisk</name> <init>= <expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <init>(<decl><type><name>LifecycleTransaction</name></type> <name>txn</name> <init>= <expr><call><name><name>LifecycleTransaction</name><operator>.</operator><name>offline</name></name><argument_list>(<argument><expr><name><name>OperationType</name><operator>.</operator><name>FLUSH</name></name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Memtable</name><operator>.</operator><name>FlushRunnable</name></name></argument>&gt;</argument_list></name></type> <name>flushRunnables</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableMultiWriter</name></argument>&gt;</argument_list></name></type> <name>flushResults</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

                <try>try
                <block>{<block_content>
                    <comment type="line">// flush the memtable</comment>
                    <expr_stmt><expr><name>flushRunnables</name> <operator>=</operator> <call><name><name>memtable</name><operator>.</operator><name>flushRunnables</name></name><argument_list>(<argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name><name>ExecutorService</name><index>[]</index></name></type> <name>executors</name> <init>= <expr><call><name><name>perDiskflushExecutors</name><operator>.</operator><name>getExecutorsFor</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>flushRunnables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>executors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>submit</name><argument_list>(<argument><expr><call><name><name>flushRunnables</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                    <comment type="block" format="javadoc">/**
                     * we can flush 2is as soon as the barrier completes, as they will be consistent with (or ahead of) the
                     * flushed memtables and CL position, which is as good as we can guarantee.
                     * TODO: SecondaryIndex should support setBarrier(), so custom implementations can co-ordinate exactly
                     * with CL as we do with memtables/CFS-backed SecondaryIndexes.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>flushNonCf2i</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>indexManager</name><operator>.</operator><name>flushAllNonCFSBackedIndexesBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>flushResults</name> <operator>=</operator> <call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>memtable</name><operator>.</operator><name>abortRunnables</name></name><argument_list>(<argument><expr><name>flushRunnables</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>txn</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <throw>throw <expr><call><name><name>Throwables</name><operator>.</operator><name>propagate</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></catch></try>

                <try>try
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>SSTableMultiWriter</name></argument>&gt;</argument_list></name></type> <name>writerIterator</name> <init>= <expr><call><name><name>flushResults</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <while>while <condition>(<expr><call><name><name>writerIterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
                        <type><name>SSTableMultiWriter</name></type> <name>writer</name> <init>= <expr><call><name><name>writerIterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>writer</name><operator>.</operator><name>getFilePointer</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>setOpenResult</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>prepareToCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>maybeFail</name><argument_list>(<argument><expr><call><name><name>writer</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>writerIterator</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></while>
                </block_content>}</block>
                <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>SSTableMultiWriter</name></type> <name>writer</name> <range>: <expr><name>flushResults</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>writer</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>txn</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>Throwables</name><operator>.</operator><name>propagate</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></catch></try>

                <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>Throwable</name></type> <name>accumulate</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>SSTableMultiWriter</name></type> <name>writer</name> <range>: <expr><name>flushResults</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>writer</name><operator>.</operator><name>commit</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <expr_stmt><expr><call><name>maybeFail</name><argument_list>(<argument><expr><call><name><name>txn</name><operator>.</operator><name>commit</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><decl><type><name>SSTableMultiWriter</name></type> <name>writer</name> <range>: <expr><name>flushResults</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>flushedSSTables</name> <init>= <expr><call><name><name>writer</name><operator>.</operator><name>finished</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>flushedSSTables</name></expr></range></decl></init>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>sstable</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name><name>sstables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>bytesOnDisk</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>totalBytesOnDisk</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>maxBytesOnDisk</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>maxBytesOnDisk</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>minBytesOnDisk</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>minBytesOnDisk</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></try>
            <expr_stmt><expr><call><name><name>memtable</name><operator>.</operator><name>cfs</name><operator>.</operator><name>replaceFlushed</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>reclaim</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>memtable</name><operator>.</operator><name>cfs</name><operator>.</operator><name>compactionStrategyManager</name><operator>.</operator><name>compactionLogger</name><operator>.</operator><name>flush</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Flushed to {} ({} sstables, {}), biggest {}, smallest {}"</literal></expr></argument>,
                         <argument><expr><name>sstables</name></expr></argument>,
                         <argument><expr><call><name><name>sstables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>totalBytesOnDisk</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>maxBytesOnDisk</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>minBytesOnDisk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>sstables</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>reclaim</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>Memtable</name></type> <name>memtable</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <comment type="line">// issue a read barrier for reclaiming the memory, and offload the wait to another thread</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>OpOrder</name><operator>.</operator><name>Barrier</name></name></type> <name>readBarrier</name> <init>= <expr><call><name><name>readOrdering</name><operator>.</operator><name>newBarrier</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>readBarrier</name><operator>.</operator><name>issue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>postFlushTask</name><operator>.</operator><name>addListener</name></name><argument_list>(<argument><expr><operator>new</operator> <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>readBarrier</name><operator>.</operator><name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>memtable</name><operator>.</operator><name>setDiscarded</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></function>
            }</block></class></expr></argument>, <argument><expr><name>reclaimExecutor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <comment type="line">// atomically set the upper bound for the commit log</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>setCommitLogUpperBound</name><parameter_list>(<parameter><decl><type><name><name>AtomicReference</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>commitLogUpperBound</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// we attempt to set the holder to the current commit log context. at the same time all writes to the memtables are</comment>
        <comment type="line">// also maintaining this value, so if somebody sneaks ahead of us somehow (should be rare) we simply retry,</comment>
        <comment type="line">// so that we know all operations prior to the position have not reached it yet</comment>
        <decl_stmt><decl><type><name>CommitLogPosition</name></type> <name>lastReplayPosition</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lastReplayPosition</name> <operator>=</operator> <operator>new</operator> <call><name><name>Memtable</name><operator>.</operator><name>LastCommitLogPosition</name></name><argument_list>(<argument><expr><operator>(</operator><call><name><name>CommitLog</name><operator>.</operator><name>instance</name><operator>.</operator><name>getCurrentPosition</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CommitLogPosition</name></type> <name>currentLast</name> <init>= <expr><call><name><name>commitLogUpperBound</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>currentLast</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>currentLast</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>lastReplayPosition</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator>
                <operator>&amp;&amp;</operator> <call><name><name>commitLogUpperBound</name><operator>.</operator><name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentLast</name></expr></argument>, <argument><expr><name>lastReplayPosition</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Finds the largest memtable, as a percentage of *either* on- or off-heap memory limits, and immediately
     * queues it for flushing. If the memtable selected is flushed before this completes, no work is done.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>CompletableFuture</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>flushLargestMemtable</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>float</name></type> <name>largestRatio</name> <init>= <expr><literal type="number">0f</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Memtable</name></type> <name>largest</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name>liveOnHeap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>liveOffHeap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>ColumnFamilyStore</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// we take a reference to the current main memtable for the CF prior to snapping its ownership ratios</comment>
            <comment type="line">// to ensure we have some ordering guarantee for performing the switchMemtableIf(), i.e. we will only</comment>
            <comment type="line">// swap if the memtables we are measuring here haven't already been swapped by the time we try to swap them</comment>
            <decl_stmt><decl><type><name>Memtable</name></type> <name>current</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getView</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// find the total ownership ratio for the memtable and all SecondaryIndexes owned by this CF,</comment>
            <comment type="line">// both on- and off-heap, and select the largest of the two ratios to weight this CF</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>onHeap</name> <init>= <expr><literal type="number">0f</literal></expr></init></decl>, <decl><type ref="prev"/><name>offHeap</name> <init>= <expr><literal type="number">0f</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>onHeap</name> <operator>+=</operator> <call><name><name>current</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>onHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offHeap</name> <operator>+=</operator> <call><name><name>current</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>offHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>indexCfs</name> <range>: <expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>getAllIndexColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MemtableAllocator</name></type> <name>allocator</name> <init>= <expr><call><name><name>indexCfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getView</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentMemtable</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAllocator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>onHeap</name> <operator>+=</operator> <call><name><name>allocator</name><operator>.</operator><name>onHeap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offHeap</name> <operator>+=</operator> <call><name><name>allocator</name><operator>.</operator><name>offHeap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <decl_stmt><decl><type><name>float</name></type> <name>ratio</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>onHeap</name></expr></argument>, <argument><expr><name>offHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ratio</name> <operator>&gt;</operator> <name>largestRatio</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>largest</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>largestRatio</name> <operator>=</operator> <name>ratio</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>liveOnHeap</name> <operator>+=</operator> <name>onHeap</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>liveOffHeap</name> <operator>+=</operator> <name>offHeap</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name><name>CompletableFuture</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>returnFuture</name> <init>= <expr><operator>new</operator> <call><name><name>CompletableFuture</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>largest</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>float</name></type> <name>usedOnHeap</name> <init>= <expr><call><name><name>Memtable</name><operator>.</operator><name>MEMORY_POOL</name><operator>.</operator><name>onHeap</name><operator>.</operator><name>usedRatio</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>usedOffHeap</name> <init>= <expr><call><name><name>Memtable</name><operator>.</operator><name>MEMORY_POOL</name><operator>.</operator><name>offHeap</name><operator>.</operator><name>usedRatio</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>flushingOnHeap</name> <init>= <expr><call><name><name>Memtable</name><operator>.</operator><name>MEMORY_POOL</name><operator>.</operator><name>onHeap</name><operator>.</operator><name>reclaimingRatio</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>flushingOffHeap</name> <init>= <expr><call><name><name>Memtable</name><operator>.</operator><name>MEMORY_POOL</name><operator>.</operator><name>offHeap</name><operator>.</operator><name>reclaimingRatio</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>thisOnHeap</name> <init>= <expr><call><name><name>largest</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>onHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>thisOffHeap</name> <init>= <expr><call><name><name>largest</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>offHeap</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ownershipRatio</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Flushing largest {} to free up room. Used total: {}, live: {}, flushing: {}, this: {}"</literal></expr></argument>,
                         <argument><expr><name><name>largest</name><operator>.</operator><name>cfs</name></name></expr></argument>, <argument><expr><call><name>ratio</name><argument_list>(<argument><expr><name>usedOnHeap</name></expr></argument>, <argument><expr><name>usedOffHeap</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ratio</name><argument_list>(<argument><expr><name>liveOnHeap</name></expr></argument>, <argument><expr><name>liveOffHeap</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ratio</name><argument_list>(<argument><expr><name>flushingOnHeap</name></expr></argument>, <argument><expr><name>flushingOffHeap</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ratio</name><argument_list>(<argument><expr><name>thisOnHeap</name></expr></argument>, <argument><expr><name>thisOffHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>flushFuture</name> <init>= <expr><call><name><name>largest</name><operator>.</operator><name>cfs</name><operator>.</operator><name>switchMemtableIfCurrent</name></name><argument_list>(<argument><expr><name>largest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>flushFuture</name><operator>.</operator><name>addListener</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
                <try>try
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>flushFuture</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>returnFuture</name><operator>.</operator><name>complete</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>returnFuture</name><operator>.</operator><name>completeExceptionally</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></catch></try>
            </block_content>}</block></lambda></expr></argument>, <argument><expr><call><name><name>MoreExecutors</name><operator>.</operator><name>directExecutor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Flushing of largest memtable, not done, no memtable found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>returnFuture</name><operator>.</operator><name>complete</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <return>return <expr><name>returnFuture</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>ratio</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>onHeap</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>offHeap</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"%.2f/%.2f"</literal></expr></argument>, <argument><expr><name>onHeap</name></expr></argument>, <argument><expr><name>offHeap</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Insert/Update the column family for this key.
     * Caller is responsible for acquiring Keyspace.switchLock
     * param @ lock - lock that needs to be used.
     * param @ key - key for update/insert
     * param @ columnFamily - columnFamily changes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>PartitionUpdate</name></type> <name>update</name></decl></parameter>, <parameter><decl><type><name>UpdateTransaction</name></type> <name>indexer</name></decl></parameter>, <parameter><decl><type><name><name>OpOrder</name><operator>.</operator><name>Group</name></name></type> <name>opGroup</name></decl></parameter>, <parameter><decl><type><name>CommitLogPosition</name></type> <name>commitLogPosition</name></decl></parameter>)</parameter_list>

    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>Memtable</name></type> <name>mt</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getMemtableFor</name></name><argument_list>(<argument><expr><name>opGroup</name></expr></argument>, <argument><expr><name>commitLogPosition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>timeDelta</name> <init>= <expr><call><name><name>mt</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>update</name></expr></argument>, <argument><expr><name>indexer</name></expr></argument>, <argument><expr><name>opGroup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>key</name> <init>= <expr><call><name><name>update</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>invalidateCachedPartition</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>topWritePartitionFrequency</name><operator>.</operator><name>addSample</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>metric</name><operator>.</operator><name>topWritePartitionSize</name><operator>.</operator><name>isEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// dont compute datasize if not needed</comment>
                <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>topWritePartitionSize</name><operator>.</operator><name>addSample</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>update</name><operator>.</operator><name>dataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>StorageHook</name><operator>.</operator><name>instance</name><operator>.</operator><name>reportWrite</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>writeLatency</name><operator>.</operator><name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// CASSANDRA-11117 - certain resolution paths on memtable put can result in very</comment>
            <comment type="line">// large time deltas, either through a variety of sentinel timestamps (used for empty values, ensuring</comment>
            <comment type="line">// a minimal write, etc). This limits the time delta to the max value the histogram</comment>
            <comment type="line">// can bucket correctly. This also filters the Long.MAX_VALUE case where there was no previous value</comment>
            <comment type="line">// to update.</comment>
            <if_stmt><if>if<condition>(<expr><name>timeDelta</name> <operator>&lt;</operator> <name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>colUpdateTimeDeltaHistogram</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">18165375903306L</literal></expr></argument>, <argument><expr><name>timeDelta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>RuntimeException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call>
                                       <operator>+</operator> <literal type="string">" for ks: "</literal>
                                       <operator>+</operator> <call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">", table: "</literal> <operator>+</operator> <name>name</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param sstables
     * @return sstables whose key range overlaps with that of the given sstables, not including itself.
     * (The given sstables may or may not overlap with each other.)
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getOverlappingLiveSSTables</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Checking for sstables overlapping {}"</literal></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// a normal compaction won't ever have an empty sstables list, but we create a skeleton</comment>
        <comment type="line">// compaction controller for streaming, and that passes an empty list.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>sstables</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasNext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>of</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>View</name></type> <name>view</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sortedByFirst</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>sortedByFirst</name></expr></argument>, <argument><expr><lambda><parameter_list>(<parameter><decl><name>o1</name></decl></parameter>, <parameter><decl><name>o2</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>o1</name><operator>.</operator><name>first</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>o2</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>bounds</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>first</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>, <decl><type ref="prev"/><name>last</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
        normalize the intervals covered by the sstables
        assume we have sstables like this (brackets representing first/last key in the sstable);
        [   ] [   ]    [   ]   [  ]
           [   ]         [       ]
        then we can, instead of searching the interval tree 6 times, normalize the intervals and
        only query the tree 2 times, for these intervals;
        [         ]    [          ]
         */</comment>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sortedByFirst</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name><name>sstable</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>sstable</name><operator>.</operator><name>last</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <comment type="line">// we do overlap</comment>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>sstable</name><operator>.</operator><name>last</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>bounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>AbstractBounds</name><operator>.</operator><name>bounds</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>first</name> <operator>=</operator> <name><name>sstable</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>sstable</name><operator>.</operator><name>last</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>bounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>AbstractBounds</name><operator>.</operator><name>bounds</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>results</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>bound</name> <range>: <expr><name>bounds</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>Iterables</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><call><name><name>view</name><operator>.</operator><name>liveSSTablesInBounds</name></name><argument_list>(<argument><expr><name><name>bound</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>bound</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <return>return <expr><call><name><name>Sets</name><operator>.</operator><name>difference</name></name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><call><name><name>ImmutableSet</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * like getOverlappingSSTables, but acquires references before returning
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getAndReferenceOverlappingLiveSSTables</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>overlapped</name> <init>= <expr><call><name>getOverlappingLiveSSTables</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name> <init>= <expr><call><name><name>Refs</name><operator>.</operator><name>tryRef</name></name><argument_list>(<argument><expr><name>overlapped</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>refs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>refs</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block">/*
     * Called after a BinaryMemtable flushes its in-memory data, or we add a file
     * via bootstrap. This information is cached in the ColumnFamilyStore.
     * This is useful for reads because the ColumnFamilyStore first looks in
     * the in-memory store and the into the disk to find the key. If invoked
     * during recoveryMode the onMemtableFlush() need not be invoked.
     *
     * param @ filename - filename just flushed to disk
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSSTable</name><parameter_list>(<parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name><name>sstable</name><operator>.</operator><name>getColumnFamilyName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name>addSSTables</name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singletonList</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSSTables</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>addSSTables</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate expected file size of SSTable after compaction.
     *
     * If operation type is {@code CLEANUP} and we're not dealing with an index sstable,
     * then we calculate expected file size with checking token range to be eliminated.
     *
     * Otherwise, we just add up all the files' size, which is the worst case file
     * size for compaction of all the list of files given.
     *
     * @param sstables SSTables to calculate expected compacted file size
     * @param operation Operation type
     * @return Expected file size of SSTable after compaction
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getExpectedCompactedFileSize</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>, <parameter><decl><type><name>OperationType</name></type> <name>operation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name><name>OperationType</name><operator>.</operator><name>CLEANUP</name></name> <operator>||</operator> <call><name>isIndex</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name><name>SSTableReader</name><operator>.</operator><name>getTotalBytes</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// cleanup size estimation only counts bytes for keys local to this node</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>expectedFileSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getLocalReplicas</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>SSTableReader</name><operator>.</operator><name>PartitionPositionBounds</name></name></argument>&gt;</argument_list></name></type> <name>positions</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>getPositionsForRanges</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>SSTableReader</name><operator>.</operator><name>PartitionPositionBounds</name></name></type> <name>position</name> <range>: <expr><name>positions</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>expectedFileSize</name> <operator>+=</operator> <name><name>position</name><operator>.</operator><name>upperPosition</name></name> <operator>-</operator> <name><name>position</name><operator>.</operator><name>lowerPosition</name></name></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name>double</name></type> <name>compressionRatio</name> <init>= <expr><call><name><name>metric</name><operator>.</operator><name>compressionRatio</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>compressionRatio</name> <operator>&gt;</operator> <literal type="number">0d</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>expectedFileSize</name> <operator>*=</operator> <name>compressionRatio</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>expectedFileSize</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
     *  Find the maximum size file in the list .
     */</comment>
    <function><type><specifier>public</specifier> <name>SSTableReader</name></type> <name>getMaxSizeFile</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>maxSize</name> <init>= <expr><literal type="number">0L</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>maxFile</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>sstable</name><operator>.</operator><name>onDiskLength</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>maxSize</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>maxSize</name> <operator>=</operator> <call><name><name>sstable</name><operator>.</operator><name>onDiskLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>maxFile</name> <operator>=</operator> <name>sstable</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>maxFile</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>forceCleanup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>performCleanup</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>scrub</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>disableSnapshot</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipCorrupted</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>checkData</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>reinsertOverflowedTTL</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>scrub</name><argument_list>(<argument><expr><name>disableSnapshot</name></expr></argument>, <argument><expr><name>skipCorrupted</name></expr></argument>, <argument><expr><name>reinsertOverflowedTTL</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>checkData</name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>scrub</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>disableSnapshot</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipCorrupted</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>reinsertOverflowedTTL</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>alwaysFail</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>checkData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <comment type="line">// skip snapshot creation during scrub, SEE JIRA 5891</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>disableSnapshot</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snapshotWithoutFlush</name><argument_list>(<argument><expr><literal type="string">"pre-scrub-"</literal> <operator>+</operator> <call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>performScrub</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>skipCorrupted</name></expr></argument>, <argument><expr><name>checkData</name></expr></argument>, <argument><expr><name>reinsertOverflowedTTL</name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <catch>catch<parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rebuildOnFailedScrub</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><name>t</name></expr>;</throw></block_content></block></if></if_stmt>

            <return>return <expr><ternary><condition><expr><name>alwaysFail</name></expr> ?</condition><then> <expr><name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name><operator>.</operator><name>ABORTED</name></name></expr> </then><else>: <expr><name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name><operator>.</operator><name>SUCCESSFUL</name></name></expr></else></ternary></expr>;</return>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * CASSANDRA-5174 : For an index cfs we may be able to discard everything and just rebuild
     * the index when a scrub fails.
     *
     * @return true if we are an index cfs and we successfully rebuilt the index
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>rebuildOnFailedScrub</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>failure</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isIndex</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>SecondaryIndexManager</name><operator>.</operator><name>isIndexColumnFamilyStore</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>truncateBlocking</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Rebuilding index for {} because of &lt;{}&gt;"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>failure</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>parentCfs</name> <init>= <expr><call><name><name>SecondaryIndexManager</name><operator>.</operator><name>getParentCfs</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><call><name><name>parentCfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>getAllIndexColumnFamilyStores</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name>String</name></type> <name>indexName</name> <init>= <expr><call><name><name>SecondaryIndexManager</name><operator>.</operator><name>getIndexName</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>parentCfs</name><operator>.</operator><name>rebuildSecondaryIndex</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>verify</name><parameter_list>(<parameter><decl><type><name><name>Verifier</name><operator>.</operator><name>Options</name></name></type> <name>options</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>performVerify</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>sstablesRewrite</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>excludeCurrentVersion</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>performSSTableRewrite</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>excludeCurrentVersion</name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>relocateSSTables</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>relocateSSTables</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>CompactionManager</name><operator>.</operator><name>AllSSTableOpStatus</name></name></type> <name>garbageCollect</name><parameter_list>(<parameter><decl><type><name>TombstoneOption</name></type> <name>tombstoneOption</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>performGarbageCollection</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>tombstoneOption</name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>markObsolete</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>, <parameter><decl><type><name>OperationType</name></type> <name>compactionType</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><operator>!</operator><call><name><name>sstables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name>maybeFail</name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>dropSSTables</name></name><argument_list>(<argument><expr><call><name><name>Predicates</name><operator>.</operator><name>in</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>compactionType</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>replaceFlushed</name><parameter_list>(<parameter><decl><type><name>Memtable</name></type> <name>memtable</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>replaceFlushed</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sstables</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>sstables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isValid</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>valid</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Package protected for access from the CompactionManager.
     */</comment>
    <function><type><specifier>public</specifier> <name>Tracker</name></type> <name>getTracker</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>data</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getLiveSSTables</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>liveSSTables</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getSSTables</name><parameter_list>(<parameter><decl><type><name>SSTableSet</name></type> <name>sstableSet</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>select</name><argument_list>(<argument><expr><name>sstableSet</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getUncompactingSSTables</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getUncompacting</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>UUID</name></argument>, <argument><name>PendingStat</name></argument>&gt;</argument_list></name></type> <name>getPendingRepairStats</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>UUID</name></argument>, <argument><name><name>PendingStat</name><operator>.</operator><name>Builder</name></name></argument>&gt;</argument_list></name></type> <name>builders</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getLiveSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>UUID</name></type> <name>session</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>getPendingRepair</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>session</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>builders</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>builders</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>PendingStat</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>builders</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>addSSTable</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>UUID</name></argument>, <argument><name>PendingStat</name></argument>&gt;</argument_list></name></type> <name>stats</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>UUID</name></argument>, <argument><name><name>PendingStat</name><operator>.</operator><name>Builder</name></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>builders</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>stats</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>stats</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * promotes (or demotes) data attached to an incremental repair session that has either completed successfully,
     * or failed
     *
     * @return session ids whose data could not be released
     */</comment>
    <function><type><specifier>public</specifier> <name>CleanupSummary</name></type> <name>releaseRepairData</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>sessions</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>force</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>force</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>predicate</name> <init>= <expr><lambda><parameter_list type="pseudo"><parameter><decl><name>sst</name></decl></parameter></parameter_list> -&gt; <block>{<block_content>
                <decl_stmt><decl><type><name>UUID</name></type> <name>session</name> <init>= <expr><call><name><name>sst</name><operator>.</operator><name>getPendingRepair</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><name>session</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>sessions</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>runWithCompactionsDisabled</name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>releaseRepairData</name></name><argument_list>(<argument><expr><name>sessions</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>,
                                              <argument><expr><name>predicate</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>releaseRepairData</name></name><argument_list>(<argument><expr><name>sessions</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFilterFullyCoveredBy</name><parameter_list>(<parameter><decl><type><name>ClusteringIndexFilter</name></type> <name>filter</name></decl></parameter>,
                                          <parameter><decl><type><name>DataLimits</name></type> <name>limits</name></decl></parameter>,
                                          <parameter><decl><type><name>CachedPartition</name></type> <name>cached</name></decl></parameter>,
                                          <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>,
                                          <parameter><decl><type><name>boolean</name></type> <name>enforceStrictLiveness</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// We can use the cached value only if we know that no data it doesn't contain could be covered</comment>
        <comment type="line">// by the query filter, that is if:</comment>
        <comment type="line">//   1) either the whole partition is cached</comment>
        <comment type="line">//   2) or we can ensure than any data the filter selects is in the cached partition</comment>

        <comment type="line">// We can guarantee that a partition is fully cached if the number of rows it contains is less than</comment>
        <comment type="line">// what we're caching. Wen doing that, we should be careful about expiring cells: we should count</comment>
        <comment type="line">// something expired that wasn't when the partition was cached, or we could decide that the whole</comment>
        <comment type="line">// partition is cached when it's not. This is why we use CachedPartition#cachedLiveRows.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>cached</name><operator>.</operator><name>cachedLiveRows</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>caching</name><operator>.</operator><name>rowsPerPartitionToCache</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// If the whole partition isn't cached, then we must guarantee that the filter cannot select data that</comment>
        <comment type="line">// is not in the cache. We can guarantee that if either the filter is a "head filter" and the cached</comment>
        <comment type="line">// partition has more live rows that queried (where live rows refers to the rows that are live now),</comment>
        <comment type="line">// or if we can prove that everything the filter selects is in the cached partition based on its content.</comment>
        <return>return <expr><operator>(</operator><call><name><name>filter</name><operator>.</operator><name>isHeadFilter</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>limits</name><operator>.</operator><name>hasEnoughLiveData</name></name><argument_list>(<argument><expr><name>cached</name></expr></argument>,
                                                                  <argument><expr><name>nowInSec</name></expr></argument>,
                                                                  <argument><expr><call><name><name>filter</name><operator>.</operator><name>selectsAllPartition</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                  <argument><expr><name>enforceStrictLiveness</name></expr></argument>)</argument_list></call><operator>)</operator>
               <operator>||</operator> <call><name><name>filter</name><operator>.</operator><name>isFullyCoveredBy</name></name><argument_list>(<argument><expr><name>cached</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>gcBefore</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>nowInSec</name> <operator>-</operator> <call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>gcGraceSeconds</name></name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>public</specifier> <name>RefViewFragment</name></type> <name>selectAndReference</name><parameter_list>(<parameter><decl><type><name><name>Function</name><argument_list type="generic">&lt;<argument><name>View</name></argument>, <argument><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>filter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>failingSince</name> <init>= <expr><operator>-</operator><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ViewFragment</name></type> <name>view</name> <init>= <expr><call><name>select</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name> <init>= <expr><call><name><name>Refs</name><operator>.</operator><name>tryRef</name></name><argument_list>(<argument><expr><name><name>view</name><operator>.</operator><name>sstables</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>refs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>new</operator> <call><name>RefViewFragment</name><argument_list>(<argument><expr><name><name>view</name><operator>.</operator><name>sstables</name></name></expr></argument>, <argument><expr><name><name>view</name><operator>.</operator><name>memtables</name></name></expr></argument>, <argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>failingSince</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>failingSince</name> <operator>=</operator> <call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>failingSince</name> <operator>&gt;</operator> <call><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name><operator>.</operator><name>toNanos</name></name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>released</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>reader</name> <range>: <expr><name><name>view</name><operator>.</operator><name>sstables</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>reader</name><operator>.</operator><name>selfRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>globalCount</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>released</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
                <expr_stmt><expr><call><name><name>NoSpamLogger</name><operator>.</operator><name>log</name></name><argument_list>(<argument><expr><name>logger</name></expr></argument>, <argument><expr><name><name>NoSpamLogger</name><operator>.</operator><name>Level</name><operator>.</operator><name>WARN</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>,
                                 <argument><expr><literal type="string">"Spinning trying to capture readers {}, released: {}, "</literal></expr></argument>, <argument><expr><name><name>view</name><operator>.</operator><name>sstables</name></name></expr></argument>, <argument><expr><name>released</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>failingSince</name> <operator>=</operator> <call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>ViewFragment</name></type> <name>select</name><parameter_list>(<parameter><decl><type><name><name>Function</name><argument_list type="generic">&lt;<argument><name>View</name></argument>, <argument><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>filter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>View</name></type> <name>view</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><call><name><name>filter</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name>ViewFragment</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><call><name><name>view</name><operator>.</operator><name>getAllMemtables</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="line">// WARNING: this returns the set of LIVE sstables only, which may be only partially written</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getSSTablesForKey</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getSSTablesForKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getSSTablesForKey</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>hexFormat</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>keyBuffer</name> <init>= <expr><ternary><condition><expr><name>hexFormat</name></expr> ?</condition><then> <expr><call><name><name>ByteBufferUtil</name><operator>.</operator><name>hexToBytes</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>partitionKeyType</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>dk</name> <init>= <expr><call><name>decorateKey</name><argument_list>(<argument><expr><name>keyBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name><name>OpOrder</name><operator>.</operator><name>Group</name></name></type> <name>op</name> <init>= <expr><call><name><name>readOrdering</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>files</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstr</name> <range>: <expr><call><name>select</name><argument_list>(<argument><expr><call><name><name>View</name><operator>.</operator><name>select</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>LIVE</name></name></expr></argument>, <argument><expr><name>dk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name>sstables</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <comment type="line">// check if the key actually exists in this sstable, without updating cache and stats</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>sstr</name><operator>.</operator><name>getPosition</name></name><argument_list>(<argument><expr><name>dk</name></expr></argument>, <argument><expr><name><name>SSTableReader</name><operator>.</operator><name>Operator</name><operator>.</operator><name>EQ</name></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>files</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>sstr</name><operator>.</operator><name>getFilename</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <return>return <expr><name>files</name></expr>;</return>
        </block_content>}</block></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>beginLocalSampling</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>sampler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>capacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>durationMillis</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>metric</name><operator>.</operator><name>samplers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>SamplerType</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>sampler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>beginSampling</name><argument_list>(<argument><expr><name>capacity</name></expr></argument>, <argument><expr><name>durationMillis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><block>{ <expr><literal type="string">"rawtypes"</literal></expr>, <argument><expr><literal type="string">"unchecked"</literal></expr></argument> }</block></expr></argument>)</argument_list></annotation>
    <type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>CompositeData</name></argument>&gt;</argument_list></name></type> <name>finishLocalSampling</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>sampler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>OpenDataException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Sampler</name></type> <name>samplerImpl</name> <init>= <expr><call><name><name>metric</name><operator>.</operator><name>samplers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>SamplerType</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>sampler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Sample</name></argument>&gt;</argument_list></name></type> <name>samplerResults</name> <init>= <expr><call><name><name>samplerImpl</name><operator>.</operator><name>finishSampling</name></name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>CompositeData</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Sample</name></type> <name>counter</name> <range>: <expr><name>samplerResults</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">//Not duplicating the buffer for safety because AbstractSerializer and ByteBufferUtil.bytesToHex</comment>
            <comment type="line">//don't modify position or limit</comment>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>CompositeDataSupport</name><argument_list>(<argument><expr><name>COUNTER_COMPOSITE_TYPE</name></expr></argument>, <argument><expr><name>COUNTER_NAMES</name></expr></argument>, <argument><expr><operator>new</operator> <name><name>Object</name><index>[]</index></name> <block>{
                    <expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">"."</literal> <operator>+</operator> <name>name</name></expr>,
                    <expr><name><name>counter</name><operator>.</operator><name>count</name></name></expr>,
                    <expr><name><name>counter</name><operator>.</operator><name>error</name></name></expr>,
                    <expr><call><name><name>samplerImpl</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name><name>counter</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr> }</block></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// string</comment>
        </block_content>}</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isCompactionDiskSpaceCheckEnabled</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>compactionSpaceCheck</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>compactionDiskSpaceCheck</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>enable</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>compactionSpaceCheck</name> <operator>=</operator> <name>enable</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>cleanupCache</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getLocalReplicas</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>RowCacheKey</name></argument>&gt;</argument_list></name></type> <name>keyIter</name> <init>= <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>keyIterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
             <condition><expr><call><name><name>keyIter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RowCacheKey</name></type> <name>key</name> <init>= <expr><call><name><name>keyIter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>dk</name> <init>= <expr><call><name>decorateKey</name><argument_list>(<argument><expr><call><name><name>ByteBuffer</name><operator>.</operator><name>wrap</name></name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>sameTable</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Range</name><operator>.</operator><name>isInRanges</name></name><argument_list>(<argument><expr><call><name><name>dk</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>invalidateCachedPartition</name><argument_list>(<argument><expr><name>dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isCounter</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>CounterCacheKey</name></argument>&gt;</argument_list></name></type> <name>keyIter</name> <init>= <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>keyIterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
                 <condition><expr><call><name><name>keyIter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CounterCacheKey</name></type> <name>key</name> <init>= <expr><call><name><name>keyIter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>dk</name> <init>= <expr><call><name>decorateKey</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>sameTable</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Range</name><operator>.</operator><name>isInRanges</name></name><argument_list>(<argument><expr><call><name><name>dk</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>ClusteringComparator</name></type> <name>getComparator</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name>comparator</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>snapshotWithoutFlush</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snapshotWithoutFlush</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param ephemeral If this flag is set to true, the snapshot will be cleaned during next startup
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>snapshotWithoutFlush</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>predicate</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>ephemeral</name></decl></parameter>, <parameter><decl><type><name>RateLimiter</name></type> <name>rateLimiter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>rateLimiter</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rateLimiter</name> <operator>=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getSnapshotRateLimiter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>snapshottedSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>JSONArray</name></type> <name>filesJSONArr</name> <init>= <expr><operator>new</operator> <call><name>JSONArray</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <try>try <init>(<decl><type><name>RefViewFragment</name></type> <name>currentView</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>selectAndReference</name></name><argument_list>(<argument><expr><call><name><name>View</name><operator>.</operator><name>select</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>, <argument><expr><lambda><parameter_list>(<parameter><decl><name>x</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name>predicate</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>predicate</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{
                <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>ssTable</name> <range>: <expr><name><name>currentView</name><operator>.</operator><name>sstables</name></name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>File</name></type> <name>snapshotDirectory</name> <init>= <expr><call><name><name>Directories</name><operator>.</operator><name>getSnapshotDirectory</name></name><argument_list>(<argument><expr><name><name>ssTable</name><operator>.</operator><name>descriptor</name></name></expr></argument>, <argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>ssTable</name><operator>.</operator><name>createLinks</name></name><argument_list>(<argument><expr><call><name><name>snapshotDirectory</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rateLimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// hard links</comment>
                    <expr_stmt><expr><call><name><name>filesJSONArr</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>ssTable</name><operator>.</operator><name>descriptor</name><operator>.</operator><name>relativeFilenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Snapshot for {} keyspace data file {} created in {}"</literal></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><call><name><name>ssTable</name><operator>.</operator><name>getFilename</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>snapshotDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>snapshottedSSTables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>ssTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt/></block_content></block></for>}</block></try>
            </block_content>}</block></for>
        </block_content>}</block></function>

        <constructor_decl><name>writeSnapshotManifest</name><parameter_list>(<parameter><decl><type><name>filesJSONArr</name></type></decl></parameter>, <parameter><decl><type><name>snapshotName</name></type></decl></parameter>)</parameter_list>;</constructor_decl>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SchemaConstants</name><operator>.</operator><name>isLocalSystemKeyspace</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>keyspace</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>SchemaConstants</name><operator>.</operator><name>isReplicatedSystemKeyspace</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>keyspace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>writeSnapshotSchema</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ephemeral</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>createEphemeralSnapshotMarkerFile</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>snapshottedSSTables</name></expr>;</return>
    }</block></class>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeSnapshotManifest</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>JSONArray</name></type> <name>filesJSONArr</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>File</name></type> <name>manifestFile</name> <init>= <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSnapshotManifestFile</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>manifestFile</name><operator>.</operator><name>getParentFile</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>manifestFile</name><operator>.</operator><name>getParentFile</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mkdirs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <try>try <init>(<decl><type><name>PrintStream</name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name>PrintStream</name><argument_list>(<argument><expr><name>manifestFile</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>final</specifier> <name>JSONObject</name></type> <name>manifestJSON</name> <init>= <expr><operator>new</operator> <call><name>JSONObject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>manifestJSON</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"files"</literal></expr></argument>, <argument><expr><name>filesJSONArr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><call><name><name>manifestJSON</name><operator>.</operator><name>toJSONString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></try>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>FSWriteError</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>manifestFile</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeSnapshotSchema</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>File</name></type> <name>schemaFile</name> <init>= <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSnapshotSchemaFile</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>schemaFile</name><operator>.</operator><name>getParentFile</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>schemaFile</name><operator>.</operator><name>getParentFile</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mkdirs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <try>try <init>(<decl><type><name>PrintStream</name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name>PrintStream</name><argument_list>(<argument><expr><name>schemaFile</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>SchemaCQLHelper</name><operator>.</operator><name>reCreateStatementsForSchemaCql</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>,
                                                               <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>types</name></expr></argument>)</argument_list></call>
                               <operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>out</name><operator>::</operator><name>println</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></try>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>FSWriteError</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>schemaFile</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>createEphemeralSnapshotMarkerFile</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>File</name></type> <name>ephemeralSnapshotMarker</name> <init>= <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNewEphemeralSnapshotMarkerFile</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ephemeralSnapshotMarker</name><operator>.</operator><name>getParentFile</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>ephemeralSnapshotMarker</name><operator>.</operator><name>getParentFile</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mkdirs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>Files</name><operator>.</operator><name>createFile</name></name><argument_list>(<argument><expr><call><name><name>ephemeralSnapshotMarker</name><operator>.</operator><name>toPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Created ephemeral snapshot marker file on {}."</literal></expr></argument>, <argument><expr><call><name><name>ephemeralSnapshotMarker</name><operator>.</operator><name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Could not create marker file %s for ephemeral snapshot %s. "</literal> <operator>+</operator>
                                      <literal type="string">"In case there is a failure in the operation that created "</literal> <operator>+</operator>
                                      <literal type="string">"this snapshot, you may need to clean it manually afterwards."</literal></expr></argument>,
                                      <argument><expr><call><name><name>ephemeralSnapshotMarker</name><operator>.</operator><name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>void</name></type> <name>clearEphemeralSnapshots</name><parameter_list>(<parameter><decl><type><name>Directories</name></type> <name>directories</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RateLimiter</name></type> <name>clearSnapshotRateLimiter</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getSnapshotRateLimiter</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>String</name></type> <name>ephemeralSnapshot</name> <range>: <expr><call><name><name>directories</name><operator>.</operator><name>listEphemeralSnapshots</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Clearing ephemeral snapshot {} leftover from previous session."</literal></expr></argument>, <argument><expr><name>ephemeralSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Directories</name><operator>.</operator><name>clearSnapshot</name></name><argument_list>(<argument><expr><name>ephemeralSnapshot</name></expr></argument>, <argument><expr><call><name><name>directories</name><operator>.</operator><name>getCFDirectories</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>clearSnapshotRateLimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getSnapshotSSTableReaders</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>tag</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>active</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>active</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>sstable</name><operator>.</operator><name>descriptor</name><operator>.</operator><name>generation</name></name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>snapshots</name> <init>= <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>sstableLister</name><argument_list>(<argument><expr><name><name>Directories</name><operator>.</operator><name>OnTxnErr</name><operator>.</operator><name>IGNORE</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>snapshots</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>list</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name> <init>= <expr><operator>new</operator> <call><name><name>Refs</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entries</name> <range>: <expr><call><name><name>snapshots</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <comment type="line">// Try acquire reference to an active sstable instead of snapshot if it exists,</comment>
                <comment type="line">// to avoid opening new sstables. If it fails, use the snapshot reference instead.</comment>
                <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>active</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>entries</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><name>generation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>sstable</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>refs</name><operator>.</operator><name>tryRef</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"using snapshot sstable {}"</literal></expr></argument>, <argument><expr><call><name><name>entries</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="line">// open offline so we don't modify components or track hotness.</comment>
                    <expr_stmt><expr><name>sstable</name> <operator>=</operator> <call><name><name>SSTableReader</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><call><name><name>entries</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entries</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>refs</name><operator>.</operator><name>tryRef</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// release the self ref as we never add the snapshot sstable to DataTracker where it is otherwise released</comment>
                    <expr_stmt><expr><call><name><name>sstable</name><operator>.</operator><name>selfRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"using active sstable {}"</literal></expr></argument>, <argument><expr><call><name><name>entries</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>FSReadError</name></type> | <type><name>RuntimeException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <comment type="line">// In case one of the snapshot sstables fails to open,</comment>
            <comment type="line">// we must release the references to the ones we opened so far</comment>
            <expr_stmt><expr><call><name><name>refs</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        </block_content>}</block></catch></try>
        <return>return <expr><name>refs</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Take a snap shot of this columnfamily store.
     *
     * @param snapshotName the name of the associated with the snapshot
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>snapshot</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Take a snap shot of this columnfamily store.
     *
     * @param snapshotName the name of the associated with the snapshot
     * @param skipFlush Skip blocking flush of memtable
     * @param rateLimiter Rate limiter for hardlinks-per-second
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>snapshot</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipFlush</name></decl></parameter>, <parameter><decl><type><name>RateLimiter</name></type> <name>rateLimiter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>skipFlush</name></expr></argument>, <argument><expr><name>rateLimiter</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * @param ephemeral If this flag is set to true, the snapshot will be cleaned up during next startup
     * @param skipFlush Skip blocking flush of memtable
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>snapshot</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>predicate</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>ephemeral</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipFlush</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>ephemeral</name></expr></argument>, <argument><expr><name>skipFlush</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param ephemeral If this flag is set to true, the snapshot will be cleaned up during next startup
     * @param skipFlush Skip blocking flush of memtable
     * @param rateLimiter Rate limiter for hardlinks-per-second
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>snapshot</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>predicate</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>ephemeral</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipFlush</name></decl></parameter>, <parameter><decl><type><name>RateLimiter</name></type> <name>rateLimiter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFlush</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>forceBlockingFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>snapshotWithoutFlush</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>ephemeral</name></expr></argument>, <argument><expr><name>rateLimiter</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>snapshotExists</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>snapshotExists</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getSnapshotCreationTime</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>snapshotCreationTime</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Clear all the snapshots for a given column family.
     *
     * @param snapshotName the user supplied snapshot name. If left empty,
     *                     all the snapshots will be cleaned.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>clearSnapshot</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>snapshotName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RateLimiter</name></type> <name>clearSnapshotRateLimiter</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getSnapshotRateLimiter</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>File</name></argument>&gt;</argument_list></name></type> <name>snapshotDirs</name> <init>= <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCFDirectories</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Directories</name><operator>.</operator><name>clearSnapshot</name></name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><name>snapshotDirs</name></expr></argument>, <argument><expr><name>clearSnapshotRateLimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <comment type="block" format="javadoc">/**
     *
     * @return  Return a map of all snapshots to space being used
     * The pair for a snapshot has true size and size on disk.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>Directories</name><operator>.</operator><name>SnapshotSizeDetails</name></name></argument>&gt;</argument_list></name></type> <name>getSnapshotDetails</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSnapshotDetails</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return the cached partition for @param key if it is already present in the cache.
     * Not that this will not readAndCache the parition if it is not present, nor
     * are these calls counted in cache statistics.
     *
     * Note that this WILL cause deserialization of a SerializingCache partition, so if all you
     * need to know is whether a partition is present or not, use containsCachedParition instead.
     */</comment>
    <function><type><specifier>public</specifier> <name>CachedPartition</name></type> <name>getRawCachedPartition</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isRowCacheEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>IRowCacheEntry</name></type> <name>cached</name> <init>= <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>getInternal</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>RowCacheKey</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>cached</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>cached</name> <operator>instanceof</operator> <name>RowCacheSentinel</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>(</operator><name>CachedPartition</name><operator>)</operator><name>cached</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>invalidateCaches</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>invalidateKeyCacheForCf</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>invalidateRowCacheForCf</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isCounter</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>invalidateCounterCacheForCf</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>invalidateRowCache</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Bounds</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>boundsToInvalidate</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>invalidatedKeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>RowCacheKey</name></argument>&gt;</argument_list></name></type> <name>keyIter</name> <init>= <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>keyIterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
             <condition><expr><call><name><name>keyIter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RowCacheKey</name></type> <name>key</name> <init>= <expr><call><name><name>keyIter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>dk</name> <init>= <expr><call><name>decorateKey</name><argument_list>(<argument><expr><call><name><name>ByteBuffer</name><operator>.</operator><name>wrap</name></name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>sameTable</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Bounds</name><operator>.</operator><name>isInBounds</name></name><argument_list>(<argument><expr><call><name><name>dk</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>boundsToInvalidate</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>invalidateCachedPartition</name><argument_list>(<argument><expr><name>dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>invalidatedKeys</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>invalidatedKeys</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>invalidateCounterCache</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Bounds</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>boundsToInvalidate</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>invalidatedKeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>CounterCacheKey</name></argument>&gt;</argument_list></name></type> <name>keyIter</name> <init>= <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>keyIterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
             <condition><expr><call><name><name>keyIter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CounterCacheKey</name></type> <name>key</name> <init>= <expr><call><name><name>keyIter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>dk</name> <init>= <expr><call><name>decorateKey</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>sameTable</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Bounds</name><operator>.</operator><name>isInBounds</name></name><argument_list>(<argument><expr><call><name><name>dk</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>boundsToInvalidate</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>invalidatedKeys</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>invalidatedKeys</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return true if @param key is contained in the row cache
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>containsCachedParition</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>getCapacity</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>RowCacheKey</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidateCachedPartition</name><parameter_list>(<parameter><decl><type><name>RowCacheKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidateCachedPartition</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isRowCacheEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>invalidateCachedPartition</name><argument_list>(<argument><expr><operator>new</operator> <call><name>RowCacheKey</name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>ClockAndCount</name></type> <name>getCachedCounter</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>partitionKey</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name>ColumnMetadata</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name>CellPath</name></type> <name>path</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>getCapacity</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// counter cache disabled.</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>CounterCacheKey</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>partitionKey</name></expr></argument>, <argument><expr><name>clustering</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>putCachedCounter</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>partitionKey</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name>ColumnMetadata</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name>CellPath</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>ClockAndCount</name></type> <name>clockAndCount</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>getCapacity</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// counter cache disabled.</comment>
            <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>CounterCacheKey</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>partitionKey</name></expr></argument>, <argument><expr><name>clustering</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>clockAndCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceMajorCompaction</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>forceMajorCompaction</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceMajorCompaction</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>splitOutput</name></decl></parameter>)</parameter_list>
   <block>{<block_content>
        <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>performMaximal</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>splitOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceCompactionForTokenRange</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>tokenRanges</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>forceCompactionForTokenRange</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>tokenRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>all</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>stores</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getKeyspaces</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Keyspace</name></type> <name>keyspace</name> <range>: <expr><call><name><name>Keyspace</name><operator>.</operator><name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>stores</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>Iterables</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name>stores</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keySamples</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try <init>(<decl><type><name>RefViewFragment</name></type> <name>view</name> <init>= <expr><call><name>selectAndReference</name><argument_list>(<argument><expr><call><name><name>View</name><operator>.</operator><name>selectFunction</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>samples</name> <init>= <expr><operator>new</operator> <name><name>Iterable</name><index>[<expr><call><name><name>view</name><operator>.</operator><name>sstables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name><range>: <expr><name><name>view</name><operator>.</operator><name>sstables</name></name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>samples</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name><name>sstable</name><operator>.</operator><name>getKeySamples</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <return>return <expr><call><name><name>Iterables</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name>samples</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>estimatedKeysForRange</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try <init>(<decl><type><name>RefViewFragment</name></type> <name>view</name> <init>= <expr><call><name>selectAndReference</name><argument_list>(<argument><expr><call><name><name>View</name><operator>.</operator><name>selectFunction</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name><name>view</name><operator>.</operator><name>sstables</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>estimatedKeysForRanges</name></name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <return>return <expr><name>count</name></expr>;</return>
        </block_content>}</block></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * For testing.  No effort is made to clear historical or even the current memtables, nor for
     * thread safety.  All we do is wipe the sstable containers clean, while leaving the actual
     * data files present on disk.  (This allows tests to easily call loadNewSSTables on them.)
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>clearUnsafe</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>runWithCompactionsDisabled</name></name><argument_list>(<argument><expr><operator>(</operator><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>Void</name></argument>&gt;</argument_list></name><operator>)</operator> <lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>data</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Memtable</name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>AtomicReference</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>CommitLogPosition</name><operator>.</operator><name>NONE</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></lambda></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>truncateBlocking</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>truncateBlocking</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>truncateBlockingWithoutSnapshot</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>truncateBlocking</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Truncate deletes the entire column family's data with no expensive tombstone creation
     * @param noSnapshot if {@code true} no snapshot will be taken
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>truncateBlocking</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>noSnapshot</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// We have two goals here:</comment>
        <comment type="line">// - truncate should delete everything written before truncate was invoked</comment>
        <comment type="line">// - but not delete anything that isn't part of the snapshot we create.</comment>
        <comment type="line">// We accomplish this by first flushing manually, then snapshotting, and</comment>
        <comment type="line">// recording the timestamp IN BETWEEN those actions. Any sstables created</comment>
        <comment type="line">// with this timestamp or greater time, will not be marked for delete.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Bonus complication: since we store commit log segment position in sstable metadata,</comment>
        <comment type="line">// truncating those sstables means we will replay any CL segments from the</comment>
        <comment type="line">// beginning if we restart before they [the CL segments] are discarded for</comment>
        <comment type="line">// normal reasons post-truncate.  To prevent this, we store truncation</comment>
        <comment type="line">// position in the System keyspace.</comment>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Truncating {}.{}"</literal></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>viewManager</name><operator>.</operator><name>stopBuild</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>truncatedAt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>CommitLogPosition</name></type> <name>replayAfter</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noSnapshot</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>keyspace</name><operator>.</operator><name>getMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>durableWrites</name></name> <operator>||</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>isAutoSnapshot</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>replayAfter</name> <operator>=</operator> <call><name>forceBlockingFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>viewManager</name><operator>.</operator><name>forceBlockingFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// just nuke the memtable data w/o writing to disk first</comment>
            <expr_stmt><expr><call><name><name>viewManager</name><operator>.</operator><name>dumpMemtables</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><name>replayAfter</name> <operator>=</operator> <call><name>dumpMemtable</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></else></if_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>now</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// make sure none of our sstables are somehow in the future (clock drift, perhaps)</comment>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name><name>cfs</name><operator>.</operator><name>getLiveSSTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>sstable</name><operator>.</operator><name>maxDataAge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
        <expr_stmt><expr><name>truncatedAt</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Runnable</name></type> <name>truncateRunnable</name> <init>= <expr><operator>new</operator> <class><super><name>Runnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Truncating {}.{} with truncatedAt={}"</literal></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTableName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// since truncation can happen at different times on different nodes, we need to make sure</comment>
                <comment type="line">// that any repairs are aborted, otherwise we might clear the data on one node and then</comment>
                <comment type="line">// stream in data that is actually supposed to have been deleted</comment>
                <expr_stmt><expr><call><name><name>ActiveRepairService</name><operator>.</operator><name>instance</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>prs</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>prs</name><operator>.</operator><name>getTableIds</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>,
                                                   <argument><expr><literal type="string">"Stopping parent sessions {} due to truncation of tableId="</literal><operator>+</operator><name><name>metadata</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>notifyTruncated</name></name><argument_list>(<argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noSnapshot</name> <operator>&amp;&amp;</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>isAutoSnapshot</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>snapshot</name><argument_list>(<argument><expr><call><name><name>Keyspace</name><operator>.</operator><name>getTimestampedSnapshotNameWithPrefix</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SNAPSHOT_TRUNCATE_PREFIX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>discardSSTables</name><argument_list>(<argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>indexManager</name><operator>.</operator><name>truncateAllIndexesBlocking</name></name><argument_list>(<argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>viewManager</name><operator>.</operator><name>truncateBlocking</name></name><argument_list>(<argument><expr><name>replayAfter</name></expr></argument>, <argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>saveTruncationRecord</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>truncatedAt</name></expr></argument>, <argument><expr><name>replayAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"cleaning out row cache"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>invalidateCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>runWithCompactionsDisabled</name><argument_list>(<argument><expr><call><name><name>Executors</name><operator>.</operator><name>callable</name></name><argument_list>(<argument><expr><name>truncateRunnable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>viewManager</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Truncate of {}.{} is complete"</literal></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Drops current memtable without flushing to disk. This should only be called when truncating a column family which is not durable.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>CommitLogPosition</name></argument>&gt;</argument_list></name></type> <name>dumpMemtable</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <synchronized>synchronized <init>(<expr><name>data</name></expr>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>final</specifier> <name>Flush</name></type> <name>flush</name> <init>= <expr><operator>new</operator> <call><name>Flush</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>flushExecutor</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>postFlushExecutor</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name><name>flush</name><operator>.</operator><name>postFlushTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>flush</name><operator>.</operator><name>postFlushTask</name></name></expr>;</return>
        </block_content>}</block></synchronized>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>V</name></parameter>&gt;</parameter_list> <name>V</name></type> <name>runWithCompactionsDisabled</name><parameter_list>(<parameter><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>callable</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptValidation</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptViews</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>runWithCompactionsDisabled</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><lambda><parameter_list>(<parameter><decl><name>sstable</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><literal type="boolean">true</literal></expr></block_content></block></lambda></expr></argument>, <argument><expr><name>interruptValidation</name></expr></argument>, <argument><expr><name>interruptViews</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Runs callable with compactions paused and compactions including sstables matching sstablePredicate stopped
     *
     * @param callable what to do when compactions are paused
     * @param sstablesPredicate which sstables should we cancel compactions for
     * @param interruptValidation if we should interrupt validation compactions
     * @param interruptViews if we should interrupt view compactions
     * @param interruptIndexes if we should interrupt compactions on indexes. NOTE: if you set this to true your sstablePredicate
     *                         must be able to handle LocalPartitioner sstables!
     */</comment>
    <function><type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>V</name></parameter>&gt;</parameter_list> <name>V</name></type> <name>runWithCompactionsDisabled</name><parameter_list>(<parameter><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>callable</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstablesPredicate</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptValidation</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptViews</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptIndexes</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// synchronize so that concurrent invocations don't re-enable compactions partway through unexpectedly,</comment>
        <comment type="line">// and so we only run one major compaction at a time</comment>
        <synchronized>synchronized <init>(<expr><name>this</name></expr>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Cancelling in-progress compactions for {}"</literal></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>toInterruptFor</name> <init>= <expr><ternary><condition><expr><name>interruptIndexes</name></expr>
                                                         ?</condition><then> <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr>
                                                         </then><else>: <expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>toInterruptFor</name> <operator>=</operator> <ternary><condition><expr><name>interruptViews</name></expr>
                             ?</condition><then> <expr><call><name><name>Iterables</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><name>toInterruptFor</name></expr></argument>, <argument><expr><call><name><name>viewManager</name><operator>.</operator><name>allViewsCfs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>
                             </then><else>: <expr><name>toInterruptFor</name></expr></else></ternary></expr>;</expr_stmt>

            <try>try <init>(<decl><type><name><name>CompactionManager</name><operator>.</operator><name>CompactionPauser</name></name></type> <name>pause</name> <init>= <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>pauseGlobalCompaction</name></name><argument_list>()</argument_list></call></expr></init></decl>;
                 <decl><type><name><name>CompactionManager</name><operator>.</operator><name>CompactionPauser</name></name></type> <name>pausedStrategies</name> <init>= <expr><call><name>pauseCompactionStrategies</name><argument_list>(<argument><expr><name>toInterruptFor</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <comment type="line">// interrupt in-progress compactions</comment>
                <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>interruptCompactionForCFs</name></name><argument_list>(<argument><expr><name>toInterruptFor</name></expr></argument>, <argument><expr><name>sstablesPredicate</name></expr></argument>, <argument><expr><name>interruptValidation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>waitForCessation</name></name><argument_list>(<argument><expr><name>toInterruptFor</name></expr></argument>, <argument><expr><name>sstablesPredicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// doublecheck that we finished, instead of timing out</comment>
                <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>toInterruptFor</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>cfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCompacting</name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call><operator>.</operator><call><name>anyMatch</name><argument_list>(<argument><expr><name>sstablesPredicate</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Unable to cancel in-progress compactions for {}.  Perhaps there is an unusually large row in progress somewhere, or the system is simply overloaded."</literal></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="null">null</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Compactions successfully cancelled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// run our task</comment>
                <try>try
                <block>{<block_content>
                    <return>return <expr><call><name><name>callable</name><operator>.</operator><name>call</name></name><argument_list>()</argument_list></call></expr>;</return>
                </block_content>}</block>
                <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></catch></try>
            </block_content>}</block></try>
        </block_content>}</block></synchronized>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>CompactionManager</name><operator>.</operator><name>CompactionPauser</name></name></type> <name>pauseCompactionStrategies</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>toPause</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>successfullyPaused</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>toPause</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>successfullyPaused</name><operator>.</operator><name>ensureCapacity</name></name><argument_list>(<argument><expr><call><name><name>successfullyPaused</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// to avoid OOM:ing after pausing the strategies</comment>
                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>pause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>successfullyPaused</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <return>return <expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>maybeFail</name><argument_list>(<argument><expr><call><name>resumeAll</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>toPause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>resumeAll</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>successfullyPaused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>t</name></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Throwable</name></type> <name>resumeAll</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>, <parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfss</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>cfss</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>resume</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name>merge</name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></for>
        <return>return <expr><name>accumulate</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>LifecycleTransaction</name></type> <name>markAllCompacting</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>OperationType</name></type> <name>operationType</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>LifecycleTransaction</name></argument>&gt;</argument_list></name></type> <name>callable</name> <init>= <expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
            <assert>assert <expr><call><name><name>data</name><operator>.</operator><name>getCompacting</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name><name>data</name><operator>.</operator><name>getCompacting</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name>getLiveSSTables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>sstables</name> <operator>=</operator> <call><name><name>AbstractCompactionStrategy</name><operator>.</operator><name>filterSuspectSSTables</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>LifecycleTransaction</name></type> <name>modifier</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>tryModify</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>operationType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>modifier</name> <operator>!=</operator> <literal type="null">null</literal><operator>:</operator> <literal type="string">"something marked things compacting while compactions are disabled"</literal></expr>;</assert>
            <return>return <expr><name>modifier</name></expr>;</return>
        </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name>runWithCompactionsDisabled</name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>


    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="string">"CFS("</literal> <operator>+</operator>
               <literal type="string">"Keyspace='"</literal> <operator>+</operator> <call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="char">'\''</literal> <operator>+</operator>
               <literal type="string">", ColumnFamily='"</literal> <operator>+</operator> <name>name</name> <operator>+</operator> <literal type="char">'\''</literal> <operator>+</operator>
               <literal type="char">')'</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>disableAutoCompaction</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// we don't use CompactionStrategy.pause since we don't want users flipping that on and off</comment>
        <comment type="line">// during runWithCompactionsDisabled</comment>
        <expr_stmt><expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>disable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>enableAutoCompaction</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>enableAutoCompaction</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * used for tests - to be able to check things after a minor compaction
     * @param waitForFutures if we should block until autocompaction is done
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>enableAutoCompaction</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>waitForFutures</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>enable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>waitForFutures</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isAutoCompactionDisabled</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>compactionStrategyManager</name><operator>.</operator><name>isEnabled</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
     JMX getters and setters for the Default&lt;T&gt;s.
       - get/set minCompactionThreshold
       - get/set maxCompactionThreshold
       - get     memsize
       - get     memops
       - get/set memtime
     */</comment>

    <function><type><specifier>public</specifier> <name>CompactionStrategyManager</name></type> <name>getCompactionStrategyManager</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>compactionStrategyManager</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCrcCheckChance</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>crcCheckChance</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>TableParams</name><operator>.</operator><name>builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>crcCheckChance</name><argument_list>(<argument><expr><name>crcCheckChance</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call><operator>.</operator><call><name>validate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>crcCheckChance</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>crcCheckChance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name><name>cfs</name><operator>.</operator><name>getSSTables</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>LIVE</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>sstable</name><operator>.</operator><name>setCrcCheckChance</name></name><argument_list>(<argument><expr><name>crcCheckChance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></for>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>


    <function><type><specifier>public</specifier> <name>Double</name></type> <name>getCrcCheckChance</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>crcCheckChance</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionThresholds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minThreshold</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxThreshold</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>validateCompactionThresholds</name><argument_list>(<argument><expr><name>minThreshold</name></expr></argument>, <argument><expr><name>maxThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>minCompactionThreshold</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>minThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>maxCompactionThreshold</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>maxThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMinimumCompactionThreshold</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>minCompactionThreshold</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMinimumCompactionThreshold</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minCompactionThreshold</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>validateCompactionThresholds</name><argument_list>(<argument><expr><name>minCompactionThreshold</name></expr></argument>, <argument><expr><call><name><name>maxCompactionThreshold</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>minCompactionThreshold</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>minCompactionThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaximumCompactionThreshold</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>maxCompactionThreshold</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaximumCompactionThreshold</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxCompactionThreshold</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>validateCompactionThresholds</name><argument_list>(<argument><expr><call><name><name>minCompactionThreshold</name><operator>.</operator><name>value</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>maxCompactionThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>maxCompactionThreshold</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>maxCompactionThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>validateCompactionThresholds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minThreshold</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxThreshold</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>minThreshold</name> <operator>&gt;</operator> <name>maxThreshold</name></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"The min_compaction_threshold cannot be larger than the max_compaction_threshold. "</literal> <operator>+</operator>
                                                     <literal type="string">"Min is '%d', Max is '%d'."</literal></expr></argument>, <argument><expr><name>minThreshold</name></expr></argument>, <argument><expr><name>maxThreshold</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>maxThreshold</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>minThreshold</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Disabling compaction by setting min_compaction_threshold or max_compaction_threshold to 0 "</literal> <operator>+</operator>
                                       <literal type="string">"is deprecated, set the compaction strategy option 'enabled' to 'false' instead or use the nodetool command 'disableautocompaction'."</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="line">// End JMX get/set.</comment>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMeanEstimatedCellPerPartitionCount</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>getEstimatedCellPerPartitionCount</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>getEstimatedCellPerPartitionCount</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mean</name><argument_list>()</argument_list></call> <operator>*</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><ternary><condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>sum</name> <operator>/</operator> <name>count</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getMeanPartitionSize</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>getEstimatedPartitionSize</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>getEstimatedPartitionSize</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mean</name><argument_list>()</argument_list></call> <operator>*</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><ternary><condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>sum</name> <operator>*</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>count</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMeanRowCount</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>totalRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>totalPartitions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>totalPartitions</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>getEstimatedPartitionSize</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>totalRows</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>getTotalRows</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><ternary><condition><expr><name>totalPartitions</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>totalRows</name> <operator>/</operator> <name>totalPartitions</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>estimateKeys</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>estimatedKeys</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><name>n</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>IPartitioner</name></type> <name>getPartitioner</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name>partitioner</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>DecoratedKey</name></type> <name>decorateKey</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call><operator>.</operator><call><name>decorateKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** true if this CFS contains secondary index data */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isIndex</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isIndex</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>concatWithIndexes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// we return the main CFS first, which we rely on for simplicity in switchMemtable(), for getting the</comment>
        <comment type="line">// latest commit log segment position</comment>
        <return>return <expr><call><name><name>Iterables</name><operator>.</operator><name>concat</name></name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>indexManager</name><operator>.</operator><name>getAllIndexColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getBuiltIndexes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>indexManager</name><operator>.</operator><name>getBuiltIndexNames</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getUnleveledSSTables</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>getUnleveledSSTables</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>int</name><index>[]</index></name></type> <name>getSSTableCountPerLevel</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>getSSTableCountPerLevel</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getLevelFanoutSize</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>compactionStrategyManager</name><operator>.</operator><name>getLevelFanoutSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ViewFragment</name>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>ViewFragment</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>, <parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sstables</name></name> <operator>=</operator> <name>sstables</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>memtables</name></name> <operator>=</operator> <name>memtables</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>RefViewFragment</name> <super_list><extends>extends <super><name>ViewFragment</name></super></extends> <implements>implements <super><name>AutoCloseable</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>RefViewFragment</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>, <parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl></parameter>, <parameter><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>memtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>refs</name></name> <operator>=</operator> <name>refs</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>release</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>refs</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>refs</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEmpty</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>data</name><operator>.</operator><name>getView</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isRowCacheEnabled</name><parameter_list>()</parameter_list>
    <block>{<block_content>

        <decl_stmt><decl><type><name>boolean</name></type> <name>retval</name> <init>= <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>caching</name><operator>.</operator><name>cacheRows</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>rowCache</name><operator>.</operator><name>getCapacity</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <assert>assert<expr><operator>(</operator><operator>!</operator><name>retval</name> <operator>||</operator> <operator>!</operator><call><name>isIndex</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</assert>
        <return>return <expr><name>retval</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isCounterCacheEnabled</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isCounter</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>counterCache</name><operator>.</operator><name>getCapacity</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isKeyCacheEnabled</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>params</name><operator>.</operator><name>caching</name><operator>.</operator><name>cacheKeys</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>CacheService</name><operator>.</operator><name>instance</name><operator>.</operator><name>keyCache</name><operator>.</operator><name>getCapacity</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Discard all SSTables that were created before given timestamp.
     *
     * Caller should first ensure that comapctions have quiesced.
     *
     * @param truncatedAt The timestamp of the truncation
     *                    (all SSTables before that timestamp are going be marked as compacted)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>discardSSTables</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>truncatedAt</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name><name>data</name><operator>.</operator><name>getCompacting</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name><name>data</name><operator>.</operator><name>getCompacting</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>truncatedSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>keptSSTables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>LIVE</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>sstable</name><operator>.</operator><name>newSince</name></name><argument_list>(<argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>truncatedSSTables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>keptSSTables</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Truncation is keeping {} maxDataAge={} truncatedAt={}"</literal></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><name><name>sstable</name><operator>.</operator><name>maxDataAge</name></name></expr></argument>, <argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>truncatedSSTables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Truncation is dropping {} sstables and keeping {} due to sstable.maxDataAge &gt; truncatedAt"</literal></expr></argument>, <argument><expr><call><name><name>truncatedSSTables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>keptSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>markObsolete</name><argument_list>(<argument><expr><name>truncatedSSTables</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>UNKNOWN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getDroppableTombstoneRatio</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>allDroppable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>allColumns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>localTime</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call><operator>/</operator><literal type="number">1000</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>LIVE</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>allDroppable</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>getDroppableTombstonesBefore</name></name><argument_list>(<argument><expr><name>localTime</name> <operator>-</operator> <call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>gcGraceSeconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>allColumns</name> <operator>+=</operator> <call><name><name>sstable</name><operator>.</operator><name>getEstimatedCellPerPartitionCount</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mean</name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>sstable</name><operator>.</operator><name>getEstimatedCellPerPartitionCount</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><ternary><condition><expr><name>allColumns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>allDroppable</name> <operator>/</operator> <name>allColumns</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>trueSnapshotsSize</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>trueSnapshotsSize</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a ColumnFamilyStore by id if it exists, null otherwise
     * Differently from others, this method does not throw exception if the table does not exist.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamilyStore</name></type> <name>getIfExists</name><parameter_list>(<parameter><decl><type><name>TableId</name></type> <name>id</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TableMetadata</name></type> <name>metadata</name> <init>= <expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTableMetadata</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>metadata</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>Keyspace</name></type> <name>keyspace</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>keyspace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyspace</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><ternary><condition><expr><call><name><name>keyspace</name><operator>.</operator><name>hasColumnFamilyStore</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>
             ?</condition><then> <expr><call><name><name>keyspace</name><operator>.</operator><name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>
             </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a ColumnFamilyStore by ksname and cfname if it exists, null otherwise
     * Differently from others, this method does not throw exception if the keyspace or table does not exist.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamilyStore</name></type> <name>getIfExists</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>ksName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>cfName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ksName</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>cfName</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>Keyspace</name></type> <name>keyspace</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyspace</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>TableMetadata</name></type> <name>table</name> <init>= <expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTableMetadata</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>table</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><call><name><name>keyspace</name><operator>.</operator><name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name><name>table</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>TableMetrics</name></type> <name>metricsFor</name><parameter_list>(<parameter><decl><type><name>TableId</name></type> <name>tableId</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><call><name>getIfExists</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name>metric</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>DiskBoundaries</name></type> <name>getDiskBoundaries</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>diskBoundaryManager</name><operator>.</operator><name>getDiskBoundaries</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidateDiskBoundaries</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>diskBoundaryManager</name><operator>.</operator><name>invalidate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>setNeverPurgeTombstones</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>neverPurgeTombstones</name> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Changing neverPurgeTombstones for {}.{} from {} to {}"</literal></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTableName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>neverPurgeTombstones</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Not changing neverPurgeTombstones for {}.{}, it is {}"</literal></expr></argument>, <argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTableName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>neverPurgeTombstones</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>neverPurgeTombstones</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>getNeverPurgeTombstones</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>neverPurgeTombstones</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * The thread pools used to flush memtables.
     *
     * &lt;p&gt;Each disk has its own set of thread pools to perform memtable flushes.&lt;/p&gt;
     * &lt;p&gt;Based on the configuration. Local system keyspaces can have their own disk
     * to allow for special redundancy mechanism. If it is the case the executor services returned for
     * local system keyspaces will be different from the ones for the other keyspaces.&lt;/p&gt;
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>PerDiskFlushExecutors</name>
    <block>{
        <comment type="block" format="javadoc">/**
         * The flush executors for non local system keyspaces.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ExecutorService</name><index>[]</index></name></type> <name>nonLocalSystemflushExecutors</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * The flush executors for the local system keyspaces.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ExecutorService</name><index>[]</index></name></type> <name>localSystemDiskFlushExecutors</name></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * {@code true} if local system keyspaces are stored in their own directory and use an extra flush executor,
         * {@code false} otherwise.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>useSpecificExecutorForSystemKeyspaces</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>PerDiskFlushExecutors</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flushWriters</name></decl></parameter>,
                                     <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>locationsForNonSystemKeyspaces</name></decl></parameter>,
                                     <parameter><decl><type><name>boolean</name></type> <name>useSpecificLocationForSystemKeyspaces</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>ExecutorService</name><index>[]</index></name></type> <name>flushExecutors</name> <init>= <expr><call><name>createPerDiskFlushWriters</name><argument_list>(<argument><expr><name><name>locationsForNonSystemKeyspaces</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name>flushWriters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>nonLocalSystemflushExecutors</name> <operator>=</operator> <name>flushExecutors</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>useSpecificExecutorForSystemKeyspaces</name> <operator>=</operator> <name>useSpecificLocationForSystemKeyspaces</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>localSystemDiskFlushExecutors</name> <operator>=</operator> <ternary><condition><expr><name>useSpecificLocationForSystemKeyspaces</name></expr> ?</condition><then> <expr><operator>new</operator> <name><name>ExecutorService</name><index>[]</index></name> <block>{<expr><call><name>newThreadPool</name><argument_list>(<argument><expr><literal type="string">"LocalSystemKeyspacesDiskMemtableFlushWriter"</literal></expr></argument>, <argument><expr><name>flushWriters</name></expr></argument>)</argument_list></call></expr>}</block></expr>
                                                                                  </then><else>: <expr><operator>new</operator> <name><name>ExecutorService</name><index>[]</index></name> <block>{<expr><name><name>flushExecutors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>}</block></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>ExecutorService</name><index>[]</index></name></type> <name>createPerDiskFlushWriters</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numberOfExecutors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flushWriters</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>ExecutorService</name><index>[]</index></name></type> <name>flushExecutors</name> <init>= <expr><operator>new</operator> <name><name>ExecutorService</name><index>[<expr><name>numberOfExecutors</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfExecutors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>flushExecutors</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>newThreadPool</name><argument_list>(<argument><expr><literal type="string">"PerDiskMemtableFlushWriter_"</literal> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>flushWriters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <return>return <expr><name>flushExecutors</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <specifier>static</specifier> <name>JMXEnabledThreadPoolExecutor</name></type> <name>newThreadPool</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>poolName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                                                    <argument><expr><name><name>Stage</name><operator>.</operator><name>KEEP_ALIVE_SECONDS</name></name></expr></argument>,
                                                    <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>,
                                                    <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                                                    <argument><expr><operator>new</operator> <call><name>NamedThreadFactory</name><argument_list>(<argument><expr><name>poolName</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Returns the flush executors for the specified keyspace.
         *
         * @param keyspaceName the keyspace name
         * @param tableName the table name
         * @return the flush executors that should be used for flushing the memtables of the specified keyspace.
         */</comment>
        <function><type><specifier>public</specifier> <name><name>ExecutorService</name><index>[]</index></name></type> <name>getExecutorsFor</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>tableName</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><call><name><name>Directories</name><operator>.</operator><name>isStoredInLocalSystemKeyspacesDataLocation</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>localSystemDiskFlushExecutors</name></expr>
                                                                                                   </then><else>: <expr><name>nonLocalSystemflushExecutors</name></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Appends all the {@code ExecutorService} used for flushes to the collection.
         *
         * @param collection the collection to append to.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>appendAllExecutors</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ExecutorService</name></argument>&gt;</argument_list></name></type> <name>collection</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>collection</name></expr></argument>, <argument><expr><name>nonLocalSystemflushExecutors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>useSpecificExecutorForSystemKeyspaces</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>collection</name></expr></argument>, <argument><expr><name>localSystemDiskFlushExecutors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block">/*
     * Check SSTables whether or not they are misplaced.
     * @return true if any of the SSTables is misplaced.
     *         If all SSTables are correctly placed or the partitioner does not support splitting, it returns false.
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>hasMisplacedSSTables</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getPartitioner</name><argument_list>()</argument_list></call><operator>.</operator><call><name>splitter</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPresent</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>DiskBoundaries</name></type> <name>diskBoundaries</name> <init>= <expr><call><name>getDiskBoundaries</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Directories</name><operator>.</operator><name>DataDirectory</name></name></type> <name>dataDirectory</name> <init>= <expr><call><name>getDirectories</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDataDirectoryForFile</name><argument_list>(<argument><expr><name><name>sstable</name><operator>.</operator><name>descriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>diskBoundaries</name><operator>.</operator><name>isInCorrectLocation</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>dataDirectory</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>
}
</unit>
