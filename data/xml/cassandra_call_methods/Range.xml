<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/dht/Range.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Serializable</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Predicate</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang3</name><operator>.</operator><name>ObjectUtils</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>PartitionPosition</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Pair</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A representation of the range that a node is responsible for on the DHT ring.
 *
 * A Range is responsible for the tokens between (left, right].
 *
 * Used by the partitioner and by map/reduce by-token range scans.
 *
 * Note: this class has a natural ordering that is inconsistent with equals
 */</comment>
<class><specifier>public</specifier> class <name><name>Range</name><parameter_list>&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><parameter_list>&lt;<parameter><name>T</name></parameter>&gt;</parameter_list></name></extends></parameter>&gt;</parameter_list></name> <super_list><extends>extends <super><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></super></extends> <implements>implements <super><name><name>Comparable</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super>, <super><name>Serializable</name></super></implements></super_list>
<block>{
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>Range</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>point</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We are wrapping around, so the interval is (a,b] where a &gt;= b,
             * then we have 3 cases which hold for any given token k:
             * (1) a &lt; k -- return true
             * (2) k &lt;= b -- return true
             * (3) b &lt; k &lt;= a -- return false
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>point</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * This is the range (a, b] where a &lt; b.
             */</comment>
            <return>return <expr><call><name><name>point</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// full ring always contains all other ranges</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>thiswraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>thatwraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>thiswraps</name> <operator>==</operator> <name>thatwraps</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>that</name><operator>.</operator><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>thiswraps</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// wrapping might contain non-wrapping</comment>
            <comment type="line">// that is contained if both its tokens are in one of our wrap segments</comment>
            <return>return <expr><call><name><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>that</name><operator>.</operator><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// (thatwraps)</comment>
            <comment type="line">// non-wrapping cannot contain wrapping</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Helps determine if a given point on the DHT ring is contained
     * in the range in question.
     * @param point point in question
     * @return true if the point contains within the range else false.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>point</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>contains</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param that range to check for intersection
     * @return true if the given range intersects with this range.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>intersectionWith</name><argument_list>(<argument><expr><name>that</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<parameter><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// implemented for cleanup compaction membership test, so only Range + Bounds are supported for now</comment>
        <if_stmt><if>if <condition>(<expr><name>that</name> <operator>instanceof</operator> <name>Range</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>intersects</name><argument_list>(<argument><expr><operator>(</operator><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><operator>)</operator> <name>that</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>that</name> <operator>instanceof</operator> <name>Bounds</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>intersects</name><argument_list>(<argument><expr><operator>(</operator><name><name>Bounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><operator>)</operator> <name>that</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><literal type="string">"Intersection is only supported for Bounds and Range objects; found "</literal> <operator>+</operator> <call><name><name>that</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param that range to check for intersection
     * @return true if the given range intersects with this range.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<parameter><decl><type><name><name>Bounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// Same punishment than in Bounds.contains(), we must be carefull if that.left == that.right as</comment>
        <comment type="line">// as new Range&lt;T&gt;(that.left, that.right) will then cover the full ring which is not what we</comment>
        <comment type="line">// want.</comment>
        <return>return <expr><call><name>contains</name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name><name>that</name><operator>.</operator><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>intersects</name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>r</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>Iterables</name><operator>.</operator><name>any</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>rng</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>rng</name><operator>.</operator><name>intersects</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>SafeVarargs</name></annotation>
    <type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeSet</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name> <modifier>...</modifier></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>unmodifiableSet</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeSet</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param that
     * @return the intersection of the two Ranges.  this can be two disjoint Ranges if one is wrapping and one is not.
     * say you have nodes G and M, with query range (D,T]; the intersection is (M-T] and (D-G].
     * If there is no intersection, an empty list is returned.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionWith</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>that</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>rangeSet</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>rangeSet</name><argument_list>(<argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>thiswraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>thatwraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>thiswraps</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>thatwraps</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// neither wraps:  the straightforward case.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>that</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptySet</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><call><name>rangeSet</name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ObjectUtils</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name><name>ObjectUtils</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>thiswraps</name> <operator>&amp;&amp;</operator> <name>thatwraps</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//both wrap: if the starts are the same, one contains the other, which we have already ruled out.</comment>
            <assert>assert <expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</assert>
            <comment type="line">// two wrapping ranges always intersect.</comment>
            <comment type="line">// since we have already determined that neither this nor that contains the other, we have 2 cases,</comment>
            <comment type="line">// and mirror images of those case.</comment>
            <comment type="line">// (1) both of that's (1, 2] endpoints lie in this's (A, B] right segment:</comment>
            <comment type="line">//  ---------B--------A--1----2------&gt;</comment>
            <comment type="line">// (2) only that's start endpoint lies in this's right segment:</comment>
            <comment type="line">//  ---------B----1---A-------2------&gt;</comment>
            <comment type="line">// or, we have the same cases on the left segement, which we can handle by swapping this and that.</comment>
            <return>return <expr><ternary><condition><expr><call><name><name>this</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>
                   ?</condition><then> <expr><call><name>intersectionBothWrapping</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>
                   </then><else>: <expr><call><name>intersectionBothWrapping</name><argument_list>(<argument><expr><name>that</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>thiswraps</name></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// this wraps, that does not wrap</comment>
            <return>return <expr><call><name>intersectionOneWrapping</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <comment type="line">// the last case: this does not wrap, that wraps</comment>
        <return>return <expr><call><name>intersectionOneWrapping</name><argument_list>(<argument><expr><name>that</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionBothWrapping</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersection</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>that</name><operator>.</operator><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>first</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>intersection</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>first</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>that</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>intersection</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>first</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>unmodifiableSet</name></name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionOneWrapping</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>wrapping</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>other</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersection</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>other</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>wrapping</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>intersection</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>wrapping</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="line">// need the extra compareto here because ranges are asymmetrical; wrapping.left _is not_ contained by the wrapping range</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>other</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>wrapping</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>wrapping</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>intersection</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>wrapping</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>unmodifiableSet</name></name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>split</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>position</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name>contains</name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</assert>
        <comment type="line">// Check if the split would have no effect on the range</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>position</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>position</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>lb</name> <init>= <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>position</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rb</name> <init>= <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>Pair</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>lb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>inclusiveLeft</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>inclusiveRight</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>unwrap</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>T</name></type> <name>minValue</name> <init>= <expr><call><name><name>right</name><operator>.</operator><name>minValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isWrapAround</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>minValue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>unwrapped</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>unwrapped</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>minValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>unwrapped</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>unwrapped</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Tells if the given range is a wrap around.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>boolean</name></type> <name>isWrapAround</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
       <return>return <expr><call><name><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Tells if the given range covers the entire ring
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>boolean</name></type> <name>isFull</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Note: this class has a natural ordering that is inconsistent with equals
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>compareTo</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>lhsWrap</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>rhsWrap</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>rhs</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// if one of the two wraps, that's the smaller one.</comment>
        <if_stmt><if>if <condition>(<expr><name>lhsWrap</name> <operator>!=</operator> <name>rhsWrap</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>Boolean</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><operator>!</operator><name>lhsWrap</name></expr></argument>, <argument><expr><operator>!</operator><name>rhsWrap</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <comment type="line">// otherwise compare by right.</comment>
        <return>return <expr><call><name><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Subtracts a portion of this range.
     * @param contained The range to subtract from this. It must be totally
     * contained by this range.
     * @return A List of the Ranges left after subtracting contained
     * from this.
     */</comment>
    <function><type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtractContained</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>contained</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// both ranges cover the entire ring, their difference is an empty set</comment>
        <if_stmt><if>if<condition>(<expr><call><name>isFull</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isFull</name><argument_list>(<argument><expr><name><name>contained</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>contained</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// a range is subtracted from another range that covers the entire ring</comment>
        <if_stmt><if>if<condition>(<expr><call><name>isFull</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>singletonList</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>contained</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>contained</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>difference</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>contained</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>difference</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name><name>contained</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>contained</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>difference</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>contained</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>difference</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtract</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>rhs</name><operator>.</operator><name>differenceToFetch</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtractAll</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>substractAllFromToken</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>substractAllFromToken</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>subtract</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>subtract</name></name><argument_list>(<argument><expr><name>subtract</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtract</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtract</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>subtractAll</name></name><argument_list>(<argument><expr><name>subtract</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate set of the difference ranges of given two ranges
     * (as current (A, B] and rhs is (C, D])
     * which node will need to fetch when moving to a given new token
     *
     * @param rhs range to calculate difference
     * @return set of difference ranges
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>differenceToFetch</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionSet</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>intersectionWith</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>intersectionSet</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
            <type><name><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>intersections</name> <init>= <expr><operator>new</operator> <name><name>Range</name><index>[<expr><call><name><name>intersectionSet</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>intersectionSet</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><name>intersections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>intersections</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>rhs</name><operator>.</operator><name>subtractContained</name></name><argument_list>(<argument><expr><name><name>intersections</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// intersections.length must be 2</comment>
                <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>first</name> <init>= <expr><name><name>intersections</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>second</name> <init>= <expr><name><name>intersections</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>temp</name> <init>= <expr><call><name><name>rhs</name><operator>.</operator><name>subtractContained</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Because there are two intersections, subtracting only one of them</comment>
                <comment type="line">// will yield a single Range.</comment>
                <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>single</name> <init>= <expr><call><name><name>temp</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>single</name><operator>.</operator><name>subtractContained</name></name><argument_list>(<argument><expr><name>second</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>boolean</name></type> <name>isInRanges</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>ranges</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>range</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>o</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name> <operator>instanceof</operator> <name>Range</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>rhs</name> <init>= <expr><operator>(</operator><name><name>Range</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator><name>o</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="string">"("</literal> <operator>+</operator> <name>left</name> <operator>+</operator> <literal type="string">","</literal> <operator>+</operator> <name>right</name> <operator>+</operator> <literal type="string">"]"</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>protected</specifier> <name>String</name></type> <name>getOpeningString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="string">"("</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>protected</specifier> <name>String</name></type> <name>getClosingString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="string">"]"</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isStartInclusive</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEndInclusive</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>asList</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>ret</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>left</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>right</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isWrapAround</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return A copy of the given list of with all ranges unwrapped, sorted by left bound and with overlapping bounds merged.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>normalize</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// unwrap all</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>output</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ranges</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>unwrap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// sort by left</comment>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>b2</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>b1</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>b2</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></function>
        }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// deoverlap</comment>
        <return>return <expr><call><name>deoverlap</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Given a list of unwrapped ranges sorted by left position, return an
     * equivalent list of ranges but with no overlapping ranges.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>deoverlap</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>ranges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>ranges</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>output</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>ranges</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>current</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>T</name></type> <name>min</name> <init>= <expr><call><name><name>current</name><operator>.</operator><name>left</name><operator>.</operator><name>minValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If current goes to the end of the ring, we're done</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If one range is the full range, we return only that</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name><name>Collections</name><operator>.</operator></name>&lt;<name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><operator>&gt;</operator><call><name>singletonList</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>output</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>next</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// if next left is equal to current right, we do not intersect per se, but replacing (A, B] and (B, C] by (A, C] is</comment>
            <comment type="line">// legit, and since this avoid special casing and will result in more "optimal" ranges, we do the transformation</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>next</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// We do overlap</comment>
                <comment type="line">// (we've handled current.right.equals(min) already)</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>next</name><operator>.</operator><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>current</name><operator>.</operator><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>next</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>next</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>output</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>withNewRight</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>newRight</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>newRight</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>output</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ranges</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>r</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>r</name><operator>.</operator><name>unwrap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <comment type="line">// sort by left</comment>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>b2</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>b1</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>b2</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></function>
        }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>output</name></expr>;</return>
    </block_content>}</block></function>


    <comment type="block" format="javadoc">/**
     * Compute a range of keys corresponding to a given range of token.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Range</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>makeRowRange</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>left</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>right</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Range</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>makeRowRange</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokenBounds</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>makeRowRange</name><argument_list>(<argument><expr><name><name>tokenBounds</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>tokenBounds</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Helper class to check if a token is contained within a given collection of ranges
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>OrderedRangeContainmentChecker</name> <super_list><implements>implements <super><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>normalizedRangesIterator</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Token</name></type> <name>lastToken</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>currentRange</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>OrderedRangeContainmentChecker</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>normalizedRangesIterator</name> <operator>=</operator> <call><name>normalize</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>normalizedRangesIterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <expr_stmt><expr><name>currentRange</name> <operator>=</operator> <call><name><name>normalizedRangesIterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * Returns true if the ranges given in the constructor contains the token, false otherwise.
         *
         * The tokens passed to this method must be in increasing order
         *
         * @param t token to check, must be larger than or equal to the last token passed
         * @return true if the token is contained within the ranges given to the constructor.
         */</comment>
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>boolean</name></type> <name>test</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <assert>assert <expr><name>lastToken</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>lastToken</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</assert>
            <expr_stmt><expr><name>lastToken</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>t</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>currentRange</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name><name>t</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>currentRange</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>currentRange</name><operator>.</operator><name>right</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>currentRange</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>normalizedRangesIterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>currentRange</name> <operator>=</operator> <call><name><name>normalizedRangesIterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name> <extends>extends <name><name>RingPosition</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends></parameter>&gt;</parameter_list> <name>void</name></type> <name>assertNormalized</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>lastRange</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>lastRange</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>lastRange</name> <operator>=</operator> <name>range</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name><name>lastRange</name><operator>.</operator><name>left</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>lastRange</name><operator>.</operator><name>intersects</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Ranges aren't properly normalized. lastRange %s, range %s, compareTo %d, intersects %b, all ranges %s%n"</literal></expr></argument>,
                                                       <argument><expr><name>lastRange</name></expr></argument>,
                                                       <argument><expr><name>range</name></expr></argument>,
                                                       <argument><expr><call><name><name>lastRange</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name><name>lastRange</name><operator>.</operator><name>intersects</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>
}</block></class>
</unit>
