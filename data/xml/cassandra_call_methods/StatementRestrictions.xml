<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>restrictions</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Joiner</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>functions</name><operator>.</operator><name>Function</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>Bound</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>StatementType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>filter</name><operator>.</operator><name>RowFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>AbstractType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>InvalidRequestException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>Index</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexRegistry</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>ColumnMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>TableMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>btree</name><operator>.</operator><name>BTreeSet</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang3</name><operator>.</operator><name>builder</name><operator>.</operator><name>ToStringBuilder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang3</name><operator>.</operator><name>builder</name><operator>.</operator><name>ToStringStyle</name></name>;</import>

<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>RequestValidations</name><operator>.</operator><name>checkFalse</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>RequestValidations</name><operator>.</operator><name>checkNotNull</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>RequestValidations</name><operator>.</operator><name>invalidRequest</name></name>;</import>

<comment type="block" format="javadoc">/**
 * The restrictions corresponding to the relations specified on the where-clause of CQL query.
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>StatementRestrictions</name>
<block>{
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>REQUIRES_ALLOW_FILTERING_MESSAGE</name> <init>=
            <expr><literal type="string">"Cannot execute this query as it might involve data filtering and "</literal> <operator>+</operator>
            <literal type="string">"thus may have unpredictable performance. If you want to execute "</literal> <operator>+</operator>
            <literal type="string">"this query despite the performance unpredictability, use ALLOW FILTERING"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The type of statement
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>StatementType</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The Column Family meta data
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>TableMetadata</name></type> <name>table</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Restrictions on partitioning columns
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>PartitionKeyRestrictions</name></type> <name>partitionKeyRestrictions</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Restrictions on clustering columns
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ClusteringColumnRestrictions</name></type> <name>clusteringColumnsRestrictions</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Restriction on non-primary key columns (i.e. secondary index restrictions)
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>RestrictionSet</name></type> <name>nonPrimaryKeyRestrictions</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>notNullColumns</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The restrictions used to build the row filter
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>IndexRestrictions</name></type> <name>filterRestrictions</name> <init>= <expr><operator>new</operator> <call><name>IndexRestrictions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;code&gt;true&lt;/code&gt; if the secondary index need to be queried, &lt;code&gt;false&lt;/code&gt; otherwise
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>usesSecondaryIndexing</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Specify if the query will return a range of partition keys.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isKeyRange</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * &lt;code&gt;true&lt;/code&gt; if nonPrimaryKeyRestrictions contains restriction on a regular column,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>hasRegularColumnsRestrictions</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Creates a new empty &lt;code&gt;StatementRestrictions&lt;/code&gt;.
     *
     * @param type the type of statement
     * @param table the column family meta data
     * @return a new empty &lt;code&gt;StatementRestrictions&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>StatementRestrictions</name></type> <name>empty</name><parameter_list>(<parameter><decl><type><name>StatementType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>TableMetadata</name></type> <name>table</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>StatementRestrictions</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <constructor><specifier>private</specifier> <name>StatementRestrictions</name><parameter_list>(<parameter><decl><type><name>StatementType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>TableMetadata</name></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>allowFiltering</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>table</name></name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>partitionKeyRestrictions</name></name> <operator>=</operator> <operator>new</operator> <call><name>PartitionKeySingleRestrictionSet</name><argument_list>(<argument><expr><call><name><name>table</name><operator>.</operator><name>partitionKeyAsClusteringComparator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>clusteringColumnsRestrictions</name></name> <operator>=</operator> <operator>new</operator> <call><name>ClusteringColumnRestrictions</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>allowFiltering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nonPrimaryKeyRestrictions</name></name> <operator>=</operator> <operator>new</operator> <call><name>RestrictionSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>notNullColumns</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <constructor><specifier>public</specifier> <name>StatementRestrictions</name><parameter_list>(<parameter><decl><type><name>StatementType</name></type> <name>type</name></decl></parameter>,
                                 <parameter><decl><type><name>TableMetadata</name></type> <name>table</name></decl></parameter>,
                                 <parameter><decl><type><name>WhereClause</name></type> <name>whereClause</name></decl></parameter>,
                                 <parameter><decl><type><name>VariableSpecifications</name></type> <name>boundNames</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>selectsOnlyStaticColumns</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>allowFiltering</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>forView</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>boundNames</name></expr></argument>, <argument><expr><name>selectsOnlyStaticColumns</name></expr></argument>, <argument><expr><call><name><name>type</name><operator>.</operator><name>allowUseOfSecondaryIndices</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>allowFiltering</name></expr></argument>, <argument><expr><name>forView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block">/*
     * We want to override allowUseOfSecondaryIndices flag from the StatementType for MV statements
     * to avoid initing the Keyspace and SecondaryIndexManager.
     */</comment>
    <constructor><specifier>public</specifier> <name>StatementRestrictions</name><parameter_list>(<parameter><decl><type><name>StatementType</name></type> <name>type</name></decl></parameter>,
                                 <parameter><decl><type><name>TableMetadata</name></type> <name>table</name></decl></parameter>,
                                 <parameter><decl><type><name>WhereClause</name></type> <name>whereClause</name></decl></parameter>,
                                 <parameter><decl><type><name>VariableSpecifications</name></type> <name>boundNames</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>selectsOnlyStaticColumns</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>allowUseOfSecondaryIndices</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>allowFiltering</name></decl></parameter>,
                                 <parameter><decl><type><name>boolean</name></type> <name>forView</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>allowFiltering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>IndexRegistry</name></type> <name>indexRegistry</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>allowUseOfSecondaryIndices</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>indexRegistry</name> <operator>=</operator> <call><name><name>IndexRegistry</name><operator>.</operator><name>obtain</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * WHERE clause. For a given entity, rules are:
         *   - EQ relation conflicts with anything else (including a 2nd EQ)
         *   - Can't have more than one LT(E) relation (resp. GT(E) relation)
         *   - IN relation are restricted to row keys (for now) and conflicts with anything else (we could
         *     allow two IN for the same entity but that doesn't seem very useful)
         *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value
         *     in CQL so far)
         *   - CONTAINS and CONTAINS_KEY cannot be used with UPDATE or DELETE
         */</comment>
        <for>for <control>(<init><decl><type><name>Relation</name></type> <name>relation</name> <range>: <expr><name><name>whereClause</name><operator>.</operator><name>relations</name></name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>relation</name><operator>.</operator><name>isContains</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>relation</name><operator>.</operator><name>isContainsKey</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>type</name><operator>.</operator><name>isUpdate</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>type</name><operator>.</operator><name>isDelete</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"Cannot use %s with %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name><name>relation</name><operator>.</operator><name>operator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>relation</name><operator>.</operator><name>operator</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Operator</name><operator>.</operator><name>IS_NOT</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>forView</name></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>InvalidRequestException</name><argument_list>(<argument><expr><literal type="string">"Unsupported restriction: "</literal> <operator>+</operator> <name>relation</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>notNullColumns</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>relation</name><operator>.</operator><name>toRestriction</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>boundNames</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnDefs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name><name>relation</name><operator>.</operator><name>isLIKE</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><call><name><name>relation</name><operator>.</operator><name>toRestriction</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>boundNames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>allowUseOfSecondaryIndices</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>restriction</name><operator>.</operator><name>hasSupportingIndex</name></name><argument_list>(<argument><expr><name>indexRegistry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"LIKE restriction is only supported on properly "</literal> <operator>+</operator>
                                                                    <literal type="string">"indexed columns. %s is not valid."</literal></expr></argument>,
                                                                    <argument><expr><call><name><name>relation</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>addRestriction</name><argument_list>(<argument><expr><name>restriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>addRestriction</name><argument_list>(<argument><expr><call><name><name>relation</name><operator>.</operator><name>toRestriction</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>boundNames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>hasRegularColumnsRestrictions</name> <operator>=</operator> <call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>hasRestrictionFor</name></name><argument_list>(<argument><expr><name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name><operator>.</operator><name>REGULAR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>hasQueriableClusteringColumnIndex</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>hasQueriableIndex</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>allowUseOfSecondaryIndices</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>whereClause</name><operator>.</operator><name>containsCustomExpressions</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>processCustomIndexExpressions</name><argument_list>(<argument><expr><name><name>whereClause</name><operator>.</operator><name>expressions</name></name></expr></argument>, <argument><expr><name>boundNames</name></expr></argument>, <argument><expr><name>indexRegistry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>hasQueriableClusteringColumnIndex</name> <operator>=</operator> <call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>hasSupportingIndex</name></name><argument_list>(<argument><expr><name>indexRegistry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hasQueriableIndex</name> <operator>=</operator> <operator>!</operator><call><name><name>filterRestrictions</name><operator>.</operator><name>getCustomIndexExpressions</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call>
                    <operator>||</operator> <name>hasQueriableClusteringColumnIndex</name>
                    <operator>||</operator> <call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasSupportingIndex</name></name><argument_list>(<argument><expr><name>indexRegistry</name></expr></argument>)</argument_list></call>
                    <operator>||</operator> <call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>hasSupportingIndex</name></name><argument_list>(<argument><expr><name>indexRegistry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// At this point, the select statement if fully constructed, but we still have a few things to validate</comment>
        <expr_stmt><expr><call><name>processPartitionKeyRestrictions</name><argument_list>(<argument><expr><name>hasQueriableIndex</name></expr></argument>, <argument><expr><name>allowFiltering</name></expr></argument>, <argument><expr><name>forView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Some but not all of the partition key columns have been specified;</comment>
        <comment type="line">// hence we need turn these restrictions into a row filter.</comment>
        <if_stmt><if>if <condition>(<expr><name>usesSecondaryIndexing</name> <operator>||</operator> <call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>needFiltering</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>filterRestrictions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>partitionKeyRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>selectsOnlyStaticColumns</name> <operator>&amp;&amp;</operator> <call><name>hasClusteringColumnsRestrictions</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If the only updated/deleted columns are static, then we don't need clustering columns.</comment>
            <comment type="line">// And in fact, unless it is an INSERT, we reject if clustering colums are provided as that</comment>
            <comment type="line">// suggest something unintended. For instance, given:</comment>
            <comment type="line">//   CREATE TABLE t (k int, v int, s int static, PRIMARY KEY (k, v))</comment>
            <comment type="line">// it can make sense to do:</comment>
            <comment type="line">//   INSERT INTO t(k, v, s) VALUES (0, 1, 2)</comment>
            <comment type="line">// but both</comment>
            <comment type="line">//   UPDATE t SET s = 3 WHERE k = 0 AND v = 1</comment>
            <comment type="line">//   DELETE v FROM t WHERE k = 0 AND v = 1</comment>
            <comment type="line">// sounds like you don't really understand what your are doing.</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isDelete</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>type</name><operator>.</operator><name>isUpdate</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"Invalid restrictions on clustering columns since the %s statement modifies only static columns"</literal></expr></argument>,
                                     <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isSelect</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"Cannot restrict clustering columns when selecting only static columns"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>processClusteringColumnsRestrictions</name><argument_list>(<argument><expr><name>hasQueriableIndex</name></expr></argument>,
                                             <argument><expr><name>selectsOnlyStaticColumns</name></expr></argument>,
                                             <argument><expr><name>forView</name></expr></argument>,
                                             <argument><expr><name>allowFiltering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Covers indexes on the first clustering column (among others).</comment>
        <if_stmt><if>if <condition>(<expr><name>isKeyRange</name> <operator>&amp;&amp;</operator> <name>hasQueriableClusteringColumnIndex</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>usesSecondaryIndexing</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>usesSecondaryIndexing</name> <operator>||</operator> <call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>needFiltering</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>filterRestrictions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>clusteringColumnsRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Even if usesSecondaryIndexing is false at this point, we'll still have to use one if</comment>
        <comment type="line">// there is restrictions not covered by the PK.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>allowNonPrimaryKeyInWhereClause</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>nonPrimaryKeyColumns</name> <init>=
                        <expr><call><name><name>ColumnMetadata</name><operator>.</operator><name>toIdentifiers</name></name><argument_list>(<argument><expr><call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>getColumnDefs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"Non PRIMARY KEY columns found in where clause: %s "</literal></expr></argument>,
                                     <argument><expr><call><name><name>Joiner</name><operator>.</operator><name>on</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>join</name><argument_list>(<argument><expr><name>nonPrimaryKeyColumns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>hasQueriableIndex</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>usesSecondaryIndexing</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>allowFiltering</name></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><name><name>StatementRestrictions</name><operator>.</operator><name>REQUIRES_ALLOW_FILTERING_MESSAGE</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>filterRestrictions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>nonPrimaryKeyRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>usesSecondaryIndexing</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>validateSecondaryIndexSelections</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>addRestriction</name><parameter_list>(<parameter><decl><type><name>Restriction</name></type> <name>restriction</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnMetadata</name></type> <name>def</name> <init>= <expr><call><name><name>restriction</name><operator>.</operator><name>getFirstColumn</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>def</name><operator>.</operator><name>isPartitionKey</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>partitionKeyRestrictions</name> <operator>=</operator> <call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>mergeWith</name></name><argument_list>(<argument><expr><name>restriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name><name>def</name><operator>.</operator><name>isClusteringColumn</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>clusteringColumnsRestrictions</name> <operator>=</operator> <call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>mergeWith</name></name><argument_list>(<argument><expr><name>restriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>nonPrimaryKeyRestrictions</name> <operator>=</operator> <call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>addRestriction</name></name><argument_list>(<argument><expr><operator>(</operator><name>SingleRestriction</name><operator>)</operator> <name>restriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFunctionsTo</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Function</name></argument>&gt;</argument_list></name></type> <name>functions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>addFunctionsTo</name></name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>addFunctionsTo</name></name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>addFunctionsTo</name></name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line">// may be used by QueryHandler implementations</comment>
    <function><type><specifier>public</specifier> <name>IndexRestrictions</name></type> <name>getIndexRestrictions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>filterRestrictions</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the non-PK column that are restricted.  If includeNotNullRestrictions is true, columns that are restricted
     * by an IS NOT NULL restriction will be included, otherwise they will not be included (unless another restriction
     * applies to them).
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>nonPKRestrictedColumns</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>includeNotNullRestrictions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Restrictions</name></type> <name>r</name> <range>: <expr><call><name><name>filterRestrictions</name><operator>.</operator><name>getRestrictions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>ColumnMetadata</name></type> <name>def</name> <range>: <expr><call><name><name>r</name><operator>.</operator><name>getColumnDefs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>def</name><operator>.</operator><name>isPrimaryKeyColumn</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>columns</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>includeNotNullRestrictions</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>ColumnMetadata</name></type> <name>def</name> <range>: <expr><name>notNullColumns</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>def</name><operator>.</operator><name>isPrimaryKeyColumn</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>columns</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>columns</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return the set of columns that have an IS NOT NULL restriction on them
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>notNullColumns</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>notNullColumns</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return true if column is restricted by some restriction, false otherwise
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isRestricted</name><parameter_list>(<parameter><decl><type><name>ColumnMetadata</name></type> <name>column</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>notNullColumns</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><call><name>getRestrictions</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>kind</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnDefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the restrictions on the partition key has IN restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; the restrictions on the partition key has an IN restriction, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>keyIsInRelation</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasIN</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the query request a range of partition keys.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the query request a range of partition keys, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isKeyRange</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name><name>this</name><operator>.</operator><name>isKeyRange</name></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the specified column is restricted by an EQ restriction.
     *
     * @param columnDef the column definition
     * @return &lt;code&gt;true&lt;/code&gt; if the specified column is restricted by an EQ restiction, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isColumnRestrictedByEq</name><parameter_list>(<parameter><decl><type><name>ColumnMetadata</name></type> <name>columnDef</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Restriction</name></argument>&gt;</argument_list></name></type> <name>restrictions</name> <init>= <expr><call><name>getRestrictions</name><argument_list>(<argument><expr><name><name>columnDef</name><operator>.</operator><name>kind</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getRestrictions</name><argument_list>(<argument><expr><name>columnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>restrictions</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                           <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name><name>SingleRestriction</name><operator>.</operator><name>class</name></name><operator>::</operator><name>isInstance</name></expr></argument>)</argument_list></call>
                           <operator>.</operator><call><name>anyMatch</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>p</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>(</operator><operator>(</operator><name>SingleRestriction</name><operator>)</operator> <name>p</name><operator>)</operator><operator>.</operator><call><name>isEQ</name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the &lt;code&gt;Restrictions&lt;/code&gt; for the specified type of columns.
     *
     * @param kind the column type
     * @return the &lt;code&gt;Restrictions&lt;/code&gt; for the specified type of columns
     */</comment>
    <function><type><specifier>private</specifier> <name>Restrictions</name></type> <name>getRestrictions</name><parameter_list>(<parameter><decl><type><name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name></name></type> <name>kind</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PARTITION_KEY</name></expr>:</case> <return>return <expr><name>partitionKeyRestrictions</name></expr>;</return>
            <case>case <expr><name>CLUSTERING</name></expr>:</case> <return>return <expr><name>clusteringColumnsRestrictions</name></expr>;</return>
            <default>default:</default> <return>return <expr><name>nonPrimaryKeyRestrictions</name></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the secondary index need to be queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the secondary index need to be queried, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>usesSecondaryIndexing</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name><name>this</name><operator>.</operator><name>usesSecondaryIndexing</name></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>processPartitionKeyRestrictions</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>hasQueriableIndex</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>allowFiltering</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>forView</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>allowPartitionKeyRanges</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>checkFalse</name><argument_list>(<argument><expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isOnToken</name></name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><literal type="string">"The token function cannot be used in WHERE clauses for %s statements"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasUnrestrictedPartitionKeyComponents</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"Some partition key parts are missing: %s"</literal></expr></argument>,
                                     <argument><expr><call><name><name>Joiner</name><operator>.</operator><name>on</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>join</name><argument_list>(<argument><expr><call><name>getPartitionKeyUnrestrictedComponents</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <comment type="line">// slice query</comment>
            <expr_stmt><expr><call><name>checkFalse</name><argument_list>(<argument><expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasSlice</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><literal type="string">"Only EQ and IN relation are supported on the partition key (unless you use the token() function)"</literal>
                            <operator>+</operator> <literal type="string">" for %s statements"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// If there are no partition restrictions or there's only token restriction, we have to set a key range</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isOnToken</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>isKeyRange</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasUnrestrictedPartitionKeyComponents</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>isKeyRange</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>usesSecondaryIndexing</name> <operator>=</operator> <name>hasQueriableIndex</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If there is a queriable index, no special condition is required on the other restrictions.</comment>
            <comment type="line">// But we still need to know 2 things:</comment>
            <comment type="line">// - If we don't have a queriable index, is the query ok</comment>
            <comment type="line">// - Is it queriable without 2ndary index, which is always more efficient</comment>
            <comment type="line">// If a component of the partition key is restricted by a relation, all preceding</comment>
            <comment type="line">// components must have a EQ. Only the last partition key component can be in IN relation.</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>needFiltering</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowFiltering</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forView</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasQueriableIndex</name></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>InvalidRequestException</name><argument_list>(<argument><expr><name>REQUIRES_ALLOW_FILTERING_MESSAGE</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasIN</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>InvalidRequestException</name><argument_list>(<argument><expr><literal type="string">"IN restrictions are not supported when the query involves filtering"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>isKeyRange</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>usesSecondaryIndexing</name> <operator>=</operator> <name>hasQueriableIndex</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasPartitionKeyRestrictions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the restrictions contain any non-primary key restrictions
     * @return &lt;code&gt;true&lt;/code&gt; if the restrictions contain any non-primary key restrictions, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasNonPrimaryKeyRestrictions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the partition key components that are not restricted.
     * @return the partition key components that are not restricted.
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>getPartitionKeyUnrestrictedComponents</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>table</name><operator>.</operator><name>partitionKeyColumns</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>removeAll</name></name><argument_list>(<argument><expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>getColumnDefs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>ColumnMetadata</name><operator>.</operator><name>toIdentifiers</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the restrictions on the partition key are token restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the restrictions on the partition key are token restrictions,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isPartitionKeyRestrictionsOnToken</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isOnToken</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if restrictions on the clustering key have IN restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the restrictions on the clustering key have IN restrictions,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>clusteringKeyRestrictionsHasIN</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>hasIN</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Processes the clustering column restrictions.
     *
     * @param hasQueriableIndex &lt;code&gt;true&lt;/code&gt; if some of the queried data are indexed, &lt;code&gt;false&lt;/code&gt; otherwise
     * @param selectsOnlyStaticColumns &lt;code&gt;true&lt;/code&gt; if the selected or modified columns are all statics,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>processClusteringColumnsRestrictions</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>hasQueriableIndex</name></decl></parameter>,
                                                      <parameter><decl><type><name>boolean</name></type> <name>selectsOnlyStaticColumns</name></decl></parameter>,
                                                      <parameter><decl><type><name>boolean</name></type> <name>forView</name></decl></parameter>,
                                                      <parameter><decl><type><name>boolean</name></type> <name>allowFiltering</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>checkFalse</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>allowClusteringColumnSlices</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>hasSlice</name></name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr><literal type="string">"Slice restrictions are not supported on the clustering columns in %s statements"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>allowClusteringColumnSlices</name></name><argument_list>()</argument_list></call>
            <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>table</name><operator>.</operator><name>isCompactTable</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>table</name><operator>.</operator><name>isCompactTable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasClusteringColumnsRestrictions</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>selectsOnlyStaticColumns</name> <operator>&amp;&amp;</operator> <call><name>hasUnrestrictedClusteringColumns</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"Some clustering keys are missing: %s"</literal></expr></argument>,
                                     <argument><expr><call><name><name>Joiner</name><operator>.</operator><name>on</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>join</name><argument_list>(<argument><expr><call><name>getUnrestrictedClusteringColumns</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>checkFalse</name><argument_list>(<argument><expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>hasContains</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasQueriableIndex</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allowFiltering</name></expr></argument>,
                       <argument><expr><literal type="string">"Clustering columns can only be restricted with CONTAINS with a secondary index or filtering"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>hasClusteringColumnsRestrictions</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>needFiltering</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>hasQueriableIndex</name> <operator>||</operator> <name>forView</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>usesSecondaryIndexing</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><operator>!</operator><name>allowFiltering</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>clusteringColumns</name> <init>= <expr><call><name><name>table</name><operator>.</operator><name>clusteringColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>restrictedColumns</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>getColumnDefs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>m</name> <init>= <expr><call><name><name>restrictedColumns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>m</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ColumnMetadata</name></type> <name>clusteringColumn</name> <init>= <expr><call><name><name>clusteringColumns</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>ColumnMetadata</name></type> <name>restrictedColumn</name> <init>= <expr><call><name><name>restrictedColumns</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>clusteringColumn</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>restrictedColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <throw>throw <expr><call><name>invalidRequest</name><argument_list>(<argument><expr><literal type="string">"PRIMARY KEY column \"%s\" cannot be restricted as preceding column \"%s\" is not restricted"</literal></expr></argument>,
                                                 <argument><expr><name><name>restrictedColumn</name><operator>.</operator><name>name</name></name></expr></argument>,
                                                 <argument><expr><name><name>clusteringColumn</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</throw>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

        </block_content>}</block></else></if_stmt>

    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the clustering columns that are not restricted.
     * @return the clustering columns that are not restricted.
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>getUnrestrictedClusteringColumns</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>missingClusteringColumns</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>table</name><operator>.</operator><name>clusteringColumns</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>missingClusteringColumns</name><operator>.</operator><name>removeAll</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>getColumnDefs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>ColumnMetadata</name><operator>.</operator><name>toIdentifiers</name></name><argument_list>(<argument><expr><name>missingClusteringColumns</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if some clustering columns are not restricted.
     * @return &lt;code&gt;true&lt;/code&gt; if some clustering columns are not restricted, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hasUnrestrictedClusteringColumns</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>table</name><operator>.</operator><name>clusteringColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>processCustomIndexExpressions</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>CustomIndexExpression</name></argument>&gt;</argument_list></name></type> <name>expressions</name></decl></parameter>,
                                               <parameter><decl><type><name>VariableSpecifications</name></type> <name>boundNames</name></decl></parameter>,
                                               <parameter><decl><type><name>IndexRegistry</name></type> <name>indexRegistry</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>expressions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>InvalidRequestException</name><argument_list>(<argument><expr><name><name>IndexRestrictions</name><operator>.</operator><name>MULTIPLE_EXPRESSIONS</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>CustomIndexExpression</name></type> <name>expression</name> <init>= <expr><call><name><name>expressions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>QualifiedName</name></type> <name>name</name> <init>= <expr><name><name>expression</name><operator>.</operator><name>targetIndex</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>name</name><operator>.</operator><name>hasKeyspace</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>name</name><operator>.</operator><name>getKeyspace</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>table</name><operator>.</operator><name>keyspace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name><name>IndexRestrictions</name><operator>.</operator><name>invalidIndex</name></name><argument_list>(<argument><expr><name><name>expression</name><operator>.</operator><name>targetIndex</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>table</name><operator>.</operator><name>indexes</name><operator>.</operator><name>has</name></name><argument_list>(<argument><expr><call><name><name>expression</name><operator>.</operator><name>targetIndex</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name><name>IndexRestrictions</name><operator>.</operator><name>indexNotFound</name></name><argument_list>(<argument><expr><name><name>expression</name><operator>.</operator><name>targetIndex</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name><name>indexRegistry</name><operator>.</operator><name>getIndex</name></name><argument_list>(<argument><expr><call><name><name>table</name><operator>.</operator><name>indexes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>expression</name><operator>.</operator><name>targetIndex</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isCustom</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name><name>IndexRestrictions</name><operator>.</operator><name>nonCustomIndexInExpression</name></name><argument_list>(<argument><expr><name><name>expression</name><operator>.</operator><name>targetIndex</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>expressionType</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>customExpressionValueType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>expressionType</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name><name>IndexRestrictions</name><operator>.</operator><name>customExpressionNotSupported</name></name><argument_list>(<argument><expr><name><name>expression</name><operator>.</operator><name>targetIndex</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>expression</name><operator>.</operator><name>prepareValue</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>expressionType</name></expr></argument>, <argument><expr><name>boundNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>filterRestrictions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>RowFilter</name></type> <name>getRowFilter</name><parameter_list>(<parameter><decl><type><name>IndexRegistry</name></type> <name>indexRegistry</name></decl></parameter>, <parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>filterRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>RowFilter</name><operator>.</operator><name>NONE</name></name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>RowFilter</name></type> <name>filter</name> <init>= <expr><call><name><name>RowFilter</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Restrictions</name></type> <name>restrictions</name> <range>: <expr><call><name><name>filterRestrictions</name><operator>.</operator><name>getRestrictions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>restrictions</name><operator>.</operator><name>addRowFilterTo</name></name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>indexRegistry</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <for>for <control>(<init><decl><type><name>CustomIndexExpression</name></type> <name>expression</name> <range>: <expr><call><name><name>filterRestrictions</name><operator>.</operator><name>getCustomIndexExpressions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>expression</name><operator>.</operator><name>addToRowFilter</name></name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <return>return <expr><name>filter</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the partition keys for which the data is requested.
     *
     * @param options the query options
     * @return the partition keys for which the data is requested.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>getPartitionKeys</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>values</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the specified bound of the partition key.
     *
     * @param b the boundary type
     * @param options the query options
     * @return the specified bound of the partition key
     */</comment>
    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>getPartitionKeyBound</name><parameter_list>(<parameter><decl><type><name>Bound</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// We deal with IN queries for keys in other places, so we know buildBound will return only one result</comment>
        <return>return <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>bounds</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the partition key bounds.
     *
     * @param options the query options
     * @return the partition key bounds
     */</comment>
    <function><type><specifier>public</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>getPartitionKeyBounds</name><parameter_list>(<parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>IPartitioner</name></type> <name>p</name> <init>= <expr><name><name>table</name><operator>.</operator><name>partitioner</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isOnToken</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name>getPartitionKeyBoundsForTokenRestrictions</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name>getPartitionKeyBounds</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>getPartitionKeyBounds</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>,
                                                                    <parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// Deal with unrestricted partition key components (special-casing is required to deal with 2i queries on the</comment>
        <comment type="line">// first component of a composite partition key) queries that filter on the partition key.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>needFiltering</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>p</name><operator>.</operator><name>getMinimumToken</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>minKeyBound</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>p</name><operator>.</operator><name>getMinimumToken</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>maxKeyBound</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>startKeyBytes</name> <init>= <expr><call><name>getPartitionKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>START</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>finishKeyBytes</name> <init>= <expr><call><name>getPartitionKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>END</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>PartitionPosition</name></type> <name>startKey</name> <init>= <expr><call><name><name>PartitionPosition</name><operator>.</operator><name>ForKey</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>startKeyBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PartitionPosition</name></type> <name>finishKey</name> <init>= <expr><call><name><name>PartitionPosition</name><operator>.</operator><name>ForKey</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>finishKeyBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>startKey</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>finishKey</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>finishKey</name><operator>.</operator><name>isMinimum</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>START</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>END</name></name></expr></argument>)</argument_list></call></expr>
                    ?</condition><then> <expr><operator>new</operator> <call><name><name>Bounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr>
                    </then><else>: <expr><operator>new</operator> <call><name><name>IncludingExcludingBounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><ternary><condition><expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>END</name></name></expr></argument>)</argument_list></call></expr>
                ?</condition><then> <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr>
                </then><else>: <expr><operator>new</operator> <call><name><name>ExcludingBounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractBounds</name><argument_list type="generic">&lt;<argument><name>PartitionPosition</name></argument>&gt;</argument_list></name></type> <name>getPartitionKeyBoundsForTokenRestrictions</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>,
                                                                                        <parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Token</name></type> <name>startToken</name> <init>= <expr><call><name>getTokenBound</name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>START</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>endToken</name> <init>= <expr><call><name>getTokenBound</name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>END</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>includeStart</name> <init>= <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>START</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>includeEnd</name> <init>= <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name><operator>.</operator><name>END</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we ask SP.getRangeSlice() for (token(200), token(200)], it will happily return the whole ring.
         * However, wrapping range doesn't really make sense for CQL, and we want to return an empty result in that
         * case (CASSANDRA-5573). So special case to create a range that is guaranteed to be empty.
         *
         * In practice, we want to return an empty result set if either startToken &gt; endToken, or both are equal but
         * one of the bound is excluded (since [a, a] can contains something, but not (a, a], [a, a) or (a, a)).
         * Note though that in the case where startToken or endToken is the minimum token, then this special case
         * rule should not apply.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name><name>startToken</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>endToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>startToken</name><operator>.</operator><name>isMinimum</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>endToken</name><operator>.</operator><name>isMinimum</name></name><argument_list>()</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>(</operator><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>includeStart</name> <operator>||</operator> <operator>!</operator><name>includeEnd</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>PartitionPosition</name></type> <name>start</name> <init>= <expr><ternary><condition><expr><name>includeStart</name></expr> ?</condition><then> <expr><call><name><name>startToken</name><operator>.</operator><name>minKeyBound</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>startToken</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PartitionPosition</name></type> <name>end</name> <init>= <expr><ternary><condition><expr><name>includeEnd</name></expr> ?</condition><then> <expr><call><name><name>endToken</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>endToken</name><operator>.</operator><name>minKeyBound</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <return>return <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Token</name></type> <name>getTokenBound</name><parameter_list>(<parameter><decl><type><name>Bound</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasBound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>p</name><operator>.</operator><name>getMinimumToken</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>value</name> <init>= <expr><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>bounds</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>checkNotNull</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"Invalid null token value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>p</name><operator>.</operator><name>getTokenFactory</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>fromByteArray</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the query has some restrictions on the clustering columns.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the query has some restrictions on the clustering columns,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasClusteringColumnsRestrictions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the requested clustering columns.
     *
     * @param options the query options
     * @return the requested clustering columns
     */</comment>
    <function><type><specifier>public</specifier> <name><name>NavigableSet</name><argument_list type="generic">&lt;<argument><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getClusteringColumns</name><parameter_list>(<parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// If this is a names command and the table is a static compact one, then as far as CQL is concerned we have</comment>
        <comment type="line">// only a single row which internally correspond to the static parts. In which case we want to return an empty</comment>
        <comment type="line">// set (since that's what ClusteringIndexNamesFilter expects).</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>table</name><operator>.</operator><name>isStaticCompactTable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>BTreeSet</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name><name>table</name><operator>.</operator><name>comparator</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>valuesAsClustering</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the bounds (start or end) of the clustering columns.
     *
     * @param b the bound type
     * @param options the query options
     * @return the bounds (start or end) of the clustering columns
     */</comment>
    <function><type><specifier>public</specifier> <name><name>NavigableSet</name><argument_list type="generic">&lt;<argument><name><name>ClusteringBound</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getClusteringColumnsBounds</name><parameter_list>(<parameter><decl><type><name>Bound</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>QueryOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>boundsAsClustering</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the query returns a range of columns.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the query returns a range of columns, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isColumnRange</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>numberOfClusteringColumns</name> <init>= <expr><call><name><name>table</name><operator>.</operator><name>clusteringColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>table</name><operator>.</operator><name>isStaticCompactTable</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// For static compact tables we want to ignore the fake clustering column (note that if we weren't special casing,</comment>
            <comment type="line">// this would mean a 'SELECT *' on a static compact table would query whole partitions, even though we'll only return</comment>
            <comment type="line">// the static part as far as CQL is concerned. This is thus mostly an optimization to use the query-by-name path).</comment>
            <expr_stmt><expr><name>numberOfClusteringColumns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// it is a range query if it has at least one the column alias for which no relation is defined or is not EQ or IN.</comment>
        <return>return <expr><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>numberOfClusteringColumns</name>
            <operator>||</operator> <operator>!</operator><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>hasOnlyEqualityRestrictions</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the query need to use filtering.
     * @return &lt;code&gt;true&lt;/code&gt; if the query need to use filtering, &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>needFiltering</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>numberOfRestrictions</name> <init>= <expr><call><name><name>filterRestrictions</name><operator>.</operator><name>getCustomIndexExpressions</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Restrictions</name></type> <name>restrictions</name> <range>: <expr><call><name><name>filterRestrictions</name><operator>.</operator><name>getRestrictions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>numberOfRestrictions</name> <operator>+=</operator> <call><name><name>restrictions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <return>return <expr><name>numberOfRestrictions</name> <operator>&gt;</operator> <literal type="number">1</literal>
                <operator>||</operator> <operator>(</operator><name>numberOfRestrictions</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call><operator>)</operator>
                <operator>||</operator> <operator>(</operator><name>numberOfRestrictions</name> <operator>!=</operator> <literal type="number">0</literal>
                        <operator>&amp;&amp;</operator> <call><name><name>nonPrimaryKeyRestrictions</name><operator>.</operator><name>hasMultipleContains</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>validateSecondaryIndexSelections</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>checkFalse</name><argument_list>(<argument><expr><call><name>keyIsInRelation</name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr><literal type="string">"Select on indexed columns and with IN clause for the PRIMARY KEY are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks that all the primary key columns (partition key and clustering columns) are restricted by an equality
     * relation ('=' or 'IN').
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all the primary key columns are restricted by an equality relation.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasAllPKColumnsRestrictedByEqualities</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name>isPartitionKeyRestrictionsOnToken</name><argument_list>()</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasUnrestrictedPartitionKeyComponents</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>partitionKeyRestrictions</name><operator>.</operator><name>hasOnlyEqualityRestrictions</name></name><argument_list>()</argument_list></call><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasUnrestrictedClusteringColumns</name><argument_list>()</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>clusteringColumnsRestrictions</name><operator>.</operator><name>hasOnlyEqualityRestrictions</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if one of the restrictions applies to a regular column.
     * @return {@code true} if one of the restrictions applies to a regular column, {@code false} otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasRegularColumnsRestrictions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>hasRegularColumnsRestrictions</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the query is a full partitions selection.
     * @return {@code true} if the query is a full partitions selection, {@code false} otherwise.
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>queriesFullPartitions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name>hasClusteringColumnsRestrictions</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasRegularColumnsRestrictions</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Determines if the query should return the static content when a partition without rows is returned (as a
     * result set row with null for all other regular columns.)
     *
     * @return {@code true} if the query should return the static content when a partition without rows is returned,
     * {@code false} otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>returnStaticContentOnPartitionWithNoRows</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>table</name><operator>.</operator><name>isStaticCompactTable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// The general rationale is that if some rows are specifically selected by the query (have clustering or</comment>
        <comment type="line">// regular columns restrictions), we ignore partitions that are empty outside of static content, but if it's</comment>
        <comment type="line">// a full partition query, then we include that content.</comment>
        <return>return <expr><call><name>queriesFullPartitions</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>ToStringBuilder</name><operator>.</operator><name>reflectionToString</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>ToStringStyle</name><operator>.</operator><name>SHORT_PREFIX_STYLE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
}</block></class>
</unit>
