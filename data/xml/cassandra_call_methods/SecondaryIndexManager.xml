<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/index/SecondaryIndexManager.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>reflect</name><operator>.</operator><name>Constructor</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Function</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>stream</name><operator>.</operator><name>Collectors</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>stream</name><operator>.</operator><name>Stream</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Joiner</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Strings</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>ImmutableSet</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Iterables</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Lists</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Maps</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Sets</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>primitives</name><operator>.</operator><name>Longs</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>FutureCallback</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Futures</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ListenableFuture</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ListeningExecutorService</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>MoreExecutors</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>SettableFuture</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang3</name><operator>.</operator><name>StringUtils</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>JMXEnabledThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>NamedThreadFactory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Stage</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexTarget</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>compaction</name><operator>.</operator><name>CompactionManager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>filter</name><operator>.</operator><name>RowFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>SSTableSet</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>View</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>ValueAccessor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>rows</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>InvalidRequestException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>Index</name><operator>.</operator><name>IndexBuildingSupport</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>internal</name><operator>.</operator><name>CassandraIndex</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>transactions</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>notifications</name><operator>.</operator><name>INotification</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>notifications</name><operator>.</operator><name>INotificationConsumer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>notifications</name><operator>.</operator><name>SSTableAddedNotification</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>ColumnMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>Indexes</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>pager</name><operator>.</operator><name>SinglePartitionPager</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>tracing</name><operator>.</operator><name>Tracing</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>transport</name><operator>.</operator><name>ProtocolVersion</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>JVMStabilityInspector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Refs</name></name>;</import>

<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>ExecutorUtils</name><operator>.</operator><name>awaitTermination</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>ExecutorUtils</name><operator>.</operator><name>shutdown</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Handles the core maintenance functionality associated with indexes: adding/removing them to or from
 * a table, (re)building during bootstrap or other streaming operations, flushing, reloading metadata
 * and so on.
 * &lt;br&gt;&lt;br&gt;
 * The Index interface defines a number of methods which return {@code Callable&lt;?&gt;}. These are primarily the
 * management tasks for an index implementation. Most of them are currently executed in a blocking
 * fashion via submission to SIM's blockingExecutor. This provides the desired behaviour in pretty
 * much all cases, as tasks like flushing an index needs to be executed synchronously to avoid potentially
 * deadlocking on the FlushWriter or PostFlusher. Several of these {@code Callable&lt;?&gt;} returning methods on Index could
 * then be defined with as void and called directly from SIM (rather than being run via the executor service).
 * Separating the task defintion from execution gives us greater flexibility though, so that in future, for example,
 * if the flush process allows it we leave open the possibility of executing more of these tasks asynchronously.
 * &lt;br&gt;&lt;br&gt;
 * The primary exception to the above is the Callable returned from Index#addIndexedColumn. This may
 * involve a significant effort, building a new index over any existing data. We perform this task asynchronously;
 * as it is called as part of a schema update, which we do not want to block for a long period. Building non-custom
 * indexes is performed on the CompactionManager.
 * &lt;br&gt;&lt;br&gt;
 * This class also provides instances of processors which listen to updates to the base table and forward to
 * registered Indexes the info required to keep those indexes up to date.
 * There are two variants of these processors, each with a factory method provided by SIM:
 * IndexTransaction: deals with updates generated on the regular write path.
 * CleanupTransaction: used when partitions are modified during compaction or cleanup operations.
 * Further details on their usage and lifecycles can be found in the interface definitions below.
 * &lt;br&gt;&lt;br&gt;
 * The bestIndexFor method is used at query time to identify the most selective index of those able
 * to satisfy any search predicates defined by a ReadCommand's RowFilter. It returns a thin IndexAccessor object
 * which enables the ReadCommand to access the appropriate functions of the Index at various stages in its lifecycle.
 * e.g. the getEstimatedResultRows is required when StorageProxy calculates the initial concurrency factor for
 * distributing requests to replicas, whereas a Searcher instance is needed when the ReadCommand is executed locally on
 * a target replica.
 * &lt;br&gt;&lt;br&gt;
 * Finally, this class provides a clear and safe lifecycle to manage index builds, either full rebuilds via
 * {@link this#rebuildIndexesBlocking(Set)} or builds of new sstables
 * added via {@link org.apache.cassandra.notifications.SSTableAddedNotification}s, guaranteeing
 * the following:
 * &lt;ul&gt;
 * &lt;li&gt;The initialization task and any subsequent successful (re)build mark the index as built.&lt;/li&gt;
 * &lt;li&gt;If any (re)build operation fails, the index is not marked as built, and only another full rebuild can mark the
 * index as built.&lt;/li&gt;
 * &lt;li&gt;Full rebuilds cannot be run concurrently with other full or sstable (re)builds.&lt;/li&gt;
 * &lt;li&gt;SSTable builds can always be run concurrently with any other builds.&lt;/li&gt;
 * &lt;/ul&gt;
 */</comment>
<class><specifier>public</specifier> class <name>SecondaryIndexManager</name> <super_list><implements>implements <super><name>IndexRegistry</name></super>, <super><name>INotificationConsumer</name></super></implements></super_list>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>SecondaryIndexManager</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// default page size (in rows) when rebuilding the index for a whole partition</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_PAGE_SIZE</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * All registered indexes.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name> <init>= <expr><call><name><name>Maps</name><operator>.</operator><name>newConcurrentMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The indexes that had a build failure.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>needsFullRebuild</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>newConcurrentHashSet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The indexes that are available for querying.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>queryableIndexes</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>newConcurrentHashSet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <comment type="block" format="javadoc">/**
     * The indexes that are available for writing.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>writableIndexes</name> <init>= <expr><call><name><name>Maps</name><operator>.</operator><name>newConcurrentMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The count of pending index builds for each index.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>AtomicInteger</name></argument>&gt;</argument_list></name></type> <name>inProgressBuilds</name> <init>= <expr><call><name><name>Maps</name><operator>.</operator><name>newConcurrentMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// executes tasks returned by Indexer#addIndexColumn which may require index(es) to be (re)built</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ListeningExecutorService</name></type> <name>asyncExecutor</name> <init>= <expr><call><name><name>MoreExecutors</name><operator>.</operator><name>listeningDecorator</name></name><argument_list>(
    <argument><expr><operator>new</operator> <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                                     <argument><expr><name><name>Stage</name><operator>.</operator><name>KEEP_ALIVE_SECONDS</name></name></expr></argument>,
                                     <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>,
                                     <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr><operator>new</operator> <call><name>NamedThreadFactory</name><argument_list>(<argument><expr><literal type="string">"SecondaryIndexManagement"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// executes all blocking tasks produced by Indexers e.g. getFlushTask, getMetadataReloadTask etc</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ListeningExecutorService</name></type> <name>blockingExecutor</name> <init>= <expr><call><name><name>MoreExecutors</name><operator>.</operator><name>newDirectExecutorService</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * The underlying column family containing the source data for these indexes
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>baseCfs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Keyspace</name></type> <name>keyspace</name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>SecondaryIndexManager</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>baseCfs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>baseCfs</name></name> <operator>=</operator> <name>baseCfs</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keyspace</name></name> <operator>=</operator> <name><name>baseCfs</name><operator>.</operator><name>keyspace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>baseCfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>subscribe</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Drops and adds new indexes associated with the underlying CF
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>reload</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// figure out what needs to be added and dropped.</comment>
        <decl_stmt><decl><type><name>Indexes</name></type> <name>tableIndexes</name> <init>= <expr><call><name><name>baseCfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>indexes</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call>
               <operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
               <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>indexName</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>tableIndexes</name><operator>.</operator><name>has</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
               <operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>this</name><operator>::</operator><name>removeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// we call add for every index definition in the collection as</comment>
        <comment type="line">// some may not have been created here yet, only added to schema</comment>
        <for>for <control>(<init><decl><type><name>IndexMetadata</name></type> <name>tableIndex</name> <range>: <expr><name>tableIndexes</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addIndex</name><argument_list>(<argument><expr><name>tableIndex</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>reloadIndex</name><parameter_list>(<parameter><decl><type><name>IndexMetadata</name></type> <name>indexDef</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name><name>indexes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>indexDef</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>reloadTask</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getMetadataReloadTask</name></name><argument_list>(<argument><expr><name>indexDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>reloadTask</name> <operator>==</operator> <literal type="null">null</literal></expr>
               ?</condition><then> <expr><call><name><name>Futures</name><operator>.</operator><name>immediateFuture</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>
               </then><else>: <expr><call><name><name>blockingExecutor</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><name>reloadTask</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>private</specifier> <specifier>synchronized</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>createIndex</name><parameter_list>(<parameter><decl><type><name>IndexMetadata</name></type> <name>indexDef</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isNewCF</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Index</name></type> <name>index</name> <init>= <expr><call><name>createInstance</name><argument_list>(<argument><expr><name>indexDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>index</name><operator>.</operator><name>register</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>writableIndexes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index [{}] registered and writable."</literal></expr></argument>, <argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>markIndexesBuilding</name><argument_list>(<argument><expr><call><name><name>ImmutableSet</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>isNewCF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>initialBuildTask</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// if the index didn't register itself, we can probably assume that no initialization needs to happen</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexes</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name><name>indexDef</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><name>initialBuildTask</name> <operator>=</operator> <call><name><name>index</name><operator>.</operator><name>getInitializationTask</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>logAndMarkIndexesFailed</name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <throw>throw <expr><name>t</name></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// if there's no initialization, just mark as built and return:</comment>
        <if_stmt><if>if <condition>(<expr><name>initialBuildTask</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>markIndexBuilt</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>Futures</name><operator>.</operator><name>immediateFuture</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// otherwise run the initialization task asynchronously with a callback to mark it built or failed</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>SettableFuture</name></type> <name>initialization</name> <init>= <expr><call><name><name>SettableFuture</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Futures</name><operator>.</operator><name>addCallback</name></name><argument_list>(<argument><expr><call><name><name>asyncExecutor</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><name>initialBuildTask</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>FutureCallback</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>logAndMarkIndexesFailed</name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>initialization</name><operator>.</operator><name>setException</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>o</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>markIndexBuilt</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>initialization</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><call><name><name>MoreExecutors</name><operator>.</operator><name>directExecutor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>initialization</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Adds and builds a index
     *
     * @param indexDef the IndexMetadata describing the index
     * @param isNewCF true if the index is added as part of a new table/columnfamily (i.e. loading a CF at startup), 
     * false for all other cases (i.e. newly added index)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>addIndex</name><parameter_list>(<parameter><decl><type><name>IndexMetadata</name></type> <name>indexDef</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isNewCF</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexes</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name><name>indexDef</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>reloadIndex</name><argument_list>(<argument><expr><name>indexDef</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><call><name>createIndex</name><argument_list>(<argument><expr><name>indexDef</name></expr></argument>, <argument><expr><name>isNewCF</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the specified index is queryable.
     *
     * @param index the index
     * @return &lt;code&gt;true&lt;/code&gt; if the specified index is queryable, &lt;code&gt;false&lt;/code&gt; otherwise
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isIndexQueryable</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>queryableIndexes</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    
    <comment type="block" format="javadoc">/**
     * Checks if the specified index is writable.
     *
     * @param index the index
     * @return &lt;code&gt;true&lt;/code&gt; if the specified index is writable, &lt;code&gt;false&lt;/code&gt; otherwise
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isIndexWritable</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>writableIndexes</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the specified index has any running build task.
     *
     * @param indexName the index name
     * @return {@code true} if the index is building, {@code false} otherwise
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>synchronized</specifier> <name>boolean</name></type> <name>isIndexBuilding</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>indexName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AtomicInteger</name></type> <name>counter</name> <init>= <expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>counter</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>counter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>removeIndex</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>indexName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type> <name>index</name> <init>= <expr><call><name>unregisterIndex</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>index</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>markIndexRemoved</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>executeBlocking</name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getInvalidateTask</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>


    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>IndexMetadata</name></argument>&gt;</argument_list></name></type> <name>getDependentIndexes</name><parameter_list>(<parameter><decl><type><name>ColumnMetadata</name></type> <name>column</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptySet</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>IndexMetadata</name></argument>&gt;</argument_list></name></type> <name>dependentIndexes</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>index</name><operator>.</operator><name>dependsOn</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>dependentIndexes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

        <return>return <expr><name>dependentIndexes</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Called when dropping a Table
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>markAllIndexesRemoved</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>getBuiltIndexNames</name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>this</name><operator>::</operator><name>markIndexRemoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Does a blocking full rebuild/recovery of the specifed indexes from all the sstables in the base table.
     * Note also that this method of (re)building/recovering indexes:
     * a) takes a set of index *names* rather than Indexers
     * b) marks existing indexes removed prior to rebuilding
     * c) fails if such marking operation conflicts with any ongoing index builds, as full rebuilds cannot be run
     * concurrently
     *
     * @param indexNames the list of indexes to be rebuilt
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>rebuildIndexesBlocking</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>indexNames</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// Get the set of indexes that require blocking build</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>toRebuild</name> <init>= <expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call>
                                      <operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
                                      <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>indexNames</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                      <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>Index</name><operator>::</operator><name>shouldBuildBlocking</name></expr></argument>)</argument_list></call>
                                      <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toSet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>toRebuild</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"No defined indexes with the supplied names: {}"</literal></expr></argument>, <argument><expr><call><name><name>Joiner</name><operator>.</operator><name>on</name></name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>join</name><argument_list>(<argument><expr><name>indexNames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Optimistically mark the indexes as writable, so we don't miss incoming writes</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>needsFlush</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><name>toRebuild</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>writableIndexes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index [{}] became writable starting recovery."</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>needsFlush</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Once we are tracking new writes, flush any memtable contents to not miss them from the sstable-based rebuild</comment>
        <if_stmt><if>if <condition>(<expr><name>needsFlush</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>baseCfs</name><operator>.</operator><name>forceBlockingFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Now that we are tracking new writes and we haven't left untracked contents on the memtables, we are ready to</comment>
        <comment type="line">// index the sstables</comment>
        <try>try <init>(<decl><type><name><name>ColumnFamilyStore</name><operator>.</operator><name>RefViewFragment</name></name></type> <name>viewFragment</name> <init>= <expr><call><name><name>baseCfs</name><operator>.</operator><name>selectAndReference</name></name><argument_list>(<argument><expr><call><name><name>View</name><operator>.</operator><name>selectFunction</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>allSSTables</name> <init>= <expr><name><name>viewFragment</name><operator>.</operator><name>refs</name></name></expr></init></decl>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name>buildIndexesBlocking</name><argument_list>(<argument><expr><name>allSSTables</name></expr></argument>, <argument><expr><name>toRebuild</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the specified {@link ColumnFamilyStore} is a secondary index.
     *
     * @param cfs the &lt;code&gt;ColumnFamilyStore&lt;/code&gt; to check.
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;ColumnFamilyStore&lt;/code&gt; is a secondary index,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isIndexColumnFamilyStore</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>isIndexColumnFamily</name><argument_list>(<argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Checks if the specified {@link ColumnFamilyStore} is the one secondary index.
     *
     * @param cfName the name of the &lt;code&gt;ColumnFamilyStore&lt;/code&gt; to check.
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;ColumnFamilyStore&lt;/code&gt; is a secondary index,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isIndexColumnFamily</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>cfName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>cfName</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Directories</name><operator>.</operator><name>SECONDARY_INDEX_NAME_SEPARATOR</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the parent of the specified {@link ColumnFamilyStore}.
     *
     * @param cfs the &lt;code&gt;ColumnFamilyStore&lt;/code&gt;
     * @return the parent of the specified &lt;code&gt;ColumnFamilyStore&lt;/code&gt;
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamilyStore</name></type> <name>getParentCfs</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>parentCfs</name> <init>= <expr><call><name>getParentCfsName</name><argument_list>(<argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>parentCfs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the parent name of the specified {@link ColumnFamilyStore}.
     *
     * @param cfName the &lt;code&gt;ColumnFamilyStore&lt;/code&gt; name
     * @return the parent name of the specified &lt;code&gt;ColumnFamilyStore&lt;/code&gt;
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getParentCfsName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>cfName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name>isIndexColumnFamily</name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr>;</assert>
        <return>return <expr><call><name><name>StringUtils</name><operator>.</operator><name>substringBefore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>, <argument><expr><name><name>Directories</name><operator>.</operator><name>SECONDARY_INDEX_NAME_SEPARATOR</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the index name
     *
     * @param cfs the &lt;code&gt;ColumnFamilyStore&lt;/code&gt;
     * @return the index name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getIndexName</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getIndexName</name><argument_list>(<argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the index name
     *
     * @param cfName the &lt;code&gt;ColumnFamilyStore&lt;/code&gt; name
     * @return the index name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getIndexName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>cfName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name>isIndexColumnFamily</name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr>;</assert>
        <return>return <expr><call><name><name>StringUtils</name><operator>.</operator><name>substringAfter</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>, <argument><expr><name><name>Directories</name><operator>.</operator><name>SECONDARY_INDEX_NAME_SEPARATOR</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Performs a blocking (re)indexing/recovery of the specified SSTables for the specified indexes.
     *
     * If the index doesn't support ALL {@link Index.LoadType} it performs a recovery {@link Index#getRecoveryTaskSupport()}
     * instead of a build {@link Index#getBuildTaskSupport()}
     * 
     * @param sstables      the SSTables to be (re)indexed
     * @param indexes       the indexes to be (re)built for the specifed SSTables
     * @param isFullRebuild True if this method is invoked as a full index rebuild, false otherwise
     */</comment>
    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><block>{ <expr><literal type="string">"unchecked"</literal></expr> }</block></expr></argument>)</argument_list></annotation>
    <type><specifier>private</specifier> <name>void</name></type> <name>buildIndexesBlocking</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>, <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isFullRebuild</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="line">// Mark all indexes as building: this step must happen first, because if any index can't be marked, the whole</comment>
        <comment type="line">// process needs to abort</comment>
        <expr_stmt><expr><call><name>markIndexesBuilding</name><argument_list>(<argument><expr><name>indexes</name></expr></argument>, <argument><expr><name>isFullRebuild</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Build indexes in a try/catch, so that any index not marked as either built or failed will be marked as failed:</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>builtIndexes</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>newConcurrentHashSet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>unbuiltIndexes</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>newConcurrentHashSet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Any exception thrown during index building that could be suppressed by the finally block</comment>
        <decl_stmt><decl><type><name>Exception</name></type> <name>accumulatedFail</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Submitting index {} of {} for data in {}"</literal></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>isFullRebuild</name></expr> ?</condition><then> <expr><literal type="string">"recovery"</literal></expr> </then><else>: <expr><literal type="string">"build"</literal></expr></else></ternary></expr></argument>,
                        <argument><expr><call><name><name>indexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>joining</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>sstables</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>SSTableReader</name><operator>::</operator><name>toString</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>joining</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Group all building tasks</comment>
            <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name><name>Index</name><operator>.</operator><name>IndexBuildingSupport</name></name></argument>, <argument><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>byType</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><name>indexes</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IndexBuildingSupport</name></type> <name>buildOrRecoveryTask</name> <init>= <expr><ternary><condition><expr><name>isFullRebuild</name></expr>
                                                           ?</condition><then> <expr><call><name><name>index</name><operator>.</operator><name>getBuildTaskSupport</name></name><argument_list>()</argument_list></call></expr>
                                                           </then><else>: <expr><call><name><name>index</name><operator>.</operator><name>getRecoveryTaskSupport</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>stored</name> <init>= <expr><call><name><name>byType</name><operator>.</operator><name>computeIfAbsent</name></name><argument_list>(<argument><expr><name>buildOrRecoveryTask</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>stored</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">// Schedule all index building tasks with a callback to mark them as built or failed</comment>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>byType</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>byType</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>buildingSupport</name></decl></parameter>, <parameter><decl><name>groupedIndexes</name></decl></parameter>)</parameter_list> -&gt;
                           <block>{<block_content>
                               <decl_stmt><decl><type><name>SecondaryIndexBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>buildingSupport</name><operator>.</operator><name>getIndexBuildTask</name></name><argument_list>(<argument><expr><name>baseCfs</name></expr></argument>, <argument><expr><name>groupedIndexes</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                               <decl_stmt><decl><type><specifier>final</specifier> <name>SettableFuture</name></type> <name>build</name> <init>= <expr><call><name><name>SettableFuture</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                               <expr_stmt><expr><call><name><name>Futures</name><operator>.</operator><name>addCallback</name></name><argument_list>(<argument><expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>submitIndexBuild</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>FutureCallback</name></super><argument_list>()</argument_list>
                               <block>{
                                   <function><annotation>@<name>Override</name></annotation>
                                   <type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
                                   <block>{<block_content>
                                       <expr_stmt><expr><call><name>logAndMarkIndexesFailed</name><argument_list>(<argument><expr><name>groupedIndexes</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                       <expr_stmt><expr><call><name><name>unbuiltIndexes</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>groupedIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                       <expr_stmt><expr><call><name><name>build</name><operator>.</operator><name>setException</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                   </block_content>}</block></function>

                                   <function><annotation>@<name>Override</name></annotation>
                                   <type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>o</name></decl></parameter>)</parameter_list>
                                   <block>{<block_content>
                                       <expr_stmt><expr><call><name><name>groupedIndexes</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>markIndexBuilt</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>isFullRebuild</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                       <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index build of {} completed"</literal></expr></argument>, <argument><expr><call><name>getIndexNames</name><argument_list>(<argument><expr><name>groupedIndexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                       <expr_stmt><expr><call><name><name>builtIndexes</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>groupedIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                       <expr_stmt><expr><call><name><name>build</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                   </block_content>}</block></function>
                               }</block></class></expr></argument>, <argument><expr><call><name><name>MoreExecutors</name><operator>.</operator><name>directExecutor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                               <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>build</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                           </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Finally wait for the index builds to finish and flush the indexes that built successfully</comment>
            <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>accumulatedFail</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        </block_content>}</block></catch>
        <finally>finally
        <block>{<block_content>
            <try>try
            <block>{<block_content>
                <comment type="line">// Fail any indexes that couldn't be marked</comment>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>failedIndexes</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>difference</name></name><argument_list>(<argument><expr><name>indexes</name></expr></argument>, <argument><expr><call><name><name>Sets</name><operator>.</operator><name>union</name></name><argument_list>(<argument><expr><name>builtIndexes</name></expr></argument>, <argument><expr><name>unbuiltIndexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>failedIndexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>logAndMarkIndexesFailed</name><argument_list>(<argument><expr><name>failedIndexes</name></expr></argument>, <argument><expr><name>accumulatedFail</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Flush all built indexes with an aynchronous callback to log the success or failure of the flush</comment>
                <expr_stmt><expr><call><name>flushIndexesBlocking</name><argument_list>(<argument><expr><name>builtIndexes</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>FutureCallback</name></super><argument_list>()</argument_list>
                <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>indexNames</name> <init>= <expr><call><name><name>StringUtils</name><operator>.</operator><name>join</name></name><argument_list>(<argument><expr><call><name><name>builtIndexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                                                                     <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                                                     <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <function><annotation>@<name>Override</name></annotation>
                    <type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>ignored</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index flush of {} failed"</literal></expr></argument>, <argument><expr><name>indexNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></function>

                    <function><annotation>@<name>Override</name></annotation>
                    <type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>ignored</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index flush of {} completed"</literal></expr></argument>, <argument><expr><name>indexNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></function>
                }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>accumulatedFail</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>accumulatedFail</name><operator>.</operator><name>addSuppressed</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <throw>throw <expr><name>e</name></expr>;</throw>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>getIndexNames</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>indexNames</name> <init>= <expr><call><name><name>indexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                                         <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                         <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>StringUtils</name><operator>.</operator><name>join</name></name><argument_list>(<argument><expr><name>indexNames</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Marks the specified indexes as (re)building if:
     * 1) There's no in progress rebuild of any of the given indexes.
     * 2) There's an in progress rebuild but the caller is not a full rebuild.
     * &lt;p&gt;
     * Otherwise, this method invocation fails, as it is not possible to run full rebuilds while other concurrent rebuilds
     * are in progress. Please note this is checked atomically against all given indexes; that is, no index will be marked
     * if even a single one fails.
     * &lt;p&gt;
     * Marking an index as "building" practically means:
     * 1) The index is removed from the "failed" set if this is a full rebuild.
     * 2) The index is removed from the system keyspace built indexes; this only happens if this method is not invoked
     * for a new table initialization, as in such case there's no need to remove it (it is either already not present,
     * or already present because already built).
     * &lt;p&gt;
     * Thread safety is guaranteed by having all methods managing index builds synchronized: being synchronized on
     * the SecondaryIndexManager instance, it means all invocations for all different indexes will go through the same
     * lock, but this is fine as the work done while holding such lock is trivial.
     * &lt;p&gt;
     * {@link #markIndexBuilt(Index, boolean)} or {@link #markIndexFailed(Index, boolean)} should be always called after
     * the rebuilding has finished, so that the index build state can be correctly managed and the index rebuilt.
     *
     * @param indexes the index to be marked as building
     * @param isFullRebuild {@code true} if this method is invoked as a full index rebuild, {@code false} otherwise
     * @param isNewCF {@code true} if this method is invoked when initializing a new table/columnfamily (i.e. loading a CF at startup), 
     * {@code false} for all other cases (i.e. newly added index)
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>markIndexesBuilding</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isFullRebuild</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isNewCF</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>keyspaceName</name> <init>= <expr><call><name><name>baseCfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// First step is to validate against concurrent rebuilds; it would be more optimized to do everything on a single</comment>
        <comment type="line">// step, but we're not really expecting a very high number of indexes, and this isn't on any hot path, so</comment>
        <comment type="line">// we're favouring readability over performance</comment>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>String</name></type> <name>indexName</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>AtomicInteger</name></type> <name>counter</name> <init>= <expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>computeIfAbsent</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ignored</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>new</operator> <call><name>AtomicInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name><name>counter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isFullRebuild</name></expr>)</condition><block type="pseudo"><block_content>
                                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Cannot rebuild index %s as another index build for the same index is currently in progress."</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
                        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Second step is the actual marking:</comment>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>String</name></type> <name>indexName</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>AtomicInteger</name></type> <name>counter</name> <init>= <expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>computeIfAbsent</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ignored</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>new</operator> <call><name>AtomicInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>isFullRebuild</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name><name>needsFullRebuild</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name><name>counter</name><operator>.</operator><name>getAndIncrement</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>isDaemonInitialized</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNewCF</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>setIndexRemoved</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Marks the specified index as built if there are no in progress index builds and the index is not failed.
     * {@link #markIndexesBuilding(Set, boolean, boolean)} should always be invoked before this method.
     *
     * @param index the index to be marked as built
     * @param isFullRebuild {@code true} if this method is invoked as a full index rebuild, {@code false} otherwise
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>markIndexBuilt</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isFullRebuild</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>indexName</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>isFullRebuild</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>queryableIndexes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index [{}] became queryable after successful build."</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>writableIndexes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index [{}] became writable after successful build."</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <decl_stmt><decl><type><name>AtomicInteger</name></type> <name>counter</name> <init>= <expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>counter</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <assert>assert <expr><call><name><name>counter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>
            <if_stmt><if>if <condition>(<expr><call><name><name>counter</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>needsFullRebuild</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>isDaemonInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>setIndexBuilt</name></name><argument_list>(<argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Marks the specified index as failed.
     * {@link #markIndexesBuilding(Set, boolean, boolean)} should always be invoked before this method.
     *
     * @param index the index to be marked as built
     * @param isInitialBuild {@code true} if the index failed during its initial build, {@code false} otherwise
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>markIndexFailed</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isInitialBuild</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>indexName</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>AtomicInteger</name></type> <name>counter</name> <init>= <expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>counter</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <assert>assert <expr><call><name><name>counter</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>

            <expr_stmt><expr><call><name><name>counter</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>isDaemonInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>setIndexRemoved</name></name><argument_list>(<argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>needsFullRebuild</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>index</name><operator>.</operator><name>getSupportedLoadTypeOnFailure</name></name><argument_list>(<argument><expr><name>isInitialBuild</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>supportsWrites</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>writableIndexes</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index [{}] became not-writable because of failed build."</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>index</name><operator>.</operator><name>getSupportedLoadTypeOnFailure</name></name><argument_list>(<argument><expr><name>isInitialBuild</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>supportsReads</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>queryableIndexes</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Index [{}] became not-queryable because of failed build."</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>logAndMarkIndexesFailed</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>, <parameter><decl><type><name>Throwable</name></type> <name>indexBuildFailure</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isInitialBuild</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>JVMStabilityInspector</name><operator>.</operator><name>inspectThrowable</name></name><argument_list>(<argument><expr><name>indexBuildFailure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>indexBuildFailure</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Index build of {} failed. Please run full index rebuild to fix it."</literal></expr></argument>, <argument><expr><call><name>getIndexNames</name><argument_list>(<argument><expr><name>indexes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indexBuildFailure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Index build of {} failed. Please run full index rebuild to fix it."</literal></expr></argument>, <argument><expr><call><name>getIndexNames</name><argument_list>(<argument><expr><name>indexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>this</name><operator>.</operator><name>markIndexFailed</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>isInitialBuild</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Marks the specified index as removed.
     *
     * @param indexName the index name
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>markIndexRemoved</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>indexName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>setIndexRemoved</name></name><argument_list>(<argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>queryableIndexes</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>writableIndexes</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>needsFullRebuild</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>inProgressBuilds</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Index</name></type> <name>getIndexByName</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>indexName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>indexes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Index</name></type> <name>createInstance</name><parameter_list>(<parameter><decl><type><name>IndexMetadata</name></type> <name>indexDef</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type> <name>newIndex</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexDef</name><operator>.</operator><name>isCustom</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <assert>assert <expr><name><name>indexDef</name><operator>.</operator><name>options</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <decl_stmt><decl><type><name>String</name></type> <name>className</name> <init>= <expr><call><name><name>indexDef</name><operator>.</operator><name>options</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>IndexTarget</name><operator>.</operator><name>CUSTOM_INDEX_OPTION_NAME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><operator>!</operator><call><name><name>Strings</name><operator>.</operator><name>isNullOrEmpty</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</assert>
            <try>try
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>Index</name></extends></argument>&gt;</argument_list></name></type> <name>indexClass</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>classForName</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><literal type="string">"Index"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Constructor</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>Index</name></extends></argument>&gt;</argument_list></name></type> <name>ctor</name> <init>= <expr><call><name><name>indexClass</name><operator>.</operator><name>getConstructor</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><name><name>IndexMetadata</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>newIndex</name> <operator>=</operator> <call><name><name>ctor</name><operator>.</operator><name>newInstance</name></name><argument_list>(<argument><expr><name>baseCfs</name></expr></argument>, <argument><expr><name>indexDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>newIndex</name> <operator>=</operator> <call><name><name>CassandraIndex</name><operator>.</operator><name>newIndex</name></name><argument_list>(<argument><expr><name>baseCfs</name></expr></argument>, <argument><expr><name>indexDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>newIndex</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Truncate all indexes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>truncateAllIndexesBlocking</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>long</name></type> <name>truncatedAt</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>executeAllBlocking</name><argument_list>(<argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><parameter_list>(<parameter><decl><name>index</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>index</name><operator>.</operator><name>getTruncateTask</name></name><argument_list>(<argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Remove all indexes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>dropAllIndexes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>markAllIndexesRemoved</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>invalidateAllIndexesBlocking</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>invalidateAllIndexesBlocking</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>executeAllBlocking</name><argument_list>(<argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Index</name><operator>::</operator><name>getInvalidateTask</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Perform a blocking flush all indexes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>flushAllIndexesBlocking</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>flushIndexesBlocking</name><argument_list>(<argument><expr><call><name><name>ImmutableSet</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Perform a blocking flush of selected indexes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>flushIndexesBlocking</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>flushIndexesBlocking</name><argument_list>(<argument><expr><name>indexes</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Performs a blocking flush of all custom indexes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>flushAllNonCFSBackedIndexesBlocking</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>executeAllBlocking</name><argument_list>(<argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call>
                                  <operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
                                  <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>index</name><operator>.</operator><name>getBackingTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPresent</name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>Index</name><operator>::</operator><name>getBlockingFlushTask</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Performs a blocking execution of pre-join tasks of all indexes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>executePreJoinTasksBlocking</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>hadBootstrap</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Executing pre-join{} tasks for: {}"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>hadBootstrap</name></expr> ?</condition><then> <expr><literal type="string">" post-bootstrap"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>baseCfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>executeAllBlocking</name><argument_list>(<argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><parameter_list>(<parameter><decl><name>index</name></decl></parameter>)</parameter_list> -&gt;
        <block>{<block_content>
            <return>return <expr><call><name><name>index</name><operator>.</operator><name>getPreJoinTask</name></name><argument_list>(<argument><expr><name>hadBootstrap</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></lambda></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>flushIndexesBlocking</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>, <parameter><decl><type><name><name>FutureCallback</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>callback</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>wait</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>nonCfsIndexes</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// for each CFS backed index, submit a flush task which we'll wait on for completion</comment>
        <comment type="line">// for the non-CFS backed indexes, we'll flush those while we wait.</comment>
        <synchronized>synchronized <init>(<expr><call><name><name>baseCfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call></expr>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content>
                            <expr><call><name><name>index</name><operator>.</operator><name>getBackingTable</name></name><argument_list>()</argument_list></call>
                                 <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>cfs</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>wait</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>forceFlush</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                 <operator>.</operator><call><name>orElseGet</name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>nonCfsIndexes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></synchronized>

        <expr_stmt><expr><call><name>executeAllBlocking</name><argument_list>(<argument><expr><call><name><name>nonCfsIndexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Index</name><operator>::</operator><name>getBlockingFlushTask</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return all indexes which are marked as built and ready to use
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getBuiltIndexNames</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>allIndexNames</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
               <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
               <operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>allIndexNames</name><operator>::</operator><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>getBuiltIndexes</name></name><argument_list>(<argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>allIndexNames</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return all backing Tables used by registered indexes
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>getAllIndexColumnFamilyStores</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>backingTables</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>index</name><operator>.</operator><name>getBackingTable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ifPresent</name><argument_list>(<argument><expr><name>backingTables</name><operator>::</operator><name>add</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>backingTables</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return if there are ANY indexes registered for this table
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasIndexes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * When building an index against existing data in sstables, add the given partition to the index
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>indexPartition</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageSize</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Indexing partition {}"</literal></expr></argument>, <argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>partitionKeyType</name><operator>.</operator><name>getString</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SinglePartitionReadCommand</name></type> <name>cmd</name> <init>= <expr><call><name><name>SinglePartitionReadCommand</name><operator>.</operator><name>fullPartitionRead</name></name><argument_list>(<argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                          <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                          <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nowInSec</name> <init>= <expr><call><name><name>cmd</name><operator>.</operator><name>nowInSec</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>readStatic</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>SinglePartitionPager</name></type> <name>pager</name> <init>= <expr><operator>new</operator> <call><name>SinglePartitionPager</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>ProtocolVersion</name><operator>.</operator><name>CURRENT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>!</operator><call><name><name>pager</name><operator>.</operator><name>isExhausted</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <try>try <init>(<decl><type><name>ReadExecutionController</name></type> <name>controller</name> <init>= <expr><call><name><name>cmd</name><operator>.</operator><name>executionController</name></name><argument_list>()</argument_list></call></expr></init></decl>;
                     <decl><type><name>WriteContext</name></type> <name>ctx</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getWriteHandler</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>createContextForIndexing</name><argument_list>()</argument_list></call></expr></init></decl>;
                     <decl><type><name>UnfilteredPartitionIterator</name></type> <name>page</name> <init>= <expr><call><name><name>pager</name><operator>.</operator><name>fetchPageUnfiltered</name></name><argument_list>(<argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>, <argument><expr><name>controller</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>page</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>

                    <try>try <init>(<decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name> <init>= <expr><call><name><name>page</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>)</init>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Index</name><operator>.</operator><name>Indexer</name></name></argument>&gt;</argument_list></name></type> <name>indexers</name> <init>= <expr><call><name><name>indexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                                                             <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>index</name><operator>.</operator><name>indexerFor</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>,
                                                                                            <argument><expr><call><name><name>partition</name><operator>.</operator><name>columns</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                                            <argument><expr><name>nowInSec</name></expr></argument>,
                                                                                            <argument><expr><name>ctx</name></expr></argument>,
                                                                                            <argument><expr><name><name>IndexTransaction</name><operator>.</operator><name>Type</name><operator>.</operator><name>UPDATE</name></name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                                             <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>Objects</name><operator>::</operator><name>nonNull</name></expr></argument>)</argument_list></call>
                                                             <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toSet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Short-circuit empty partitions if static row is processed or isn't read</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>readStatic</name> <operator>&amp;&amp;</operator> <call><name><name>partition</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>partition</name><operator>.</operator><name>staticRow</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>

                        <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><name><name>Index</name><operator>.</operator><name>Indexer</name></name><operator>::</operator><name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>readStatic</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>partition</name><operator>.</operator><name>staticRow</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>indexer</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>indexer</name><operator>.</operator><name>insertRow</name></name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>staticRow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>i</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>partitionDelete</name></name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>readStatic</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <decl_stmt><decl><type><name><name>MutableDeletionInfo</name><operator>.</operator><name>Builder</name></name></type> <name>deletionBuilder</name> <init>= <expr><call><name><name>MutableDeletionInfo</name><operator>.</operator><name>builder</name></name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>baseCfs</name><operator>.</operator><name>getComparator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <while>while <condition>(<expr><call><name><name>partition</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Unfiltered</name></type> <name>unfilteredRow</name> <init>= <expr><call><name><name>partition</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name><name>unfilteredRow</name><operator>.</operator><name>isRow</name></name><argument_list>()</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>Row</name></type> <name>row</name> <init>= <expr><operator>(</operator><name>Row</name><operator>)</operator> <name>unfilteredRow</name></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>indexer</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>indexer</name><operator>.</operator><name>insertRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <assert>assert <expr><call><name><name>unfilteredRow</name><operator>.</operator><name>isRangeTombstoneMarker</name></name><argument_list>()</argument_list></call></expr>;</assert>
                                <decl_stmt><decl><type><name>RangeTombstoneMarker</name></type> <name>marker</name> <init>= <expr><operator>(</operator><name>RangeTombstoneMarker</name><operator>)</operator> <name>unfilteredRow</name></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>deletionBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></while>

                        <decl_stmt><decl><type><name>MutableDeletionInfo</name></type> <name>deletionInfo</name> <init>= <expr><call><name><name>deletionBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>deletionInfo</name><operator>.</operator><name>hasRanges</name></name><argument_list>()</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>RangeTombstone</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>deletionInfo</name><operator>.</operator><name>rangeIterator</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <while>while <condition>(<expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>RangeTombstone</name></type> <name>rt</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>indexer</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>indexer</name><operator>.</operator><name>rangeTombstone</name></name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></while>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><name><name>Index</name><operator>.</operator><name>Indexer</name></name><operator>::</operator><name>finish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></try>
                </block_content>}</block></try>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Return the page size used when indexing an entire partition
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>calculateIndexingPageSize</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>Boolean</name><operator>.</operator><name>getBoolean</name></name><argument_list>(<argument><expr><literal type="string">"cassandra.force_default_indexing_page_size"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>DEFAULT_PAGE_SIZE</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>targetPageSizeInBytes</name> <init>= <expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>meanPartitionSize</name> <init>= <expr><call><name><name>baseCfs</name><operator>.</operator><name>getMeanPartitionSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>meanPartitionSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>DEFAULT_PAGE_SIZE</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>meanCellsPerPartition</name> <init>= <expr><call><name><name>baseCfs</name><operator>.</operator><name>getMeanEstimatedCellPerPartitionCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>meanCellsPerPartition</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>DEFAULT_PAGE_SIZE</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>columnsPerRow</name> <init>= <expr><call><name><name>baseCfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>regularColumns</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>columnsPerRow</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>DEFAULT_PAGE_SIZE</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>meanRowsPerPartition</name> <init>= <expr><name>meanCellsPerPartition</name> <operator>/</operator> <name>columnsPerRow</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>meanRowSize</name> <init>= <expr><name>meanPartitionSize</name> <operator>/</operator> <name>meanRowsPerPartition</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>pageSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>DEFAULT_PAGE_SIZE</name></expr></argument>, <argument><expr><name>targetPageSizeInBytes</name> <operator>/</operator> <name>meanRowSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Calculated page size {} for indexing {}.{} ({}/{}/{}/{})"</literal></expr></argument>,
                     <argument><expr><name>pageSize</name></expr></argument>,
                     <argument><expr><name><name>baseCfs</name><operator>.</operator><name>metadata</name><operator>.</operator><name>keyspace</name></name></expr></argument>,
                     <argument><expr><name><name>baseCfs</name><operator>.</operator><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>,
                     <argument><expr><name>meanPartitionSize</name></expr></argument>,
                     <argument><expr><name>meanCellsPerPartition</name></expr></argument>,
                     <argument><expr><name>meanRowsPerPartition</name></expr></argument>,
                     <argument><expr><name>meanRowSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>pageSize</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Delete all data from all indexes for this partition.
     * For when cleanup rips a partition out entirely.
     * &lt;p&gt;
     * TODO : improve cleanup transaction to batch updates and perform them async
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>deletePartition</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// we need to acquire memtable lock because secondary index deletion may</comment>
        <comment type="line">// cause a race (see CASSANDRA-3712). This is done internally by the</comment>
        <comment type="line">// index transaction when it commits</comment>
        <decl_stmt><decl><type><name>CleanupTransaction</name></type> <name>indexTransaction</name> <init>= <expr><call><name>newCleanupTransaction</name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                    <argument><expr><call><name><name>partition</name><operator>.</operator><name>columns</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                    <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>onPartitionDeletion</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>DeletionTime</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>timestampMicros</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name><name>partition</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Unfiltered</name></type> <name>unfiltered</name> <init>= <expr><call><name><name>partition</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>unfiltered</name><operator>.</operator><name>kind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>Unfiltered</name><operator>.</operator><name>Kind</name><operator>.</operator><name>ROW</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>indexTransaction</name> <operator>=</operator> <call><name>newCleanupTransaction</name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name><name>partition</name><operator>.</operator><name>columns</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                     <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>onRowDelete</name></name><argument_list>(<argument><expr><operator>(</operator><name>Row</name><operator>)</operator> <name>unfiltered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>indexTransaction</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Called at query time to choose which (if any) of the registered index implementations to use for a given query.
     * &lt;p&gt;
     * This is a two step processes, firstly compiling the set of searchable indexes then choosing the one which reduces
     * the search space the most.
     * &lt;p&gt;
     * In the first phase, if the command's RowFilter contains any custom index expressions, the indexes that they
     * specify are automatically included. Following that, the registered indexes are filtered to include only those
     * which support the standard expressions in the RowFilter.
     * &lt;p&gt;
     * The filtered set then sorted by selectivity, as reported by the Index implementations' getEstimatedResultRows
     * method.
     * &lt;p&gt;
     * Implementation specific validation of the target expression, either custom or standard, by the selected
     * index should be performed in the searcherFor method to ensure that we pick the right index regardless of
     * the validity of the expression.
     * &lt;p&gt;
     * This method is only called once during the lifecycle of a ReadCommand and the result is
     * cached for future use when obtaining a Searcher, getting the index's underlying CFS for
     * ReadOrderGroup, or an estimate of the result size from an average index query.
     *
     * @param rowFilter RowFilter of the command to be executed
     * @return an Index instance, ready to use during execution of the command, or null if none
     * of the registered indexes can support the command.
     */</comment>
    <function><type><specifier>public</specifier> <name>Index</name></type> <name>getBestIndexFor</name><parameter_list>(<parameter><decl><type><name>RowFilter</name></type> <name>rowFilter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>rowFilter</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>searchableIndexes</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>RowFilter</name><operator>.</operator><name>Expression</name></name></type> <name>expression</name> <range>: <expr><name>rowFilter</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>expression</name><operator>.</operator><name>isCustom</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Only a single custom expression is allowed per query and, if present,</comment>
                <comment type="line">// we want to always favour the index specified in such an expression</comment>
                <decl_stmt><decl><type><name><name>RowFilter</name><operator>.</operator><name>CustomExpression</name></name></type> <name>customExpression</name> <init>= <expr><operator>(</operator><name><name>RowFilter</name><operator>.</operator><name>CustomExpression</name></name><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Command contains a custom index expression, using target index {}"</literal></expr></argument>, <argument><expr><call><name><name>customExpression</name><operator>.</operator><name>getTargetIndex</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>Tracing</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Command contains a custom index expression, using target index {}"</literal></expr></argument>, <argument><expr><call><name><name>customExpression</name><operator>.</operator><name>getTargetIndex</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name><name>indexes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>customExpression</name><operator>.</operator><name>getTargetIndex</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name><name>expression</name><operator>.</operator><name>isUserDefined</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
                       <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>index</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>index</name><operator>.</operator><name>supportsExpression</name></name><argument_list>(<argument><expr><call><name><name>expression</name><operator>.</operator><name>column</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expression</name><operator>.</operator><name>operator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                       <operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>searchableIndexes</name><operator>::</operator><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><call><name><name>searchableIndexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"No applicable indexes found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Tracing</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"No applicable indexes found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>Index</name></type> <name>selected</name> <init>= <expr><ternary><condition><expr><call><name><name>searchableIndexes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>
                         ?</condition><then> <expr><call><name><name>Iterables</name><operator>.</operator><name>getOnlyElement</name></name><argument_list>(<argument><expr><name>searchableIndexes</name></expr></argument>)</argument_list></call></expr>
                         </then><else>: <expr><call><name><name>searchableIndexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                                            <operator>.</operator><call><name>min</name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>a</name></decl></parameter>, <parameter><decl><name>b</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>Longs</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>getEstimatedResultRows</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                         <argument><expr><call><name><name>b</name><operator>.</operator><name>getEstimatedResultRows</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                            <operator>.</operator><call><name>orElseThrow</name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>(<argument><expr><literal type="string">"Could not select most selective index"</literal></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// pay for an additional threadlocal get() rather than build the strings unnecessarily</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>Tracing</name><operator>.</operator><name>isTracing</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>Tracing</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Index mean cardinalities are {}. Scanning with {}."</literal></expr></argument>,
                          <argument><expr><call><name><name>searchableIndexes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>i</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name> <operator>+</operator> <literal type="char">':'</literal> <operator>+</operator> <call><name><name>i</name><operator>.</operator><name>getEstimatedResultRows</name></name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                           <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>joining</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name><name>selected</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>selected</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>getBestIndexFor</name><parameter_list>(<parameter><decl><type><name><name>RowFilter</name><operator>.</operator><name>Expression</name></name></type> <name>expression</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>i</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>i</name><operator>.</operator><name>supportsExpression</name></name><argument_list>(<argument><expr><call><name><name>expression</name><operator>.</operator><name>column</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expression</name><operator>.</operator><name>operator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>findFirst</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Called at write time to ensure that values present in the update
     * are valid according to the rules of all registered indexes which
     * will process it. The partition key as well as the clustering and
     * cell values for each row in the update may be checked by index
     * implementations
     *
     * @param update PartitionUpdate containing the values to be validated by registered Index implementations
     * @throws InvalidRequestException
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>validate</name><parameter_list>(<parameter><decl><type><name>PartitionUpdate</name></type> <name>update</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>index</name><operator>.</operator><name>validate</name></name><argument_list>(<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></function>

    <comment type="block">/*
     * IndexRegistry methods
     */</comment>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>registerIndex</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>name</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Registered index {}"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>unregisterIndex</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>index</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>unregisterIndex</name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>getIndexMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>Index</name></type> <name>unregisterIndex</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type> <name>removed</name> <init>= <expr><call><name><name>indexes</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>removed</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">"Index {} was not registered"</literal></expr> </then><else>: <expr><literal type="string">"Removed index {} from registry"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>removed</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Index</name></type> <name>getIndex</name><parameter_list>(<parameter><decl><type><name>IndexMetadata</name></type> <name>metadata</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>indexes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>listIndexes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
     * Handling of index updates.
     * Implementations of the various IndexTransaction interfaces, for keeping indexes in sync with base data
     * during updates, compaction and cleanup. Plus factory methods for obtaining transaction instances.
     */</comment>

    <comment type="block" format="javadoc">/**
     * Transaction for updates on the write path.
     */</comment>
    <function><type><specifier>public</specifier> <name>UpdateTransaction</name></type> <name>newUpdateTransaction</name><parameter_list>(<parameter><decl><type><name>PartitionUpdate</name></type> <name>update</name></decl></parameter>, <parameter><decl><type><name>WriteContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasIndexes</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>UpdateTransaction</name><operator>.</operator><name>NO_OP</name></name></expr>;</return></block_content></block></if></if_stmt>
        
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Index</name><operator>.</operator><name>Indexer</name></name></argument>&gt;</argument_list></name></type> <name>idxrs</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Index</name></type> <name>i</name> <range>: <expr><call><name><name>writableIndexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>idxr</name> <init>= <expr><call><name><name>i</name><operator>.</operator><name>indexerFor</name></name><argument_list>(<argument><expr><call><name><name>update</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>update</name><operator>.</operator><name>columns</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>IndexTransaction</name><operator>.</operator><name>Type</name><operator>.</operator><name>UPDATE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>idxr</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>idxrs</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>idxr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        
        <if_stmt><if>if <condition>(<expr><call><name><name>idxrs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>UpdateTransaction</name><operator>.</operator><name>NO_OP</name></name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>new</operator> <call><name>WriteTimeTransaction</name><argument_list>(<argument><expr><call><name><name>idxrs</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Index</name><operator>.</operator><name>Indexer</name><index>[<expr><call><name><name>idxrs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Transaction for use when merging rows during compaction
     */</comment>
    <function><type><specifier>public</specifier> <name>CompactionTransaction</name></type> <name>newCompactionTransaction</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>,
                                                          <parameter><decl><type><name>RegularAndStaticColumns</name></type> <name>regularAndStaticColumns</name></decl></parameter>,
                                                          <parameter><decl><type><name>int</name></type> <name>versions</name></decl></parameter>,
                                                          <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// the check for whether there are any registered indexes is already done in CompactionIterator</comment>
        <return>return <expr><operator>new</operator> <call><name>IndexGCTransaction</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>regularAndStaticColumns</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>versions</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><call><name><name>writableIndexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Transaction for use when removing partitions during cleanup
     */</comment>
    <function><type><specifier>public</specifier> <name>CleanupTransaction</name></type> <name>newCleanupTransaction</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>,
                                                    <parameter><decl><type><name>RegularAndStaticColumns</name></type> <name>regularAndStaticColumns</name></decl></parameter>,
                                                    <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasIndexes</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>CleanupTransaction</name><operator>.</operator><name>NO_OP</name></name></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><operator>new</operator> <call><name>CleanupGCTransaction</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>regularAndStaticColumns</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><call><name><name>writableIndexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * A single use transaction for processing a partition update on the regular write path
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>WriteTimeTransaction</name> <super_list><implements>implements <super><name>UpdateTransaction</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Index</name><operator>.</operator><name>Indexer</name><index>[]</index></name></type> <name>indexers</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>WriteTimeTransaction</name><parameter_list>(<parameter><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name><modifier>...</modifier></type> <name>indexers</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <comment type="line">// don't allow null indexers, if we don't need any use a NullUpdater object</comment>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content> <assert>assert <expr><name>indexer</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert></block_content></block></for>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>indexers</name></name> <operator>=</operator> <name>indexers</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>start</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onPartitionDeletion</name><parameter_list>(<parameter><decl><type><name>DeletionTime</name></type> <name>deletionTime</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>partitionDelete</name></name><argument_list>(<argument><expr><name>deletionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onRangeTombstone</name><parameter_list>(<parameter><decl><type><name>RangeTombstone</name></type> <name>tombstone</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>rangeTombstone</name></name><argument_list>(<argument><expr><name>tombstone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onInserted</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>insertRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onUpdated</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>existing</name></decl></parameter>, <parameter><decl><type><name>Row</name></type> <name>updated</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Row</name><operator>.</operator><name>Builder</name></name></type> <name>toRemove</name> <init>= <expr><call><name><name>BTreeRow</name><operator>.</operator><name>sortedBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>newRow</name></name><argument_list>(<argument><expr><call><name><name>existing</name><operator>.</operator><name>clustering</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>addPrimaryKeyLivenessInfo</name></name><argument_list>(<argument><expr><call><name><name>existing</name><operator>.</operator><name>primaryKeyLivenessInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>addRowDeletion</name></name><argument_list>(<argument><expr><call><name><name>existing</name><operator>.</operator><name>deletion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Row</name><operator>.</operator><name>Builder</name></name></type> <name>toInsert</name> <init>= <expr><call><name><name>BTreeRow</name><operator>.</operator><name>sortedBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>toInsert</name><operator>.</operator><name>newRow</name></name><argument_list>(<argument><expr><call><name><name>updated</name><operator>.</operator><name>clustering</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>toInsert</name><operator>.</operator><name>addPrimaryKeyLivenessInfo</name></name><argument_list>(<argument><expr><call><name><name>updated</name><operator>.</operator><name>primaryKeyLivenessInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>toInsert</name><operator>.</operator><name>addRowDeletion</name></name><argument_list>(<argument><expr><call><name><name>updated</name><operator>.</operator><name>deletion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// diff listener collates the columns to be added &amp; removed from the indexes</comment>
            <decl_stmt><decl><type><name>RowDiffListener</name></type> <name>diffListener</name> <init>= <expr><operator>new</operator> <class><super><name>RowDiffListener</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>public</specifier> <name>void</name></type> <name>onPrimaryKeyLivenessInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name>LivenessInfo</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name>LivenessInfo</name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                </block_content>}</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>onDeletion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name><name>Row</name><operator>.</operator><name>Deletion</name></name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name><name>Row</name><operator>.</operator><name>Deletion</name></name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                </block_content>}</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>onComplexDeletion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name>ColumnMetadata</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name>DeletionTime</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name>DeletionTime</name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                </block_content>}</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>onCell</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name><name>Cell</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name><name>Cell</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>merged</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>merged</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>toInsert</name><operator>.</operator><name>addCell</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>merged</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>original</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name>shouldCleanupOldValue</name><argument_list>(<argument><expr><name>original</name></expr></argument>, <argument><expr><name>merged</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>toRemove</name><operator>.</operator><name>addCell</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>Rows</name><operator>.</operator><name>diff</name></name><argument_list>(<argument><expr><name>diffListener</name></expr></argument>, <argument><expr><name>updated</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Row</name></type> <name>oldRow</name> <init>= <expr><call><name><name>toRemove</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Row</name></type> <name>newRow</name> <init>= <expr><call><name><name>toInsert</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>updateRow</name></name><argument_list>(<argument><expr><name>oldRow</name></expr></argument>, <argument><expr><name>newRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>commit</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <range>: <expr><name>indexers</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <parameter_list type="generic">&lt;<parameter><name>V1</name></parameter>, <parameter><name>V2</name></parameter>&gt;</parameter_list> <name>boolean</name></type> <name>shouldCleanupOldValue</name><parameter_list>(<parameter><decl><type><name><name>Cell</name><argument_list type="generic">&lt;<argument><name>V1</name></argument>&gt;</argument_list></name></type> <name>oldCell</name></decl></parameter>, <parameter><decl><type><name><name>Cell</name><argument_list type="generic">&lt;<argument><name>V2</name></argument>&gt;</argument_list></name></type> <name>newCell</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <comment type="line">// If either the value or timestamp is different, then we</comment>
            <comment type="line">// should delete from the index. If not, then we can infer that</comment>
            <comment type="line">// at least one of the cells is an ExpiringColumn and that the</comment>
            <comment type="line">// difference is in the expiry time. In this case, we don't want to</comment>
            <comment type="line">// delete the old value from the index as the tombstone we insert</comment>
            <comment type="line">// will just hide the inserted value.</comment>
            <comment type="line">// Completely identical cells (including expiring columns with</comment>
            <comment type="line">// identical ttl &amp; localExpirationTime) will not get this far due</comment>
            <comment type="line">// to the oldCell.equals(newCell) in StandardUpdater.update</comment>
            <return>return <expr><operator>!</operator><call><name><name>Cells</name><operator>.</operator><name>valueEqual</name></name><argument_list>(<argument><expr><name>oldCell</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>oldCell</name><operator>.</operator><name>timestamp</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>newCell</name><operator>.</operator><name>timestamp</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * A single-use transaction for updating indexes for a single partition during compaction where the only
     * operation is to merge rows
     * TODO : make this smarter at batching updates so we can use a single transaction to process multiple rows in
     * a single partition
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>IndexGCTransaction</name> <super_list><implements>implements <super><name>CompactionTransaction</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>DecoratedKey</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RegularAndStaticColumns</name></type> <name>columns</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Keyspace</name></type> <name>keyspace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>versions</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>nowInSec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Row</name><index>[]</index></name></type> <name>rows</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>IndexGCTransaction</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>,
                                   <parameter><decl><type><name>RegularAndStaticColumns</name></type> <name>columns</name></decl></parameter>,
                                   <parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>versions</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>,
                                   <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>columns</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keyspace</name></name> <operator>=</operator> <name>keyspace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>versions</name></name> <operator>=</operator> <name>versions</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>indexes</name></name> <operator>=</operator> <name>indexes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nowInSec</name></name> <operator>=</operator> <name>nowInSec</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>start</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>versions</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rows</name> <operator>=</operator> <operator>new</operator> <name><name>Row</name><index>[<expr><name>versions</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onRowMerge</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name>Row</name><modifier>...</modifier></type> <name>versions</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <comment type="line">// Diff listener constructs rows representing deltas between the merged and original versions</comment>
            <comment type="line">// These delta rows are then passed to registered indexes for removal processing</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Row</name><operator>.</operator><name>Builder</name><index>[]</index></name></type> <name>builders</name> <init>= <expr><operator>new</operator> <name><name>Row</name><operator>.</operator><name>Builder</name><index>[<expr><name><name>versions</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RowDiffListener</name></type> <name>diffListener</name> <init>= <expr><operator>new</operator> <class><super><name>RowDiffListener</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>public</specifier> <name>void</name></type> <name>onPrimaryKeyLivenessInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name>LivenessInfo</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name>LivenessInfo</name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>original</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>merged</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>merged</name><operator>.</operator><name>isLive</name></name><argument_list>(<argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>getBuilder</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>clustering</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>addPrimaryKeyLivenessInfo</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>onDeletion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name><name>Row</name><operator>.</operator><name>Deletion</name></name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name><name>Row</name><operator>.</operator><name>Deletion</name></name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                </block_content>}</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>onComplexDeletion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name>ColumnMetadata</name></type> <name>column</name></decl></parameter>, <parameter><decl><type><name>DeletionTime</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name>DeletionTime</name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                </block_content>}</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>onCell</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>, <parameter><decl><type><name><name>Cell</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name><name>Cell</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>original</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>original</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>merged</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>merged</name><operator>.</operator><name>isLive</name></name><argument_list>(<argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>getBuilder</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>clustering</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>addCell</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></function>

                <function><type><specifier>private</specifier> <name><name>Row</name><operator>.</operator><name>Builder</name></name></type> <name>getBuilder</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>Clustering</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clustering</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>builders</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>builders</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <call><name><name>BTreeRow</name><operator>.</operator><name>sortedBuilder</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>builders</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><call><name>newRow</name><argument_list>(<argument><expr><name>clustering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name><name>builders</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
                </block_content>}</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>Rows</name><operator>.</operator><name>diff</name></name><argument_list>(<argument><expr><name>diffListener</name></expr></argument>, <argument><expr><name>merged</name></expr></argument>, <argument><expr><name>versions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>builders</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>builders</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>rows</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>builders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>commit</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rows</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>

            <try>try <init>(<decl><type><name>WriteContext</name></type> <name>ctx</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getWriteHandler</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>createContextForIndexing</name><argument_list>()</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><name>indexes</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>indexerFor</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>Type</name><operator>.</operator><name>COMPACTION</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>indexer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>Row</name></type> <name>row</name> <range>: <expr><name>rows</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                        <if_stmt><if>if <condition>(<expr><name>row</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>removeRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
                    <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></try>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * A single-use transaction for updating indexes for a single partition during cleanup, where
     * partitions and rows are only removed
     * TODO : make this smarter at batching updates so we can use a single transaction to process multiple rows in
     * a single partition
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>CleanupGCTransaction</name> <super_list><implements>implements <super><name>CleanupTransaction</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>DecoratedKey</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RegularAndStaticColumns</name></type> <name>columns</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Keyspace</name></type> <name>keyspace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>nowInSec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>Row</name></type> <name>row</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>DeletionTime</name></type> <name>partitionDelete</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>CleanupGCTransaction</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>,
                                     <parameter><decl><type><name>RegularAndStaticColumns</name></type> <name>columns</name></decl></parameter>,
                                     <parameter><decl><type><name>Keyspace</name></type> <name>keyspace</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>,
                                     <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexes</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>columns</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keyspace</name></name> <operator>=</operator> <name>keyspace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>indexes</name></name> <operator>=</operator> <name>indexes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nowInSec</name></name> <operator>=</operator> <name>nowInSec</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>start</name><parameter_list>()</parameter_list>
        <block>{<block_content>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onPartitionDeletion</name><parameter_list>(<parameter><decl><type><name>DeletionTime</name></type> <name>deletionTime</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>partitionDelete</name> <operator>=</operator> <name>deletionTime</name></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onRowDelete</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>row</name></name> <operator>=</operator> <name>row</name></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>commit</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>row</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>partitionDelete</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>

            <try>try <init>(<decl><type><name>WriteContext</name></type> <name>ctx</name> <init>= <expr><call><name><name>keyspace</name><operator>.</operator><name>getWriteHandler</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>createContextForIndexing</name><argument_list>()</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>Index</name></type> <name>index</name> <range>: <expr><name>indexes</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Index</name><operator>.</operator><name>Indexer</name></name></type> <name>indexer</name> <init>= <expr><call><name><name>index</name><operator>.</operator><name>indexerFor</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>Type</name><operator>.</operator><name>CLEANUP</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>indexer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>partitionDelete</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>partitionDelete</name></name><argument_list>(<argument><expr><name>partitionDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>row</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>removeRow</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name><name>indexer</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></try>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>executeBlocking</name><parameter_list>(<parameter><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>task</name></decl></parameter>, <parameter><decl><type><name><name>FutureCallback</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>callback</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>task</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>f</name> <init>= <expr><call><name><name>blockingExecutor</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>callback</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>Futures</name><operator>.</operator><name>addCallback</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><call><name><name>MoreExecutors</name><operator>.</operator><name>directExecutor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFuture</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>executeAllBlocking</name><parameter_list>(<parameter><decl><type><name><name>Stream</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>&gt;</argument_list></name></type> <name>indexers</name></decl></parameter>, <parameter><decl><type><name><name>Function</name><argument_list type="generic">&lt;<argument><name>Index</name></argument>, <argument><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>function</name></decl></parameter>, <parameter><decl><type><name><name>FutureCallback</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>callback</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>function</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"failed to flush indexes: {} because flush task is missing."</literal></expr></argument>, <argument><expr><name>indexers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>waitFor</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>indexer</name></decl></parameter></parameter_list> -&gt;
                         <block>{<block_content>
                             <decl_stmt><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>task</name> <init>= <expr><call><name><name>function</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>indexer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                             <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>task</name></expr>)</condition>
                             <block>{<block_content>
                                 <decl_stmt><decl><type><name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>f</name> <init>= <expr><call><name><name>blockingExecutor</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                 <if_stmt><if>if <condition>(<expr><name>callback</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>Futures</name><operator>.</operator><name>addCallback</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><call><name><name>MoreExecutors</name><operator>.</operator><name>directExecutor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                 <expr_stmt><expr><call><name><name>waitFor</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                             </block_content>}</block></if></if_stmt>
                         </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>waitFor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>handleNotification</name><parameter_list>(<parameter><decl><type><name>INotification</name></type> <name>notification</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>sender</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>indexes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>notification</name> <operator>instanceof</operator> <name>SSTableAddedNotification</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SSTableAddedNotification</name></type> <name>notice</name> <init>= <expr><operator>(</operator><name>SSTableAddedNotification</name><operator>)</operator> <name>notification</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// SSTables asociated to a memtable come from a flush, so their contents have already been indexed</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>notice</name><operator>.</operator><name>memtable</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPresent</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>buildIndexesBlocking</name><argument_list>(<argument><expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><name><name>notice</name><operator>.</operator><name>added</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name><name>indexes</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call>
                                            <operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
                                            <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><name>Index</name><operator>::</operator><name>shouldBuildBlocking</name></expr></argument>)</argument_list></call>
                                            <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toSet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>shutdownAndWait</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>TimeUnit</name></type> <name>units</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>TimeoutException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name>asyncExecutor</name></expr></argument>, <argument><expr><name>blockingExecutor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>awaitTermination</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>units</name></expr></argument>, <argument><expr><name>asyncExecutor</name></expr></argument>, <argument><expr><name>blockingExecutor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
}</block></class>
</unit>
