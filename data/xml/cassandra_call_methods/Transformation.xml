<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/db/transform/Transformation.java"><comment type="block">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>transform</name></name>;</package>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>DecoratedKey</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>DeletionTime</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>RegularAndStaticColumns</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>PartitionIterator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>partitions</name><operator>.</operator><name>UnfilteredPartitionIterator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>rows</name><operator>.</operator><name>*</name></name>;</import>

<comment type="block" format="javadoc">/**
 * We have a single common superclass for all Transformations to make implementation efficient.
 * we have a shared stack for all transformations, and can share the same transformation across partition and row
 * iterators, reducing garbage. Internal code is also simplified by always having a basic no-op implementation to invoke.
 *
 * Only the necessary methods need be overridden. Early termination is provided by invoking the method's stop or stopInPartition
 * methods, rather than having their own abstract method to invoke, as this is both more efficient and simpler to reason about.
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name><name>Transformation</name><parameter_list>&lt;<parameter><name>I</name> <extends>extends <name><name>BaseRowIterator</name><parameter_list>&lt;<parameter><name>?</name></parameter>&gt;</parameter_list></name></extends></parameter>&gt;</parameter_list></name>
<block>{
    <comment type="line">// internal methods for StoppableTransformation only</comment>
    <function><type><name>void</name></type> <name>attachTo</name><parameter_list>(<parameter><decl><type><name>BasePartitions</name></type> <name>partitions</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>attachTo</name><parameter_list>(<parameter><decl><type><name>BaseRows</name></type> <name>rows</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Run on the close of any (logical) partitions iterator this function was applied to
     *
     * We stipulate logical, because if applied to a transformed iterator the lifetime of the iterator
     * object may be longer than the lifetime of the "logical" iterator it was applied to; if the iterator
     * is refilled with MoreContents, for instance, the iterator may outlive this function
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>onClose</name><parameter_list>()</parameter_list> <block>{<block_content> </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Run on the close of any (logical) rows iterator this function was applied to
     *
     * We stipulate logical, because if applied to a transformed iterator the lifetime of the iterator
     * object may be longer than the lifetime of the "logical" iterator it was applied to; if the iterator
     * is refilled with MoreContents, for instance, the iterator may outlive this function
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>onPartitionClose</name><parameter_list>()</parameter_list> <block>{<block_content> </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to any rows iterator (partition) we encounter in a partitions iterator
     */</comment>
    <function><type><specifier>protected</specifier> <name>I</name></type> <name>applyToPartition</name><parameter_list>(<parameter><decl><type><name>I</name></type> <name>partition</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>partition</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to any row we encounter in a rows iterator
     */</comment>
    <function><type><specifier>protected</specifier> <name>Row</name></type> <name>applyToRow</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>row</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to any RTM we encounter in a rows/unfiltered iterator
     */</comment>
    <function><type><specifier>protected</specifier> <name>RangeTombstoneMarker</name></type> <name>applyToMarker</name><parameter_list>(<parameter><decl><type><name>RangeTombstoneMarker</name></type> <name>marker</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>marker</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to the partition key of any rows/unfiltered iterator we are applied to
     */</comment>
    <function><type><specifier>protected</specifier> <name>DecoratedKey</name></type> <name>applyToPartitionKey</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>key</name></expr>;</return> </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to the static row of any rows iterator.
     *
     * NOTE that this is only applied to the first iterator in any sequence of iterators filled by a MoreContents;
     * the static data for such iterators is all expected to be equal
     */</comment>
    <function><type><specifier>protected</specifier> <name>Row</name></type> <name>applyToStatic</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>row</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to the partition-level deletion of any rows iterator.
     *
     * NOTE that this is only applied to the first iterator in any sequence of iterators filled by a MoreContents;
     * the static data for such iterators is all expected to be equal
     */</comment>
    <function><type><specifier>protected</specifier> <name>DeletionTime</name></type> <name>applyToDeletion</name><parameter_list>(<parameter><decl><type><name>DeletionTime</name></type> <name>deletionTime</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>deletionTime</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Applied to the {@code PartitionColumns} of any rows iterator.
     *
     * NOTE: same remark than for applyToDeletion: it is only applied to the first iterator in a sequence of iterators
     * filled by MoreContents.
     */</comment>
    <function><type><specifier>protected</specifier> <name>RegularAndStaticColumns</name></type> <name>applyToPartitionColumns</name><parameter_list>(<parameter><decl><type><name>RegularAndStaticColumns</name></type> <name>columns</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>columns</name></expr>;</return>
    </block_content>}</block></function>


    <comment type="line">//******************************************************</comment>
    <comment type="line">//          Static Application Methods</comment>
    <comment type="line">//******************************************************</comment>


    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>UnfilteredPartitionIterator</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>UnfilteredPartitionIterator</name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><name><name>Transformation</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>UnfilteredRowIterator</name></super></argument>&gt;</argument_list></name></type> <name>transformation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name>mutable</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>transformation</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PartitionIterator</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>PartitionIterator</name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><name><name>Transformation</name><argument_list type="generic">&lt;<argument><name>?</name> <super>super <name>RowIterator</name></super></argument>&gt;</argument_list></name></type> <name>transformation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name>mutable</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>transformation</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>UnfilteredRowIterator</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><name><name>Transformation</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>transformation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name>mutable</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>transformation</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>RowIterator</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>RowIterator</name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><name><name>Transformation</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>transformation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name>mutable</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>transformation</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>UnfilteredPartitions</name></type> <name>mutable</name><parameter_list>(<parameter><decl><type><name>UnfilteredPartitionIterator</name></type> <name>iterator</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>iterator</name> <operator>instanceof</operator> <name>UnfilteredPartitions</name></expr>
               ?</condition><then> <expr><operator>(</operator><name>UnfilteredPartitions</name><operator>)</operator> <name>iterator</name></expr>
               </then><else>: <expr><operator>new</operator> <call><name>UnfilteredPartitions</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>static</specifier> <name>FilteredPartitions</name></type> <name>mutable</name><parameter_list>(<parameter><decl><type><name>PartitionIterator</name></type> <name>iterator</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>iterator</name> <operator>instanceof</operator> <name>FilteredPartitions</name></expr>
               ?</condition><then> <expr><operator>(</operator><name>FilteredPartitions</name><operator>)</operator> <name>iterator</name></expr>
               </then><else>: <expr><operator>new</operator> <call><name>FilteredPartitions</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>static</specifier> <name>UnfilteredRows</name></type> <name>mutable</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>iterator</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>iterator</name> <operator>instanceof</operator> <name>UnfilteredRows</name></expr>
               ?</condition><then> <expr><operator>(</operator><name>UnfilteredRows</name><operator>)</operator> <name>iterator</name></expr>
               </then><else>: <expr><operator>new</operator> <call><name>UnfilteredRows</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>FilteredRows</name></type> <name>mutable</name><parameter_list>(<parameter><decl><type><name>RowIterator</name></type> <name>iterator</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>iterator</name> <operator>instanceof</operator> <name>FilteredRows</name></expr>
               ?</condition><then> <expr><operator>(</operator><name>FilteredRows</name><operator>)</operator> <name>iterator</name></expr>
               </then><else>: <expr><operator>new</operator> <call><name>FilteredRows</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Even though this method is sumilar to `mutable`, it supresses the optimisation of avoiding creating an additional
     * wrapping interator object (which both creates an extra object and grows the call stack during the iteration), it
     * should be used with caution.
     *
     * It is useful in cases when the input has to be checked for more contents rather than directly checking if it
     * is stopped. For example, when concatenating two iterators (pseudocode):
     *
     *    iter1 = [row(1), row(2), row(3)]
     *    iter2 = [row(4), row(5), row(6)]
     *
     *    UnfilteredRowIterators.concat(DataLimits.cqlLimits(1).filter(iter1), DataLimits.cqlLimits(1).filter(iter1))
     *
     * Which should yield two rows: [row(1), row(4)].
     *
     * Using stacked transformations instead of wrapping would result into returning a single row, since the first
     * iterator will signal the iterator is stopped.
     */</comment>
    <function><type><specifier>static</specifier> <name>UnfilteredRows</name></type> <name>wrapIterator</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><name>RegularAndStaticColumns</name></type> <name>columns</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>UnfilteredRows</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name>BaseIterator</name></extends></parameter>&gt;</parameter_list> <name>E</name></type> <name>add</name><parameter_list>(<parameter><decl><type><name>E</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>Transformation</name></type> <name>add</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>to</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>to</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>E</name> <extends>extends <name>BaseIterator</name></extends></parameter>&gt;</parameter_list> <name>E</name></type> <name>add</name><parameter_list>(<parameter><decl><type><name>E</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>MoreContents</name></type> <name>add</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>to</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>to</name></expr>;</return>
    </block_content>}</block></function>

}</block></class>
</unit>
