<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>big</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>BufferOverflowException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>compaction</name><operator>.</operator><name>OperationType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>LifecycleNewTracker</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cache</name><operator>.</operator><name>ChunkCache</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>Config</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>rows</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>transform</name><operator>.</operator><name>Transformation</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>FSWriteError</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>compress</name><operator>.</operator><name>CompressedSequentialWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>compress</name><operator>.</operator><name>ICompressor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableFlushObserver</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataCollector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataComponent</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>StatsMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>CompressionParams</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>TableMetadataRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Transactional</name></name>;</import>

<class><specifier>public</specifier> class <name>BigTableWriter</name> <super_list><extends>extends <super><name>SSTableWriter</name></super></extends></super_list>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>BigTableWriter</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ColumnIndex</name></type> <name>columnIndexWriter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>IndexWriter</name></type> <name>iwriter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>FileHandle</name><operator>.</operator><name>Builder</name></name></type> <name>dbuilder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>SequentialWriter</name></type> <name>dataFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>DecoratedKey</name></type> <name>lastWrittenKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>DataPosition</name></type> <name>dataMark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>lastEarlyOpenLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><name>ChunkCache</name></argument>&gt;</argument_list></name></type> <name>chunkCache</name> <init>= <expr><call><name><name>Optional</name><operator>.</operator><name>ofNullable</name></name><argument_list>(<argument><expr><name><name>ChunkCache</name><operator>.</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>SequentialWriterOption</name></type> <name>writerOption</name> <init>= <expr><call><name><name>SequentialWriterOption</name><operator>.</operator><name>newBuilder</name></name><argument_list>()</argument_list></call>
                                                        <operator>.</operator><call><name>trickleFsync</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getTrickleFsync</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                                                        <operator>.</operator><call><name>trickleFsyncByteInterval</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getTrickleFsyncIntervalInKb</name></name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call>
                                                        <operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>BigTableWriter</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></parameter>,
                          <parameter><decl><type><name>long</name></type> <name>keyCount</name></decl></parameter>,
                          <parameter><decl><type><name>long</name></type> <name>repairedAt</name></decl></parameter>,
                          <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>,
                          <parameter><decl><type><name>boolean</name></type> <name>isTransient</name></decl></parameter>,
                          <parameter><decl><type><name>TableMetadataRef</name></type> <name>metadata</name></decl></parameter>,
                          <parameter><decl><type><name>MetadataCollector</name></type> <name>metadataCollector</name></decl></parameter>, 
                          <parameter><decl><type><name>SerializationHeader</name></type> <name>header</name></decl></parameter>,
                          <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableFlushObserver</name></argument>&gt;</argument_list></name></type> <name>observers</name></decl></parameter>,
                          <parameter><decl><type><name>LifecycleNewTracker</name></type> <name>lifecycleNewTracker</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>keyCount</name></expr></argument>, <argument><expr><name>repairedAt</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><name>isTransient</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>metadataCollector</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>observers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lifecycleNewTracker</name><operator>.</operator><name>trackNew</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// must track before any files are created</comment>

        <if_stmt><if>if <condition>(<expr><name>compression</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>final</specifier> <name>CompressionParams</name></type> <name>compressionParams</name> <init>= <expr><call><name>compressionFor</name><argument_list>(<argument><expr><call><name><name>lifecycleNewTracker</name><operator>.</operator><name>opType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>dataFile</name> <operator>=</operator> <operator>new</operator> <call><name>CompressedSequentialWriter</name><argument_list>(<argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>COMPRESSION_INFO</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DIGEST</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>writerOption</name></expr></argument>,
                                             <argument><expr><name>compressionParams</name></expr></argument>,
                                             <argument><expr><name>metadataCollector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>dataFile</name> <operator>=</operator> <operator>new</operator> <call><name>ChecksummedSequentialWriter</name><argument_list>(<argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>CRC</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DIGEST</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>writerOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>dbuilder</name> <operator>=</operator> <operator>new</operator> <call><name><name>FileHandle</name><operator>.</operator><name>Builder</name></name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>compressed</name><argument_list>(<argument><expr><name>compression</name></expr></argument>)</argument_list></call>
                                              <operator>.</operator><call><name>mmapped</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getDiskAccessMode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Config</name><operator>.</operator><name>DiskAccessMode</name><operator>.</operator><name>mmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>chunkCache</name><operator>.</operator><name>ifPresent</name></name><argument_list>(<argument><expr><name>dbuilder</name><operator>::</operator><name>withChunkCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iwriter</name> <operator>=</operator> <operator>new</operator> <call><name>IndexWriter</name><argument_list>(<argument><expr><name>keyCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>columnIndexWriter</name> <operator>=</operator> <operator>new</operator> <call><name>ColumnIndex</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>header</name></name></expr></argument>, <argument><expr><name>dataFile</name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>observers</name></name></expr></argument>, <argument><expr><call><name>getRowIndexEntrySerializer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexInfoSerializer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Given an OpType, determine the correct Compression Parameters
     * @param opType
     * @return {@link org.apache.cassandra.schema.CompressionParams}
     */</comment>
    <function><type><specifier>private</specifier> <name>CompressionParams</name></type> <name>compressionFor</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>OperationType</name></type> <name>opType</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CompressionParams</name></type> <name>compressionParams</name> <init>= <expr><call><name><name>metadata</name><operator>.</operator><name>getLocal</name></name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>compression</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ICompressor</name></type> <name>compressor</name> <init>= <expr><call><name><name>compressionParams</name><operator>.</operator><name>getSstableCompressor</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>compressor</name> <operator>&amp;&amp;</operator> <name>opType</name> <operator>==</operator> <name><name>OperationType</name><operator>.</operator><name>FLUSH</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// When we are flushing out of the memtable throughput of the compressor is critical as flushes,</comment>
            <comment type="line">// especially of large tables, can queue up and potentially block writes.</comment>
            <comment type="line">// This optimization allows us to fall back to a faster compressor if a particular</comment>
            <comment type="line">// compression algorithm indicates we should. See CASSANDRA-15379 for more details.</comment>
            <switch>switch <condition>(<expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getFlushCompression</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// It is relatively easier to insert a Noop compressor than to disable compressed writing</comment>
                <comment type="line">// entirely as the "compression" member field is provided outside the scope of this class.</comment>
                <comment type="line">// It may make sense in the future to refactor the ownership of the compression flag so that</comment>
                <comment type="line">// We can bypass the CompressedSequentialWriter in this case entirely.</comment>
                <case>case <expr><name>none</name></expr>:</case>
                    <expr_stmt><expr><name>compressionParams</name> <operator>=</operator> <name><name>CompressionParams</name><operator>.</operator><name>NOOP</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>fast</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>compressor</name><operator>.</operator><name>recommendedUses</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><name><name>ICompressor</name><operator>.</operator><name>Uses</name><operator>.</operator><name>FAST_COMPRESSION</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// The default compressor is generally fast (LZ4 with 16KiB block size)</comment>
                        <expr_stmt><expr><name>compressionParams</name> <operator>=</operator> <name><name>CompressionParams</name><operator>.</operator><name>DEFAULT</name></name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                <case>case <expr><name>table</name></expr>:</case>
                <default>default:</default>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>compressionParams</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>mark</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>dataMark</name> <operator>=</operator> <call><name><name>dataFile</name><operator>.</operator><name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>iwriter</name><operator>.</operator><name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>resetAndTruncate</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>dataFile</name><operator>.</operator><name>resetAndTruncate</name></name><argument_list>(<argument><expr><name>dataMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>iwriter</name><operator>.</operator><name>resetAndTruncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Perform sanity checks on @param decoratedKey and @return the position in the data file before any data is written
     */</comment>
    <function><type><specifier>protected</specifier> <name>long</name></type> <name>beforeAppend</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>decoratedKey</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>decoratedKey</name> <operator>!=</operator> <literal type="null">null</literal> <operator>:</operator> <literal type="string">"Keys must not be null"</literal></expr>;</assert> <comment type="line">// empty keys ARE allowed b/c of indexed column values</comment>
        <if_stmt><if>if <condition>(<expr><name>lastWrittenKey</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>lastWrittenKey</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Last written key "</literal> <operator>+</operator> <name>lastWrittenKey</name> <operator>+</operator> <literal type="string">" &gt;= current key "</literal> <operator>+</operator> <name>decoratedKey</name> <operator>+</operator> <literal type="string">" writing into "</literal> <operator>+</operator> <call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <return>return <expr><ternary><condition><expr><operator>(</operator><name>lastWrittenKey</name> <operator>==</operator> <literal type="null">null</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name><name>dataFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>afterAppend</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>decoratedKey</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>dataEnd</name></decl></parameter>, <parameter><decl><type><name>RowIndexEntry</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>indexInfo</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>metadataCollector</name><operator>.</operator><name>addKey</name></name><argument_list>(<argument><expr><call><name><name>decoratedKey</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastWrittenKey</name> <operator>=</operator> <name>decoratedKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <name>lastWrittenKey</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>lastWrittenKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"wrote {} at {}"</literal></expr></argument>, <argument><expr><name>decoratedKey</name></expr></argument>, <argument><expr><name>dataEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>iwriter</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>dataEnd</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Appends partition data to this writer.
     *
     * @param iterator the partition to write
     * @return the created index entry if something was written, that is if {@code iterator}
     * wasn't empty, {@code null} otherwise.
     *
     * @throws FSWriteError if a write to the dataFile fails
     */</comment>
    <function><type><specifier>public</specifier> <name>RowIndexEntry</name></type> <name>append</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>iterator</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>key</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>remaining</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name><name>FBUtilities</name><operator>.</operator><name>MAX_UNSIGNED_SHORT</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Key size {} exceeds maximum of {}, skipping row"</literal></expr></argument>, <argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>remaining</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>FBUtilities</name><operator>.</operator><name>MAX_UNSIGNED_SHORT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>iterator</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>startPosition</name> <init>= <expr><call><name>beforeAppend</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>observers</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>o</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>o</name><operator>.</operator><name>startPartition</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name><name>iwriter</name><operator>.</operator><name>indexFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Reuse the writer for each row</comment>
        <expr_stmt><expr><call><name><name>columnIndexWriter</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <try>try <init>(<decl><type><name>UnfilteredRowIterator</name></type> <name>collecting</name> <init>= <expr><call><name><name>Transformation</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>iterator</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>StatsCollector</name><argument_list>(<argument><expr><name>metadataCollector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>columnIndexWriter</name><operator>.</operator><name>buildRowIndex</name></name><argument_list>(<argument><expr><name>collecting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// afterAppend() writes the partition key before the first RowIndexEntry - so we have to add it's</comment>
            <comment type="line">// serialized size to the index-writer position</comment>
            <decl_stmt><decl><type><name>long</name></type> <name>indexFilePosition</name> <init>= <expr><call><name><name>ByteBufferUtil</name><operator>.</operator><name>serializedSizeWithShortLength</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>iwriter</name><operator>.</operator><name>indexFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>RowIndexEntry</name></type> <name>entry</name> <init>= <expr><call><name><name>RowIndexEntry</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>startPosition</name></expr></argument>, <argument><expr><name>indexFilePosition</name></expr></argument>,
                                                       <argument><expr><call><name><name>collecting</name><operator>.</operator><name>partitionLevelDeletion</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                       <argument><expr><name><name>columnIndexWriter</name><operator>.</operator><name>headerLength</name></name></expr></argument>,
                                                       <argument><expr><name><name>columnIndexWriter</name><operator>.</operator><name>columnIndexCount</name></name></expr></argument>,
                                                       <argument><expr><call><name><name>columnIndexWriter</name><operator>.</operator><name>indexInfoSerializedSize</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name><name>columnIndexWriter</name><operator>.</operator><name>indexSamples</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name><name>columnIndexWriter</name><operator>.</operator><name>offsets</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>getRowIndexEntrySerializer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>indexInfoSerializer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>long</name></type> <name>endPosition</name> <init>= <expr><call><name><name>dataFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>rowSize</name> <init>= <expr><name>endPosition</name> <operator>-</operator> <name>startPosition</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>maybeLogLargePartitionWarning</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>rowSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>metadataCollector</name><operator>.</operator><name>addPartitionSizeInBytes</name></name><argument_list>(<argument><expr><name>rowSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>afterAppend</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>endPosition</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><call><name><name>columnIndexWriter</name><operator>.</operator><name>buffer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>entry</name></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>BufferOverflowException</name></type> <name>boe</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>PartitionSerializationException</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>, <argument><expr><name>boe</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>FSWriteError</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name><name>dataFile</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>RowIndexEntry</name><operator>.</operator><name><name>IndexSerializer</name><argument_list type="generic">&lt;<argument><name>IndexInfo</name></argument>&gt;</argument_list></name></name></type> <name>getRowIndexEntrySerializer</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><name><name>RowIndexEntry</name><operator>.</operator><name><name>IndexSerializer</name><argument_list type="generic">&lt;<argument><name>IndexInfo</name></argument>&gt;</argument_list></name></name><operator>)</operator> <name>rowIndexEntrySerializer</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>maybeLogLargePartitionWarning</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>rowSize</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>rowSize</name> <operator>&gt;</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getCompactionLargePartitionWarningThreshold</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>keyString</name> <init>= <expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>partitionKeyType</name><operator>.</operator><name>getString</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Writing large partition {}/{}:{} ({}) to sstable {}"</literal></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>keyspace</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>keyString</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>rowSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>StatsCollector</name> <super_list><extends>extends <super><name>Transformation</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>MetadataCollector</name></type> <name>collector</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>cellCount</name></decl>;</decl_stmt>

        <constructor><name>StatsCollector</name><parameter_list>(<parameter><decl><type><name>MetadataCollector</name></type> <name>collector</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>collector</name></name> <operator>=</operator> <name>collector</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Row</name></type> <name>applyToStatic</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>row</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cellCount</name> <operator>+=</operator> <call><name><name>Rows</name><operator>.</operator><name>collectStats</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>row</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Row</name></type> <name>applyToRow</name><parameter_list>(<parameter><decl><type><name>Row</name></type> <name>row</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>updateClusteringValues</name></name><argument_list>(<argument><expr><call><name><name>row</name><operator>.</operator><name>clustering</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cellCount</name> <operator>+=</operator> <call><name><name>Rows</name><operator>.</operator><name>collectStats</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>row</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>RangeTombstoneMarker</name></type> <name>applyToMarker</name><parameter_list>(<parameter><decl><type><name>RangeTombstoneMarker</name></type> <name>marker</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>updateClusteringValues</name></name><argument_list>(<argument><expr><call><name><name>marker</name><operator>.</operator><name>clustering</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>marker</name><operator>.</operator><name>isBoundary</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeTombstoneBoundaryMarker</name></type> <name>bm</name> <init>= <expr><operator>(</operator><name>RangeTombstoneBoundaryMarker</name><operator>)</operator><name>marker</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><call><name><name>bm</name><operator>.</operator><name>endDeletionTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><call><name><name>bm</name><operator>.</operator><name>startDeletionTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RangeTombstoneBoundMarker</name><operator>)</operator><name>marker</name><operator>)</operator><operator>.</operator><call><name>deletionTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return <expr><name>marker</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>onPartitionClose</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>addCellPerPartitionCount</name></name><argument_list>(<argument><expr><name>cellCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>DeletionTime</name></type> <name>applyToDeletion</name><parameter_list>(<parameter><decl><type><name>DeletionTime</name></type> <name>deletionTime</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>collector</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><name>deletionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>deletionTime</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>public</specifier> <name>SSTableReader</name></type> <name>openEarly</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// find the max (exclusive) readable key</comment>
        <decl_stmt><decl><type><name><name>IndexSummaryBuilder</name><operator>.</operator><name>ReadableBoundary</name></name></type> <name>boundary</name> <init>= <expr><call><name><name>iwriter</name><operator>.</operator><name>getMaxReadable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>boundary</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>StatsMetadata</name></type> <name>stats</name> <init>= <expr><call><name>statsMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name><name>boundary</name><operator>.</operator><name>indexLength</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>boundary</name><operator>.</operator><name>dataLength</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>
        <comment type="line">// open the reader early</comment>
        <decl_stmt><decl><type><name>IndexSummary</name></type> <name>indexSummary</name> <init>= <expr><call><name><name>iwriter</name><operator>.</operator><name>summary</name><operator>.</operator><name>build</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name>partitioner</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>indexFileLength</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>indexBufferSize</name> <init>= <expr><call><name><name>optimizationStrategy</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><name>indexFileLength</name> <operator>/</operator> <call><name><name>indexSummary</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FileHandle</name></type> <name>ifile</name> <init>= <expr><call><name><name>iwriter</name><operator>.</operator><name>builder</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><name>indexBufferSize</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>complete</name><argument_list>(<argument><expr><name><name>boundary</name><operator>.</operator><name>indexLength</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>compression</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>dbuilder</name><operator>.</operator><name>withCompressionMetadata</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CompressedSequentialWriter</name><operator>)</operator> <name>dataFile</name><operator>)</operator><operator>.</operator><call><name>open</name><argument_list>(<argument><expr><name><name>boundary</name><operator>.</operator><name>dataLength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dataBufferSize</name> <init>= <expr><call><name><name>optimizationStrategy</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><call><name><name>stats</name><operator>.</operator><name>estimatedPartitionSize</name><operator>.</operator><name>percentile</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getDiskOptimizationEstimatePercentile</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FileHandle</name></type> <name>dfile</name> <init>= <expr><call><name><name>dbuilder</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><name>dataBufferSize</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>complete</name><argument_list>(<argument><expr><name><name>boundary</name><operator>.</operator><name>dataLength</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>invalidateCacheAtBoundary</name><argument_list>(<argument><expr><name>dfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>SSTableReader</name><operator>.</operator><name>internalOpen</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>,
                                                           <argument><expr><name>components</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>,
                                                           <argument><expr><name>ifile</name></expr></argument>, <argument><expr><name>dfile</name></expr></argument>,
                                                           <argument><expr><name>indexSummary</name></expr></argument>,
                                                           <argument><expr><call><name><name>iwriter</name><operator>.</operator><name>bf</name><operator>.</operator><name>sharedCopy</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                                           <argument><expr><name>maxDataAge</name></expr></argument>, 
                                                           <argument><expr><name>stats</name></expr></argument>, 
                                                           <argument><expr><name><name>SSTableReader</name><operator>.</operator><name>OpenReason</name><operator>.</operator><name>EARLY</name></name></expr></argument>, 
                                                           <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// now it's open, find the ACTUAL last readable key (i.e. for which the data file has also been flushed)</comment>
        <expr_stmt><expr><name><name>sstable</name><operator>.</operator><name>first</name></name> <operator>=</operator> <call><name>getMinimalKey</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sstable</name><operator>.</operator><name>last</name></name> <operator>=</operator> <call><name>getMinimalKey</name><argument_list>(<argument><expr><name><name>boundary</name><operator>.</operator><name>lastKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>sstable</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>invalidateCacheAtBoundary</name><parameter_list>(<parameter><decl><type><name>FileHandle</name></type> <name>dfile</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>chunkCache</name><operator>.</operator><name>ifPresent</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>cache</name></decl></parameter></parameter_list> -&gt; <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>lastEarlyOpenLength</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>dfile</name><operator>.</operator><name>dataLength</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>lastEarlyOpenLength</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>cache</name><operator>.</operator><name>invalidatePosition</name></name><argument_list>(<argument><expr><name>dfile</name></expr></argument>, <argument><expr><name>lastEarlyOpenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastEarlyOpenLength</name> <operator>=</operator> <call><name><name>dfile</name><operator>.</operator><name>dataLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>SSTableReader</name></type> <name>openFinalEarly</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// we must ensure the data is completely flushed to disk</comment>
        <expr_stmt><expr><call><name><name>dataFile</name><operator>.</operator><name>sync</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>iwriter</name><operator>.</operator><name>indexFile</name><operator>.</operator><name>sync</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>openFinal</name><argument_list>(<argument><expr><name><name>SSTableReader</name><operator>.</operator><name>OpenReason</name><operator>.</operator><name>EARLY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>private</specifier> <name>SSTableReader</name></type> <name>openFinal</name><parameter_list>(<parameter><decl><type><name><name>SSTableReader</name><operator>.</operator><name>OpenReason</name></name></type> <name>openReason</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>maxDataAge</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>maxDataAge</name> <operator>=</operator> <call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>StatsMetadata</name></type> <name>stats</name> <init>= <expr><call><name>statsMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// finalize in-memory state for the reader</comment>
        <decl_stmt><decl><type><name>IndexSummary</name></type> <name>indexSummary</name> <init>= <expr><call><name><name>iwriter</name><operator>.</operator><name>summary</name><operator>.</operator><name>build</name></name><argument_list>(<argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>indexFileLength</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dataBufferSize</name> <init>= <expr><call><name><name>optimizationStrategy</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><call><name><name>stats</name><operator>.</operator><name>estimatedPartitionSize</name><operator>.</operator><name>percentile</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getDiskOptimizationEstimatePercentile</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>indexBufferSize</name> <init>= <expr><call><name><name>optimizationStrategy</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><name>indexFileLength</name> <operator>/</operator> <call><name><name>indexSummary</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FileHandle</name></type> <name>ifile</name> <init>= <expr><call><name><name>iwriter</name><operator>.</operator><name>builder</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><name>indexBufferSize</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>complete</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>compression</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>dbuilder</name><operator>.</operator><name>withCompressionMetadata</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CompressedSequentialWriter</name><operator>)</operator> <name>dataFile</name><operator>)</operator><operator>.</operator><call><name>open</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>FileHandle</name></type> <name>dfile</name> <init>= <expr><call><name><name>dbuilder</name><operator>.</operator><name>bufferSize</name></name><argument_list>(<argument><expr><name>dataBufferSize</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>complete</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>invalidateCacheAtBoundary</name><argument_list>(<argument><expr><name>dfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>SSTableReader</name><operator>.</operator><name>internalOpen</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>,
                                                           <argument><expr><name>components</name></expr></argument>,
                                                           <argument><expr><name>metadata</name></expr></argument>,
                                                           <argument><expr><name>ifile</name></expr></argument>,
                                                           <argument><expr><name>dfile</name></expr></argument>,
                                                           <argument><expr><name>indexSummary</name></expr></argument>,
                                                           <argument><expr><call><name><name>iwriter</name><operator>.</operator><name>bf</name><operator>.</operator><name>sharedCopy</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                           <argument><expr><name>maxDataAge</name></expr></argument>,
                                                           <argument><expr><name>stats</name></expr></argument>,
                                                           <argument><expr><name>openReason</name></expr></argument>,
                                                           <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>sstable</name><operator>.</operator><name>first</name></name> <operator>=</operator> <call><name>getMinimalKey</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sstable</name><operator>.</operator><name>last</name></name> <operator>=</operator> <call><name>getMinimalKey</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>sstable</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>protected</specifier> <name><name>SSTableWriter</name><operator>.</operator><name>TransactionalProxy</name></name></type> <name>txnProxy</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>TransactionalProxy</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class>class <name>TransactionalProxy</name> <super_list><extends>extends <super><name><name>SSTableWriter</name><operator>.</operator><name>TransactionalProxy</name></name></super></extends></super_list>
    <block>{
        <comment type="line">// finalise our state on disk, including renaming</comment>
        <function><type><specifier>protected</specifier> <name>void</name></type> <name>doPrepare</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>iwriter</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// write sstable statistics</comment>
            <expr_stmt><expr><call><name><name>dataFile</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>writeMetadata</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><call><name>finalizeMetadata</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// save the table of components</comment>
            <expr_stmt><expr><call><name><name>SSTable</name><operator>.</operator><name>appendTOC</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>components</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>openResult</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>finalReader</name> <operator>=</operator> <call><name>openFinal</name><argument_list>(<argument><expr><name><name>SSTableReader</name><operator>.</operator><name>OpenReason</name><operator>.</operator><name>NORMAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <function><type><specifier>protected</specifier> <name>Throwable</name></type> <name>doCommit</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>dataFile</name><operator>.</operator><name>commit</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>iwriter</name><operator>.</operator><name>commit</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>accumulate</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>Throwable</name></type> <name>doPostCleanup</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>dbuilder</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>accumulate</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>protected</specifier> <name>Throwable</name></type> <name>doAbort</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>iwriter</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>dataFile</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>accumulate</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeMetadata</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>File</name></type> <name>file</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>desc</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>STATS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name>SequentialWriter</name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name>SequentialWriter</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>writerOption</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>desc</name><operator>.</operator><name>getMetadataSerializer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>serialize</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>desc</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>FSWriteError</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name><name>file</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getFilePointer</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>dataFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getOnDiskFilePointer</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>dataFile</name><operator>.</operator><name>getOnDiskFilePointer</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getEstimatedOnDiskBytesWritten</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>dataFile</name><operator>.</operator><name>getEstimatedOnDiskBytesWritten</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Encapsulates writing the index and filter for an SSTable. The state of this object is not valid until it has been closed.
     */</comment>
    <class>class <name>IndexWriter</name> <super_list><extends>extends <super><name>AbstractTransactional</name></super></extends> <implements>implements <super><name>Transactional</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>SequentialWriter</name></type> <name>indexFile</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>FileHandle</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>IndexSummaryBuilder</name></type> <name>summary</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>IFilter</name></type> <name>bf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>DataPosition</name></type> <name>mark</name></decl>;</decl_stmt>

        <constructor><name>IndexWriter</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>keyCount</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>indexFile</name> <operator>=</operator> <operator>new</operator> <call><name>SequentialWriter</name><argument_list>(<argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>writerOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>builder</name> <operator>=</operator> <operator>new</operator> <call><name><name>FileHandle</name><operator>.</operator><name>Builder</name></name><argument_list>(<argument><expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>mmapped</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getIndexAccessMode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Config</name><operator>.</operator><name>DiskAccessMode</name><operator>.</operator><name>mmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>chunkCache</name><operator>.</operator><name>ifPresent</name></name><argument_list>(<argument><expr><name>builder</name><operator>::</operator><name>withChunkCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>summary</name> <operator>=</operator> <operator>new</operator> <call><name>IndexSummaryBuilder</name><argument_list>(<argument><expr><name>keyCount</name></expr></argument>, <argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>minIndexInterval</name></name></expr></argument>, <argument><expr><name><name>Downsampling</name><operator>.</operator><name>BASE_SAMPLING_LEVEL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>bf</name> <operator>=</operator> <call><name><name>FilterFactory</name><operator>.</operator><name>getFilter</name></name><argument_list>(<argument><expr><name>keyCount</name></expr></argument>, <argument><expr><call><name>metadata</name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>bloomFilterFpChance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// register listeners to be alerted when the data files are flushed</comment>
            <expr_stmt><expr><call><name><name>indexFile</name><operator>.</operator><name>setPostFlushListener</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>summary</name><operator>.</operator><name>markIndexSynced</name></name><argument_list>(<argument><expr><call><name><name>indexFile</name><operator>.</operator><name>getLastFlushOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dataFile</name><operator>.</operator><name>setPostFlushListener</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>summary</name><operator>.</operator><name>markDataSynced</name></name><argument_list>(<argument><expr><call><name><name>dataFile</name><operator>.</operator><name>getLastFlushOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="line">// finds the last (-offset) decorated key that can be guaranteed to occur fully in the flushed portion of the index file</comment>
        <function><type><name><name>IndexSummaryBuilder</name><operator>.</operator><name>ReadableBoundary</name></name></type> <name>getMaxReadable</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>summary</name><operator>.</operator><name>getLastReadableBoundary</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>RowIndexEntry</name></type> <name>indexEntry</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>dataEnd</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>indexInfo</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>indexStart</name> <init>= <expr><call><name><name>indexFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>ByteBufferUtil</name><operator>.</operator><name>writeWithShortLength</name></name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>indexFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rowIndexEntrySerializer</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><name>indexEntry</name></expr></argument>, <argument><expr><name>indexFile</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>FSWriteError</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name><name>indexFile</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></catch></try>
            <decl_stmt><decl><type><name>long</name></type> <name>indexEnd</name> <init>= <expr><call><name><name>indexFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"wrote index entry: {} at {}"</literal></expr></argument>, <argument><expr><name>indexEntry</name></expr></argument>, <argument><expr><name>indexStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>summary</name><operator>.</operator><name>maybeAddEntry</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>indexStart</name></expr></argument>, <argument><expr><name>indexEnd</name></expr></argument>, <argument><expr><name>dataEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Closes the index and bloomfilter, making the public state of this writer valid for consumption.
         */</comment>
        <function><type><name>void</name></type> <name>flushBf</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>components</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>FILTER</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>path</name> <init>= <expr><call><name><name>descriptor</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>FILTER</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <try>try <init>(<decl><type><name>FileOutputStream</name></type> <name>fos</name> <init>= <expr><operator>new</operator> <call><name>FileOutputStream</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;
                     <decl><type><name>DataOutputStreamPlus</name></type> <name>stream</name> <init>= <expr><operator>new</operator> <call><name>BufferedDataOutputStreamPlus</name><argument_list>(<argument><expr><name>fos</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
                <block>{<block_content>
                    <comment type="line">// bloom filter</comment>
                    <expr_stmt><expr><call><name><name>BloomFilterSerializer</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><operator>(</operator><name>BloomFilter</name><operator>)</operator> <name>bf</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stream</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>SyncUtil</name><operator>.</operator><name>sync</name></name><argument_list>(<argument><expr><name>fos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>FSWriteError</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></catch></try>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>mark</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name><name>indexFile</name><operator>.</operator><name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>resetAndTruncate</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <comment type="line">// we can't un-set the bloom filter addition, but extra keys in there are harmless.</comment>
            <comment type="line">// we can't reset dbuilder either, but that is the last thing called in afterappend so</comment>
            <comment type="line">// we assume that if that worked then we won't be trying to reset.</comment>
            <expr_stmt><expr><call><name><name>indexFile</name><operator>.</operator><name>resetAndTruncate</name></name><argument_list>(<argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>protected</specifier> <name>void</name></type> <name>doPrepare</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>flushBf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// truncate index file</comment>
            <decl_stmt><decl><type><name>long</name></type> <name>position</name> <init>= <expr><call><name><name>indexFile</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>indexFile</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>truncate</name></name><argument_list>(<argument><expr><call><name><name>indexFile</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// save summary</comment>
            <expr_stmt><expr><call><name><name>summary</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try <init>(<decl><type><name>IndexSummary</name></type> <name>indexSummary</name> <init>= <expr><call><name><name>summary</name><operator>.</operator><name>build</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>SSTableReader</name><operator>.</operator><name>saveSummary</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>indexSummary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></try>
        </block_content>}</block></function>

        <function><type><specifier>protected</specifier> <name>Throwable</name></type> <name>doCommit</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>indexFile</name><operator>.</operator><name>commit</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>protected</specifier> <name>Throwable</name></type> <name>doAbort</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>indexFile</name><operator>.</operator><name>abort</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>Throwable</name></type> <name>doPostCleanup</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>summary</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>bf</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>accumulate</name> <operator>=</operator> <call><name><name>builder</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><name>accumulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>accumulate</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>
}</block></class>
</unit>
