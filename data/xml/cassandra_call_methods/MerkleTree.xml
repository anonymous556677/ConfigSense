<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/utils/MerkleTree.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>DataInput</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Preconditions</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>PeekingIterator</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>primitives</name><operator>.</operator><name>Ints</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>primitives</name><operator>.</operator><name>Shorts</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>IPartitioner</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Murmur3Partitioner</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>RandomPartitioner</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Range</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>util</name><operator>.</operator><name>DataInputPlus</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>util</name><operator>.</operator><name>DataOutputPlus</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>util</name><operator>.</operator><name>FileUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Ref</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>memory</name><operator>.</operator><name>MemoryUtil</name></name>;</import>

<import>import static <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>String</name><operator>.</operator><name>format</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>TypeSizes</name><operator>.</operator><name>sizeof</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>ByteBufferUtil</name><operator>.</operator><name>compare</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>MerkleTree</name><operator>.</operator><name>Difference</name><operator>.</operator><name>*</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A MerkleTree implemented as a binary tree.
 *
 * A MerkleTree is a full binary tree that represents a perfect binary tree of
 * depth 'hashdepth'. In a perfect binary tree, each leaf contains a
 * sequentially hashed range, and each inner node contains the binary hash of
 * its two children. In the MerkleTree, many ranges will not be split to the
 * full depth of the perfect binary tree: the leaves of this tree are Leaf objects,
 * which contain the computed values of the nodes that would be below them if
 * the tree were perfect.
 *
 * The hash values of the inner nodes of the MerkleTree are calculated lazily based
 * on their children when the hash of a range is requested with hash(range).
 *
 * Inputs passed to TreeRange.validate should be calculated using a very secure hash,
 * because all hashing internal to the tree is accomplished using XOR.
 *
 * If two MerkleTrees have the same hashdepth, they represent a perfect tree
 * of the same depth, and can always be compared, regardless of size or splits.
 */</comment>
<class><specifier>public</specifier> class <name>MerkleTree</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>MerkleTree</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>HASH_SIZE</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 2xMM3_128 = 32 bytes.</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>EMPTY_HASH</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>HASH_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Thread-local byte array, large enough to host 32B of digest or MM3/Random partitoners' tokens
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><name><name>byte</name><index>[]</index></name></argument>&gt;</argument_list></name></type> <name>byteArray</name> <init>= <expr><call><name><name>ThreadLocal</name><operator>.</operator><name>withInitial</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>HASH_SIZE</name></expr>]</index></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>byte</name><index>[]</index></name></type> <name>getTempArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minimumSize</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>minimumSize</name> <operator>&lt;=</operator> <name>HASH_SIZE</name></expr> ?</condition><then> <expr><call><name><name>byteArray</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>minimumSize</name></expr>]</index></name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name></type> <name>RECOMMENDED_DEPTH</name> <init>= <expr><name><name>Byte</name><operator>.</operator><name>MAX_VALUE</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>hashdepth</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** The top level range that this MerkleTree covers. */</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>fullRange</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>IPartitioner</name></type> <name>partitioner</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>maxsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Node</name></type> <name>root</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @param partitioner The partitioner in use.
     * @param range the range this tree covers
     * @param hashdepth The maximum depth of the tree. 100/(2^depth) is the %
     *        of the key space covered by each subrange of a fully populated tree.
     * @param maxsize The maximum number of subranges in the tree.
     */</comment>
    <constructor><specifier>public</specifier> <name>MerkleTree</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hashdepth</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>maxsize</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>hashdepth</name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * @param partitioner The partitioner in use.
     * @param range the range this tree covers
     * @param hashdepth The maximum depth of the tree. 100/(2^depth) is the %
     *        of the key space covered by each subrange of a fully populated tree.
     * @param maxsize The maximum number of subranges in the tree.
     * @param size The size of the tree. Typically 1, unless deserilized from an existing tree
     */</comment>
    <constructor><specifier>private</specifier> <name>MerkleTree</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>root</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hashdepth</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>hashdepth</name> <operator>&lt;</operator> <name><name>Byte</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</assert>

        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fullRange</name></name> <operator>=</operator> <call><name><name>Preconditions</name><operator>.</operator><name>checkNotNull</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>partitioner</name></name> <operator>=</operator> <call><name><name>Preconditions</name><operator>.</operator><name>checkNotNull</name></name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>hashdepth</name></name> <operator>=</operator> <name>hashdepth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>maxsize</name></name> <operator>=</operator> <name>maxsize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Initializes this tree by splitting it until hashdepth is reached,
     * or until an additional level of splits would violate maxsize.
     *
     * NB: Replaces all nodes in the tree, and always builds on the heap
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// determine the depth to which we can safely split the tree</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>sizedepth</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name><name>Math</name><operator>.</operator><name>log10</name></name><argument_list>(<argument><expr><name>maxsize</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name><name>Math</name><operator>.</operator><name>log10</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>sizedepth</name></expr></argument>, <argument><expr><name>hashdepth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>initHelper</name><argument_list>(<argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>pow</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>OnHeapNode</name></type> <name>initHelper</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// we've reached the leaves</comment>
            <return>return <expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>midpoint</name> <init>= <expr><call><name><name>partitioner</name><operator>.</operator><name>midpoint</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>midpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>midpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>OnHeapNode</name></type> <name>leftChild</name> <init>= <expr><call><name>initHelper</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OnHeapNode</name></type> <name>rightChild</name> <init>= <expr><call><name>initHelper</name><argument_list>(<argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name>OnHeapInner</name><argument_list>(<argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name>leftChild</name></expr></argument>, <argument><expr><name>rightChild</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>release</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>root</name> <operator>instanceof</operator> <name>OffHeapNode</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>OffHeapNode</name><operator>)</operator> <name>root</name><operator>)</operator><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>root</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>IPartitioner</name></type> <name>partitioner</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>partitioner</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * The number of distinct ranges contained in this tree. This is a reasonable
     * measure of the memory usage of the tree (assuming 'this.order' is significant).
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>size</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>size</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>maxsize</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>maxsize</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>maxsize</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>maxsize</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>maxsize</name></name> <operator>=</operator> <name>maxsize</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @param ltree First tree.
     * @param rtree Second tree.
     * @return A list of the largest contiguous ranges where the given trees disagree.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></type> <name>difference</name><parameter_list>(<parameter><decl><type><name>MerkleTree</name></type> <name>ltree</name></decl></parameter>, <parameter><decl><type><name>MerkleTree</name></type> <name>rtree</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ltree</name><operator>.</operator><name>fullRange</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>rtree</name><operator>.</operator><name>fullRange</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Difference only make sense on tree covering the same range (but "</literal> <operator>+</operator> <name><name>ltree</name><operator>.</operator><name>fullRange</name></name> <operator>+</operator> <literal type="string">" != "</literal> <operator>+</operator> <name><name>rtree</name><operator>.</operator><name>fullRange</name></name> <operator>+</operator> <literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <comment type="line">// ensure on-heap trees' inner node hashes have been computed</comment>
        <expr_stmt><expr><call><name><name>ltree</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>rtree</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></type> <name>diff</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TreeRange</name></type> <name>active</name> <init>= <expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name><name>ltree</name><operator>.</operator><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>ltree</name><operator>.</operator><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Node</name></type> <name>lnode</name> <init>= <expr><name><name>ltree</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name></type> <name>rnode</name> <init>= <expr><name><name>rtree</name><operator>.</operator><name>root</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>lnode</name><operator>.</operator><name>hashesDiffer</name></name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>lnode</name> <operator>instanceof</operator> <name>Leaf</name> <operator>||</operator> <name>rnode</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Digest mismatch detected among leaf nodes {}, {}"</literal></expr></argument>, <argument><expr><name>lnode</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>diff</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Digest mismatch detected, traversing trees [{}, {}]"</literal></expr></argument>, <argument><expr><name>ltree</name></expr></argument>, <argument><expr><name>rtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>FULLY_INCONSISTENT</name> <operator>==</operator> <call><name>differenceHelper</name><argument_list>(<argument><expr><name>ltree</name></expr></argument>, <argument><expr><name>rtree</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Range {} fully inconsistent"</literal></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>diff</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>diff</name></expr>;</return>
    </block_content>}</block></function>

    <enum>enum <name>Difference</name> <block>{ <decl><name>CONSISTENT</name></decl>, <decl><name>FULLY_INCONSISTENT</name></decl>, <decl><name>PARTIALLY_INCONSISTENT</name></decl> }</block></enum>

    <comment type="block" format="javadoc">/**
     * TODO: This function could be optimized into a depth first traversal of the two trees in parallel.
     *
     * Takes two trees and a range for which they have hashes, but are inconsistent.
     * @return FULLY_INCONSISTENT if active is inconsistent, PARTIALLY_INCONSISTENT if only a subrange is inconsistent.
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>static</specifier> <name>Difference</name></type> <name>differenceHelper</name><parameter_list>(<parameter><decl><type><name>MerkleTree</name></type> <name>ltree</name></decl></parameter>, <parameter><decl><type><name>MerkleTree</name></type> <name>rtree</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></type> <name>diff</name></decl></parameter>, <parameter><decl><type><name>TreeRange</name></type> <name>active</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>active</name><operator>.</operator><name>depth</name></name> <operator>==</operator> <name><name>Byte</name><operator>.</operator><name>MAX_VALUE</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>CONSISTENT</name></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>Token</name></type> <name>midpoint</name> <init>= <expr><call><name><name>ltree</name><operator>.</operator><name>partitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>midpoint</name><argument_list>(<argument><expr><name><name>active</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// sanity check for midpoint calculation, see CASSANDRA-13052</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>midpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>active</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>midpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>active</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If the midpoint equals either the left or the right, we have a range that's too small to split - we'll simply report the</comment>
            <comment type="line">// whole range as inconsistent</comment>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) No sane midpoint ({}) for range {} , marking whole range as inconsistent"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>FULLY_INCONSISTENT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>TreeRange</name></type> <name>left</name> <init>= <expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name><name>active</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TreeRange</name></type> <name>right</name> <init>= <expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Hashing sub-ranges [{}, {}] for {} divided by midpoint {}"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>midpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Node</name></type> <name>lnode</name></decl>, <decl><type ref="prev"/><name>rnode</name></decl>;</decl_stmt>

        <comment type="line">// see if we should recurse left</comment>
        <expr_stmt><expr><name>lnode</name> <operator>=</operator> <call><name><name>ltree</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rnode</name> <operator>=</operator> <call><name><name>rtree</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Difference</name></type> <name>ldiff</name> <init>= <expr><name>CONSISTENT</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>lnode</name> <operator>&amp;&amp;</operator> <literal type="null">null</literal> <operator>!=</operator> <name>rnode</name> <operator>&amp;&amp;</operator> <call><name><name>lnode</name><operator>.</operator><name>hashesDiffer</name></name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Inconsistent digest on left sub-range {}: [{}, {}]"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>lnode</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>lnode</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ldiff</name> <operator>=</operator> <name>FULLY_INCONSISTENT</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ldiff</name> <operator>=</operator> <call><name>differenceHelper</name><argument_list>(<argument><expr><name>ltree</name></expr></argument>, <argument><expr><name>rtree</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>lnode</name> <operator>||</operator> <literal type="null">null</literal> <operator>==</operator> <name>rnode</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Left sub-range fully inconsistent {}"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ldiff</name> <operator>=</operator> <name>FULLY_INCONSISTENT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// see if we should recurse right</comment>
        <expr_stmt><expr><name>lnode</name> <operator>=</operator> <call><name><name>ltree</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rnode</name> <operator>=</operator> <call><name><name>rtree</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Difference</name></type> <name>rdiff</name> <init>= <expr><name>CONSISTENT</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>lnode</name> <operator>&amp;&amp;</operator> <literal type="null">null</literal> <operator>!=</operator> <name>rnode</name> <operator>&amp;&amp;</operator> <call><name><name>lnode</name><operator>.</operator><name>hashesDiffer</name></name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Inconsistent digest on right sub-range {}: [{}, {}]"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>lnode</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>rnode</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rdiff</name> <operator>=</operator> <name>FULLY_INCONSISTENT</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>rdiff</name> <operator>=</operator> <call><name>differenceHelper</name><argument_list>(<argument><expr><name>ltree</name></expr></argument>, <argument><expr><name>rtree</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>lnode</name> <operator>||</operator> <literal type="null">null</literal> <operator>==</operator> <name>rnode</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Right sub-range fully inconsistent {}"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rdiff</name> <operator>=</operator> <name>FULLY_INCONSISTENT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ldiff</name> <operator>==</operator> <name>FULLY_INCONSISTENT</name> <operator>&amp;&amp;</operator> <name>rdiff</name> <operator>==</operator> <name>FULLY_INCONSISTENT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// both children are fully inconsistent</comment>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Fully inconsistent range [{}, {}]"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>FULLY_INCONSISTENT</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ldiff</name> <operator>==</operator> <name>FULLY_INCONSISTENT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Adding left sub-range to diff as fully inconsistent {}"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>diff</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PARTIALLY_INCONSISTENT</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>rdiff</name> <operator>==</operator> <name>FULLY_INCONSISTENT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Adding right sub-range to diff as fully inconsistent {}"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>diff</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PARTIALLY_INCONSISTENT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"({}) Range {} partially inconstent"</literal></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PARTIALLY_INCONSISTENT</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Exceptions that stop recursion early when we are sure that no answer
     * can be found.
     */</comment>
    <class><specifier>static</specifier> <specifier>abstract</specifier> class <name>StopRecursion</name> <super_list><extends>extends <super><name>Exception</name></super></extends></super_list>
    <block>{
        <class><specifier>static</specifier> class  <name>TooDeep</name> <super_list><extends>extends <super><name>StopRecursion</name></super></extends></super_list> <block>{}</block></class>
        <class><specifier>static</specifier> class <name>BadRange</name> <super_list><extends>extends <super><name>StopRecursion</name></super></extends></super_list> <block>{}</block></class>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Find the {@link Node} node that matches the given {@code range}.
     *
     * @param range Range to find
     * @return {@link Node} found. If nothing found, return {@code null}
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>private</specifier> <name>Node</name></type> <name>find</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name>findHelper</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>fullRange</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>StopRecursion</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @throws StopRecursion If no match could be found for the range.
     */</comment>
    <function><type><specifier>private</specifier> <name>Node</name></type> <name>findHelper</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>current</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>activeRange</name></decl></parameter>, <parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>find</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>StopRecursion</name></expr></argument></throws>
    <block>{<block_content>
        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>current</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>find</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>activeRange</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name><name>StopRecursion</name><operator>.</operator><name>BadRange</name></name><argument_list>()</argument_list></call></expr>;</throw></block_content></block></if></if_stmt> <comment type="line">// we are not fully contained in this range!</comment>

                <return>return <expr><name>current</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <assert>assert <expr><name>current</name> <operator>instanceof</operator> <name>Inner</name></expr>;</assert>
            <decl_stmt><decl><type><name>Inner</name></type> <name>inner</name> <init>= <expr><operator>(</operator><name>Inner</name><operator>)</operator> <name>current</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>find</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>activeRange</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// this node is fully contained in the range</comment>
                <return>return <expr><call><name><name>inner</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>Token</name></type> <name>midpoint</name> <init>= <expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type>  <name>leftRange</name> <init>= <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>activeRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>midpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>rightRange</name> <init>= <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>midpoint</name></expr></argument>, <argument><expr><name><name>activeRange</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// else: one of our children contains the range</comment>

            <if_stmt><if>if <condition>(<expr><call><name><name>leftRange</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="line">// left child contains/matches the range</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>activeRange</name> <operator>=</operator> <name>leftRange</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>current</name> <operator>=</operator> <call><name><name>inner</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name><name>rightRange</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="line">// right child contains/matches the range</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>activeRange</name> <operator>=</operator> <name>rightRange</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>current</name> <operator>=</operator> <call><name><name>inner</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name><name>StopRecursion</name><operator>.</operator><name>BadRange</name></name><argument_list>()</argument_list></call></expr>;</throw>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Splits the range containing the given token, if no tree limits would be
     * violated. If the range would be split to a depth below hashdepth, or if
     * the tree already contains maxsize subranges, this operation will fail.
     *
     * @return True if the range was successfully split.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>split</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <name>maxsize</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

        <try>try
        <block>{<block_content>
            <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>splitHelper</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name><name>StopRecursion</name><operator>.</operator><name>TooDeep</name></name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></catch></try>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>OnHeapNode</name></type> <name>splitHelper</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>pleft</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>pright</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name><name>StopRecursion</name><operator>.</operator><name>TooDeep</name></name></expr></argument></throws>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <name>hashdepth</name></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><operator>new</operator> <call><name><name>StopRecursion</name><operator>.</operator><name>TooDeep</name></name><argument_list>()</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Token</name></type> <name>midpoint</name> <init>= <expr><call><name><name>partitioner</name><operator>.</operator><name>midpoint</name></name><argument_list>(<argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// We should not create a non-sensical range where start and end are the same token (this is non-sensical because range are</comment>
            <comment type="line">// start exclusive). Note that we shouldn't hit that unless the full range is very small or we are fairly deep</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>midpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>pleft</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>midpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>pright</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name><name>StopRecursion</name><operator>.</operator><name>TooDeep</name></name><argument_list>()</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <comment type="line">// split</comment>
            <expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><operator>new</operator> <call><name>OnHeapInner</name><argument_list>(<argument><expr><name>midpoint</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// else: node.</comment>

        <comment type="line">// recurse on the matching child</comment>
        <assert>assert <expr><name>node</name> <operator>instanceof</operator> <name>OnHeapInner</name></expr>;</assert>
        <decl_stmt><decl><type><name>OnHeapInner</name></type> <name>inner</name> <init>= <expr><operator>(</operator><name>OnHeapInner</name><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>pleft</name></expr></argument>, <argument><expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// left child contains token</comment>
            <expr_stmt><expr><call><name><name>inner</name><operator>.</operator><name>left</name></name><argument_list>(<argument><expr><call><name>splitHelper</name><argument_list>(<argument><expr><call><name><name>inner</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <comment type="line">// else: right child contains token</comment>
            <expr_stmt><expr><call><name><name>inner</name><operator>.</operator><name>right</name></name><argument_list>(<argument><expr><call><name>splitHelper</name><argument_list>(<argument><expr><call><name><name>inner</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <return>return <expr><name>inner</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns a lazy iterator of invalid TreeRanges that need to be filled
     * in order to make the given Range valid.
     */</comment>
    <function><type><name>TreeRangeIterator</name></type> <name>rangeIterator</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>TreeRangeIterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>EstimatedHistogram</name></type> <name>histogramOfRowSizePerLeaf</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HistogramBuilder</name></type> <name>histbuild</name> <init>= <expr><operator>new</operator> <call><name>HistogramBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>TreeRange</name></type> <name>range</name> <range>: <expr><operator>new</operator> <call><name>TreeRangeIterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>histbuild</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>node</name><operator>.</operator><name>sizeOfRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>histbuild</name><operator>.</operator><name>buildWithStdevRangesAroundMean</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>EstimatedHistogram</name></type> <name>histogramOfRowCountPerLeaf</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HistogramBuilder</name></type> <name>histbuild</name> <init>= <expr><operator>new</operator> <call><name>HistogramBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>TreeRange</name></type> <name>range</name> <range>: <expr><operator>new</operator> <call><name>TreeRangeIterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>histbuild</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>node</name><operator>.</operator><name>partitionsInRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>histbuild</name><operator>.</operator><name>buildWithStdevRangesAroundMean</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>rowCount</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>TreeRange</name></type> <name>range</name> <range>: <expr><operator>new</operator> <call><name>TreeRangeIterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name><name>range</name><operator>.</operator><name>node</name><operator>.</operator><name>partitionsInRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>count</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"#&lt;MerkleTree root="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>root</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>other</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>other</name> <operator>instanceof</operator> <name>MerkleTree</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>MerkleTree</name></type> <name>that</name> <init>= <expr><operator>(</operator><name>MerkleTree</name><operator>)</operator> <name>other</name></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name><name>this</name><operator>.</operator><name>root</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>fullRange</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>that</name><operator>.</operator><name>fullRange</name></name></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>partitioner</name></name> <operator>==</operator> <name><name>that</name><operator>.</operator><name>partitioner</name></name>
            <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>hashdepth</name></name> <operator>==</operator> <name><name>that</name><operator>.</operator><name>hashdepth</name></name>
            <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>maxsize</name></name> <operator>==</operator> <name><name>that</name><operator>.</operator><name>maxsize</name></name>
            <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>size</name></name> <operator>==</operator> <name><name>that</name><operator>.</operator><name>size</name></name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * The public interface to a range in the tree.
     *
     * NB: A TreeRange should not be returned by a public method unless the
     * parents of the range it represents are already invalidated, since it
     * will allow someone to modify the hash. Alternatively, a TreeRange
     * may be created with a null tree, indicating that it is read only.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>TreeRange</name> <super_list><extends>extends <super><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>MerkleTree</name></type> <name>tree</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>depth</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Node</name></type> <name>node</name></decl>;</decl_stmt>

        <constructor><name>TreeRange</name><parameter_list>(<parameter><decl><type><name>MerkleTree</name></type> <name>tree</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>Node</name></type> <name>node</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tree</name></name> <operator>=</operator> <name>tree</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>depth</name></name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <constructor><name>TreeRange</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>hash</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <assert>assert <expr><name>tree</name> <operator>!=</operator> <literal type="null">null</literal> <operator>:</operator> <literal type="string">"Not intended for modification!"</literal></expr>;</assert>
            <expr_stmt><expr><call><name><name>node</name><operator>.</operator><name>hash</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * @param entry Row to mix into the hash for this range.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>addHash</name><parameter_list>(<parameter><decl><type><name>RowHash</name></type> <name>entry</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>addHash</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><name>void</name></type> <name>addHash</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>partitionSize</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <assert>assert <expr><name>tree</name> <operator>!=</operator> <literal type="null">null</literal> <operator>:</operator> <literal type="string">"Not intended for modification!"</literal></expr>;</assert>

            <assert>assert <expr><name>node</name> <operator>instanceof</operator> <name>OnHeapLeaf</name></expr>;</assert>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>OnHeapLeaf</name><operator>)</operator> <name>node</name><operator>)</operator><operator>.</operator><call><name>addHash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>partitionSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>addAll</name><parameter_list>(<parameter><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>RowHash</name></argument>&gt;</argument_list></name></type> <name>entries</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <while>while <condition>(<expr><call><name><name>entries</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addHash</name><argument_list>(<argument><expr><call><name><name>entries</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="string">"#&lt;TreeRange "</literal> <operator>+</operator> <call><name><name>super</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" depth="</literal> <operator>+</operator> <name>depth</name> <operator>+</operator> <literal type="char">'&gt;'</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Returns the leaf (range) of a given tree in increasing order.
     * If the full range covered by the tree don't wrap, then it will return the
     * ranges in increasing order.
     * If the full range wrap, the first *and* last range returned by the
     * iterator will be the wrapping range. It is the only case where the same
     * leaf will be returned twice.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>TreeRangeIterator</name> <super_list><extends>extends <super><name><name>AbstractIterator</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></super></extends> <implements>implements <super><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></super>, <super><name><name>PeekingIterator</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></super></implements></super_list>
    <block>{
        <comment type="line">// stack of ranges to visit</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ArrayDeque</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></type> <name>tovisit</name></decl>;</decl_stmt>
        <comment type="line">// interesting range</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>MerkleTree</name></type> <name>tree</name></decl>;</decl_stmt>

        <constructor><name>TreeRangeIterator</name><parameter_list>(<parameter><decl><type><name>MerkleTree</name></type> <name>tree</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>tovisit</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayDeque</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tovisit</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>tree</name><operator>.</operator><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>tree</name><operator>.</operator><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tree</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tree</name></name> <operator>=</operator> <name>tree</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * Find the next TreeRange.
         *
         * @return The next TreeRange.
         */</comment>
        <function><type><specifier>public</specifier> <name>TreeRange</name></type> <name>computeNext</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <while>while <condition>(<expr><operator>!</operator><call><name><name>tovisit</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TreeRange</name></type> <name>active</name> <init>= <expr><call><name><name>tovisit</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>active</name><operator>.</operator><name>node</name></name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// found a leaf invalid range</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>active</name><operator>.</operator><name>isWrapAround</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>tovisit</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <comment type="line">// put to be taken again last</comment>
                        <expr_stmt><expr><call><name><name>tovisit</name><operator>.</operator><name>addLast</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <return>return <expr><name>active</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <decl_stmt><decl><type><name>Inner</name></type> <name>node</name> <init>= <expr><operator>(</operator><name>Inner</name><operator>)</operator><name><name>active</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TreeRange</name></type> <name>left</name> <init>= <expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><call><name><name>node</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>node</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TreeRange</name></type> <name>right</name> <init>= <expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><call><name><name>node</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>active</name><operator>.</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>node</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name><name>right</name><operator>.</operator><name>isWrapAround</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// whatever is on the left is 'after' everything we have seen so far (it has greater tokens)</comment>
                    <expr_stmt><expr><call><name><name>tovisit</name><operator>.</operator><name>addLast</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>tovisit</name><operator>.</operator><name>addFirst</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// do left first then right</comment>
                    <expr_stmt><expr><call><name><name>tovisit</name><operator>.</operator><name>addFirst</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>tovisit</name><operator>.</operator><name>addFirst</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <return>return <expr><call><name>endOfData</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>TreeRange</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Hash value representing a row, to be used to pass hashes to the MerkleTree.
     * The byte[] hash value should contain a digest of the key and value of the row
     * created using a very strong hash function.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>RowHash</name>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Token</name></type> <name>token</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>RowHash</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>token</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>hash</name></name>  <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>size</name></name>  <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="string">"#&lt;RowHash "</literal> <operator>+</operator> <name>token</name> <operator>+</operator> <literal type="char">' '</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>hash</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="string">"null"</literal></expr> </then><else>: <expr><call><name><name>Hex</name><operator>.</operator><name>bytesToHex</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>+</operator> <literal type="string">" @ "</literal> <operator>+</operator> <name>size</name> <operator>+</operator> <literal type="string">" bytes&gt;"</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>serialize</name><parameter_list>(<parameter><decl><type><name>DataOutputPlus</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><name>hashdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeLong</name></name><argument_list>(<argument><expr><name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeLong</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeUTF</name></name><argument_list>(<argument><expr><call><name><name>partitioner</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCanonicalName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><name><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>root</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>serializedSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><literal type="number">1</literal> <comment type="line">// mt.hashdepth</comment>
                  <operator>+</operator> <call><name>sizeof</name><argument_list>(<argument><expr><name>maxsize</name></expr></argument>)</argument_list></call>
                  <operator>+</operator> <call><name>sizeof</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call>
                  <operator>+</operator> <call><name>sizeof</name><argument_list>(<argument><expr><call><name><name>partitioner</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCanonicalName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>serializedSize</name></name><argument_list>(<argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>serializedSize</name></name><argument_list>(<argument><expr><name><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name><name>root</name><operator>.</operator><name>serializedSize</name></name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>size</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>MerkleTree</name></type> <name>deserialize</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>deserialize</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>useOffheapMerkleTrees</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>MerkleTree</name></type> <name>deserialize</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>offHeapRequested</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>hashDepth</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>readByte</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>maxSize</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>readLong</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>innerNodeCount</name> <init>= <expr><call><name><name>Ints</name><operator>.</operator><name>checkedCast</name></name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>readLong</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><name>partitioner</name> <operator>=</operator> <call><name><name>FBUtilities</name><operator>.</operator><name>newPartitioner</name></name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>readUTF</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>IOException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>

        <decl_stmt><decl><type><name>Token</name></type> <name>left</name> <init>= <expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>right</name> <init>= <expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>fullRange</name> <init>= <expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name></type> <name>root</name> <init>= <expr><call><name>deserializeTree</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>innerNodeCount</name></expr></argument>, <argument><expr><name>offHeapRequested</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name>MerkleTree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>fullRange</name></expr></argument>, <argument><expr><name>hashDepth</name></expr></argument>, <argument><expr><name>maxSize</name></expr></argument>, <argument><expr><name>innerNodeCount</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>shouldUseOffHeapTrees</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>offHeapRequested</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>offHeapSupported</name> <init>= <expr><name>partitioner</name> <operator>instanceof</operator> <name>Murmur3Partitioner</name> <operator>||</operator> <name>partitioner</name> <operator>instanceof</operator> <name>RandomPartitioner</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>offHeapRequested</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>offHeapSupported</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>warnedOnce</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Configuration requests off-heap merkle trees, but partitioner does not support it. Ignoring."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>warnedOnce</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>offHeapRequested</name> <operator>&amp;&amp;</operator> <name>offHeapSupported</name></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>warnedOnce</name></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>ByteBuffer</name></type> <name>allocate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>innerNodeCount</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>offHeapBufferSize</name><argument_list>(<argument><expr><name>innerNodeCount</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Allocating direct buffer of size {} for an off-heap merkle tree"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>buffer</name> <init>= <expr><call><name><name>ByteBuffer</name><operator>.</operator><name>allocateDirect</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>Ref</name><operator>.</operator><name>DEBUG_ENABLED</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>MemoryUtil</name><operator>.</operator><name>setAttachment</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>Ref</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>buffer</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Node</name></type> <name>deserializeTree</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>innerNodeCount</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>offHeapRequested</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><call><name>shouldUseOffHeapTrees</name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>offHeapRequested</name></expr></argument>)</argument_list></call></expr>
             ?</condition><then> <expr><call><name>deserializeOffHeap</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>innerNodeCount</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>
             </then><else>: <expr><call><name><name>OnHeapNode</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
     * Coordinating multiple trees from multiple replicas can get expensive.
     * On the deserialization path, we know in advance what the tree looks like,
     * So we can pre-size an offheap buffer and deserialize into that.
     */</comment>
    <function><type><name>MerkleTree</name></type> <name>tryMoveOffHeap</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>root</name> <operator>instanceof</operator> <name>OnHeapNode</name> <operator>&amp;&amp;</operator> <call><name>shouldUseOffHeapTrees</name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>useOffheapMerkleTrees</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>
             ?</condition><then> <expr><call><name>moveOffHeap</name><argument_list>()</argument_list></call></expr>
             </then><else>: <expr><name>this</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name>MerkleTree</name></type> <name>moveOffHeap</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <assert>assert <expr><name>root</name> <operator>instanceof</operator> <name>OnHeapNode</name></expr>;</assert>
        <expr_stmt><expr><call><name><name>root</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// ensure on-heap trees' inner node hashes have been computed</comment>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>buffer</name> <init>= <expr><call><name>allocate</name><argument_list>(<argument><expr><call><name><name>Ints</name><operator>.</operator><name>checkedCast</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pointer</name> <init>= <expr><operator>(</operator><operator>(</operator><name>OnHeapNode</name><operator>)</operator> <name>root</name><operator>)</operator><operator>.</operator><call><name>serializeOffHeap</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffHeapNode</name></type> <name>newRoot</name> <init>= <expr><call><name>fromPointer</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <call><name>MerkleTree</name><argument_list>(<argument><expr><name>newRoot</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>fullRange</name></expr></argument>, <argument><expr><name>hashdepth</name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>OffHeapNode</name></type> <name>deserializeOffHeap</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>innerNodeCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>buffer</name> <init>= <expr><call><name>allocate</name><argument_list>(<argument><expr><name>innerNodeCount</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pointer</name> <init>= <expr><call><name><name>OffHeapNode</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>fromPointer</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>OffHeapNode</name></type> <name>fromPointer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pointer</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>pointer</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>new</operator> <call><name>OffHeapInner</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <call><name>OffHeapLeaf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>~</operator><name>pointer</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>offHeapBufferSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>innerNodeCount</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>innerNodeCount</name> <operator>*</operator> <call><name><name>OffHeapInner</name><operator>.</operator><name>maxOffHeapSize</name></name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>innerNodeCount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name><name>OffHeapLeaf</name><operator>.</operator><name>maxOffHeapSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <interface>interface <name>Node</name>
    <block>{
        <function_decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name><parameter_list>()</parameter_list>;</function_decl>

        <function_decl><type><name>boolean</name></type> <name>hasEmptyHash</name><parameter_list>()</parameter_list>;</function_decl>

        <function_decl><type><name>void</name></type> <name>hash</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>;</function_decl>

        <function_decl><type><name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>other</name></decl></parameter>)</parameter_list>;</function_decl>

        <function><type><specifier>default</specifier> <name>Node</name></type> <name>fillInnerHashes</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>long</name></type> <name>sizeOfRange</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>long</name></type> <name>partitionsInRange</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></function>

        <function_decl><type><name>void</name></type> <name>serialize</name><parameter_list>(<parameter><decl><type><name>DataOutputPlus</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>;</function_decl>
        <function_decl><type><name>int</name></type> <name>serializedSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>;</function_decl>

        <function_decl><type><name>void</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxdepth</name></decl></parameter>)</parameter_list>;</function_decl>

        <function><type><specifier>static</specifier> <name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><name>hash</name> <operator>==</operator> <literal type="null">null</literal></expr>
                 ?</condition><then> <expr><literal type="string">"null"</literal></expr>
                 </then><else>: <expr><literal type="char">'['</literal> <operator>+</operator> <call><name><name>Hex</name><operator>.</operator><name>bytesToHex</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="char">']'</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function_decl><type><name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
    }</block></interface>

    <class><specifier>static</specifier> <specifier>abstract</specifier> class <name>OnHeapNode</name> <super_list><implements>implements <super><name>Node</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>sizeOfRange</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>partitionsInRange</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>protected</specifier> <name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl>;</decl_stmt>

        <constructor><name>OnHeapNode</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>()</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name><name>byte</name><index>[]</index></name></type> <name>hash</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>hash</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasEmptyHash</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <comment type="line">//noinspection ArrayEquality</comment>
            <return>return <expr><name>hash</name> <operator>==</operator> <name>EMPTY_HASH</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>hash</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>()</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><name>other</name> <operator>instanceof</operator> <name>OnHeapNode</name></expr>
                 ?</condition><then> <expr><call><name>hashesDiffer</name><argument_list>( <argument><expr><operator>(</operator><name>OnHeapNode</name><operator>)</operator> <name>other</name></expr></argument>)</argument_list></call></expr>
                 </then><else>: <expr><call><name>hashesDiffer</name><argument_list>(<argument><expr><operator>(</operator><name>OffHeapNode</name><operator>)</operator> <name>other</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>OnHeapNode</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><operator>!</operator><call><name><name>Arrays</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name>hash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>hash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>OffHeapNode</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>compare</name><argument_list>(<argument><expr><call><name>hash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>buffer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>hashBytesOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>long</name></type> <name>sizeOfRange</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>sizeOfRange</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>long</name></type> <name>partitionsInRange</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>partitionsInRange</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>OnHeapNode</name></type> <name>deserialize</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name>byte</name></type> <name>ident</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>readByte</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name>ident</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name><name>Inner</name><operator>.</operator><name>IDENT</name></name></expr>:</case>
                    <return>return <expr><call><name><name>OnHeapInner</name><operator>.</operator><name>deserializeWithoutIdent</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return>
                <case>case <expr><name><name>Leaf</name><operator>.</operator><name>IDENT</name></name></expr>:</case>
                    <return>return <expr><call><name><name>OnHeapLeaf</name><operator>.</operator><name>deserializeWithoutIdent</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
                <default>default:</default>
                    <throw>throw <expr><operator>new</operator> <call><name>IOException</name><argument_list>(<argument><expr><literal type="string">"Unexpected node type: "</literal> <operator>+</operator> <name>ident</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></switch>
        </block_content>}</block></function>

        <function_decl><type><specifier>abstract</specifier> <name>int</name></type> <name>serializeOffHeap</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>;</function_decl>
    }</block></class>

    <class><specifier>static</specifier> <specifier>abstract</specifier> class <name>OffHeapNode</name> <super_list><implements>implements <super><name>Node</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>ByteBuffer</name></type> <name>buffer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>int</name></type> <name>offset</name></decl>;</decl_stmt>

        <constructor><name>OffHeapNode</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><name>ByteBuffer</name></type> <name>buffer</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>buffer</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>byte</name><index>[]</index></name></type> <name>hash</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>position</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><call><name>hashBytesOffset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>array</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>HASH_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>array</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasEmptyHash</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>compare</name><argument_list>(<argument><expr><call><name>buffer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>hashBytesOffset</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>, <argument><expr><name>EMPTY_HASH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>hash</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><name>other</name> <operator>instanceof</operator> <name>OnHeapNode</name></expr>
                 ?</condition><then> <expr><call><name>hashesDiffer</name><argument_list>(<argument><expr><operator>(</operator><name>OnHeapNode</name><operator>)</operator> <name>other</name></expr></argument>)</argument_list></call></expr>
                 </then><else>: <expr><call><name>hashesDiffer</name><argument_list>(<argument><expr><operator>(</operator><name>OffHeapNode</name><operator>)</operator> <name>other</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>OnHeapNode</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>compare</name><argument_list>(<argument><expr><call><name>buffer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>hashBytesOffset</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>hash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hashesDiffer</name><parameter_list>(<parameter><decl><type><name>OffHeapNode</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>thisOffset</name> <init>= <expr><call><name>hashBytesOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>otherOffset</name> <init>= <expr><call><name><name>other</name><operator>.</operator><name>hashBytesOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HASH_SIZE</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>buffer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLong</name><argument_list>(<argument><expr><name>thisOffset</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>other</name><operator>.</operator><name>buffer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLong</name><argument_list>(<argument><expr><name>otherOffset</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>void</name></type> <name>release</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Object</name></type> <name>attachment</name> <init>= <expr><call><name><name>MemoryUtil</name><operator>.</operator><name>getAttachment</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>attachment</name> <operator>instanceof</operator> <name>Ref</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Ref</name><operator>)</operator> <name>attachment</name><operator>)</operator><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>clean</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function_decl><type><specifier>abstract</specifier> <name>int</name></type> <name>hashBytesOffset</name><parameter_list>()</parameter_list>;</function_decl>

        <function><type><specifier>static</specifier> <name>int</name></type> <name>deserialize</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name>byte</name></type> <name>ident</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>readByte</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name>ident</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name><name>Inner</name><operator>.</operator><name>IDENT</name></name></expr>:</case>
                    <return>return <expr><call><name><name>OffHeapInner</name><operator>.</operator><name>deserializeWithoutIdent</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return>
                <case>case <expr><name><name>Leaf</name><operator>.</operator><name>IDENT</name></name></expr>:</case>
                    <return>return  <expr><call><name><name>OffHeapLeaf</name><operator>.</operator><name>deserializeWithoutIdent</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
                <default>default:</default>
                    <throw>throw <expr><operator>new</operator> <call><name>IOException</name><argument_list>(<argument><expr><literal type="string">"Unexpected node type: "</literal> <operator>+</operator> <name>ident</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></switch>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * A leaf node in the MerkleTree. Because the MerkleTree represents a much
     * larger perfect binary tree of depth hashdepth, a Leaf object contains
     * the value that would be contained in the perfect tree at its position.
     *
     * When rows are added to the MerkleTree using TreeRange.validate(), the
     * tree extending below the Leaf is generated in memory, but only the root
     * is stored in the Leaf.
     */</comment>
    <interface>interface <name>Leaf</name> <super_list><extends>extends <super><name>Node</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>byte</name></type> <name>IDENT</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <function><type><specifier>default</specifier> <name>void</name></type> <name>serialize</name><parameter_list>(<parameter><decl><type><name>DataOutputPlus</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name> <init>= <expr><call><name>hash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name><name>hash</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name>HASH_SIZE</name></expr>;</assert>

            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><name><name>Leaf</name><operator>.</operator><name>IDENT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasEmptyHash</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><name>HASH_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>int</name></type> <name>serializedSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>hasEmptyHash</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>HASH_SIZE</name></expr></else></ternary><operator>)</operator></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>void</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxdepth</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>other</name> <operator>instanceof</operator> <name>Leaf</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hashesDiffer</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></interface>

    <class><specifier>static</specifier> class <name>OnHeapLeaf</name> <super_list><extends>extends <super><name>OnHeapNode</name></super></extends> <implements>implements <super><name>Leaf</name></super></implements></super_list>
    <block>{
        <constructor><name>OnHeapLeaf</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>EMPTY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <constructor><name>OnHeapLeaf</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * Mixes the given value into our hash. If our hash is null,
         * our hash will become the given value.
         */</comment>
        <function><type><name>void</name></type> <name>addHash</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>partitionHash</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>partitionSize</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>hasEmptyHash</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>hash</name><argument_list>(<argument><expr><name>partitionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>xorOntoLeft</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>partitionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>sizeOfRange</name> <operator>+=</operator> <name>partitionSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>partitionsInRange</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>OnHeapLeaf</name></type> <name>deserializeWithoutIdent</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>readByte</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>size</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>HASH_SIZE</name></expr>:</case>
                    <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hash</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>HASH_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
                <case>case <expr><literal type="number">0</literal></expr>:</case>
                    <return>return <expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>()</argument_list></call></expr>;</return>
                <default>default:</default>
                    <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name>format</name><argument_list>(<argument><expr><literal type="string">"Hash of size %d encountered, expecting %d or %d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></switch>
        </block_content>}</block></function>

        <function><type><name>int</name></type> <name>serializeOffHeap</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name><name>OffHeapLeaf</name><operator>.</operator><name>maxOffHeapSize</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Insufficient remaining bytes to deserialize a Leaf node off-heap"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>hash</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <name>HASH_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Hash of unexpected size when serializing a Leaf off-heap: "</literal> <operator>+</operator> <name><name>hash</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>position</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>~</operator><name>position</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="string">"#&lt;OnHeapLeaf "</literal> <operator>+</operator> <call><name><name>Node</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><call><name>hash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="char">'&gt;'</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>static</specifier> class <name>OffHeapLeaf</name> <super_list><extends>extends <super><name>OffHeapNode</name></super></extends> <implements>implements <super><name>Leaf</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>HASH_BYTES_OFFSET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <constructor><name>OffHeapLeaf</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>hashBytesOffset</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>offset</name> <operator>+</operator> <name>HASH_BYTES_OFFSET</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>int</name></type> <name>deserializeWithoutIdent</name><parameter_list>(<parameter><decl><type><name>DataInput</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name>maxOffHeapSize</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Insufficient remaining bytes to deserialize a Leaf node off-heap"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>position</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>hashLength</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>readByte</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>hashLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>hashLength</name> <operator>!=</operator> <name>HASH_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Hash of unexpected size when deserializing an off-heap Leaf node: "</literal> <operator>+</operator> <name>hashLength</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hashBytes</name> <init>= <expr><call><name>getTempArray</name><argument_list>(<argument><expr><name>HASH_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>hashBytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>hashBytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>EMPTY_HASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HASH_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <return>return <expr><operator>~</operator><name>position</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>int</name></type> <name>maxOffHeapSize</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>HASH_SIZE</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="string">"#&lt;OffHeapLeaf "</literal> <operator>+</operator> <call><name><name>Node</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><call><name>hash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="char">'&gt;'</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * An inner node in the MerkleTree. Inners can contain cached hash values, which
     * are the binary hash of their two children.
     */</comment>
    <interface>interface <name>Inner</name> <super_list><extends>extends <super><name>Node</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>byte</name></type> <name>IDENT</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

        <function_decl><type><specifier>public</specifier> <name>Token</name></type> <name>token</name><parameter_list>()</parameter_list>;</function_decl>

        <function_decl><type><specifier>public</specifier> <name>Node</name></type> <name>left</name><parameter_list>()</parameter_list>;</function_decl>
        <function_decl><type><specifier>public</specifier> <name>Node</name></type> <name>right</name><parameter_list>()</parameter_list>;</function_decl>

        <function><type><specifier>default</specifier> <name>void</name></type> <name>serialize</name><parameter_list>(<parameter><decl><type><name>DataOutputPlus</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>writeByte</name></name><argument_list>(<argument><expr><name><name>Inner</name><operator>.</operator><name>IDENT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>serialize</name></name><argument_list>(<argument><expr><call><name>token</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>left</name><argument_list>()</argument_list></call><operator>.</operator><call><name>serialize</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>right</name><argument_list>()</argument_list></call><operator>.</operator><call><name>serialize</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>int</name></type> <name>serializedSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="number">1</literal>
                 <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>serializedSize</name></name><argument_list>(<argument><expr><call><name>token</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call>
                 <operator>+</operator> <call><name>left</name><argument_list>()</argument_list></call><operator>.</operator><call><name>serializedSize</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call>
                 <operator>+</operator> <call><name>right</name><argument_list>()</argument_list></call><operator>.</operator><call><name>serializedSize</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>void</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxdepth</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"#&lt;"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name>getClass</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSimpleName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name>token</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">" hash="</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><call><name>hash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">" children=["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>maxdepth</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name></type> <name>left</name> <init>= <expr><call><name>left</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>left</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>left</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>maxdepth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>Node</name></type> <name>right</name> <init>= <expr><call><name>right</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>right</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>right</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>maxdepth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name><name>buff</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"]&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>other</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>other</name> <operator>instanceof</operator> <name>Inner</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>Inner</name></type> <name>that</name> <init>= <expr><operator>(</operator><name>Inner</name><operator>)</operator> <name>other</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><operator>!</operator><call><name>hashesDiffer</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>that</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>that</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>default</specifier> <name>void</name></type> <name>unsafeInvalidate</name><parameter_list>()</parameter_list>
        <block>{<block_content>
        </block_content>}</block></function>
    }</block></interface>

    <class><specifier>static</specifier> class <name>OnHeapInner</name> <super_list><extends>extends <super><name>OnHeapNode</name></super></extends> <implements>implements <super><name>Inner</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Token</name></type> <name>token</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>OnHeapNode</name></type> <name>left</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>OnHeapNode</name></type> <name>right</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>computed</name></decl>;</decl_stmt>

        <constructor><name>OnHeapInner</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>OnHeapNode</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>OnHeapNode</name></type> <name>right</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>EMPTY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>token</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>Token</name></type> <name>token</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>token</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>OnHeapNode</name></type> <name>left</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>left</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>OnHeapNode</name></type> <name>right</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>right</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>void</name></type> <name>left</name><parameter_list>(<parameter><decl><type><name>OnHeapNode</name></type> <name>child</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>left</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><name>void</name></type> <name>right</name><parameter_list>(<parameter><decl><type><name>OnHeapNode</name></type> <name>child</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>right</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>Node</name></type> <name>fillInnerHashes</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>computed</name></expr>)</condition> <comment type="line">// hash and size haven't been calculated; compute children then compute this</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>left</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>right</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>left</name><operator>.</operator><name>hasEmptyHash</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>right</name><operator>.</operator><name>hasEmptyHash</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>xor</name><argument_list>(<argument><expr><call><name><name>left</name><operator>.</operator><name>hash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>right</name><operator>.</operator><name>hash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name><name>left</name><operator>.</operator><name>hasEmptyHash</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name><name>right</name><operator>.</operator><name>hash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name><name>right</name><operator>.</operator><name>hasEmptyHash</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name><name>left</name><operator>.</operator><name>hash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>sizeOfRange</name>       <operator>=</operator> <call><name><name>left</name><operator>.</operator><name>sizeOfRange</name></name><argument_list>()</argument_list></call>       <operator>+</operator> <call><name><name>right</name><operator>.</operator><name>sizeOfRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>partitionsInRange</name> <operator>=</operator> <call><name><name>left</name><operator>.</operator><name>partitionsInRange</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>right</name><operator>.</operator><name>partitionsInRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>computed</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>OnHeapInner</name></type> <name>deserializeWithoutIdent</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OnHeapNode</name></type>  <name>left</name> <init>= <expr><call><name><name>OnHeapNode</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OnHeapNode</name></type> <name>right</name> <init>= <expr><call><name><name>OnHeapNode</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><operator>new</operator> <call><name>OnHeapInner</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>int</name></type> <name>serializeOffHeap</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name><name>OffHeapInner</name><operator>.</operator><name>maxOffHeapSize</name></name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Insufficient remaining bytes to deserialize Inner node off-heap"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>tokenSize</name> <init>= <expr><call><name><name>partitioner</name><operator>.</operator><name>getTokenFactory</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>byteSize</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putShort</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>TOKEN_LENGTH_OFFSET</name></name></expr></argument>, <argument><expr><call><name><name>Shorts</name><operator>.</operator><name>checkedCast</name></name><argument_list>(<argument><expr><name>tokenSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>TOKEN_BYTES_OFFSET</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>partitioner</name><operator>.</operator><name>getTokenFactory</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>serialize</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type>  <name>leftPointer</name> <init>=  <expr><call><name><name>left</name><operator>.</operator><name>serializeOffHeap</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rightPointer</name> <init>= <expr><call><name><name>right</name><operator>.</operator><name>serializeOffHeap</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putInt</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>LEFT_CHILD_POINTER_OFFSET</name></name></expr></argument>,  <argument><expr><name>leftPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putInt</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>RIGHT_CHILD_POINTER_OFFSET</name></name></expr></argument>, <argument><expr><name>rightPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type>  <name>leftHashOffset</name> <init>= <expr><call><name><name>OffHeapInner</name><operator>.</operator><name>hashBytesOffset</name></name><argument_list>(<argument><expr><name>leftPointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rightHashOffset</name> <init>= <expr><call><name><name>OffHeapInner</name><operator>.</operator><name>hashBytesOffset</name></name><argument_list>(<argument><expr><name>rightPointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HASH_SIZE</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putLong</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>HASH_BYTES_OFFSET</name></name> <operator>+</operator> <name>i</name></expr></argument>,
                               <argument><expr><call><name><name>buffer</name><operator>.</operator><name>getLong</name></name><argument_list>(<argument><expr><name>leftHashOffset</name>  <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name><name>buffer</name><operator>.</operator><name>getLong</name></name><argument_list>(<argument><expr><name>rightHashOffset</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <return>return <expr><name>offset</name></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>toString</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>unsafeInvalidate</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>computed</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>static</specifier> class <name>OffHeapInner</name> <super_list><extends>extends <super><name>OffHeapNode</name></super></extends> <implements>implements <super><name>Inner</name></super></implements></super_list>
    <block>{
        <comment type="block" format="javadoc">/**
         * All we want to keep here is just a pointer to the start of the Inner leaf in the
         * direct buffer. From there, we'll be able to deserialize the following, in this order:
         *
         * 1. pointer to left child (int)
         * 2. pointer to right child (int)
         * 3. hash bytes (space allocated as HASH_MAX_SIZE)
         * 4. token length (short)
         * 5. token bytes (variable length)
         */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>LEFT_CHILD_POINTER_OFFSET</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>RIGHT_CHILD_POINTER_OFFSET</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>HASH_BYTES_OFFSET</name>          <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TOKEN_LENGTH_OFFSET</name>        <init>= <expr><literal type="number">8</literal> <operator>+</operator> <name>HASH_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TOKEN_BYTES_OFFSET</name>         <init>= <expr><name>TOKEN_LENGTH_OFFSET</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>IPartitioner</name></type> <name>partitioner</name></decl>;</decl_stmt>

        <constructor><name>OffHeapInner</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>partitioner</name></name> <operator>=</operator> <name>partitioner</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>Token</name></type> <name>token</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getShort</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>TOKEN_LENGTH_OFFSET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>partitioner</name><operator>.</operator><name>getTokenFactory</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>fromByteBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <name>TOKEN_BYTES_OFFSET</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Node</name></type> <name>left</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>child</name><argument_list>(<argument><expr><name>LEFT_CHILD_POINTER_OFFSET</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Node</name></type> <name>right</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>child</name><argument_list>(<argument><expr><name>RIGHT_CHILD_POINTER_OFFSET</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>Node</name></type> <name>child</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>childOffset</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>pointer</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>getInt</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>childOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><ternary><condition><expr><name>pointer</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>new</operator> <call><name>OffHeapInner</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <call><name>OffHeapLeaf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>~</operator><name>pointer</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>hashBytesOffset</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>offset</name> <operator>+</operator> <name>HASH_BYTES_OFFSET</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>int</name></type> <name>deserializeWithoutIdent</name><parameter_list>(<parameter><decl><type><name>DataInputPlus</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>remaining</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name>maxOffHeapSize</name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Insufficient remaining bytes to deserialize Inner node off-heap"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>tokenSize</name> <init>= <expr><call><name><name>Token</name><operator>.</operator><name>serializer</name><operator>.</operator><name>deserializeSize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>tokenBytes</name> <init>= <expr><call><name>getTempArray</name><argument_list>(<argument><expr><name>tokenSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>readFully</name></name><argument_list>(<argument><expr><name>tokenBytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tokenSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putShort</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>TOKEN_LENGTH_OFFSET</name></name></expr></argument>, <argument><expr><call><name><name>Shorts</name><operator>.</operator><name>checkedCast</name></name><argument_list>(<argument><expr><name>tokenSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>position</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>TOKEN_BYTES_OFFSET</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>tokenBytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tokenSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>leftPointer</name>  <init>= <expr><call><name><name>OffHeapNode</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rightPointer</name> <init>= <expr><call><name><name>OffHeapNode</name><operator>.</operator><name>deserialize</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putInt</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>LEFT_CHILD_POINTER_OFFSET</name></name></expr></argument>,  <argument><expr><name>leftPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putInt</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>RIGHT_CHILD_POINTER_OFFSET</name></name></expr></argument>, <argument><expr><name>rightPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>leftHashOffset</name>  <init>= <expr><call><name>hashBytesOffset</name><argument_list>(<argument><expr><name>leftPointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rightHashOffset</name> <init>= <expr><call><name>hashBytesOffset</name><argument_list>(<argument><expr><name>rightPointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HASH_SIZE</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>putLong</name></name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>HASH_BYTES_OFFSET</name></name> <operator>+</operator> <name>i</name></expr></argument>,
                               <argument><expr><call><name><name>buffer</name><operator>.</operator><name>getLong</name></name><argument_list>(<argument><expr><name>leftHashOffset</name>  <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name><name>buffer</name><operator>.</operator><name>getLong</name></name><argument_list>(<argument><expr><name>rightHashOffset</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <return>return <expr><name>offset</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>int</name></type> <name>maxOffHeapSize</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="number">4</literal> <comment type="line">// left pointer</comment>
                 <operator>+</operator> <literal type="number">4</literal> <comment type="line">// right pointer</comment>
                 <operator>+</operator> <name>HASH_SIZE</name>
                 <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <call><name><name>partitioner</name><operator>.</operator><name>getMaxTokenSize</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>int</name></type> <name>hashBytesOffset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pointer</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><ternary><condition><expr><name>pointer</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>pointer</name> <operator>+</operator> <name><name>OffHeapInner</name><operator>.</operator><name>HASH_BYTES_OFFSET</name></name></expr> </then><else>: <expr><operator>~</operator><name>pointer</name> <operator>+</operator> <name><name>OffHeapLeaf</name><operator>.</operator><name>HASH_BYTES_OFFSET</name></name></expr></else></ternary></expr>;</return>
        </block_content>}</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buff</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>toString</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>buff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * @return The bitwise XOR of the inputs.
     */</comment>
    <function><type><specifier>static</specifier> <name><name>byte</name><index>[]</index></name></type> <name>xor</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name><name>left</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>right</name><operator>.</operator><name>length</name></name></expr>;</assert>

        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>out</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>left</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>right</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><name>out</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Bitwise XOR of the inputs, in place on the left array.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>xorOntoLeft</name><parameter_list>(<parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name><name>left</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>right</name><operator>.</operator><name>length</name></name></expr>;</assert>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>left</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator> <operator>(</operator><operator>(</operator><name><name>left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>right</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Estimate the allowable depth while keeping the resulting heap usage of this tree under the provided
     * number of bytes. This is important for ensuring that we do not allocate overly large trees that could
     * OOM the JVM and cause instability.
     *
     * Calculated using the following logic:
     *
     * Let T = size of a tree of depth n
     *
     * T = #leafs  * sizeof(leaf) + #inner  * sizeof(inner)
     * T = 2^n     * L            + 2^n - 1 * I
     *
     * T = 2^n * L + 2^n * I - I;
     *
     * So to solve for n given sizeof(tree_n) T:
     *
     * n = floor(log_2((T + I) / (L + I))
     *
     * @param numBytes: The number of bytes to fit the tree within
     * @param bytesPerHash: The number of bytes stored in a leaf node, for example 2 * murmur128 will be 256 bits
     *                    or 32 bytes
     * @return the estimated depth that will fit within the provided number of bytes
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>estimatedMaxDepthForBytes</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>numBytes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytesPerHash</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hashLeft</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>bytesPerHash</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>hashRigth</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>bytesPerHash</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OnHeapLeaf</name></type> <name>left</name> <init>= <expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>(<argument><expr><name>hashLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OnHeapLeaf</name></type> <name>right</name> <init>= <expr><operator>new</operator> <call><name>OnHeapLeaf</name><argument_list>(<argument><expr><name>hashRigth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Inner</name></type> <name>inner</name> <init>= <expr><operator>new</operator> <call><name>OnHeapInner</name><argument_list>(<argument><expr><call><name><name>partitioner</name><operator>.</operator><name>getMinimumToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>inner</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Some partioners have variable token sizes, try to estimate as close as we can by using the same</comment>
        <comment type="line">// heap estimate as the memtables use.</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>innerTokenSize</name> <init>= <expr><call><name><name>ObjectSizes</name><operator>.</operator><name>measureDeep</name></name><argument_list>(<argument><expr><call><name><name>partitioner</name><operator>.</operator><name>getMinimumToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>realInnerTokenSize</name> <init>= <expr><call><name><name>partitioner</name><operator>.</operator><name>getMinimumToken</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getHeapSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>sizeOfLeaf</name> <init>= <expr><call><name><name>ObjectSizes</name><operator>.</operator><name>measureDeep</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>sizeOfInner</name> <init>= <expr><call><name><name>ObjectSizes</name><operator>.</operator><name>measureDeep</name></name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call> <operator>-</operator>
                           <operator>(</operator><call><name><name>ObjectSizes</name><operator>.</operator><name>measureDeep</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>ObjectSizes</name><operator>.</operator><name>measureDeep</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>innerTokenSize</name><operator>)</operator> <operator>+</operator>
                           <name>realInnerTokenSize</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>adjustedBytes</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>numBytes</name> <operator>+</operator> <name>sizeOfInner</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>sizeOfLeaf</name> <operator>+</operator> <name>sizeOfInner</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>floor</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>log</name></name><argument_list>(<argument><expr><name>adjustedBytes</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name><name>Math</name><operator>.</operator><name>log</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
     * Test-only methods.
     */</comment>

    <comment type="block" format="javadoc">/**
     * Invalidates the ranges containing the given token.
     * Useful for testing.
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name>void</name></type> <name>unsafeInvalidate</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>unsafeInvalidateHelper</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>unsafeInvalidateHelper</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>pleft</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>node</name><operator>.</operator><name>hash</name></name><argument_list>(<argument><expr><name>EMPTY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <assert>assert <expr><name>node</name> <operator>instanceof</operator> <name>Inner</name></expr>;</assert>
        <decl_stmt><decl><type><name>Inner</name></type> <name>inner</name> <init>= <expr><operator>(</operator><name>Inner</name><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>inner</name><operator>.</operator><name>unsafeInvalidate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>pleft</name></expr></argument>, <argument><expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>unsafeInvalidateHelper</name><argument_list>(<argument><expr><call><name><name>inner</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="line">// left child contains token</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>unsafeInvalidateHelper</name><argument_list>(<argument><expr><call><name><name>inner</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="line">// right child contains token</comment>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Hash the given range in the tree. The range must have been generated
     * with recursive applications of partitioner.midpoint().
     *
     * NB: Currently does not support wrapping ranges that do not end with
     * partitioner.getMinimumToken().
     *
     * @return {@link #EMPTY_HASH} if any subrange of the range is invalid, or if the exact
     *         range cannot be calculated using this tree.
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name><name>byte</name><index>[]</index></name></type> <name>hash</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>find</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>hash</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <interface>interface <name><name>Consumer</name><parameter_list>&lt;<parameter><name>E</name> <extends>extends <name>Exception</name></extends></parameter>&gt;</parameter_list></name>
    <block>{
        <function_decl><type><name>void</name></type> <name>accept</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>node</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>E</name></expr></argument></throws>;</function_decl>
    }</block></interface>

    <function><annotation>@<name><name>VisibleForTesting</name>
    <argument_list type="generic">&lt;<argument><name>E</name> <extends>extends <name>Exception</name></extends></argument>&gt;</argument_list></name></annotation> <type><name>boolean</name></type> <name>ifHashesRange</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>, <parameter><decl><type><name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>E</name></argument>&gt;</argument_list></name></type> <name>consumer</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>E</name></expr></argument></throws>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name></type> <name>node</name> <init>= <expr><call><name>findHelper</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>hasHash</name> <init>= <expr><operator>!</operator><call><name><name>node</name><operator>.</operator><name>hasEmptyHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>hasHash</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>consumer</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>hasHash</name></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>StopRecursion</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name>boolean</name></type> <name>hashesRange</name><parameter_list>(<parameter><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>ifHashesRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>n</name></decl></parameter></parameter_list> -&gt; <block>{<block_content/>}</block></lambda></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * For testing purposes.
     * Gets the smallest range containing the token.
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>TreeRange</name></type> <name>get</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getHelper</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>fullRange</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>TreeRange</name></type> <name>getHelper</name><parameter_list>(<parameter><decl><type><name>Node</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>pleft</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>pright</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>t</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>node</name> <operator>instanceof</operator> <name>Leaf</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// we've reached a hash: wrap it up and deliver it</comment>
                <return>return <expr><operator>new</operator> <call><name>TreeRange</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <assert>assert <expr><name>node</name> <operator>instanceof</operator> <name>Inner</name></expr>;</assert>
            <decl_stmt><decl><type><name>Inner</name></type> <name>inner</name> <init>= <expr><operator>(</operator><name>Inner</name><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>pleft</name></expr></argument>, <argument><expr><call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="line">// left child contains token</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>pright</name> <operator>=</operator> <call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>inner</name><operator>.</operator><name>left</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="line">// right child contains token</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>pleft</name> <operator>=</operator> <call><name><name>inner</name><operator>.</operator><name>token</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>inner</name><operator>.</operator><name>right</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>fillInnerHashes</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>root</name><operator>.</operator><name>fillInnerHashes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
}</block></class>
</unit>
