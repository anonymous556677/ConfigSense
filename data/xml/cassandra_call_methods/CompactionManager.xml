<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/db/compaction/CompactionManager.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>compaction</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>File</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>BooleanSupplier</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Predicate</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>stream</name><operator>.</operator><name>Collectors</name></name>;</import>
<import>import <name><name>javax</name><operator>.</operator><name>management</name><operator>.</operator><name>openmbean</name><operator>.</operator><name>OpenDataException</name></name>;</import>
<import>import <name><name>javax</name><operator>.</operator><name>management</name><operator>.</operator><name>openmbean</name><operator>.</operator><name>TabularData</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Preconditions</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>*</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>AbstractBounds</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>RangesAtEndpoint</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>io</name><operator>.</operator><name>netty</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>FastThreadLocal</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cache</name><operator>.</operator><name>AutoSavingCache</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>DebuggableThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>JMXEnabledThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>NamedThreadFactory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>exceptions</name><operator>.</operator><name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>TableMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>Schema</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>compaction</name><operator>.</operator><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>ILifecycleTransaction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>LifecycleTransaction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>SSTableIntervalTree</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>SSTableSet</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>View</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>WrappedLifecycleTransaction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>rows</name><operator>.</operator><name>UnfilteredRowIterator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>view</name><operator>.</operator><name>ViewBuilderTask</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Bounds</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Range</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>index</name><operator>.</operator><name>SecondaryIndexBuilder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>Descriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>ISSTableScanner</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>IndexSummaryRedistribution</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>SSTableRewriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>SnapshotDeletingTask</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>format</name><operator>.</operator><name>SSTableWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataCollector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>StatsMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>util</name><operator>.</operator><name>FileUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>CompactionMetrics</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>metrics</name><operator>.</operator><name>TableMetrics</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>CompactionParams</name><operator>.</operator><name>TombstoneOption</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>ActiveRepairService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>StorageService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>PreviewKind</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Throwables</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Refs</name></name>;</import>

<import>import static <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name><operator>.</operator><name>singleton</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>ActiveRepairService</name><operator>.</operator><name>NO_PENDING_REPAIR</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>ActiveRepairService</name><operator>.</operator><name>UNREPAIRED_SSTABLE</name></name>;</import>

<comment type="block" format="javadoc">/**
 * &lt;p&gt;
 * A singleton which manages a private executor of ongoing compactions.
 * &lt;/p&gt;
 * Scheduling for compaction is accomplished by swapping sstables to be compacted into
 * a set via Tracker. New scheduling attempts will ignore currently compacting
 * sstables.
 */</comment>
<class><specifier>public</specifier> class <name>CompactionManager</name> <super_list><implements>implements <super><name>CompactionManagerMBean</name></super></implements></super_list>
<block>{
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MBEAN_OBJECT_NAME</name> <init>= <expr><literal type="string">"org.apache.cassandra.db:type=CompactionManager"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>CompactionManager</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>CompactionManager</name></type> <name>instance</name></decl>;</decl_stmt>

    <decl_stmt><decl><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>currentlyBackgroundUpgrading</name> <init>= <expr><operator>new</operator> <call><name>AtomicInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>NO_GC</name> <init>= <expr><name><name>Integer</name><operator>.</operator><name>MIN_VALUE</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GC_ALL</name> <init>= <expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// A thread local that tells us if the current thread is owned by the compaction manager. Used</comment>
    <comment type="line">// by CounterContext to figure out if it should log a warning for invalid counter shards.</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>FastThreadLocal</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>isCompactionManager</name> <init>= <expr><operator>new</operator> <class><super><name><name>FastThreadLocal</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
    <block>{
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>protected</specifier> <name>Boolean</name></type> <name>initialValue</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <static>static
    <block>{<block_content>
        <expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>new</operator> <call><name>CompactionManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MBeanWrapper</name><operator>.</operator><name>instance</name><operator>.</operator><name>registerMBean</name></name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>MBEAN_OBJECT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></static>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CompactionExecutor</name></type> <name>executor</name> <init>= <expr><operator>new</operator> <call><name>CompactionExecutor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ValidationExecutor</name></type> <name>validationExecutor</name> <init>= <expr><operator>new</operator> <call><name>ValidationExecutor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CompactionExecutor</name></type> <name>cacheCleanupExecutor</name> <init>= <expr><operator>new</operator> <call><name>CacheCleanupExecutor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CompactionExecutor</name></type> <name>viewBuildExecutor</name> <init>= <expr><operator>new</operator> <call><name>ViewBuildExecutor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CompactionMetrics</name></type> <name>metrics</name> <init>= <expr><operator>new</operator> <call><name>CompactionMetrics</name><argument_list>(<argument><expr><name>executor</name></expr></argument>, <argument><expr><name>validationExecutor</name></expr></argument>, <argument><expr><name>viewBuildExecutor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>final</specifier> <name><name>Multiset</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>compactingCF</name> <init>= <expr><call><name><name>ConcurrentHashMultiset</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>ActiveCompactions</name></type> <name>active</name> <init>= <expr><operator>new</operator> <call><name>ActiveCompactions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// used to temporarily pause non-strategy managed compactions (like index summary redistribution)</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>globalCompactionPauseCount</name> <init>= <expr><operator>new</operator> <call><name>AtomicInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RateLimiter</name></type> <name>compactionRateLimiter</name> <init>= <expr><call><name><name>RateLimiter</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name><name>Double</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <name>CompactionMetrics</name></type> <name>getMetrics</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>metrics</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Gets compaction rate limiter.
     * Rate unit is bytes per sec.
     *
     * @return RateLimiter with rate limit set
     */</comment>
    <function><type><specifier>public</specifier> <name>RateLimiter</name></type> <name>getRateLimiter</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>setRate</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getCompactionThroughputMbPerSec</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>compactionRateLimiter</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Sets the rate for the rate limiter. When compaction_throughput_mb_per_sec is 0 or node is bootstrapping,
     * this sets the rate to Double.MAX_VALUE bytes per second.
     * @param throughPutMbPerSec throughput to set in mb per second
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRate</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>double</name></type> <name>throughPutMbPerSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>throughput</name> <init>= <expr><name>throughPutMbPerSec</name> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// if throughput is set to 0, throttling is disabled</comment>
        <if_stmt><if>if <condition>(<expr><name>throughput</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>isBootstrapMode</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>throughput</name> <operator>=</operator> <name><name>Double</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>compactionRateLimiter</name><operator>.</operator><name>getRate</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>throughput</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>compactionRateLimiter</name><operator>.</operator><name>setRate</name></name><argument_list>(<argument><expr><name>throughput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Call this whenever a compaction might be needed on the given columnfamily.
     * It's okay to over-call (within reason) if a call is unnecessary, it will
     * turn into a no-op in the bucketing/candidate-scan phase.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>submitBackground</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>cfs</name><operator>.</operator><name>isAutoCompactionDisabled</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Autocompaction is disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block" format="javadoc">/**
         * If a CF is currently being compacted, and there are no idle threads, submitBackground should be a no-op;
         * we can wait for the current compaction to finish and re-submit when more information is available.
         * Otherwise, we should submit at least one task to prevent starvation by busier CFs, and more if there
         * are idle threads stil. (CASSANDRA-4310)
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name><name>compactingCF</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>executor</name><operator>.</operator><name>getActiveCount</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>executor</name><operator>.</operator><name>getMaximumPoolSize</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Background compaction is still running for {}.{} ({} remaining). Skipping"</literal></expr></argument>,
                         <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Scheduling a background task check for {}.{} with {}"</literal></expr></argument>,
                     <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>,
                     <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fut</name> <init>= <expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>BackgroundCompactionCandidate</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"background task"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fut</name><operator>.</operator><name>isCancelled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>fut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>compactingCF</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><name>futures</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isCompacting</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfses</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstablePredicate</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>cfses</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>cfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCompacting</name><argument_list>()</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call><operator>.</operator><call><name>anyMatch</name><argument_list>(<argument><expr><name>sstablePredicate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Shutdowns both compaction and validation executors, cancels running compaction / validation,
     * and waits for tasks to complete if tasks were not cancelable.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceShutdown</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <comment type="line">// shutdown executors to prevent further submission</comment>
        <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>validationExecutor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cacheCleanupExecutor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// interrupt compactions and validations</comment>
        <for>for <control>(<init><decl><type><name>Holder</name></type> <name>compactionHolder</name> <range>: <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>compactionHolder</name><operator>.</operator><name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// wait for tasks to terminate</comment>
        <comment type="line">// compaction tasks are interrupted above, so it shuold be fairy quick</comment>
        <comment type="line">// until not interrupted tasks to complete.</comment>
        <for>for <control>(<init><decl><type><name>ExecutorService</name></type> <name>exec</name> <range>: <expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>executor</name></expr></argument>, <argument><expr><name>validationExecutor</name></expr></argument>, <argument><expr><name>viewBuildExecutor</name></expr></argument>, <argument><expr><name>cacheCleanupExecutor</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <try>try
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>exec</name><operator>.</operator><name>awaitTermination</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MINUTES</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Failed to wait for compaction executors shutdown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>InterruptedException</name></type> <name>e</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Interrupted while waiting for tasks to be terminated"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></catch></try>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>finishCompactionsAndShutdown</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>TimeUnit</name></type> <name>unit</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>awaitTermination</name></name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line">// the actual sstables to compact are not determined until we run the BCT; that way, if new sstables</comment>
    <comment type="line">// are created between task submission and execution, we execute against the most up-to-date information</comment>
    <class><annotation>@<name>VisibleForTesting</name></annotation>
    class <name>BackgroundCompactionCandidate</name> <super_list><implements>implements <super><name>Runnable</name></super></implements></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl>;</decl_stmt>

        <constructor><name>BackgroundCompactionCandidate</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>compactingCF</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>cfs</name></name> <operator>=</operator> <name>cfs</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <decl_stmt><decl><type><name>boolean</name></type> <name>ranCompaction</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Checking {}.{}"</literal></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cfs</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Aborting compaction for dropped CF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>

                <decl_stmt><decl><type><name>CompactionStrategyManager</name></type> <name>strategy</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AbstractCompactionTask</name></type> <name>task</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getNextBackgroundTask</name></name><argument_list>(<argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>automaticSSTableUpgrade</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>ranCompaction</name> <operator>=</operator> <call><name>maybeRunUpgradeTask</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ranCompaction</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>
            <finally>finally
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>compactingCF</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
            <if_stmt><if>if <condition>(<expr><name>ranCompaction</name></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// only submit background if we actually ran a compaction - otherwise we end up in an infinite loop submitting noop background tasks</comment>
                <expr_stmt><expr><call><name>submitBackground</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></function>

        <function><type><name>boolean</name></type> <name>maybeRunUpgradeTask</name><parameter_list>(<parameter><decl><type><name>CompactionStrategyManager</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Checking for upgrade tasks {}.{}"</literal></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>currentlyBackgroundUpgrading</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>maxConcurrentAutoUpgradeTasks</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AbstractCompactionTask</name></type> <name>upgradeTask</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>findUpgradeSSTableTask</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>upgradeTask</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>upgradeTask</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <finally>finally
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>currentlyBackgroundUpgrading</name><operator>.</operator><name>decrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"No tasks available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>BackgroundCompactionCandidate</name></type> <name>getBackgroundCompactionCandidate</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>BackgroundCompactionCandidate</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Run an operation over all sstables using jobs threads
     *
     * @param cfs the column family store to run the operation on
     * @param operation the operation to run
     * @param jobs the number of threads to use - 0 means use all available. It never uses more than concurrent_compactors threads
     * @return status of the operation
     * @throws ExecutionException
     * @throws InterruptedException
     */</comment>
    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>private</specifier> <name>AllSSTableOpStatus</name></type> <name>parallelAllSSTableOperation</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>OneSSTableOperation</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>, <parameter><decl><type><name>OperationType</name></type> <name>operationType</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Starting {} for {}.{}"</literal></expr></argument>, <argument><expr><name>operationType</name></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>LifecycleTransaction</name></argument>&gt;</argument_list></name></type> <name>transactions</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name>LifecycleTransaction</name></type> <name>compacting</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>markAllCompacting</name></name><argument_list>(<argument><expr><name>operationType</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>compacting</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>UNABLE_TO_CANCEL</name></name></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>operation</name><operator>.</operator><name>filterSSTables</name></name><argument_list>(<argument><expr><name>compacting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>Iterables</name><operator>.</operator><name>isEmpty</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"No sstables to {} for {}.{}"</literal></expr></argument>, <argument><expr><call><name><name>operationType</name><operator>.</operator><name>name</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cfs</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>SUCCESSFUL</name></name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><decl><type><specifier>final</specifier> <name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>final</specifier> <name>LifecycleTransaction</name></type> <name>txn</name> <init>= <expr><call><name><name>compacting</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><call><name>singleton</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>transactions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>callable</name> <init>= <expr><operator>new</operator> <class><super><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
                <block>{
                    <function><annotation>@<name>Override</name></annotation>
                    <type><specifier>public</specifier> <name>Object</name></type> <name>call</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>operation</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>this</name></expr>;</return>
                    </block_content>}</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fut</name> <init>= <expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>callable</name></expr></argument>, <argument><expr><literal type="string">"paralell sstable operation"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fut</name><operator>.</operator><name>isCancelled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>fut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>ABORTED</name></name></expr>;</return></block_content></block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>jobs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>futures</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>jobs</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>f</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFirstFuture</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>compacting</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>;</assert>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Finished {} for {}.{} successfully"</literal></expr></argument>, <argument><expr><name>operationType</name></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>SUCCESSFUL</name></name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <comment type="line">// wait on any unfinished futures to make sure we don't close an ongoing transaction</comment>
            <try>try
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
               <comment type="line">// these are handled/logged in CompactionExecutor#afterExecute</comment>
            </block_content>}</block></catch></try>
            <decl_stmt><decl><type><name>Throwable</name></type> <name>fail</name> <init>= <expr><call><name><name>Throwables</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>transactions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fail</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Failed to cleanup lifecycle transactions ({} for {}.{})"</literal></expr></argument>, <argument><expr><name>operationType</name></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <interface><specifier>private</specifier> <specifier>static</specifier> interface <name>OneSSTableOperation</name>
    <block>{
        <function_decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>transaction</name></decl></parameter>)</parameter_list>;</function_decl>
        <function_decl><type><name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>input</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>;</function_decl>
    }</block></interface>

    <enum><specifier>public</specifier> enum <name>AllSSTableOpStatus</name>
    <block>{
        <decl><name>SUCCESSFUL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>,
        <decl><name>ABORTED</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>,
        <decl><name>UNABLE_TO_CANCEL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></decl>;

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>statusCode</name></decl>;</decl_stmt>

        <constructor><name>AllSSTableOpStatus</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>statusCode</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>statusCode</name></name> <operator>=</operator> <name>statusCode</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>
    }</block></enum>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>performScrub</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>skipCorrupted</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>checkData</name></decl></parameter>,
                                           <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list>
    <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>performScrub</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>skipCorrupted</name></expr></argument>, <argument><expr><name>checkData</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>performScrub</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>skipCorrupted</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>checkData</name></decl></parameter>,
                                           <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>reinsertOverflowedTTL</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list>
    <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>parallelAllSSTableOperation</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>OneSSTableOperation</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>input</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>input</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>input</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>scrubOne</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>skipCorrupted</name></expr></argument>, <argument><expr><name>checkData</name></expr></argument>, <argument><expr><name>reinsertOverflowedTTL</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><name>jobs</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>SCRUB</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>performVerify</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name><name>Verifier</name><operator>.</operator><name>Options</name></name></type> <name>options</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{<block_content>
        <assert>assert <expr><operator>!</operator><call><name><name>cfs</name><operator>.</operator><name>isIndex</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><call><name>parallelAllSSTableOperation</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>OneSSTableOperation</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>input</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>input</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>input</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>verifyOne</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><call><name><name>input</name><operator>.</operator><name>onlyOne</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>VERIFY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>performSSTableRewrite</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>excludeCurrentVersion</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>parallelAllSSTableOperation</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>OneSSTableOperation</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>transaction</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sortedSSTables</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>transaction</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>sortedSSTables</name></expr></argument>, <argument><expr><call><name><name>SSTableReader</name><operator>.</operator><name>sizeComparator</name><operator>.</operator><name>reversed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>sortedSSTables</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>excludeCurrentVersion</name> <operator>&amp;&amp;</operator> <call><name><name>sstable</name><operator>.</operator><name>descriptor</name><operator>.</operator><name>version</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>descriptor</name><operator>.</operator><name>getFormat</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLatestVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>transaction</name><operator>.</operator><name>cancel</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>iter</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <return>return <expr><name>sortedSSTables</name></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AbstractCompactionTask</name></type> <name>task</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCompactionTask</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><name>NO_GC</name></expr></argument>, <argument><expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>setUserDefined</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>setCompactionType</name></name><argument_list>(<argument><expr><name><name>OperationType</name><operator>.</operator><name>UPGRADE_SSTABLES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><name>jobs</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>UPGRADE_SSTABLES</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>performCleanup</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfStore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{<block_content>
        <assert>assert <expr><operator>!</operator><call><name><name>cfStore</name><operator>.</operator><name>isIndex</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name>Keyspace</name></type> <name>keyspace</name> <init>= <expr><name><name>cfStore</name><operator>.</operator><name>keyspace</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>isJoined</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Cleanup cannot run before a node has joined the ring"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>ABORTED</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// if local ranges is empty, it means no data should remain</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>RangesAtEndpoint</name></type> <name>replicas</name> <init>= <expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getLocalReplicas</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>allRanges</name> <init>= <expr><call><name><name>replicas</name><operator>.</operator><name>ranges</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>transientRanges</name> <init>= <expr><call><name><name>replicas</name><operator>.</operator><name>onlyTransient</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>fullRanges</name> <init>= <expr><call><name><name>replicas</name><operator>.</operator><name>onlyFull</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>hasIndexes</name> <init>= <expr><call><name><name>cfStore</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>hasIndexes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name>parallelAllSSTableOperation</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>OneSSTableOperation</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>transaction</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sortedSSTables</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><call><name><name>transaction</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstableIter</name> <init>= <expr><call><name><name>sortedSSTables</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>totalSSTables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>skippedSStables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>sstableIter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>sstableIter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>needsCleanupFull</name> <init>= <expr><call><name>needsCleanup</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>fullRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>needsCleanupTransient</name> <init>= <expr><operator>!</operator><call><name><name>transientRanges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>sstable</name><operator>.</operator><name>isRepaired</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>needsCleanup</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>transientRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">//If there are no ranges for which the table needs cleanup either due to lack of intersection or lack</comment>
                    <comment type="line">//of the table being repaired.</comment>
                    <expr_stmt><expr><name>totalSSTables</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>needsCleanupFull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>needsCleanupTransient</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Skipping {} ([{}, {}]) for cleanup; all rows should be kept. Needs cleanup full ranges: {} Needs cleanup transient ranges: {} Repaired: {}"</literal></expr></argument>,
                                    <argument><expr><name>sstable</name></expr></argument>,
                                    <argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name>needsCleanupFull</name></expr></argument>,
                                    <argument><expr><name>needsCleanupTransient</name></expr></argument>,
                                    <argument><expr><call><name><name>sstable</name><operator>.</operator><name>isRepaired</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>sstableIter</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>transaction</name><operator>.</operator><name>cancel</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>skippedSStables</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Skipping cleanup for {}/{} sstables for {}.{} since they are fully contained in owned ranges (full ranges: {}, transient ranges: {})"</literal></expr></argument>,
                            <argument><expr><name>skippedSStables</name></expr></argument>, <argument><expr><name>totalSSTables</name></expr></argument>, <argument><expr><call><name><name>cfStore</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfStore</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>fullRanges</name></expr></argument>, <argument><expr><name>transientRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>sortedSSTables</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name><name>SSTableReader</name><operator>.</operator><name>sizeComparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>sortedSSTables</name></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CleanupStrategy</name></type> <name>cleanupStrategy</name> <init>= <expr><call><name><name>CleanupStrategy</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><name>allRanges</name></expr></argument>, <argument><expr><name>transientRanges</name></expr></argument>, <argument><expr><call><name><name>txn</name><operator>.</operator><name>onlyOne</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isRepaired</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>doCleanupOne</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>cleanupStrategy</name></expr></argument>, <argument><expr><call><name><name>replicas</name><operator>.</operator><name>ranges</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hasIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><name>jobs</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>CLEANUP</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>performGarbageCollection</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfStore</name></decl></parameter>, <parameter><decl><type><name>TombstoneOption</name></type> <name>tombstoneOption</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{<block_content>
        <assert>assert <expr><operator>!</operator><call><name><name>cfStore</name><operator>.</operator><name>isIndex</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <return>return <expr><call><name>parallelAllSSTableOperation</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>OneSSTableOperation</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>transaction</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>originals</name> <init>= <expr><call><name><name>transaction</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>cfStore</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>onlyPurgeRepairedTombstones</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>originals</name> <operator>=</operator> <call><name><name>Iterables</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name>originals</name></expr></argument>, <argument><expr><name>SSTableReader</name><operator>::</operator><name>isRepaired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sortedSSTables</name> <init>= <expr><call><name><name>Lists</name><operator>.</operator><name>newArrayList</name></name><argument_list>(<argument><expr><name>originals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>sortedSSTables</name></expr></argument>, <argument><expr><name><name>SSTableReader</name><operator>.</operator><name>maxTimestampAscending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>sortedSSTables</name></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Garbage collecting {}"</literal></expr></argument>, <argument><expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>CompactionTask</name></type> <name>task</name> <init>= <expr><operator>new</operator> <class><super><name>CompactionTask</name></super><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
                <block>{
                    <function><annotation>@<name>Override</name></annotation>
                    <type><specifier>protected</specifier> <name>CompactionController</name></type> <name>getCompactionController</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>toCompact</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
                        <return>return <expr><operator>new</operator> <call><name>CompactionController</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><name>toCompact</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>tombstoneOption</name></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></function>

                    <function><annotation>@<name>Override</name></annotation>
                    <type><specifier>protected</specifier> <name>int</name></type> <name>getLevel</name><parameter_list>()</parameter_list>
                    <block>{<block_content>
                        <return>return <expr><call><name><name>txn</name><operator>.</operator><name>onlyOne</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSSTableLevel</name><argument_list>()</argument_list></call></expr>;</return>
                    </block_content>}</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>setUserDefined</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>setCompactionType</name></name><argument_list>(<argument><expr><name><name>OperationType</name><operator>.</operator><name>GARBAGE_COLLECT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><name>jobs</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>GARBAGE_COLLECT</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>AllSSTableOpStatus</name></type> <name>relocateSSTables</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobs</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cfs</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>splitter</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPresent</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Partitioner does not support splitting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>ABORTED</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getLocalReplicas</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Relocate cannot run before a node has joined the ring"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>AllSSTableOpStatus</name><operator>.</operator><name>ABORTED</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>DiskBoundaries</name></type> <name>diskBoundaries</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getDiskBoundaries</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name>parallelAllSSTableOperation</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>OneSSTableOperation</name></super><argument_list>()</argument_list>
        <block>{
            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>filterSSTables</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>transaction</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>originals</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>newHashSet</name></name><argument_list>(<argument><expr><call><name><name>transaction</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>needsRelocation</name> <init>= <expr><call><name><name>originals</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>s</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name>inCorrectLocation</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toSet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>transaction</name><operator>.</operator><name>cancel</name></name><argument_list>(<argument><expr><call><name><name>Sets</name><operator>.</operator><name>difference</name></name><argument_list>(<argument><expr><name>originals</name></expr></argument>, <argument><expr><name>needsRelocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>groupedByDisk</name> <init>= <expr><call><name>groupByDiskIndex</name><argument_list>(<argument><expr><name>needsRelocation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>maxSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>diskSSTables</name> <range>: <expr><call><name><name>groupedByDisk</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>maxSize</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>maxSize</name></expr></argument>, <argument><expr><call><name><name>diskSSTables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>mixedSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <for>for <control>(<init><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>diskSSTables</name> <range>: <expr><call><name><name>groupedByDisk</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name><name>diskSSTables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name><name>mixedSSTables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>diskSSTables</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>

                <return>return <expr><name>mixedSSTables</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>groupByDiskIndex</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>needsRelocation</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>needsRelocation</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>groupingBy</name></name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>s</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>diskBoundaries</name><operator>.</operator><name>getDiskIndex</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>private</specifier> <name>boolean</name></type> <name>inCorrectLocation</name><parameter_list>(<parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cfs</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>splitter</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPresent</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

                <comment type="line">// Compare the expected data directory for the sstable with its current data directory</comment>
                <decl_stmt><decl><type><name><name>Directories</name><operator>.</operator><name>DataDirectory</name></name></type> <name>currentDirectory</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getDirectories</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDataDirectoryForFile</name><argument_list>(<argument><expr><name><name>sstable</name><operator>.</operator><name>descriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><call><name><name>diskBoundaries</name><operator>.</operator><name>isInCorrectLocation</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>currentDirectory</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Relocating {}"</literal></expr></argument>, <argument><expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>AbstractCompactionTask</name></type> <name>task</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCompactionTask</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><name>NO_GC</name></expr></argument>, <argument><expr><name><name>Long</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>setUserDefined</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>setCompactionType</name></name><argument_list>(<argument><expr><name><name>OperationType</name><operator>.</operator><name>RELOCATE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>
        }</block></class></expr></argument>, <argument><expr><name>jobs</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>RELOCATE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Splits the given token ranges of the given sstables into a pending repair silo
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitPendingAntiCompaction</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                                                           <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>tokenRanges</name></decl></parameter>,
                                                           <parameter><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>,
                                                           <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>,
                                                           <parameter><decl><type><name>UUID</name></type> <name>sessionId</name></decl></parameter>,
                                                           <parameter><decl><type><name>BooleanSupplier</name></type> <name>isCancelled</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><operator>new</operator> <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
            <block>{<block_content>
                <try>try <init>(<decl><type><name><name>TableMetrics</name><operator>.</operator><name>TableTimer</name><operator>.</operator><name>Context</name></name></type> <name>ctx</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>metric</name><operator>.</operator><name>anticompactionTime</name><operator>.</operator><name>time</name></name><argument_list>()</argument_list></call></expr></init></decl>)</init>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>performAnticompaction</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>tokenRanges</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>sessionId</name></expr></argument>, <argument><expr><name>isCancelled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></try>
            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>task</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><name>task</name> <operator>=</operator> <call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><literal type="string">"pending anticompaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>task</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>task</name><operator>.</operator><name>isCancelled</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>sstables</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>abort</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * for sstables that are fully contained in the given ranges, just rewrite their metadata with
     * the pending repair id and remove them from the transaction
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>mutateFullyContainedSSTables</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                                                     <parameter><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name></decl></parameter>,
                                                     <parameter><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstableIterator</name></decl></parameter>,
                                                     <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>,
                                                     <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>,
                                                     <parameter><decl><type><name>UUID</name></type> <name>sessionID</name></decl></parameter>,
                                                     <parameter><decl><type><name>boolean</name></type> <name>isTransient</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>ranges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>normalizedRanges</name> <init>= <expr><call><name><name>Range</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>fullyContainedSSTables</name> <init>= <expr><call><name>findSSTablesToAnticompact</name><argument_list>(<argument><expr><name>sstableIterator</name></expr></argument>, <argument><expr><name>normalizedRanges</name></expr></argument>, <argument><expr><name>sessionID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>metric</name><operator>.</operator><name>bytesMutatedAnticompaction</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><call><name><name>SSTableReader</name><operator>.</operator><name>getTotalBytes</name></name><argument_list>(<argument><expr><name>fullyContainedSSTables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>mutateRepaired</name><argument_list>(<argument><expr><name>fullyContainedSSTables</name></expr></argument>, <argument><expr><name>UNREPAIRED_SSTABLE</name></expr></argument>, <argument><expr><name>sessionID</name></expr></argument>, <argument><expr><name>isTransient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// since we're just re-writing the sstable metdata for the fully contained sstables, we don't want</comment>
        <comment type="line">// them obsoleted when the anti-compaction is complete. So they're removed from the transaction here</comment>
        <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>cancel</name></name><argument_list>(<argument><expr><name>fullyContainedSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>refs</name><operator>.</operator><name>release</name></name><argument_list>(<argument><expr><name>fullyContainedSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Make sure the {validatedForRepair} are marked for compaction before calling this.
     *
     * Caller must reference the validatedForRepair sstables (via ParentRepairSession.getActiveRepairedSSTableRefs(..)).
     *
     * @param cfs
     * @param replicas token ranges to be repaired
     * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
     * @param sessionID the repair session we're anti-compacting for
     * @param isCancelled function that indicates if active anti-compaction should be canceled
     * @throws InterruptedException
     * @throws IOException
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>performAnticompaction</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                                      <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>replicas</name></decl></parameter>,
                                      <parameter><decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>validatedForRepair</name></decl></parameter>,
                                      <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>,
                                      <parameter><decl><type><name>UUID</name></type> <name>sessionID</name></decl></parameter>,
                                      <parameter><decl><type><name>BooleanSupplier</name></type> <name>isCancelled</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>ActiveRepairService</name><operator>.</operator><name>ParentRepairSession</name></name></type> <name>prs</name> <init>= <expr><call><name><name>ActiveRepairService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getParentRepairSession</name></name><argument_list>(<argument><expr><name>sessionID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>Preconditions</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><operator>!</operator><call><name><name>prs</name><operator>.</operator><name>isPreview</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Cannot anticompact for previews"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Preconditions</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><operator>!</operator><call><name><name>replicas</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"No ranges to anti-compact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isInfoEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"{} Starting anticompaction for {}.{} on {}/{} sstables"</literal></expr></argument>, <argument><expr><call><name><name>PreviewKind</name><operator>.</operator><name>NONE</name><operator>.</operator><name>logPrefix</name></name><argument_list>(<argument><expr><name>sessionID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>validatedForRepair</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getLiveSSTables</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"{} Starting anticompaction for ranges {}"</literal></expr></argument>, <argument><expr><call><name><name>PreviewKind</name><operator>.</operator><name>NONE</name><operator>.</operator><name>logPrefix</name></name><argument_list>(<argument><expr><name>sessionID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>validatedForRepair</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>validateSSTableBoundsForAnticompaction</name><argument_list>(<argument><expr><name>sessionID</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>mutateFullyContainedSSTables</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>validatedForRepair</name></expr></argument>, <argument><expr><call><name><name>sstables</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>replicas</name><operator>.</operator><name>onlyFull</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>sessionID</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>mutateFullyContainedSSTables</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>validatedForRepair</name></expr></argument>, <argument><expr><call><name><name>sstables</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>replicas</name><operator>.</operator><name>onlyTransient</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>sessionID</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <assert>assert <expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</assert>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>sstables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>doAntiCompaction</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>sessionID</name></expr></argument>, <argument><expr><name>isCancelled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>validatedForRepair</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"{} Completed anticompaction successfully"</literal></expr></argument>, <argument><expr><call><name><name>PreviewKind</name><operator>.</operator><name>NONE</name><operator>.</operator><name>logPrefix</name></name><argument_list>(<argument><expr><name>sessionID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>validateSSTableBoundsForAnticompaction</name><parameter_list>(<parameter><decl><type><name>UUID</name></type> <name>sessionID</name></decl></parameter>,
                                                       <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>,
                                                       <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>normalizedRanges</name> <init>= <expr><call><name><name>Range</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><call><name><name>ranges</name><operator>.</operator><name>ranges</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Bounds</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>bounds</name> <init>= <expr><operator>new</operator> <call><name><name>Bounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Iterables</name><operator>.</operator><name>any</name></name><argument_list>(<argument><expr><name>normalizedRanges</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>r</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>(</operator><call><name><name>r</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>bounds</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>r</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>bounds</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name><name>r</name><operator>.</operator><name>intersects</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{
                <comment type="line">// this should never happen - in PendingAntiCompaction#getSSTables we select all sstables that intersect the repaired ranges, that can't have changed here</comment>
                <expr><name>String</name> <name>message</name> <operator>=</operator> <call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"%s SSTable %s (%s) does not intersect repaired ranges %s, this sstable should not have been included."</literal></expr></argument>,
                                               <argument><expr><call><name><name>PreviewKind</name><operator>.</operator><name>NONE</name><operator>.</operator><name>logPrefix</name></name><argument_list>(<argument><expr><name>sessionID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>, <argument><expr><name>normalizedRanges</name></expr></argument>)</argument_list></call></expr>;
                <call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></block><empty_stmt>;</empty_stmt></if></if_stmt>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></for>
        </block_content>}</block></function>

    }</block></class>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>static</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>findSSTablesToAnticompact</name><parameter_list>(<parameter><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstableIterator</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>normalizedRanges</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>parentRepairSession</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>fullyContainedSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>sstableIterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>sstableIterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name><name>Bounds</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sstableBounds</name> <init>= <expr><operator>new</operator> <call><name><name>Bounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>r</name> <range>: <expr><name>normalizedRanges</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <comment type="line">// ranges are normalized - no wrap around - if first and last are contained we know that all tokens are contained in the range</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>r</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>r</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"{} SSTable {} fully contained in range {}, mutating repairedAt instead of anticompacting"</literal></expr></argument>, <argument><expr><call><name><name>PreviewKind</name><operator>.</operator><name>NONE</name><operator>.</operator><name>logPrefix</name></name><argument_list>(<argument><expr><name>parentRepairSession</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>fullyContainedSSTables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>sstableIterator</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name><name>r</name><operator>.</operator><name>intersects</name></name><argument_list>(<argument><expr><name>sstableBounds</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"{} SSTable {} ({}) will be anticompacted on range {}"</literal></expr></argument>, <argument><expr><call><name><name>PreviewKind</name><operator>.</operator><name>NONE</name><operator>.</operator><name>logPrefix</name></name><argument_list>(<argument><expr><name>parentRepairSession</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>sstableBounds</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></while>
        <return>return <expr><name>fullyContainedSSTables</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>performMaximal</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfStore</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>splitOutput</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><call><name>submitMaximal</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>splitOutput</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"resource"</literal></expr></argument>)</argument_list></annotation> <comment type="line">// the tasks are executed in parallel on the executor, making sure that they get closed</comment>
    <type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>submitMaximal</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfStore</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>gcBefore</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>splitOutput</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// here we compute the task off the compaction executor, so having that present doesn't</comment>
        <comment type="line">// confuse runWithCompactionsDisabled -- i.e., we don't want to deadlock ourselves, waiting</comment>
        <comment type="line">// for ourselves to finish/acknowledge cancellation before continuing.</comment>
        <decl_stmt><decl><type><name>CompactionTasks</name></type> <name>tasks</name> <init>= <expr><call><name><name>cfStore</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMaximalTasks</name><argument_list>(<argument><expr><name>gcBefore</name></expr></argument>, <argument><expr><name>splitOutput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>tasks</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>nonEmptyTasks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>final</specifier> <name>AbstractCompactionTask</name></type> <name>task</name> <range>: <expr><name>tasks</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>task</name><operator>.</operator><name>transaction</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>nonEmptyTasks</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><operator>new</operator> <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fut</name> <init>= <expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><literal type="string">"maximal task"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fut</name><operator>.</operator><name>isCancelled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>fut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>nonEmptyTasks</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Major compaction will not result in a single sstable - repaired and unrepaired data is kept separate and compaction runs per data_file_directory."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>futures</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceCompactionForTokenRange</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>CompactionTasks</name></argument>&gt;</argument_list></name></type> <name>taskCreator</name> <init>= <expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name>sstablesInBounds</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>sstables</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>sstables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"No sstables found for the provided token range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name><name>CompactionTasks</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><call><name><name>cfStore</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getUserDefinedTasks</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

        <try>try <init>(<decl><type><name>CompactionTasks</name></type> <name>tasks</name> <init>= <expr><call><name><name>cfStore</name><operator>.</operator><name>runWithCompactionsDisabled</name></name><argument_list>(<argument><expr><name>taskCreator</name></expr></argument>,
                                                                        <argument><expr><lambda><parameter_list>(<parameter><decl><name>sstable</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>new</operator> <call><name><name>Bounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>intersects</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>,
                                                                        <argument><expr><literal type="boolean">false</literal></expr></argument>,
                                                                        <argument><expr><literal type="boolean">false</literal></expr></argument>,
                                                                        <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{
            <if_stmt><if>if <condition>(<expr><call><name><name>tasks</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>

            <name>Runnable</name> <name>runnable</name> <operator>=</operator> <operator>new</operator> <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list>
                <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>AbstractCompactionTask</name></type> <name>task</name> <range>: <expr><name>tasks</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                        <if_stmt><if>if <condition>(<expr><name>task</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
                </block_content>}</block></function>
            }</block></class></block><empty_stmt>;</empty_stmt></try>

            <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFuture</name></name><argument_list>(<argument><expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><literal type="string">"force compaction for token range"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }

    private <function><type><specifier>static</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstablesInBounds</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>tokenRangeCollection</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>liveTables</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getView</name><argument_list>()</argument_list></call><operator>.</operator><call><name>select</name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>LIVE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SSTableIntervalTree</name></type> <name>tree</name> <init>= <expr><call><name><name>SSTableIntervalTree</name><operator>.</operator><name>build</name></name><argument_list>(<argument><expr><name>liveTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokenRange</name> <range>: <expr><name>tokenRangeCollection</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>AbstractBounds</name><operator>.</operator><name>strictlyWrapsAround</name></name><argument_list>(<argument><expr><name><name>tokenRange</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>tokenRange</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>ssTableReaders</name> <init>= <expr><call><name><name>View</name><operator>.</operator><name>sstablesInBounds</name></name><argument_list>(<argument><expr><call><name><name>tokenRange</name><operator>.</operator><name>left</name><operator>.</operator><name>minKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>tokenRange</name><operator>.</operator><name>right</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Iterables</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>ssTableReaders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// Searching an interval tree will not return the correct results for a wrapping range</comment>
                <comment type="line">// so we have to unwrap it first</comment>
                <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>unwrappedRange</name> <range>: <expr><call><name><name>tokenRange</name><operator>.</operator><name>unwrap</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>ssTableReaders</name> <init>= <expr><call><name><name>View</name><operator>.</operator><name>sstablesInBounds</name></name><argument_list>(<argument><expr><call><name><name>unwrappedRange</name><operator>.</operator><name>left</name><operator>.</operator><name>minKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>unwrappedRange</name><operator>.</operator><name>right</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>Iterables</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>ssTableReaders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>sstables</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceUserDefinedCompaction</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>dataFiles</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>filenames</name> <init>= <expr><call><name><name>dataFiles</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>, <argument><name>Descriptor</name></argument>&gt;</argument_list></name></type> <name>descriptors</name> <init>= <expr><call><name><name>ArrayListMultimap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>String</name></type> <name>filename</name> <range>: <expr><name>filenames</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// extract keyspace and columnfamily name from filename</comment>
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr><call><name><name>Descriptor</name><operator>.</operator><name>fromFilename</name></name><argument_list>(<argument><expr><call><name><name>filename</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTableMetadataRef</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Schema does not exist for file {}. Skipping."</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// group by keyspace/columnfamily</comment>
            <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>ksname</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>cfname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>descriptors</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getDirectories</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>find</name><argument_list>(<argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>filename</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>descriptors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nowInSec</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>descriptors</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>futures</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>submitUserDefined</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><call><name><name>descriptors</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name><name>FBUtilities</name><operator>.</operator><name>waitOnFutures</name></name><argument_list>(<argument><expr><name>futures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceUserDefinedCleanup</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>dataFiles</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>filenames</name> <init>= <expr><call><name><name>dataFiles</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>, <argument><name>Descriptor</name></argument>&gt;</argument_list></name></type> <name>descriptors</name> <init>= <expr><call><name><name>Maps</name><operator>.</operator><name>newHashMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>String</name></type> <name>filename</name> <range>: <expr><name>filenames</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// extract keyspace and columnfamily name from filename</comment>
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr><call><name><name>Descriptor</name><operator>.</operator><name>fromFilename</name></name><argument_list>(<argument><expr><call><name><name>filename</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTableMetadataRef</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Schema does not exist for file {}. Skipping."</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// group by keyspace/columnfamily</comment>
            <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>ksname</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>cfname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name><name>cfs</name><operator>.</operator><name>getDirectories</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>find</name><argument_list>(<argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name><name>filename</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>desc</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>descriptors</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>isJoined</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Cleanup cannot run before a node has joined the ring"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>,<argument><name>Descriptor</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>descriptors</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Keyspace</name></type> <name>keyspace</name> <init>= <expr><name><name>cfs</name><operator>.</operator><name>keyspace</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>RangesAtEndpoint</name></type> <name>replicas</name> <init>= <expr><call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getLocalReplicas</name></name><argument_list>(<argument><expr><call><name><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>allRanges</name> <init>= <expr><call><name><name>replicas</name><operator>.</operator><name>ranges</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>transientRanges</name> <init>= <expr><call><name><name>replicas</name><operator>.</operator><name>onlyTransient</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>hasIndexes</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>hasIndexes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name>lookupSSTable</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>sstable</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Will not clean {}, it is not an active sstable"</literal></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>CleanupStrategy</name></type> <name>cleanupStrategy</name> <init>= <expr><call><name><name>CleanupStrategy</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>allRanges</name></expr></argument>, <argument><expr><name>transientRanges</name></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>isRepaired</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <try>try <init>(<decl><type><name>LifecycleTransaction</name></type> <name>txn</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getTracker</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>tryModify</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>CLEANUP</name></name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>doCleanupOne</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>cleanupStrategy</name></expr></argument>, <argument><expr><name>allRanges</name></expr></argument>, <argument><expr><name>hasIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"forceUserDefinedCleanup failed: {}"</literal></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>getLocalizedMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></catch></try>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>


    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitUserDefined</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>&gt;</argument_list></name></type> <name>dataFiles</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>gcBefore</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><operator>new</operator> <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
            <block>{<block_content>
                <comment type="line">// look up the sstables now that we're on the compaction executor, so we don't try to re-compact</comment>
                <comment type="line">// something that was already being compacted earlier.</comment>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>dataFiles</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>Descriptor</name></type> <name>desc</name> <range>: <expr><name>dataFiles</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <comment type="line">// inefficient but not in a performance sensitive path</comment>
                    <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name>lookupSSTable</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>sstable</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Will not compact {}: it is not an active sstable"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>sstables</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><call><name><name>sstables</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"No files to compact for user defined compaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <try>try <init>(<decl><type><name>CompactionTasks</name></type> <name>tasks</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getUserDefinedTasks</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
                    <block>{<block_content>
                        <for>for <control>(<init><decl><type><name>AbstractCompactionTask</name></type> <name>task</name> <range>: <expr><name>tasks</name></expr></range></decl></init>)</control>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>task</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name><name>task</name><operator>.</operator><name>execute</name></name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></try>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><literal type="string">"user defined task"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="line">// This acquire a reference on the sstable</comment>
    <comment type="line">// This is not efficient, do not use in any critical path</comment>
    <function><type><specifier>private</specifier> <name>SSTableReader</name></type> <name>lookupSSTable</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name><name>cfs</name><operator>.</operator><name>getSSTables</name></name><argument_list>(<argument><expr><name><name>SSTableSet</name><operator>.</operator><name>CANONICAL</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>sstable</name><operator>.</operator><name>descriptor</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>sstable</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitValidation</name><parameter_list>(<parameter><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>validation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>validationExecutor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>validation</name></expr></argument>, <argument><expr><literal type="string">"validation"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/* Used in tests. */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>disableAutoCompaction</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>ksname</name> <range>: <expr><call><name><name>Schema</name><operator>.</operator><name>instance</name><operator>.</operator><name>getNonSystemKeyspaces</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>ksname</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getColumnFamilyStores</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>disableAutoCompaction</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name>void</name></type> <name>scrubOne</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name>LifecycleTransaction</name></type> <name>modifier</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>skipCorrupted</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>checkData</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>reinsertOverflowedTTL</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name></type> <name>scrubInfo</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <try>try <init>(<decl><type><name>Scrubber</name></type> <name>scrubber</name> <init>= <expr><operator>new</operator> <call><name>Scrubber</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>modifier</name></expr></argument>, <argument><expr><name>skipCorrupted</name></expr></argument>, <argument><expr><name>checkData</name></expr></argument>, <argument><expr><name>reinsertOverflowedTTL</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <expr_stmt><expr><name>scrubInfo</name> <operator>=</operator> <call><name><name>scrubber</name><operator>.</operator><name>getScrubInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>scrubInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>scrubber</name><operator>.</operator><name>scrub</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>scrubInfo</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>scrubInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name>void</name></type> <name>verifyOne</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>, <parameter><decl><type><name><name>Verifier</name><operator>.</operator><name>Options</name></name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name></type> <name>verifyInfo</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <try>try <init>(<decl><type><name>Verifier</name></type> <name>verifier</name> <init>= <expr><operator>new</operator> <call><name>Verifier</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <expr_stmt><expr><name>verifyInfo</name> <operator>=</operator> <call><name><name>verifier</name><operator>.</operator><name>getVerifyInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>verifyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>verifier</name><operator>.</operator><name>verify</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>verifyInfo</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>verifyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Determines if a cleanup would actually remove any data in this SSTable based
     * on a set of owned ranges.
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>needsCleanup</name><parameter_list>(<parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ownedRanges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>ownedRanges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return> <comment type="line">// all data will be cleaned</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// unwrap and sort the ranges by LHS token</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sortedRanges</name> <init>= <expr><call><name><name>Range</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>ownedRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// see if there are any keys LTE the token for the start of the first range</comment>
        <comment type="line">// (token range ownership is exclusive on the LHS.)</comment>
        <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>firstRange</name> <init>= <expr><call><name><name>sortedRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>compareTo</name><argument_list>(<argument><expr><name><name>firstRange</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// then, iterate over all owned ranges and see if the next key beyond the end of the owned</comment>
        <comment type="line">// range falls before the start of the next range</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>sortedRanges</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name><name>sortedRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>range</name><operator>.</operator><name>right</name><operator>.</operator><name>isMinimum</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// we split a wrapping range and this is the second half.</comment>
                <comment type="line">// there can't be any keys beyond this (and this is the last range)</comment>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>firstBeyondRange</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>firstKeyBeyond</name></name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>right</name><operator>.</operator><name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>firstBeyondRange</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// we ran off the end of the sstable looking for the next key; we don't need to check any more ranges</comment>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>(</operator><call><name><name>sortedRanges</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// we're at the last range and we found a key beyond the end of the range</comment>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>nextRange</name> <init>= <expr><call><name><name>sortedRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>firstBeyondRange</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>compareTo</name><argument_list>(<argument><expr><name><name>nextRange</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// we found a key in between the owned ranges</comment>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * This function goes over a file and removes the keys that the node is not responsible for
     * and only keeps keys that this node is responsible for.
     *
     * @throws IOException
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>doCleanupOne</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                              <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>,
                              <parameter><decl><type><name>CleanupStrategy</name></type> <name>cleanupStrategy</name></decl></parameter>,
                              <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>allRanges</name></decl></parameter>,
                              <parameter><decl><type><name>boolean</name></type> <name>hasIndexes</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <assert>assert <expr><operator>!</operator><call><name><name>cfs</name><operator>.</operator><name>isIndex</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>txn</name><operator>.</operator><name>onlyOne</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// if ranges is empty and no index, entire sstable is discarded</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasIndexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>new</operator> <call><name><name>Bounds</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>intersects</name><argument_list>(<argument><expr><name>allRanges</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>obsoleteOriginals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"SSTable {} ([{}, {}]) does not intersect the owned ranges ({}), dropping it"</literal></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>first</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sstable</name><operator>.</operator><name>last</name><operator>.</operator><name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>allRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>totalkeysWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>expectedBloomFilterSize</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>minIndexInterval</name></name></expr></argument>,
                                               <argument><expr><call><name><name>SSTableReader</name><operator>.</operator><name>getApproximateKeyCount</name></name><argument_list>(<argument><expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Expected bloom filter size : {}"</literal></expr></argument>, <argument><expr><name>expectedBloomFilterSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Cleaning up {}"</literal></expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>File</name></type> <name>compactionFileLocation</name> <init>= <expr><name><name>sstable</name><operator>.</operator><name>descriptor</name><operator>.</operator><name>directory</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RateLimiter</name></type> <name>limiter</name> <init>= <expr><call><name>getRateLimiter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>compressionRatio</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>getCompressionRatio</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>compressionRatio</name> <operator>==</operator> <name><name>MetadataCollector</name><operator>.</operator><name>NO_COMPRESSION_RATIO</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>compressionRatio</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>finished</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>nowInSec</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name>SSTableRewriter</name></type> <name>writer</name> <init>= <expr><call><name><name>SSTableRewriter</name><operator>.</operator><name>construct</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name><name>sstable</name><operator>.</operator><name>maxDataAge</name></name></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>ISSTableScanner</name></type> <name>scanner</name> <init>= <expr><call><name><name>cleanupStrategy</name><operator>.</operator><name>getScanner</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>CompactionController</name></type> <name>controller</name> <init>= <expr><operator>new</operator> <call><name>CompactionController</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name><name>Refs</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>refs</name> <init>= <expr><call><name><name>Refs</name><operator>.</operator><name>ref</name></name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>CompactionIterator</name></type> <name>ci</name> <init>= <expr><operator>new</operator> <call><name>CompactionIterator</name><argument_list>(<argument><expr><name><name>OperationType</name><operator>.</operator><name>CLEANUP</name></name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>singletonList</name></name><argument_list>(<argument><expr><name>scanner</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>controller</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><call><name><name>UUIDGen</name><operator>.</operator><name>getTimeUUID</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StatsMetadata</name></type> <name>metadata</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>getSSTableMetadata</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>switchWriter</name></name><argument_list>(<argument><expr><call><name>createWriter</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>compactionFileLocation</name></expr></argument>, <argument><expr><name>expectedBloomFilterSize</name></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>repairedAt</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>pendingRepair</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>.</operator><name>isTransient</name></name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>lastBytesScanned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><call><name><name>ci</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <try>try <init>(<decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name> <init>= <expr><call><name><name>ci</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;
                     <decl><type><name>UnfilteredRowIterator</name></type> <name>notCleaned</name> <init>= <expr><call><name><name>cleanupStrategy</name><operator>.</operator><name>cleanup</name></name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>notCleaned</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name><name>writer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>notCleaned</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>totalkeysWritten</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <decl_stmt><decl><type><name>long</name></type> <name>bytesScanned</name> <init>= <expr><call><name><name>scanner</name><operator>.</operator><name>getBytesScanned</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>compactionRateLimiterAcquire</name><argument_list>(<argument><expr><name>limiter</name></expr></argument>, <argument><expr><name>bytesScanned</name></expr></argument>, <argument><expr><name>lastBytesScanned</name></expr></argument>, <argument><expr><name>compressionRatio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>lastBytesScanned</name> <operator>=</operator> <name>bytesScanned</name></expr>;</expr_stmt>
                </block_content>}</block></try>
            </block_content>}</block></while>

            <comment type="line">// flush to ensure we don't lose the tombstones on a restart, since they are not commitlog'd</comment>
            <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>flushAllIndexesBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name><name>writer</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></try>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>finished</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>format</name> <init>= <expr><literal type="string">"Cleaned up to %s.  %s to %s (~%d%% of original) for %,d keys.  Time: %,dms."</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>dTime</name> <init>= <expr><call><name><name>TimeUnit</name><operator>.</operator><name>NANOSECONDS</name><operator>.</operator><name>toMillis</name></name><argument_list>(<argument><expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>startsize</name> <init>= <expr><call><name><name>sstable</name><operator>.</operator><name>onDiskLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>endsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>newSstable</name> <range>: <expr><name>finished</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>endsize</name> <operator>+=</operator> <call><name><name>newSstable</name><operator>.</operator><name>onDiskLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <decl_stmt><decl><type><name>double</name></type> <name>ratio</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>endsize</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>startsize</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><call><name><name>finished</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>startsize</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>prettyPrintMemory</name></name><argument_list>(<argument><expr><name>endsize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ratio</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator></expr></argument>, <argument><expr><name>totalkeysWritten</name></expr></argument>, <argument><expr><name>dTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>compactionRateLimiterAcquire</name><parameter_list>(<parameter><decl><type><name>RateLimiter</name></type> <name>limiter</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>bytesScanned</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>lastBytesScanned</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>compressionRatio</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>lengthRead</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>bytesScanned</name> <operator>-</operator> <name>lastBytesScanned</name><operator>)</operator> <operator>*</operator> <name>compressionRatio</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>lengthRead</name> <operator>&gt;=</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>limiter</name><operator>.</operator><name>acquire</name></name><argument_list>(<argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lengthRead</name> <operator>-=</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>lengthRead</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>limiter</name><operator>.</operator><name>acquire</name></name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>lengthRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>abstract</specifier> class <name>CleanupStrategy</name>
    <block>{
        <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>int</name></type> <name>nowInSec</name></decl>;</decl_stmt>

        <constructor><specifier>protected</specifier> <name>CleanupStrategy</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ranges</name></name> <operator>=</operator> <name>ranges</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>nowInSec</name></name> <operator>=</operator> <name>nowInSec</name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CleanupStrategy</name></type> <name>get</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>transientRanges</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isRepaired</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>hasIndexes</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>transientRanges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">//Shouldn't have been possible to create this situation</comment>
                    <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>(<argument><expr><literal type="string">"Can't have indexes and transient ranges"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><operator>new</operator> <call><name>Full</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><operator>new</operator> <call><name>Bounded</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>transientRanges</name></expr></argument>, <argument><expr><name>isRepaired</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>ISSTableScanner</name></type> <name>getScanner</name><parameter_list>(<parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>UnfilteredRowIterator</name></type> <name>cleanup</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name></decl></parameter>)</parameter_list>;</function_decl>

        <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>Bounded</name> <super_list><extends>extends <super><name>CleanupStrategy</name></super></extends></super_list>
        <block>{
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>transientRanges</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isRepaired</name></decl>;</decl_stmt>

            <constructor><specifier>public</specifier> <name>Bounded</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>transientRanges</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>isRepaired</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>instance</name><operator>.</operator><name>cacheCleanupExecutor</name><operator>.</operator><name>submit</name></name><argument_list>(<argument><expr><operator>new</operator> <class><super><name>Runnable</name></super><argument_list>()</argument_list>
                <block>{
                    <function><annotation>@<name>Override</name></annotation>
                    <type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>cleanupCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></function>
                }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>transientRanges</name></name> <operator>=</operator> <name>transientRanges</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isRepaired</name></name> <operator>=</operator> <name>isRepaired</name></expr>;</expr_stmt>
            </block_content>}</block></constructor>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>ISSTableScanner</name></type> <name>getScanner</name><parameter_list>(<parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <comment type="line">//If transient replication is enabled and there are transient ranges</comment>
                <comment type="line">//then cleanup should remove any partitions that are repaired and in the transient range</comment>
                <comment type="line">//as they should already be synchronized at other full replicas.</comment>
                <comment type="line">//So just don't scan the portion of the table containing the repaired transient ranges</comment>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToScan</name> <init>= <expr><name>ranges</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>isRepaired</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>rangesToScan</name> <operator>=</operator> <call><name><name>Collections2</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>range</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>transientRanges</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><call><name><name>sstable</name><operator>.</operator><name>getScanner</name></name><argument_list>(<argument><expr><name>rangesToScan</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>UnfilteredRowIterator</name></type> <name>cleanup</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><name>partition</name></expr>;</return>
            </block_content>}</block></function>
        }</block></class>

        <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>Full</name> <super_list><extends>extends <super><name>CleanupStrategy</name></super></extends></super_list>
        <block>{
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfs</name></decl>;</decl_stmt>

            <constructor><specifier>public</specifier> <name>Full</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>cfs</name></name> <operator>=</operator> <name>cfs</name></expr>;</expr_stmt>
            </block_content>}</block></constructor>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>ISSTableScanner</name></type> <name>getScanner</name><parameter_list>(<parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>sstable</name><operator>.</operator><name>getScanner</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <type><specifier>public</specifier> <name>UnfilteredRowIterator</name></type> <name>cleanup</name><parameter_list>(<parameter><decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>isInRanges</name></name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getToken</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>partition</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>invalidateCachedPartition</name></name><argument_list>(<argument><expr><call><name><name>partition</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>deletePartition</name></name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="null">null</literal></expr>;</return>
            </block_content>}</block></function>
        }</block></class>
    }</block></class>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableWriter</name></type> <name>createWriter</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                                             <parameter><decl><type><name>File</name></type> <name>compactionFileLocation</name></decl></parameter>,
                                             <parameter><decl><type><name>long</name></type> <name>expectedBloomFilterSize</name></decl></parameter>,
                                             <parameter><decl><type><name>long</name></type> <name>repairedAt</name></decl></parameter>,
                                             <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>,
                                             <parameter><decl><type><name>boolean</name></type> <name>isTransient</name></decl></parameter>,
                                             <parameter><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></parameter>,
                                             <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>createDirectory</name></name><argument_list>(<argument><expr><name>compactionFileLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name><name>SSTableWriter</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name><name>cfs</name><operator>.</operator><name>metadata</name></name></expr></argument>,
                                    <argument><expr><call><name><name>cfs</name><operator>.</operator><name>newSSTableDescriptor</name></name><argument_list>(<argument><expr><name>compactionFileLocation</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>expectedBloomFilterSize</name></expr></argument>,
                                    <argument><expr><name>repairedAt</name></expr></argument>,
                                    <argument><expr><name>pendingRepair</name></expr></argument>,
                                    <argument><expr><name>isTransient</name></expr></argument>,
                                    <argument><expr><call><name><name>sstable</name><operator>.</operator><name>getSSTableLevel</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>sstable</name><operator>.</operator><name>header</name></name></expr></argument>,
                                    <argument><expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>listIndexes</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableWriter</name></type> <name>createWriterForAntiCompaction</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                                                              <parameter><decl><type><name>File</name></type> <name>compactionFileLocation</name></decl></parameter>,
                                                              <parameter><decl><type><name>int</name></type> <name>expectedBloomFilterSize</name></decl></parameter>,
                                                              <parameter><decl><type><name>long</name></type> <name>repairedAt</name></decl></parameter>,
                                                              <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>,
                                                              <parameter><decl><type><name>boolean</name></type> <name>isTransient</name></decl></parameter>,
                                                              <parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></parameter>,
                                                              <parameter><decl><type><name>ILifecycleTransaction</name></type> <name>txn</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>FileUtils</name><operator>.</operator><name>createDirectory</name></name><argument_list>(<argument><expr><name>compactionFileLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>minLevel</name> <init>= <expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
        <comment type="line">// if all sstables have the same level, we can compact them together without creating overlap during anticompaction</comment>
        <comment type="line">// note that we only anticompact from unrepaired sstables, which is not leveled, but we still keep original level</comment>
        <comment type="line">// after first migration to be able to drop the sstables back in their original place in the repaired sstable manifest</comment>
        <for>for <control>(<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>minLevel</name> <operator>==</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>minLevel</name> <operator>=</operator> <call><name><name>sstable</name><operator>.</operator><name>getSSTableLevel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>minLevel</name> <operator>!=</operator> <call><name><name>sstable</name><operator>.</operator><name>getSSTableLevel</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>minLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>SSTableWriter</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>newSSTableDescriptor</name></name><argument_list>(<argument><expr><name>compactionFileLocation</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>expectedBloomFilterSize</name></expr></argument>,
                                    <argument><expr><name>repairedAt</name></expr></argument>,
                                    <argument><expr><name>pendingRepair</name></expr></argument>,
                                    <argument><expr><name>isTransient</name></expr></argument>,
                                    <argument><expr><name><name>cfs</name><operator>.</operator><name>metadata</name></name></expr></argument>,
                                    <argument><expr><operator>new</operator> <call><name>MetadataCollector</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name>comparator</name></expr></argument>, <argument><expr><name>minLevel</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>SerializationHeader</name><operator>.</operator><name>make</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>cfs</name><operator>.</operator><name>indexManager</name><operator>.</operator><name>listIndexes</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Splits up an sstable into two new sstables. The first of the new tables will store repaired ranges, the second
     * will store the non-repaired ranges. Once anticompation is completed, the original sstable is marked as compacted
     * and subsequently deleted.
     * @param cfs
     * @param txn a transaction over the repaired sstables to anticompact
     * @param ranges full and transient ranges to be placed into one of the new sstables. The repaired table will be tracked via
     *   the {@link org.apache.cassandra.io.sstable.metadata.StatsMetadata#pendingRepair} field.
     * @param pendingRepair the repair session we're anti-compacting for
     * @param isCancelled function that indicates if active anti-compaction should be canceled
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>doAntiCompaction</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                                  <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>ranges</name></decl></parameter>,
                                  <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>,
                                  <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>,
                                  <parameter><decl><type><name>BooleanSupplier</name></type> <name>isCancelled</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>originalCount</name> <init>= <expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Performing anticompaction on {} sstables for {}"</literal></expr></argument>, <argument><expr><name>originalCount</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Group SSTables</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Repairs can take place on both unrepaired (incremental + full) and repaired (full) data.</comment>
        <comment type="line">// Although anti-compaction could work on repaired sstables as well and would result in having more accurate</comment>
        <comment type="line">// repairedAt values for these, we still avoid anti-compacting already repaired sstables, as we currently don't</comment>
        <comment type="line">// make use of any actual repairedAt value and splitting up sstables just for that is not worth it at this point.</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>unrepairedSSTables</name> <init>= <expr><call><name><name>sstables</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>s</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>s</name><operator>.</operator><name>isRepaired</name></name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toSet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cfs</name><operator>.</operator><name>metric</name><operator>.</operator><name>bytesAnticompacted</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><call><name><name>SSTableReader</name><operator>.</operator><name>getTotalBytes</name></name><argument_list>(<argument><expr><name>unrepairedSSTables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>groupedSSTables</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>groupSSTablesForAntiCompaction</name><argument_list>(<argument><expr><name>unrepairedSSTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// iterate over sstables to check if the full / transient / unrepaired ranges intersect them.</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>antiCompactedSSTableCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstableGroup</name> <range>: <expr><name>groupedSSTables</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <try>try <init>(<decl><type><name>LifecycleTransaction</name></type> <name>groupTxn</name> <init>= <expr><call><name><name>txn</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><name>sstableGroup</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>antiCompacted</name> <init>= <expr><call><name>antiCompactGroup</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>groupTxn</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><name>isCancelled</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>antiCompactedSSTableCount</name> <operator>+=</operator> <name>antiCompacted</name></expr>;</expr_stmt>
            </block_content>}</block></try>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name>String</name></type> <name>format</name> <init>= <expr><literal type="string">"Anticompaction completed successfully, anticompacted from {} to {} sstable(s) for {}."</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>originalCount</name></expr></argument>, <argument><expr><name>antiCompactedSSTableCount</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name>int</name></type> <name>antiCompactGroup</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>,
                         <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>ranges</name></decl></parameter>,
                         <parameter><decl><type><name>LifecycleTransaction</name></type> <name>txn</name></decl></parameter>,
                         <parameter><decl><type><name>UUID</name></type> <name>pendingRepair</name></decl></parameter>,
                         <parameter><decl><type><name>BooleanSupplier</name></type> <name>isCancelled</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>Preconditions</name><operator>.</operator><name>checkArgument</name></name><argument_list>(<argument><expr><operator>!</operator><call><name><name>ranges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"need at least one full or transient range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>groupMaxDataAge</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>i</name> <init>= <expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>i</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr><call><name><name>i</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>groupMaxDataAge</name> <operator>&lt;</operator> <name><name>sstable</name><operator>.</operator><name>maxDataAge</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>groupMaxDataAge</name> <operator>=</operator> <name><name>sstable</name><operator>.</operator><name>maxDataAge</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"No valid anticompactions for this group, All sstables were compacted and are no longer available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Anticompacting {} in {}.{} for {}"</literal></expr></argument>, <argument><expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstableAsSet</name> <init>= <expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>File</name></type> <name>destination</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getDirectories</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getWriteableLocationAsFile</name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>getExpectedCompactedFileSize</name></name><argument_list>(<argument><expr><name>sstableAsSet</name></expr></argument>, <argument><expr><name><name>OperationType</name><operator>.</operator><name>ANTICOMPACTION</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nowInSec</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>nowInSeconds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RateLimiter</name></type> <name>limiter</name> <init>= <expr><call><name>getRateLimiter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * HACK WARNING
         *
         * We have multiple writers operating over the same Transaction, producing different sets of sstables that all
         * logically replace the transaction's originals.  The SSTableRewriter assumes it has exclusive control over
         * the transaction state, and this will lead to temporarily inconsistent sstable/tracker state if we do not
         * take special measures to avoid it.
         *
         * Specifically, if a number of rewriter have prepareToCommit() invoked in sequence, then two problematic things happen:
         *   1. The obsoleteOriginals() call of the first rewriter immediately remove the originals from the tracker, despite
         *      their having been only partially replaced.  To avoid this, we must either avoid obsoleteOriginals() or checkpoint()
         *   2. The LifecycleTransaction may only have prepareToCommit() invoked once, and this will checkpoint() also.
         *
         * Similarly commit() would finalise partially complete on-disk state.
         *
         * To avoid these problems, we introduce a SharedTxn that proxies all calls onto the underlying transaction
         * except prepareToCommit(), checkpoint(), obsoleteOriginals(), and commit().
         * We then invoke these methods directly once each of the rewriter has updated the transaction
         * with their share of replacements.
         *
         * Note that for the same essential reason we also explicitly disable early open.
         * By noop-ing checkpoint we avoid any of the problems with early open, but by continuing to explicitly
         * disable it we also prevent any of the extra associated work from being performed.
         */</comment>
        <class>class <name>SharedTxn</name> <super_list><extends>extends <super><name>WrappedLifecycleTransaction</name></super></extends></super_list>
        <block>{
            <constructor><specifier>public</specifier> <name>SharedTxn</name><parameter_list>(<parameter><decl><type><name>ILifecycleTransaction</name></type> <name>delegate</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>delegate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></constructor>
            <function><type><specifier>public</specifier> <name>Throwable</name></type> <name>commit</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>accumulate</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>accumulate</name></expr>;</return> </block_content>}</block></function>
            <function><type><specifier>public</specifier> <name>void</name></type> <name>prepareToCommit</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
            <function><type><specifier>public</specifier> <name>void</name></type> <name>checkpoint</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
            <function><type><specifier>public</specifier> <name>void</name></type> <name>obsoleteOriginals</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
            <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
        }</block></class>

        <decl_stmt><decl><type><name>CompactionStrategyManager</name></type> <name>strategy</name> <init>= <expr><call><name><name>cfs</name><operator>.</operator><name>getCompactionStrategyManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <init>(<decl><type><name>SharedTxn</name></type> <name>sharedTxn</name> <init>= <expr><operator>new</operator> <call><name>SharedTxn</name><argument_list>(<argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>SSTableRewriter</name></type> <name>fullWriter</name> <init>= <expr><call><name><name>SSTableRewriter</name><operator>.</operator><name>constructWithoutEarlyOpening</name></name><argument_list>(<argument><expr><name>sharedTxn</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>groupMaxDataAge</name></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>SSTableRewriter</name></type> <name>transWriter</name> <init>= <expr><call><name><name>SSTableRewriter</name><operator>.</operator><name>constructWithoutEarlyOpening</name></name><argument_list>(<argument><expr><name>sharedTxn</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>groupMaxDataAge</name></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>SSTableRewriter</name></type> <name>unrepairedWriter</name> <init>= <expr><call><name><name>SSTableRewriter</name><operator>.</operator><name>constructWithoutEarlyOpening</name></name><argument_list>(<argument><expr><name>sharedTxn</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>groupMaxDataAge</name></expr></argument>)</argument_list></call></expr></init></decl>;

             <decl><type><name><name>AbstractCompactionStrategy</name><operator>.</operator><name>ScannerList</name></name></type> <name>scanners</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getScanners</name></name><argument_list>(<argument><expr><call><name><name>txn</name><operator>.</operator><name>originals</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>CompactionController</name></type> <name>controller</name> <init>= <expr><operator>new</operator> <call><name>CompactionController</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>sstableAsSet</name></expr></argument>, <argument><expr><call><name>getDefaultGcBefore</name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;
             <decl><type><name>CompactionIterator</name></type> <name>ci</name> <init>= <expr><call><name>getAntiCompactionIterator</name><argument_list>(<argument><expr><name><name>scanners</name><operator>.</operator><name>scanners</name></name></expr></argument>, <argument><expr><name>controller</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><call><name><name>UUIDGen</name><operator>.</operator><name>getTimeUUID</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>isCancelled</name></expr></argument>)</argument_list></call></expr></init></decl>)</init>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>expectedBloomFilterSize</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call><operator>.</operator><name><name>params</name><operator>.</operator><name>minIndexInterval</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name><name>SSTableReader</name><operator>.</operator><name>getApproximateKeyCount</name></name><argument_list>(<argument><expr><name>sstableAsSet</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>fullWriter</name><operator>.</operator><name>switchWriter</name></name><argument_list>(<argument><expr><call><name><name>CompactionManager</name><operator>.</operator><name>createWriterForAntiCompaction</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>expectedBloomFilterSize</name></expr></argument>, <argument><expr><name>UNREPAIRED_SSTABLE</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>sstableAsSet</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>transWriter</name><operator>.</operator><name>switchWriter</name></name><argument_list>(<argument><expr><call><name><name>CompactionManager</name><operator>.</operator><name>createWriterForAntiCompaction</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>expectedBloomFilterSize</name></expr></argument>, <argument><expr><name>UNREPAIRED_SSTABLE</name></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>sstableAsSet</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>unrepairedWriter</name><operator>.</operator><name>switchWriter</name></name><argument_list>(<argument><expr><call><name><name>CompactionManager</name><operator>.</operator><name>createWriterForAntiCompaction</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>expectedBloomFilterSize</name></expr></argument>, <argument><expr><name>UNREPAIRED_SSTABLE</name></expr></argument>, <argument><expr><name>NO_PENDING_REPAIR</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>sstableAsSet</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>fullChecker</name> <init>= <expr><ternary><condition><expr><operator>!</operator><call><name><name>ranges</name><operator>.</operator><name>onlyFull</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>new</operator> <call><name><name>Range</name><operator>.</operator><name>OrderedRangeContainmentChecker</name></name><argument_list>(<argument><expr><call><name><name>ranges</name><operator>.</operator><name>onlyFull</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><lambda><parameter_list type="pseudo"><parameter><decl><name>t</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><literal type="boolean">false</literal></expr></block_content></block></lambda></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>transChecker</name> <init>= <expr><ternary><condition><expr><operator>!</operator><call><name><name>ranges</name><operator>.</operator><name>onlyTransient</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>new</operator> <call><name><name>Range</name><operator>.</operator><name>OrderedRangeContainmentChecker</name></name><argument_list>(<argument><expr><call><name><name>ranges</name><operator>.</operator><name>onlyTransient</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><lambda><parameter_list type="pseudo"><parameter><decl><name>t</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><literal type="boolean">false</literal></expr></block_content></block></lambda></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>compressionRatio</name> <init>= <expr><call><name><name>scanners</name><operator>.</operator><name>getCompressionRatio</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>compressionRatio</name> <operator>==</operator> <name><name>MetadataCollector</name><operator>.</operator><name>NO_COMPRESSION_RATIO</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compressionRatio</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>long</name></type> <name>lastBytesScanned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><call><name><name>ci</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <try>try <init>(<decl><type><name>UnfilteredRowIterator</name></type> <name>partition</name> <init>= <expr><call><name><name>ci</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>)</init>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>partition</name><operator>.</operator><name>partitionKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getToken</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">// if this row is contained in the full or transient ranges, append it to the appropriate sstable</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>fullChecker</name><operator>.</operator><name>test</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>fullWriter</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name><name>transChecker</name><operator>.</operator><name>test</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>transWriter</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="line">// otherwise, append it to the unrepaired sstable</comment>
                        <expr_stmt><expr><call><name><name>unrepairedWriter</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <decl_stmt><decl><type><name>long</name></type> <name>bytesScanned</name> <init>= <expr><call><name><name>scanners</name><operator>.</operator><name>getTotalBytesScanned</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>compactionRateLimiterAcquire</name><argument_list>(<argument><expr><name>limiter</name></expr></argument>, <argument><expr><name>bytesScanned</name></expr></argument>, <argument><expr><name>lastBytesScanned</name></expr></argument>, <argument><expr><name>compressionRatio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lastBytesScanned</name> <operator>=</operator> <name>bytesScanned</name></expr>;</expr_stmt>
                </block_content>}</block></try>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name><name>fullWriter</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>transWriter</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>unrepairedWriter</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>checkpoint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>obsoleteOriginals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>prepareToCommit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>fullSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>fullWriter</name><operator>.</operator><name>finished</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>transSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>transWriter</name><operator>.</operator><name>finished</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>unrepairedSSTables</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>unrepairedWriter</name><operator>.</operator><name>finished</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>fullWriter</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>transWriter</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>unrepairedWriter</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Anticompacted {} in {}.{} to full = {}, transient = {}, unrepaired = {} for {}"</literal></expr></argument>,
                        <argument><expr><name>sstableAsSet</name></expr></argument>,
                        <argument><expr><call><name><name>cfs</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>cfs</name><operator>.</operator><name>getTableName</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>fullSSTables</name></expr></argument>,
                        <argument><expr><name>transSSTables</name></expr></argument>,
                        <argument><expr><name>unrepairedSSTables</name></expr></argument>,
                        <argument><expr><name>pendingRepair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>fullSSTables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>transSSTables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>unrepairedSSTables</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>e</name> <operator>instanceof</operator> <name>CompactionInterruptedException</name> <operator>&amp;&amp;</operator> <call><name><name>isCancelled</name><operator>.</operator><name>getAsBoolean</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Anticompaction has been canceled for session {}"</literal></expr></argument>, <argument><expr><name>pendingRepair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>JVMStabilityInspector</name><operator>.</operator><name>inspectThrowable</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Error anticompacting "</literal> <operator>+</operator> <name>txn</name> <operator>+</operator> <literal type="string">" for "</literal> <operator>+</operator> <name>pendingRepair</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <specifier>static</specifier> <name>CompactionIterator</name></type> <name>getAntiCompactionIterator</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ISSTableScanner</name></argument>&gt;</argument_list></name></type> <name>scanners</name></decl></parameter>, <parameter><decl><type><name>CompactionController</name></type> <name>controller</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>, <parameter><decl><type><name>UUID</name></type> <name>timeUUID</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>, <parameter><decl><type><name>BooleanSupplier</name></type> <name>isCancelled</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <class><super><name>CompactionIterator</name></super><argument_list>(<argument><expr><name><name>OperationType</name><operator>.</operator><name>ANTICOMPACTION</name></name></expr></argument>, <argument><expr><name>scanners</name></expr></argument>, <argument><expr><name>controller</name></expr></argument>, <argument><expr><name>nowInSec</name></expr></argument>, <argument><expr><name>timeUUID</name></expr></argument>, <argument><expr><name>activeCompactions</name></expr></argument>)</argument_list> <block>{

            <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isStopRequested</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <return>return <expr><call><name><name>super</name><operator>.</operator><name>isStopRequested</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>isCancelled</name><operator>.</operator><name>getAsBoolean</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></function>
        }</block></class></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitIndexBuild</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>SecondaryIndexBuilder</name></type> <name>builder</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><operator>new</operator> <class><super><name>Runnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <try>try
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <finally>finally
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></finally></try>
            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><literal type="string">"index build"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Is not scheduled, because it is performing disjoint work from sstable compaction.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitIndexBuild</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>SecondaryIndexBuilder</name></type> <name>builder</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>submitIndexBuild</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitCacheWrite</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>AutoSavingCache</name><operator>.</operator><name>Writer</name></name></type> <name>writer</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>submitCacheWrite</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><name><name>Future</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitCacheWrite</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>AutoSavingCache</name><operator>.</operator><name>Writer</name></name></type> <name>writer</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><operator>new</operator> <class><super><name>Runnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>AutoSavingCache</name><operator>.</operator><name>flushInProgress</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>writer</name><operator>.</operator><name>cacheType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Cache flushing was already in progress: skipping {}"</literal></expr></argument>, <argument><expr><call><name><name>writer</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <try>try
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <try>try
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>saveCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    <finally>finally
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></finally></try>
                </block_content>}</block>
                <finally>finally
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>AutoSavingCache</name><operator>.</operator><name>flushInProgress</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>writer</name><operator>.</operator><name>cacheType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></finally></try>
            </block_content>}</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name><name>executor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>, <argument><expr><literal type="string">"cache write"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>runIndexSummaryRedistribution</name><parameter_list>(<parameter><decl><type><name>IndexSummaryRedistribution</name></type> <name>redistribution</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <return>return <expr><call><name>runIndexSummaryRedistribution</name><argument_list>(<argument><expr><name>redistribution</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>runIndexSummaryRedistribution</name><parameter_list>(<parameter><decl><type><name>IndexSummaryRedistribution</name></type> <name>redistribution</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>redistribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>redistribution</name><operator>.</operator><name>redistributeSummaries</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>redistribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>getDefaultGcBefore</name><parameter_list>(<parameter><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nowInSec</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// 2ndary indexes have ExpiringColumns too, so we need to purge tombstones deleted before now. We do not need to</comment>
        <comment type="line">// add any GcGrace however since 2ndary indexes are local to a node.</comment>
        <return>return <expr><ternary><condition><expr><call><name><name>cfs</name><operator>.</operator><name>isIndex</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>nowInSec</name></expr> </then><else>: <expr><call><name><name>cfs</name><operator>.</operator><name>gcBefore</name></name><argument_list>(<argument><expr><name>nowInSec</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>submitViewBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ViewBuilderTask</name></type> <name>task</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>submitViewBuilder</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>submitViewBuilder</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>ViewBuilderTask</name></type> <name>task</name></decl></parameter>, <parameter><decl><type><name>ActiveCompactionsTracker</name></type> <name>activeCompactions</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>submitIfRunning</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
            <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>beginCompaction</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{<block_content>
                <return>return <expr><call><name><name>task</name><operator>.</operator><name>call</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block>
            <finally>finally
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>activeCompactions</name><operator>.</operator><name>finishCompaction</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>
        </block_content>}</block></lambda></expr></argument>, <argument><expr><literal type="string">"view build"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getActiveCompactions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <class><specifier>static</specifier> class <name>CompactionExecutor</name> <super_list><extends>extends <super><name>JMXEnabledThreadPoolExecutor</name></super></extends></super_list>
    <block>{
        <constructor><specifier>protected</specifier> <name>CompactionExecutor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minThreads</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxThreads</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>BlockingQueue</name><argument_list type="generic">&lt;<argument><name>Runnable</name></argument>&gt;</argument_list></name></type> <name>queue</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>minThreads</name></expr></argument>, <argument><expr><name>maxThreads</name></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>SECONDS</name></name></expr></argument>, <argument><expr><name>queue</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>NamedThreadFactory</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>Thread</name><operator>.</operator><name>MIN_PRIORITY</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <constructor><specifier>private</specifier> <name>CompactionExecutor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>threadCount</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>threadCount</name></expr></argument>, <argument><expr><name>threadCount</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>LinkedBlockingQueue</name><argument_list type="generic">&lt;<argument><name>Runnable</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <constructor><specifier>public</specifier> <name>CompactionExecutor</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getConcurrentCompactors</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"CompactionExecutor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>protected</specifier> <name>void</name></type> <name>beforeExecute</name><parameter_list>(<parameter><decl><type><name>Thread</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>Runnable</name></type> <name>r</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <comment type="line">// can't set this in Thread factory, so we do it redundantly here</comment>
            <expr_stmt><expr><call><name><name>isCompactionManager</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>beforeExecute</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <comment type="line">// modified from DebuggableThreadPoolExecutor so that CompactionInterruptedExceptions are not logged</comment>
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>void</name></type> <name>afterExecute</name><parameter_list>(<parameter><decl><type><name>Runnable</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>Throwable</name></type> <name>t</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>DebuggableThreadPoolExecutor</name><operator>.</operator><name>maybeResetLocalSessionWrapper</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>DebuggableThreadPoolExecutor</name><operator>.</operator><name>extractThrowable</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>t</name> <operator>instanceof</operator> <name>CompactionInterruptedException</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><call><name><name>t</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>t</name><operator>.</operator><name>getSuppressed</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>t</name><operator>.</operator><name>getSuppressed</name></name><argument_list>()</argument_list></call><operator>.</operator><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Interruption of compaction encountered exceptions:"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Full interruption stack trace:"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>DebuggableThreadPoolExecutor</name><operator>.</operator><name>handleOrLog</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Snapshots cannot be deleted on Windows while segments of the root element are mapped in NTFS. Compactions</comment>
            <comment type="line">// unmap those segments which could free up a snapshot for successful deletion.</comment>
            <expr_stmt><expr><call><name><name>SnapshotDeletingTask</name><operator>.</operator><name>rescheduleFailedTasks</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>submitIfRunning</name><parameter_list>(<parameter><decl><type><name>Runnable</name></type> <name>task</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>submitIfRunning</name><argument_list>(<argument><expr><call><name><name>Executors</name><operator>.</operator><name>callable</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Submit the task but only if the executor has not been shutdown.If the executor has
         * been shutdown, or in case of a rejected execution exception return a cancelled future.
         *
         * @param task - the task to submit
         * @param name - the task name to use in log messages
         *
         * @return the future that will deliver the task result, or a future that has already been
         *         cancelled if the task could not be submitted.
         */</comment>
        <function><type><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <name><name>ListenableFuture</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>submitIfRunning</name><parameter_list>(<parameter><decl><type><name><name>Callable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>task</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>isShutdown</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Executor has been shut down, not submitting {}"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name><name>Futures</name><operator>.</operator><name>immediateCancelledFuture</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <try>try
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>ListenableFutureTask</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>ret</name> <init>= <expr><call><name><name>ListenableFutureTask</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>execute</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ret</name></expr>;</return>
            </block_content>}</block>
            <catch>catch <parameter_list>(<parameter><decl><type><name>RejectedExecutionException</name></type> <name>ex</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>isShutdown</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Executor has shut down, could not submit {}"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"Failed to submit {}"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <return>return <expr><call><name><name>Futures</name><operator>.</operator><name>immediateCancelledFuture</name></name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></catch></try>
        </block_content>}</block></function>
    }</block></class>

    <comment type="line">// TODO: pull out relevant parts of CompactionExecutor and move to ValidationManager</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ValidationExecutor</name> <super_list><extends>extends <super><name>CompactionExecutor</name></super></extends></super_list>
    <block>{
        <comment type="line">// CompactionExecutor, and by extension ValidationExecutor, use DebuggableThreadPoolExecutor's</comment>
        <comment type="line">// default RejectedExecutionHandler which blocks the submitting thread when the work queue is</comment>
        <comment type="line">// full. The calling thread in this case is AntiEntropyStage, so in most cases we don't actually</comment>
        <comment type="line">// want to block when the ValidationExecutor is saturated as this prevents progress on all</comment>
        <comment type="line">// repair tasks and may cause repair sessions to time out. Also, it can lead to references to</comment>
        <comment type="line">// heavyweight validation responses containing merkle trees being held for extended periods which</comment>
        <comment type="line">// increases GC pressure. Using LinkedBlockingQueue instead of the default SynchronousQueue allows</comment>
        <comment type="line">// tasks to be submitted without blocking the caller, but will always prefer queueing to creating</comment>
        <comment type="line">// new threads if the pool already has at least `corePoolSize` threads already running. For this</comment>
        <comment type="line">// reason we set corePoolSize to the maximum desired concurrency, but allow idle core threads to</comment>
        <comment type="line">// be terminated.</comment>

        <constructor><specifier>public</specifier> <name>ValidationExecutor</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getConcurrentValidations</name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getConcurrentValidations</name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><literal type="string">"ValidationExecutor"</literal></expr></argument>,
                  <argument><expr><operator>new</operator> <call><name>LinkedBlockingQueue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>allowCoreThreadTimeOut</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>adjustPoolSize</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>setMaximumPoolSize</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getConcurrentValidations</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setCorePoolSize</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getConcurrentValidations</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>ViewBuildExecutor</name> <super_list><extends>extends <super><name>CompactionExecutor</name></super></extends></super_list>
    <block>{
        <constructor><specifier>public</specifier> <name>ViewBuildExecutor</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getConcurrentViewBuilders</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ViewBuildExecutor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>
    }</block></class>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>CacheCleanupExecutor</name> <super_list><extends>extends <super><name>CompactionExecutor</name></super></extends></super_list>
    <block>{
        <constructor><specifier>public</specifier> <name>CacheCleanupExecutor</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"CacheCleanupExecutor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>
    }</block></class>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>incrementAborted</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>metrics</name><operator>.</operator><name>compactionsAborted</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>incrementCompactionsReduced</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>metrics</name><operator>.</operator><name>compactionsReduced</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>incrementSstablesDropppedFromCompactions</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>metrics</name><operator>.</operator><name>sstablesDropppedFromCompactions</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>


    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getCompactions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Holder</name></argument>&gt;</argument_list></name></type> <name>compactionHolders</name> <init>= <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>compactionHolders</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name></type> <name>ci</name> <range>: <expr><name>compactionHolders</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>ci</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>asMap</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><name>out</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getCompactionSummary</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Holder</name></argument>&gt;</argument_list></name></type> <name>compactionHolders</name> <init>= <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>compactionHolders</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name></type> <name>ci</name> <range>: <expr><name>compactionHolders</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>ci</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><name>out</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TabularData</name></type> <name>getCompactionHistory</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>SystemKeyspace</name><operator>.</operator><name>getCompactionHistory</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>OpenDataException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalBytesCompacted</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>metrics</name><operator>.</operator><name>bytesCompacted</name><operator>.</operator><name>getCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalCompactionsCompleted</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>metrics</name><operator>.</operator><name>totalCompactionsCompleted</name><operator>.</operator><name>getCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getPendingTasks</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>metrics</name><operator>.</operator><name>pendingTasks</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getCompletedTasks</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>metrics</name><operator>.</operator><name>completedTasks</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopCompaction</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>type</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OperationType</name></type> <name>operation</name> <init>= <expr><call><name><name>OperationType</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Holder</name></type> <name>holder</name> <range>: <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>holder</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTaskType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>operation</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>holder</name><operator>.</operator><name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopCompactionById</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>compactionId</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>Holder</name></type> <name>holder</name> <range>: <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>UUID</name></type> <name>holderId</name> <init>= <expr><call><name><name>holder</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTaskId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>holderId</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>holderId</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><call><name><name>UUID</name><operator>.</operator><name>fromString</name></name><argument_list>(<argument><expr><name>compactionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>holder</name><operator>.</operator><name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setConcurrentCompactors</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <call><name><name>executor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// we are increasing the value</comment>
            <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <call><name><name>executor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// we are reducing the value</comment>
            <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setConcurrentValidations</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>validationExecutor</name><operator>.</operator><name>adjustPoolSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setConcurrentViewBuilders</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <call><name><name>viewBuildExecutor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// we are increasing the value</comment>
            <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <call><name><name>viewBuildExecutor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// we are reducing the value</comment>
            <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCoreCompactorThreads</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>executor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCoreCompactorThreads</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaximumCompactorThreads</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>executor</name><operator>.</operator><name>getMaximumPoolSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaximumCompactorThreads</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>executor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCoreValidationThreads</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>validationExecutor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCoreValidationThreads</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>validationExecutor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaximumValidatorThreads</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>validationExecutor</name><operator>.</operator><name>getMaximumPoolSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaximumValidatorThreads</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>validationExecutor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getDisableSTCSInL0</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getDisableSTCSInL0</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDisableSTCSInL0</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>disabled</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>disabled</name> <operator>!=</operator> <call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getDisableSTCSInL0</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Changing STCS in L0 disabled from {} to {}"</literal></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getDisableSTCSInL0</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>disabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>setDisableSTCSInL0</name></name><argument_list>(<argument><expr><name>disabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCoreViewBuildThreads</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>getCorePoolSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCoreViewBuildThreads</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>setCorePoolSize</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaximumViewBuildThreads</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>getMaximumPoolSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaximumViewBuildThreads</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>viewBuildExecutor</name><operator>.</operator><name>setMaximumPoolSize</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getAutomaticSSTableUpgradeEnabled</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>automaticSSTableUpgrade</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setAutomaticSSTableUpgradeEnabled</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>enabled</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>setAutomaticSSTableUpgradeEnabled</name></name><argument_list>(<argument><expr><name>enabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaxConcurrentAutoUpgradeTasks</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>maxConcurrentAutoUpgradeTasks</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaxConcurrentAutoUpgradeTasks</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>setMaxConcurrentAutoUpgradeTasks</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Try to stop all of the compactions for given ColumnFamilies.
     *
     * Note that this method does not wait for all compactions to finish; you'll need to loop against
     * isCompacting if you want that behavior.
     *
     * @param columnFamilies The ColumnFamilies to try to stop compaction upon.
     * @param sstablePredicate the sstable predicate to match on
     * @param interruptValidation true if validation operations for repair should also be interrupted
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>interruptCompactionFor</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>TableMetadata</name></argument>&gt;</argument_list></name></type> <name>columnFamilies</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstablePredicate</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptValidation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>columnFamilies</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <comment type="line">// interrupt in-progress compactions</comment>
        <for>for <control>(<init><decl><type><name>Holder</name></type> <name>compactionHolder</name> <range>: <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CompactionInfo</name></type> <name>info</name> <init>= <expr><call><name><name>compactionHolder</name><operator>.</operator><name>getCompactionInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>info</name><operator>.</operator><name>getTaskType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>OperationType</name><operator>.</operator><name>VALIDATION</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>interruptValidation</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>info</name><operator>.</operator><name>getTableMetadata</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>Iterables</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>columnFamilies</name></expr></argument>, <argument><expr><call><name><name>info</name><operator>.</operator><name>getTableMetadata</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>info</name><operator>.</operator><name>shouldStop</name></name><argument_list>(<argument><expr><name>sstablePredicate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>compactionHolder</name><operator>.</operator><name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>interruptCompactionForCFs</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfss</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstablePredicate</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>interruptValidation</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TableMetadata</name></argument>&gt;</argument_list></name></type> <name>metadata</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>cfss</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>metadata</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name><operator>.</operator><name>metadata</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>interruptCompactionFor</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>sstablePredicate</name></expr></argument>, <argument><expr><name>interruptValidation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>waitForCessation</name><parameter_list>(<parameter><decl><type><name><name>Iterable</name><argument_list type="generic">&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfss</name></decl></parameter>, <parameter><decl><type><name><name>Predicate</name><argument_list type="generic">&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstablePredicate</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>delay</name> <init>= <expr><call><name><name>TimeUnit</name><operator>.</operator><name>MINUTES</name><operator>.</operator><name>toNanos</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>System</name><operator>.</operator><name>nanoTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>start</name> <operator>&lt;</operator> <name>delay</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>CompactionManager</name><operator>.</operator><name>instance</name><operator>.</operator><name>isCompacting</name></name><argument_list>(<argument><expr><name>cfss</name></expr></argument>, <argument><expr><name>sstablePredicate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>Uninterruptibles</name><operator>.</operator><name>sleepUninterruptibly</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>TimeUnit</name><operator>.</operator><name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <break>break;</break></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>


    <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>CompactionInfo</name></argument>&gt;</argument_list></name></type> <name>getSSTableTasks</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>active</name><operator>.</operator><name>getCompactions</name></name><argument_list>()</argument_list></call>
                     <operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
                     <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name><name>CompactionInfo</name><operator>.</operator><name>Holder</name></name><operator>::</operator><name>getCompactionInfo</name></expr></argument>)</argument_list></call>
                     <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>task</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>task</name><operator>.</operator><name>getTaskType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OperationType</name><operator>.</operator><name>COUNTER_CACHE_SAVE</name></name>
                                     <operator>&amp;&amp;</operator> <call><name><name>task</name><operator>.</operator><name>getTaskType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OperationType</name><operator>.</operator><name>KEY_CACHE_SAVE</name></name>
                                     <operator>&amp;&amp;</operator> <call><name><name>task</name><operator>.</operator><name>getTaskType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OperationType</name><operator>.</operator><name>ROW_CACHE_SAVE</name></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                     <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>toList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Return whether "global" compactions should be paused, used by ColumnFamilyStore#runWithCompactionsDisabled
     *
     * a global compaction is one that includes several/all tables, currently only IndexSummaryBuilder
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isGlobalCompactionPaused</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>globalCompactionPauseCount</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>CompactionPauser</name></type> <name>pauseGlobalCompaction</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CompactionPauser</name></type> <name>pauser</name> <init>= <expr><name>globalCompactionPauseCount</name><operator>::</operator><name>decrementAndGet</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>globalCompactionPauseCount</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>pauser</name></expr>;</return>
    </block_content>}</block></function>

    <interface><specifier>public</specifier> interface <name>CompactionPauser</name> <super_list><extends>extends <super><name>AutoCloseable</name></super></extends></super_list>
    <block>{
        <function_decl><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list>;</function_decl>
    }</block></interface>
}
</unit>
