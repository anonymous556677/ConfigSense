<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/locator/TokenMetadata.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ConcurrentHashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>ConcurrentMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicReference</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>locks</name><operator>.</operator><name>ReadWriteLock</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>locks</name><operator>.</operator><name>ReentrantReadWriteLock</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Supplier</name></name>;</import>

<import>import <name><name>javax</name><operator>.</operator><name>annotation</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>GuardedBy</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang3</name><operator>.</operator><name>StringUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>DecoratedKey</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>Keyspace</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>IPartitioner</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Range</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>gms</name><operator>.</operator><name>FailureDetector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>ReplicaCollection</name><operator>.</operator><name>Builder</name><operator>.</operator><name>Conflict</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name><operator>.</operator><name>StorageService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>BiMultiValMap</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Pair</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>SortedBiMultiValMap</name></name>;</import>

<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>CassandraRelevantProperties</name><operator>.</operator><name>LINE_SEPARATOR</name></name>;</import>

<class><specifier>public</specifier> class <name>TokenMetadata</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>TokenMetadata</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Maintains token to endpoint map of every node in the cluster.
     * Each Token is associated with exactly one Address, but each Address may have
     * multiple tokens.  Hence, the BiMultiValMap collection.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>tokenToEndpointMap</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** Maintains endpoint to host ID map of every node in the cluster */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>BiMap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>endpointToHostIdMap</name></decl>;</decl_stmt>

    <comment type="line">// Prior to CASSANDRA-603, we just had &lt;tt&gt;Map&lt;Range, InetAddressAndPort&gt; pendingRanges&lt;tt&gt;,</comment>
    <comment type="line">// which was added to when a node began bootstrap and removed from when it finished.</comment>
    <comment type="line">//</comment>
    <comment type="line">// This is inadequate when multiple changes are allowed simultaneously.  For example,</comment>
    <comment type="line">// suppose that there is a ring of nodes A, C and E, with replication factor 3.</comment>
    <comment type="line">// Node D bootstraps between C and E, so its pending ranges will be E-A, A-C and C-D.</comment>
    <comment type="line">// Now suppose node B bootstraps between A and C at the same time. Its pending ranges</comment>
    <comment type="line">// would be C-E, E-A and A-B. Now both nodes need to be assigned pending range E-A,</comment>
    <comment type="line">// which we would be unable to represent with the old Map.  The same thing happens</comment>
    <comment type="line">// even more obviously for any nodes that boot simultaneously between same two nodes.</comment>
    <comment type="line">//</comment>
    <comment type="line">// So, we made two changes:</comment>
    <comment type="line">//</comment>
    <comment type="line">// First, we changed pendingRanges to a &lt;tt&gt;Multimap&lt;Range, InetAddressAndPort&gt;&lt;/tt&gt; (now</comment>
    <comment type="line">// &lt;tt&gt;Map&lt;String, Multimap&lt;Range, InetAddressAndPort&gt;&gt;&lt;/tt&gt;, because replication strategy</comment>
    <comment type="line">// and options are per-KeySpace).</comment>
    <comment type="line">//</comment>
    <comment type="line">// Second, we added the bootstrapTokens and leavingEndpoints collections, so we can</comment>
    <comment type="line">// rebuild pendingRanges from the complete information of what is going on, when</comment>
    <comment type="line">// additional changes are made mid-operation.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Finally, note that recording the tokens of joining nodes in bootstrapTokens also</comment>
    <comment type="line">// means we can detect and reject the addition of multiple nodes at the same token</comment>
    <comment type="line">// before one becomes part of the ring.</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>bootstrapTokens</name> <init>= <expr><operator>new</operator> <call><name><name>BiMultiValMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>BiMap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>replacementToOriginal</name> <init>= <expr><call><name><name>HashBiMap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// (don't need to record Token here since it's still part of tokenToEndpointMap until it's done leaving)</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>leavingEndpoints</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// this is a cache of the calculation from {tokenToEndpointMap, bootstrapTokens, leavingEndpoints}</comment>
    <comment type="line">// NOTE: this may contain ranges that conflict with the those implied by sortedTokens when a range is changing its transient status</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ConcurrentMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>PendingRangeMaps</name></argument>&gt;</argument_list></name></type> <name>pendingRanges</name> <init>= <expr><operator>new</operator> <call><name><name>ConcurrentHashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>PendingRangeMaps</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// nodes which are migrating to the new tokens in the ring</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>movingEndpoints</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Use this lock for manipulating the token map */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ReadWriteLock</name></type> <name>lock</name> <init>= <expr><operator>new</operator> <call><name>ReentrantReadWriteLock</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name></decl>;</decl_stmt> <comment type="line">// safe to be read without a lock, as it's never mutated</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>Topology</name></type> <name>topology</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>IPartitioner</name></type> <name>partitioner</name></decl>;</decl_stmt>

    <comment type="line">// signals replication strategies that nodes have joined or left the ring and they need to recompute ownership</comment>
    <decl_stmt><decl><annotation>@<name>GuardedBy</name><argument_list>(<argument><expr><literal type="string">"lock"</literal></expr></argument>)</argument_list></annotation>
    <type><specifier>private</specifier> <name>long</name></type> <name>ringVersion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>TokenMetadata</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>SortedBiMultiValMap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>HashBiMap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>Topology</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <constructor><specifier>public</specifier> <name>TokenMetadata</name><parameter_list>(<parameter><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>SortedBiMultiValMap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>HashBiMap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>Topology</name><operator>.</operator><name>builder</name></name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name>snitch</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <constructor><specifier>private</specifier> <name>TokenMetadata</name><parameter_list>(<parameter><decl><type><name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>tokenToEndpointMap</name></decl></parameter>, <parameter><decl><type><name><name>BiMap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>endpointsMap</name></decl></parameter>, <parameter><decl><type><name>Topology</name></type> <name>topology</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>tokenToEndpointMap</name></expr></argument>, <argument><expr><name>endpointsMap</name></expr></argument>, <argument><expr><name>topology</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <constructor><specifier>private</specifier> <name>TokenMetadata</name><parameter_list>(<parameter><decl><type><name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>tokenToEndpointMap</name></decl></parameter>, <parameter><decl><type><name><name>BiMap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>endpointsMap</name></decl></parameter>, <parameter><decl><type><name>Topology</name></type> <name>topology</name></decl></parameter>, <parameter><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>ringVersion</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokenToEndpointMap</name></name> <operator>=</operator> <name>tokenToEndpointMap</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>topology</name></name> <operator>=</operator> <name>topology</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>partitioner</name></name> <operator>=</operator> <name>partitioner</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>endpointToHostIdMap</name> <operator>=</operator> <name>endpointsMap</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sortedTokens</name> <operator>=</operator> <call><name>sortTokens</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ringVersion</name></name> <operator>=</operator> <name>ringVersion</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * To be used by tests only (via {@link org.apache.cassandra.service.StorageService#setPartitionerUnsafe}).
     */</comment>
    <function><annotation>@<name>VisibleForTesting</name></annotation>
    <type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>cloneWithNewPartitioner</name><parameter_list>(<parameter><decl><type><name>IPartitioner</name></type> <name>newPartitioner</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>TokenMetadata</name><argument_list>(<argument><expr><name>tokenToEndpointMap</name></expr></argument>, <argument><expr><name>endpointToHostIdMap</name></expr></argument>, <argument><expr><name>topology</name></expr></argument>, <argument><expr><name>newPartitioner</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortTokens</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** @return the number of nodes bootstrapping into source's primary range */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>pendingRangeChanges</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>source</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sourceRanges</name> <init>= <expr><call><name>getPrimaryRangesFor</name><argument_list>(<argument><expr><call><name>getTokens</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>sourceRanges</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>range</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
        <return>return <expr><name>n</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Update token map with a single token/endpoint pair in normal state.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateNormalToken</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>updateNormalTokens</name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateNormalTokens</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>endpointTokens</name> <init>= <expr><call><name><name>HashMultimap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>endpointTokens</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>updateNormalTokens</name><argument_list>(<argument><expr><name>endpointTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Update token map with a set of token/endpoint pairs in normal state.
     *
     * Prefer this whenever there are multiple pairs to update, as each update (whether a single or multiple)
     * is expensive (CASSANDRA-3831).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateNormalTokens</name><parameter_list>(<parameter><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>endpointTokens</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>endpointTokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>boolean</name></type> <name>shouldSortTokens</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Topology</name><operator>.</operator><name>Builder</name></name></type> <name>topologyBuilder</name> <init>= <expr><call><name><name>topology</name><operator>.</operator><name>unbuild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name> <range>: <expr><call><name><name>endpointTokens</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>endpointTokens</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <assert>assert <expr><name>tokens</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>tokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>

                <expr_stmt><expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>removeValue</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>removeValue</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>topologyBuilder</name><operator>.</operator><name>addEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>leavingEndpoints</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>replacementToOriginal</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>removeFromMoving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// also removing this endpoint from moving</comment>

                <for>for <control>(<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>InetAddressAndPort</name></type> <name>prev</name> <init>= <expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>endpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Token {} changing ownership from {} to {}"</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>shouldSortTokens</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
            <expr_stmt><expr><name>topology</name> <operator>=</operator> <call><name><name>topologyBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>shouldSortTokens</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>sortedTokens</name> <operator>=</operator> <call><name>sortTokens</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Store an end-point to host ID mapping.  Each ID must be unique, and
     * cannot be changed after the fact.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateHostId</name><parameter_list>(<parameter><decl><type><name>UUID</name></type> <name>hostId</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>hostId</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>InetAddressAndPort</name></type> <name>storedEp</name> <init>= <expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>storedEp</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>storedEp</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>FailureDetector</name><operator>.</operator><name>instance</name><operator>.</operator><name>isAlive</name></name><argument_list>(<argument><expr><name>storedEp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Host ID collision between active endpoint %s and %s (id=%s)"</literal></expr></argument>,
                                                             <argument><expr><name>storedEp</name></expr></argument>,
                                                             <argument><expr><name>endpoint</name></expr></argument>,
                                                             <argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>UUID</name></type> <name>storedId</name> <init>= <expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>storedId</name> <operator>!=</operator> <literal type="null">null</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>storedId</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>hostId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Changing {}'s host ID from {} to {}"</literal></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>storedId</name></expr></argument>, <argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>forcePut</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>

    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** Return the unique host ID for an end-point. */</comment>
    <function><type><specifier>public</specifier> <name>UUID</name></type> <name>getHostId</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** Return the end-point for a unique host ID */</comment>
    <function><type><specifier>public</specifier> <name>InetAddressAndPort</name></type> <name>getEndpointForHostId</name><parameter_list>(<parameter><decl><type><name>UUID</name></type> <name>hostId</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** @return a copy of the endpoint-to-id map for read-only operations */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>getEndpointToHostIdMapForReading</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>readMap</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>readMap</name><operator>.</operator><name>putAll</name></name><argument_list>(<argument><expr><name>endpointToHostIdMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>readMap</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>addBootstrapToken</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addBootstrapTokens</name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addBootstrapTokens</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addBootstrapTokens</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>addBootstrapTokens</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>original</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>tokens</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>tokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>

            <decl_stmt><decl><type><name>InetAddressAndPort</name></type> <name>oldEndpoint</name></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>oldEndpoint</name> <operator>=</operator> <call><name><name>bootstrapTokens</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>oldEndpoint</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>oldEndpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Bootstrap Token collision between "</literal> <operator>+</operator> <name>oldEndpoint</name> <operator>+</operator> <literal type="string">" and "</literal> <operator>+</operator> <name>endpoint</name> <operator>+</operator> <literal type="string">" (token "</literal> <operator>+</operator> <name>token</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>oldEndpoint</name> <operator>=</operator> <call><name><name>tokenToEndpointMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>oldEndpoint</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>oldEndpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>oldEndpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Bootstrap Token collision between "</literal> <operator>+</operator> <name>oldEndpoint</name> <operator>+</operator> <literal type="string">" and "</literal> <operator>+</operator> <name>endpoint</name> <operator>+</operator> <literal type="string">" (token "</literal> <operator>+</operator> <name>token</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>removeValue</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addReplaceTokens</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>replacingTokens</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>newNode</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>oldNode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>replacingTokens</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>replacingTokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <assert>assert <expr><name>newNode</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>oldNode</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>oldNodeTokens</name> <init>= <expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>replacingTokens</name><operator>.</operator><name>containsAll</name></name><argument_list>(<argument><expr><name>oldNodeTokens</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>oldNodeTokens</name><operator>.</operator><name>containsAll</name></name><argument_list>(<argument><expr><name>replacingTokens</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Node %s is trying to replace node %s with tokens %s with a "</literal> <operator>+</operator>
                                                         <literal type="string">"different set of tokens %s."</literal></expr></argument>, <argument><expr><name>newNode</name></expr></argument>, <argument><expr><name>oldNode</name></expr></argument>, <argument><expr><name>oldNodeTokens</name></expr></argument>,
                                                         <argument><expr><name>replacingTokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Replacing {} with {}"</literal></expr></argument>, <argument><expr><name>newNode</name></expr></argument>, <argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>replacementToOriginal</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>newNode</name></expr></argument>, <argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>addBootstrapTokens</name><argument_list>(<argument><expr><name>replacingTokens</name></expr></argument>, <argument><expr><name>newNode</name></expr></argument>, <argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getReplacementNode</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>Optional</name><operator>.</operator><name>ofNullable</name></name><argument_list>(<argument><expr><call><name><name>replacementToOriginal</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getReplacingNode</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>Optional</name><operator>.</operator><name>ofNullable</name></name><argument_list>(<argument><expr><operator>(</operator><call><name><name>replacementToOriginal</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeBootstrapTokens</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>tokens</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>tokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addLeavingEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>leavingEndpoints</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Add a new moving endpoint
     * @param token token which is node moving to
     * @param endpoint address of the moving node
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addMovingEndpoint</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>movingEndpoints</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>Pair</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>removeValue</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>removeValue</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>topology</name> <operator>=</operator> <call><name><name>topology</name><operator>.</operator><name>unbuild</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>removeEndpoint</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>leavingEndpoints</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>replacementToOriginal</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Node {} failed during replace."</literal></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sortedTokens</name> <operator>=</operator> <call><name>sortTokens</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>invalidateCachedRingsUnsafe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * This is called when the snitch properties for this endpoint are updated, see CASSANDRA-10238.
     */</comment>
    <function><type><specifier>public</specifier> <name>Topology</name></type> <name>updateTopology</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Updating topology for {}"</literal></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>topology</name> <operator>=</operator> <call><name><name>topology</name><operator>.</operator><name>unbuild</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>updateEndpoint</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>invalidateCachedRingsUnsafe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>topology</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * This is called when the snitch properties for many endpoints are updated, it will update
     * the topology mappings of any endpoints whose snitch has changed, see CASSANDRA-10238.
     */</comment>
    <function><type><specifier>public</specifier> <name>Topology</name></type> <name>updateTopology</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Updating topology for all endpoints that have changed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>topology</name> <operator>=</operator> <call><name><name>topology</name><operator>.</operator><name>unbuild</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>updateEndpoints</name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>invalidateCachedRingsUnsafe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>topology</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Remove pair of token/address from moving endpoints
     * @param endpoint address of the moving node
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeFromMoving</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>pair</name> <range>: <expr><name>movingEndpoints</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>pair</name><operator>.</operator><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>movingEndpoints</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>invalidateCachedRingsUnsafe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getTokens</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <assert>assert <expr><call><name>isMember</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</assert> <comment type="line">// don't want to return nulls</comment>
            <return>return <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>public</specifier> <name>Token</name></type> <name>getToken</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getTokens</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isMember</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>containsKey</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isLeaving</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>leavingEndpoints</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isMoving</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>endpoint</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>pair</name> <range>: <expr><name>movingEndpoints</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>pair</name><operator>.</operator><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>AtomicReference</name><argument_list type="generic">&lt;<argument><name>TokenMetadata</name></argument>&gt;</argument_list></name></type> <name>cachedTokenMap</name> <init>= <expr><operator>new</operator> <call><name><name>AtomicReference</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Create a copy of TokenMetadata with only tokenToEndpointMap. That is, pending ranges,
     * bootstrap tokens and leaving endpoints are not included in the copy.
     */</comment>
    <function><type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>cloneOnlyTokenMap</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>TokenMetadata</name><argument_list>(<argument><expr><call><name><name>SortedBiMultiValMap</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>tokenToEndpointMap</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name><name>HashBiMap</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>endpointToHostIdMap</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>topology</name></expr></argument>,
                                     <argument><expr><name>partitioner</name></expr></argument>,
                                     <argument><expr><name>ringVersion</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Return a cached TokenMetadata with only tokenToEndpointMap, i.e., the same as cloneOnlyTokenMap but
     * uses a cached copy that is invalided when the ring changes, so in the common case
     * no extra locking is required.
     *
     * Callers must *NOT* mutate the returned metadata object.
     */</comment>
    <function><type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>cachedOnlyTokenMap</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>tm</name> <init>= <expr><call><name><name>cachedTokenMap</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tm</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// synchronize to prevent thundering herd (CASSANDRA-6345)</comment>
        <synchronized>synchronized <init>(<expr><name>this</name></expr>)</init>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tm</name> <operator>=</operator> <call><name><name>cachedTokenMap</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>tm</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>cloneOnlyTokenMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cachedTokenMap</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>tm</name></expr>;</return>
        </block_content>}</block></synchronized>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Create a copy of TokenMetadata with tokenToEndpointMap reflecting situation after all
     * current leave operations have finished.
     *
     * @return new token metadata
     */</comment>
    <function><type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>cloneAfterAllLeft</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name>removeEndpoints</name><argument_list>(<argument><expr><call><name>cloneOnlyTokenMap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>leavingEndpoints</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>TokenMetadata</name></type> <name>removeEndpoints</name><parameter_list>(<parameter><decl><type><name>TokenMetadata</name></type> <name>allLeftMetadata</name></decl></parameter>, <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>leavingEndpoints</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name> <range>: <expr><name>leavingEndpoints</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>allLeftMetadata</name><operator>.</operator><name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <return>return <expr><name>allLeftMetadata</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Create a copy of TokenMetadata with tokenToEndpointMap reflecting situation after all
     * current leave, and move operations have finished.
     *
     * @return new token metadata
     */</comment>
    <function><type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>cloneAfterAllSettled</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>metadata</name> <init>= <expr><call><name>cloneOnlyTokenMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name> <range>: <expr><name>leavingEndpoints</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>metadata</name><operator>.</operator><name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


            <for>for <control>(<init><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>pair</name> <range>: <expr><name>movingEndpoints</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>metadata</name><operator>.</operator><name>updateNormalToken</name></name><argument_list>(<argument><expr><name><name>pair</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <return>return <expr><name>metadata</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>InetAddressAndPort</name></type> <name>getEndpoint</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getPrimaryRangesFor</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Token</name></type> <name>right</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>ranges</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>Range</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPredecessor</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><name>ranges</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>public</specifier> <name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getPrimaryRangeFor</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>right</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>getPrimaryRangesFor</name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>sortedTokens</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>EndpointsByRange</name></type> <name>getPendingRangesMM</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>EndpointsByRange</name><operator>.</operator><name>Builder</name></name></type> <name>byRange</name> <init>= <expr><operator>new</operator> <call><name><name>EndpointsByRange</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PendingRangeMaps</name></type> <name>pendingRangeMaps</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>pendingRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>pendingRangeMaps</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>EndpointsForRange</name><operator>.</operator><name>Builder</name></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><name>pendingRangeMaps</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>byRange</name><operator>.</operator><name>putAll</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Conflict</name><operator>.</operator><name>ALL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name><name>byRange</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** a mutable map may be returned but caller should not modify it */</comment>
    <function><type><specifier>public</specifier> <name>PendingRangeMaps</name></type> <name>getPendingRanges</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>pendingRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>RangesAtEndpoint</name></type> <name>getPendingRanges</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>, <parameter><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>RangesAtEndpoint</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name> <init>= <expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>builder</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Replica</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getPendingRangesMM</name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>flattenEntries</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Replica</name></type> <name>replica</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>replica</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>, <argument><expr><name><name>Conflict</name><operator>.</operator><name>DUPLICATE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>builder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

     <comment type="block" format="javadoc">/**
     * Calculate pending ranges according to bootsrapping and leaving nodes. Reasoning is:
     *
     * (1) When in doubt, it is better to write too much to a node than too little. That is, if
     * there are multiple nodes moving, calculate the biggest ranges a node could have. Cleaning
     * up unneeded data afterwards is better than missing writes during movement.
     * (2) When a node leaves, ranges for other nodes can only grow (a node might get additional
     * ranges, but it will not lose any of its current ranges as a result of a leave). Therefore
     * we will first remove _all_ leaving tokens for the sake of calculation and then check what
     * ranges would go where if all nodes are to leave. This way we get the biggest possible
     * ranges with regard current leave operations, covering all subsets of possible final range
     * values.
     * (3) When a node bootstraps, ranges of other nodes can only get smaller. Without doing
     * complex calculations to see if multiple bootstraps overlap, we simply base calculations
     * on the same token ring used before (reflecting situation after all leave operations have
     * completed). Bootstrapping nodes will be added and removed one by one to that metadata and
     * checked what their ranges would be. This will give us the biggest possible ranges the
     * node could have. It might be that other bootstraps make our actual final ranges smaller,
     * but it does not matter as we can clean up the data afterwards.
     *
     * NOTE: This is heavy and ineffective operation. This will be done only once when a node
     * changes state in the cluster, so it should be manageable.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>calculatePendingRanges</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// avoid race between both branches - do not use a lock here as this will block any other unrelated operations!</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>startedAt</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized <init>(<expr><name>pendingRanges</name></expr>)</init>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>TokenMetadataDiagnostics</name><operator>.</operator><name>pendingRangeCalculationStarted</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// create clone of current state</comment>
            <decl_stmt><decl><type><name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>bootstrapTokensClone</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>leavingEndpointsClone</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>movingEndpointsClone</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>metadata</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{<block_content>

                <if_stmt><if>if <condition>(<expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>leavingEndpoints</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>movingEndpoints</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"No bootstrapping, leaving or moving nodes -&gt; empty pending ranges for {}"</literal></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>leavingEndpoints</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>movingEndpoints</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"No bootstrapping, leaving or moving nodes -&gt; empty pending ranges for {}"</literal></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name><name>pendingRanges</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>PendingRangeMaps</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <return>return;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>bootstrapTokensClone</name>  <operator>=</operator> <operator>new</operator> <call><name><name>BiMultiValMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>bootstrapTokens</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>leavingEndpointsClone</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>leavingEndpoints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>movingEndpointsClone</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>movingEndpoints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <finally>finally
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></finally></try>

            <expr_stmt><expr><call><name><name>pendingRanges</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><call><name>calculatePendingRanges</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>bootstrapTokensClone</name></expr></argument>,
                                                                   <argument><expr><name>leavingEndpointsClone</name></expr></argument>, <argument><expr><name>movingEndpointsClone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Starting pending range calculation for {}"</literal></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>long</name></type> <name>took</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>startedAt</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Pending range calculation for {} completed (took: {}ms)"</literal></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><name>took</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>logger</name><operator>.</operator><name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>trace</name></name><argument_list>(<argument><expr><literal type="string">"Calculated pending ranges for {}:\n{}"</literal></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name><name>pendingRanges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"&lt;empty&gt;"</literal></expr> </then><else>: <expr><call><name>printPendingRanges</name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></synchronized>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @see TokenMetadata#calculatePendingRanges(AbstractReplicationStrategy, String)
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>PendingRangeMaps</name></type> <name>calculatePendingRanges</name><parameter_list>(<parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name></decl></parameter>,
                                                           <parameter><decl><type><name>TokenMetadata</name></type> <name>metadata</name></decl></parameter>,
                                                           <parameter><decl><type><name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>bootstrapTokens</name></decl></parameter>,
                                                           <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>leavingEndpoints</name></decl></parameter>,
                                                           <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>movingEndpoints</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PendingRangeMaps</name></type> <name>newPendingRanges</name> <init>= <expr><operator>new</operator> <call><name>PendingRangeMaps</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>RangesByEndpoint</name></type> <name>addressRanges</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Copy of metadata reflecting the situation after all leave operations are finished.</comment>
        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>allLeftMetadata</name> <init>= <expr><call><name>removeEndpoints</name><argument_list>(<argument><expr><call><name><name>metadata</name><operator>.</operator><name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>leavingEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// get all ranges that will be affected by leaving nodes</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>removeAffectedRanges</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name> <range>: <expr><name>leavingEndpoints</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>removeAffectedRanges</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>addressRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>ranges</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// for each of those ranges, find what new nodes will be responsible for the range when</comment>
        <comment type="line">// all leaving nodes are gone.</comment>
        <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>removeAffectedRanges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>currentReplicas</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>calculateNaturalReplicas</name></name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>newReplicas</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>calculateNaturalReplicas</name></name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>allLeftMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>newReplica</name> <range>: <expr><name>newReplicas</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>currentReplicas</name><operator>.</operator><name>endpoints</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><call><name><name>newReplica</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// we calculate pending replicas for leave- and move- affected ranges in the same way to avoid</comment>
                <comment type="line">// a possible conflict when 2 pending replicas have the same endpoint and different ranges.</comment>
                <for>for <control>(<init><decl><type><name>Replica</name></type> <name>pendingReplica</name> <range>: <expr><call><name><name>newReplica</name><operator>.</operator><name>subtractSameReplication</name></name><argument_list>(<argument><expr><call><name><name>addressRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>newReplica</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>newPendingRanges</name><operator>.</operator><name>addPendingRange</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>pendingReplica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// At this stage newPendingRanges has been updated according to leave operations. We can</comment>
        <comment type="line">// now continue the calculation by checking bootstrapping nodes.</comment>

        <comment type="line">// For each of the bootstrapping nodes, simply add to the allLeftMetadata and check what their</comment>
        <comment type="line">// ranges would be. We actually need to clone allLeftMetadata each time as resetting its state</comment>
        <comment type="line">// after getting the new pending ranges is not as simple as just removing the bootstrapping</comment>
        <comment type="line">// endpoint. If the bootstrapping endpoint constitutes a replacement, removing it after checking</comment>
        <comment type="line">// the newly pending ranges means there are now fewer endpoints that there were originally and</comment>
        <comment type="line">// causes its next neighbour to take over its primary range which affects the next RF endpoints</comment>
        <comment type="line">// in the ring.</comment>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>bootstrapAddresses</name> <init>= <expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name> <range>: <expr><call><name><name>bootstrapAddresses</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>bootstrapAddresses</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>cloned</name> <init>= <expr><call><name><name>allLeftMetadata</name><operator>.</operator><name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>cloned</name><operator>.</operator><name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>cloned</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>newPendingRanges</name><operator>.</operator><name>addPendingRange</name></name><argument_list>(<argument><expr><call><name><name>replica</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// At this stage newPendingRanges has been updated according to leaving and bootstrapping nodes.</comment>
        <comment type="line">// We can now finish the calculation by checking moving nodes.</comment>

        <comment type="line">// For each of the moving nodes, we do the same thing we did for bootstrapping:</comment>
        <comment type="line">// simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be.</comment>
        <for>for <control>(<init><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>moving</name> <range>: <expr><name>movingEndpoints</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">//Calculate all the ranges which will could be affected. This will include the ranges before and after the move.</comment>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Replica</name></argument>&gt;</argument_list></name></type> <name>moveAffectedReplicas</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>InetAddressAndPort</name></type> <name>endpoint</name> <init>= <expr><name><name>moving</name><operator>.</operator><name>right</name></name></expr></init></decl>;</decl_stmt> <comment type="line">// address of the moving node</comment>
            <comment type="line">//Add ranges before the move</comment>
            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>allLeftMetadata</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>moveAffectedReplicas</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name><name>allLeftMetadata</name><operator>.</operator><name>updateNormalToken</name></name><argument_list>(<argument><expr><name><name>moving</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//Add ranges after the move</comment>
            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>allLeftMetadata</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>moveAffectedReplicas</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>replica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><name>moveAffectedReplicas</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>currentEndpoints</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>calculateNaturalReplicas</name></name><argument_list>(<argument><expr><call><name><name>replica</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><name>right</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>endpoints</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>newEndpoints</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>calculateNaturalReplicas</name></name><argument_list>(<argument><expr><call><name><name>replica</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><name>right</name></expr></argument>, <argument><expr><name>allLeftMetadata</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>endpoints</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>difference</name> <init>= <expr><call><name><name>Sets</name><operator>.</operator><name>difference</name></name><argument_list>(<argument><expr><name>newEndpoints</name></expr></argument>, <argument><expr><name>currentEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><specifier>final</specifier> <name>InetAddressAndPort</name></type> <name>address</name> <range>: <expr><name>difference</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>newReplicas</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>allLeftMetadata</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>oldReplicas</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Filter out the things that are already replicated</comment>
                    <expr_stmt><expr><name>newReplicas</name> <operator>=</operator> <call><name><name>newReplicas</name><operator>.</operator><name>filter</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>r</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><operator>!</operator><call><name><name>oldReplicas</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>Replica</name></type> <name>newReplica</name> <range>: <expr><name>newReplicas</name></expr></range></decl></init>)</control>
                    <block>{<block_content>
                        <comment type="line">// for correctness on write, we need to treat ranges that are becoming full differently</comment>
                        <comment type="line">// to those that are presently transient; however reads must continue to use the current view</comment>
                        <comment type="line">// for ranges that are becoming transient. We could choose to ignore them here, but it's probably</comment>
                        <comment type="line">// cleaner to ensure this is dealt with at point of use, where we can make a conscious decision</comment>
                        <comment type="line">// about which to use</comment>
                        <for>for <control>(<init><decl><type><name>Replica</name></type> <name>pendingReplica</name> <range>: <expr><call><name><name>newReplica</name><operator>.</operator><name>subtractSameReplication</name></name><argument_list>(<argument><expr><name>oldReplicas</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name><name>newPendingRanges</name><operator>.</operator><name>addPendingRange</name></name><argument_list>(<argument><expr><call><name><name>pendingReplica</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pendingReplica</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name><name>allLeftMetadata</name><operator>.</operator><name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><name>newPendingRanges</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Token</name></type> <name>getPredecessor</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name>sortedTokens</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>Collections</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>:</operator> <name>token</name> <operator>+</operator> <literal type="string">" not found in "</literal> <operator>+</operator> <call><name>tokenToEndpointMapKeysAsStrings</name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><ternary><condition><expr><name>index</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name><name>tokens</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>tokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>tokens</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>Token</name></type> <name>getSuccessor</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name>sortedTokens</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>Collections</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>:</operator> <name>token</name> <operator>+</operator> <literal type="string">" not found in "</literal> <operator>+</operator> <call><name>tokenToEndpointMapKeysAsStrings</name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><ternary><condition><expr><operator>(</operator><name>index</name> <operator>==</operator> <operator>(</operator><call><name><name>tokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><call><name><name>tokens</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>tokens</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>tokenToEndpointMapKeysAsStrings</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>StringUtils</name><operator>.</operator><name>join</name></name><argument_list>(<argument><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** @return a copy of the bootstrapping tokens map */</comment>
    <function><type><specifier>public</specifier> <name><name>BiMultiValMap</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getBootstrapTokens</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name><name>BiMultiValMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>bootstrapTokens</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getAllEndpoints</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getSizeOfAllEndpoints</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** caller should not modify leavingEndpoints */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getLeavingEndpoints</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>leavingEndpoints</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getSizeOfLeavingEndpoints</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>leavingEndpoints</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Endpoints which are migrating to the new tokens
     * @return set of addresses of moving endpoints
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getMovingEndpoints</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>ImmutableSet</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>movingEndpoints</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getSizeOfMovingEndpoints</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>movingEndpoints</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>firstTokenIndex</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>ring</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>insertMin</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><call><name><name>ring</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>
        <comment type="line">// insert the minimum token (at index == -1) if we were asked to include it and it isn't a member of the ring</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name><name>Collections</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name>ring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <call><name><name>ring</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>insertMin</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Token</name></type> <name>firstToken</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>ring</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>start</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>ring</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>firstTokenIndex</name><argument_list>(<argument><expr><name>ring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * iterator over the Tokens in the given ring, starting with the token for the node owning start
     * (which does not have to be a Token in the ring)
     * @param includeMin True if the minimum token should be returned in the ring even if it has no owner.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>ringIterator</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>ring</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>includeMin</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>ring</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><ternary><condition><expr><name>includeMin</name></expr> ?</condition><then> <expr><call><name><name>Iterators</name><operator>.</operator><name>singletonIterator</name></name><argument_list>(<argument><expr><call><name><name>start</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMinimumToken</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>
                              </then><else>: <expr><call><name><name>Collections</name><operator>.</operator><name>emptyIterator</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>insertMin</name> <init>= <expr><name>includeMin</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>ring</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>isMinimum</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>startIndex</name> <init>= <expr><call><name>firstTokenIndex</name><argument_list>(<argument><expr><name>ring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>insertMin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>new</operator> <class><super><name><name>AbstractIterator</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</decl_stmt>
            <function><type><specifier>protected</specifier> <name>Token</name></type> <name>computeNext</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><call><name>endOfData</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                <try>try
                <block>{<block_content>
                    <comment type="line">// return minimum for index == -1</comment>
                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name><name>start</name><operator>.</operator><name>getPartitioner</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMinimumToken</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <comment type="line">// return ring token for other indexes</comment>
                    <return>return <expr><call><name><name>ring</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block>
                <finally>finally
                <block>{<block_content>
                    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <call><name><name>ring</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>j</name> <operator>=</operator> <ternary><condition><expr><name>insertMin</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>startIndex</name></expr>)</condition><block type="pseudo"><block_content>
                        <comment type="line">// end iteration</comment>
                        <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></finally></try>
            </block_content>}</block></function>
        }</block></class></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** used by tests */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>clearUnsafe</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>endpointToHostIdMap</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>leavingEndpoints</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pendingRanges</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>movingEndpoints</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sortedTokens</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>topology</name> <operator>=</operator> <call><name><name>Topology</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>invalidateCachedRingsUnsafe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>endpointToTokenMap</name> <init>= <expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>inverse</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>eps</name> <init>= <expr><call><name><name>endpointToTokenMap</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>eps</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"Normal Tokens:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>ep</name> <range>: <expr><name>eps</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>endpointToTokenMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>bootstrapTokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"Bootstrapping Tokens:"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>bootstrapTokens</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>leavingEndpoints</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"Leaving Endpoints:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>ep</name> <range>: <expr><name>leavingEndpoints</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pendingRanges</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"Pending Ranges:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>LINE_SEPARATOR</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>printPendingRanges</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>

        <return>return <expr><call><name><name>sb</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>printPendingRanges</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>PendingRangeMaps</name></type> <name>pendingRangeMaps</name> <range>: <expr><call><name><name>pendingRanges</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>pendingRangeMaps</name><operator>.</operator><name>printPendingRanges</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><call><name><name>sb</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>EndpointsForToken</name></type> <name>pendingEndpointsForToken</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PendingRangeMaps</name></type> <name>pendingRangeMaps</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>pendingRanges</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pendingRangeMaps</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>EndpointsForToken</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><call><name><name>pendingRangeMaps</name><operator>.</operator><name>pendingEndpointsFor</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @deprecated retained for benefit of old tests
     */</comment>
    <function><annotation>@<name>Deprecated</name></annotation>
    <type><specifier>public</specifier> <name>EndpointsForToken</name></type> <name>getWriteEndpoints</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>keyspaceName</name></decl></parameter>, <parameter><decl><type><name>EndpointsForToken</name></type> <name>natural</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EndpointsForToken</name></type> <name>pending</name> <init>= <expr><call><name>pendingEndpointsForToken</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>ReplicaLayout</name><operator>.</operator><name>forTokenWrite</name></name><argument_list>(<argument><expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>natural</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>all</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** @return an endpoint to token multimap representation of tokenToEndpointMap (a copy) */</comment>
    <function><type><specifier>public</specifier> <name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getEndpointToTokenMapForReading</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>cloned</name> <init>= <expr><call><name><name>HashMultimap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>cloned</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <return>return <expr><name>cloned</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return a (stable copy, won't be modified) Token to Endpoint map for all the normal and bootstrapping nodes
     *         in the cluster.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getNormalAndBootstrappingTokenToEndpointMap</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenToEndpointMap</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>bootstrapTokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>putAll</name></name><argument_list>(<argument><expr><name>tokenToEndpointMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>map</name><operator>.</operator><name>putAll</name></name><argument_list>(<argument><expr><name>bootstrapTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>map</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return a (stable copy, won't be modified) datacenter to Endpoint map for all the nodes in the cluster.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>ImmutableMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getDC2AllEndpoints</name><parameter_list>(<parameter><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>Multimaps</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><call><name>getAllEndpoints</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>snitch</name><operator>::</operator><name>getDatacenter</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * @return the Topology map of nodes to DCs + Racks
     *
     * This is only allowed when a copy has been made of TokenMetadata, to avoid concurrent modifications
     * when Topology methods are subsequently used by the caller.
     */</comment>
    <function><type><specifier>public</specifier> <name>Topology</name></type> <name>getTopology</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <assert>assert <expr><name>this</name> <operator>!=</operator> <call><name><name>StorageService</name><operator>.</operator><name>instance</name><operator>.</operator><name>getTokenMetadata</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><name>topology</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getRingVersion</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <try>try
        <block>{<block_content>
            <return>return <expr><name>ringVersion</name></expr>;</return>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>readLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidateCachedRings</name><parameter_list>()</parameter_list>
    <block>{<block_content>   
        <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <try>try
        <block>{<block_content>   
            <expr_stmt><expr><call><name>invalidateCachedRingsUnsafe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <finally>finally
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>lock</name><operator>.</operator><name>writeLock</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></finally></try>
    </block_content>}</block></function>
    
    <function><type><specifier>private</specifier> <name>void</name></type> <name>invalidateCachedRingsUnsafe</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>ringVersion</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cachedTokenMap</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>DecoratedKey</name></type> <name>decorateKey</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>partitioner</name><operator>.</operator><name>decorateKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Tracks the assignment of racks and endpoints in each datacenter for all the "normal" endpoints
     * in this TokenMetadata. This allows faster calculation of endpoints in NetworkTopologyStrategy.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Topology</name>
    <block>{
        <comment type="block" format="javadoc">/** multi-map of DC to endpoints in that DC */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ImmutableMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>dcEndpoints</name></decl>;</decl_stmt>
        <comment type="block" format="javadoc">/** map of DC to multi-map of rack to endpoints in that rack */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ImmutableMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>ImmutableMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>dcRacks</name></decl>;</decl_stmt>
        <comment type="block" format="javadoc">/** reverse-lookup map for endpoint to current known dc/rack assignment */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ImmutableMap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>currentLocations</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>IEndpointSnitch</name></argument>&gt;</argument_list></name></type> <name>snitchSupplier</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Topology</name><parameter_list>(<parameter><decl><type><name>Builder</name></type> <name>builder</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dcEndpoints</name></name> <operator>=</operator> <call><name><name>ImmutableMultimap</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name><name>builder</name><operator>.</operator><name>dcEndpoints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>ImmutableMap</name><operator>.</operator><name><name>Builder</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>ImmutableMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>dcRackBuilder</name> <init>= <expr><call><name><name>ImmutableMap</name><operator>.</operator><name>builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>builder</name><operator>.</operator><name>dcRacks</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>dcRackBuilder</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ImmutableMultimap</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dcRacks</name></name> <operator>=</operator> <call><name><name>dcRackBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>currentLocations</name></name> <operator>=</operator> <call><name><name>ImmutableMap</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name><name>builder</name><operator>.</operator><name>currentLocations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>snitchSupplier</name></name> <operator>=</operator> <name><name>builder</name><operator>.</operator><name>snitchSupplier</name></name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * @return multi-map of DC to endpoints in that DC
         */</comment>
        <function><type><specifier>public</specifier> <name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>getDatacenterEndpoints</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>dcEndpoints</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * @return map of DC to multi-map of rack to endpoints in that rack
         */</comment>
        <function><type><specifier>public</specifier> <name><name>ImmutableMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>ImmutableMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getDatacenterRacks</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><name>dcRacks</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * @return The DC and rack of the given endpoint.
         */</comment>
        <function><type><specifier>public</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLocation</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>addr</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name><name>currentLocations</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><name>Builder</name></type> <name>unbuild</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>Builder</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>Builder</name></type> <name>builder</name><parameter_list>(<parameter><decl><type><name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>IEndpointSnitch</name></argument>&gt;</argument_list></name></type> <name>snitchSupplier</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>Builder</name><argument_list>(<argument><expr><name>snitchSupplier</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>static</specifier> <name>Topology</name></type> <name>empty</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>builder</name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <class><specifier>private</specifier> <specifier>static</specifier> class <name>Builder</name>
        <block>{
            <comment type="block" format="javadoc">/** multi-map of DC to endpoints in that DC */</comment>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></type> <name>dcEndpoints</name></decl>;</decl_stmt>
            <comment type="block" format="javadoc">/** map of DC to multi-map of rack to endpoints in that rack */</comment>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>dcRacks</name></decl>;</decl_stmt>
            <comment type="block" format="javadoc">/** reverse-lookup map for endpoint to current known dc/rack assignment */</comment>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>currentLocations</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>IEndpointSnitch</name></argument>&gt;</argument_list></name></type> <name>snitchSupplier</name></decl>;</decl_stmt>

            <constructor><name>Builder</name><parameter_list>(<parameter><decl><type><name><name>Supplier</name><argument_list type="generic">&lt;<argument><name>IEndpointSnitch</name></argument>&gt;</argument_list></name></type> <name>snitchSupplier</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dcEndpoints</name></name> <operator>=</operator> <call><name><name>HashMultimap</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dcRacks</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>currentLocations</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>snitchSupplier</name></name> <operator>=</operator> <name>snitchSupplier</name></expr>;</expr_stmt>
            </block_content>}</block></constructor>

            <constructor><name>Builder</name><parameter_list>(<parameter><decl><type><name>Topology</name></type> <name>from</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dcEndpoints</name></name> <operator>=</operator> <call><name><name>HashMultimap</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name><name>from</name><operator>.</operator><name>dcEndpoints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dcRacks</name></name> <operator>=</operator> <call><name><name>Maps</name><operator>.</operator><name>newHashMapWithExpectedSize</name></name><argument_list>(<argument><expr><call><name><name>from</name><operator>.</operator><name>dcRacks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name><name>ImmutableMultimap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>InetAddressAndPort</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>from</name><operator>.</operator><name>dcRacks</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>dcRacks</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>HashMultimap</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>currentLocations</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>from</name><operator>.</operator><name>currentLocations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>snitchSupplier</name></name> <operator>=</operator> <name><name>from</name><operator>.</operator><name>snitchSupplier</name></name></expr>;</expr_stmt>
            </block_content>}</block></constructor>

            <comment type="block" format="javadoc">/**
             * Stores current DC/rack assignment for ep
             */</comment>
            <function><type><name>Builder</name></type> <name>addEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>ep</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name></type> <name>dc</name> <init>= <expr><call><name><name>snitchSupplier</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDatacenter</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>rack</name> <init>= <expr><call><name><name>snitchSupplier</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRack</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>current</name> <init>= <expr><call><name><name>currentLocations</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>current</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>current</name><operator>.</operator><name>left</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>current</name><operator>.</operator><name>right</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>rack</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>doRemoveEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>doAddEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>rack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>this</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>private</specifier> <name>void</name></type> <name>doAddEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>ep</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>dc</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>rack</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>dcEndpoints</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dcRacks</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>dcRacks</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name><name>HashMultimap</name><operator>.</operator></name>&lt;<name>String</name></expr></argument>, <argument><expr><name>InetAddressAndPort</name><operator>&gt;</operator><call><name>create</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name><name>dcRacks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>put</name><argument_list>(<argument><expr><name>rack</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>currentLocations</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><call><name><name>Pair</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>rack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>

            <comment type="block" format="javadoc">/**
             * Removes current DC/rack assignment for ep
             */</comment>
            <function><type><name>Builder</name></type> <name>removeEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>ep</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>currentLocations</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>doRemoveEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><call><name><name>currentLocations</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>this</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>private</specifier> <name>void</name></type> <name>doRemoveEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>ep</name></decl></parameter>, <parameter><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>current</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>dcRacks</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>remove</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>dcEndpoints</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>

            <function><type><name>Builder</name></type> <name>updateEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>ep</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>snitch</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>currentLocations</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>updateEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>snitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>this</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><name>Builder</name></type> <name>updateEndpoints</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>snitch</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>

                <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>ep</name> <range>: <expr><call><name><name>currentLocations</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>updateEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>snitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <return>return <expr><name>this</name></expr>;</return>
            </block_content>}</block></function>

            <function><type><specifier>private</specifier> <name>void</name></type> <name>updateEndpoint</name><parameter_list>(<parameter><decl><type><name>InetAddressAndPort</name></type> <name>ep</name></decl></parameter>, <parameter><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>current</name> <init>= <expr><call><name><name>currentLocations</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>dc</name> <init>= <expr><call><name><name>snitch</name><operator>.</operator><name>getDatacenter</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>rack</name> <init>= <expr><call><name><name>snitch</name><operator>.</operator><name>getRack</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>dc</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>rack</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>doRemoveEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>doAddEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>rack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></function>

            <function><type><name>Topology</name></type> <name>build</name><parameter_list>()</parameter_list>
            <block>{<block_content>
                <return>return <expr><operator>new</operator> <call><name>Topology</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></function>
        }</block></class>
    }</block></class>
}</block></class>
</unit>
