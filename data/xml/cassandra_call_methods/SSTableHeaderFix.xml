<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/io/sstable/SSTableHeaderFix.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>File</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>charset</name><operator>.</operator><name>CharacterCodingException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>file</name><operator>.</operator><name>Files</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>nio</name><operator>.</operator><name>file</name><operator>.</operator><name>Path</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>EnumSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedHashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Objects</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Consumer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Function</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>function</name><operator>.</operator><name>Supplier</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>stream</name><operator>.</operator><name>Collectors</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>stream</name><operator>.</operator><name>Stream</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>CQL3Type</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>cql3</name><operator>.</operator><name>statements</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexTarget</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>Directories</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>SerializationHeader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>lifecycle</name><operator>.</operator><name>LifecycleTransaction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>AbstractCompositeType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>AbstractType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>CollectionType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>CompositeType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>DynamicCompositeType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>ListType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>MapType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>SetType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>TupleType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>marshal</name><operator>.</operator><name>UserType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataComponent</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>io</name><operator>.</operator><name>sstable</name><operator>.</operator><name>metadata</name><operator>.</operator><name>MetadataType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>ColumnMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>Schema</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaConstants</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>schema</name><operator>.</operator><name>TableMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>ByteBufferUtil</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>CassandraVersion</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Pair</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Validates and fixes type issues in the serialization-header of sstables.
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>SSTableHeaderFix</name>
<block>{
    <comment type="line">// C* 3.0 upgrade code</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>SKIPAUTOMATICUDTFIX</name> <init>= <expr><literal type="string">"cassandra.skipautomaticudtfix"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>SKIP_AUTOMATIC_FIX_ON_UPGRADE</name> <init>= <expr><call><name><name>Boolean</name><operator>.</operator><name>getBoolean</name></name><argument_list>(<argument><expr><name>SKIPAUTOMATICUDTFIX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>fixNonFrozenUDTIfUpgradeFrom30</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>previousVersionString</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>getPreviousReleaseVersionString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>previousVersionString</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>CassandraVersion</name></type> <name>previousVersion</name> <init>= <expr><operator>new</operator> <call><name>CassandraVersion</name><argument_list>(<argument><expr><name>previousVersionString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>previousVersion</name><operator>.</operator><name>major</name></name> <operator>!=</operator> <literal type="number">3</literal> <operator>||</operator> <name><name>previousVersion</name><operator>.</operator><name>minor</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Not an upgrade from 3.0 to 3.x, nothing to do here</comment>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>SKIP_AUTOMATIC_FIX_ON_UPGRADE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Detected upgrade from {} to {}, but -D{}=true, NOT fixing UDT type references in "</literal> <operator>+</operator>
                        <literal type="string">"sstable metadata serialization-headers"</literal></expr></argument>,
                        <argument><expr><name>previousVersionString</name></expr></argument>,
                        <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getReleaseVersionString</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>SKIPAUTOMATICUDTFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Detected upgrade from {} to {}, fixing UDT type references in sstable metadata serialization-headers"</literal></expr></argument>,
                    <argument><expr><name>previousVersionString</name></expr></argument>,
                    <argument><expr><call><name><name>FBUtilities</name><operator>.</operator><name>getReleaseVersionString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>SSTableHeaderFix</name></type> <name>instance</name> <init>= <expr><call><name><name>SSTableHeaderFix</name><operator>.</operator><name>builder</name></name><argument_list>()</argument_list></call>
                                                    <operator>.</operator><call><name>schemaCallback</name><argument_list>(<argument><expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name><name>Schema</name><operator>.</operator><name>instance</name></name><operator>::</operator><name>getTableMetadata</name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                                    <operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>instance</name><operator>.</operator><name>execute</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line">// "regular" SSTableHeaderFix code, also used by StandaloneScrubber.</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>SSTableHeaderFix</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>warn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>dryRun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name><name>Function</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name>TableMetadata</name></argument>&gt;</argument_list></name></type> <name>schemaCallback</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>&gt;</argument_list></name></type> <name>descriptors</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>updates</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>hasErrors</name></decl>;</decl_stmt>

    <constructor><name>SSTableHeaderFix</name><parameter_list>(<parameter><decl><type><name>Builder</name></type> <name>builder</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>builder</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>warn</name></name> <operator>=</operator> <name><name>builder</name><operator>.</operator><name>warn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>error</name></name> <operator>=</operator> <name><name>builder</name><operator>.</operator><name>error</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dryRun</name></name> <operator>=</operator> <name><name>builder</name><operator>.</operator><name>dryRun</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>schemaCallback</name></name> <operator>=</operator> <call><name><name>builder</name><operator>.</operator><name>schemaCallback</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>descriptors</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name><name>builder</name><operator>.</operator><name>descriptors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="string">"info is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>warn</name></name></expr></argument>, <argument><expr><literal type="string">"warn is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>error</name></name></expr></argument>, <argument><expr><literal type="string">"error is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>schemaCallback</name></name></expr></argument>, <argument><expr><literal type="string">"schemaCallback is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Builder</name></type> <name>builder</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>Builder</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Builder to configure and construct an instance of {@link SSTableHeaderFix}.
     * Default settings:
     * &lt;ul&gt;
     *     &lt;li&gt;log via the slf4j logger of {@link SSTableHeaderFix}&lt;/li&gt;
     *     &lt;li&gt;no dry-run (i.e. validate and fix, if no serious errors are detected)&lt;/li&gt;
     *     &lt;li&gt;no schema callback&lt;/li&gt;
     * &lt;/ul&gt;
     * If neither {@link #withDescriptor(Descriptor)} nor {@link #withPath(Path)} are used,
     * all "live" sstables in all data directories will be scanned.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Builder</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Path</name></argument>&gt;</argument_list></name></type> <name>paths</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>&gt;</argument_list></name></type> <name>descriptors</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>info</name> <init>= <expr><lambda><parameter_list>(<parameter><decl><name>ln</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>warn</name> <init>= <expr><lambda><parameter_list>(<parameter><decl><name>ln</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>logger</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>error</name> <init>= <expr><lambda><parameter_list>(<parameter><decl><name>ln</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>logger</name><operator>.</operator><name>error</name></name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>dryRun</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Supplier</name><argument_list type="generic">&lt;<argument><name><name>Function</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name>TableMetadata</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>schemaCallback</name> <init>= <expr><lambda><parameter_list>()</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><literal type="null">null</literal></expr></block_content></block></lambda></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Builder</name><parameter_list>()</parameter_list>
        <block>{<block_content/>}</block></constructor>

        <comment type="block" format="javadoc">/**
         * Only validate and prepare fix, but do not write updated (fixed) sstable serialization-headers.
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>dryRun</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name>dryRun</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>info</name><parameter_list>(<parameter><decl><type><name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>output</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>output</name></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>warn</name><parameter_list>(<parameter><decl><type><name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>warn</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>warn</name></name> <operator>=</operator> <name>warn</name></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>error</name><parameter_list>(<parameter><decl><type><name><name>Consumer</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>error</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>error</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Manually provide an individual sstable or directory containing sstables.
         *
         * Implementation note: procesing "live" sstables in their data directories as well as sstables
         * in snapshots and backups in the data directories works.
         *
         * But processing sstables that reside somewhere else (i.e. verifying sstables before import)
         * requires the use of {@link #withDescriptor(Descriptor)}.
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>withPath</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>paths</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>withDescriptor</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>descriptors</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block" format="javadoc">/**
         * Schema callback to retrieve the schema of a table. Production code always delegates to the
         * live schema ({@code Schema.instance}). Unit tests use this method to feed a custom schema.
         */</comment>
        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>schemaCallback</name><parameter_list>(<parameter><decl><type><name><name>Supplier</name><argument_list type="generic">&lt;<argument><name><name>Function</name><argument_list type="generic">&lt;<argument><name>Descriptor</name></argument>, <argument><name>TableMetadata</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>schemaCallback</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>schemaCallback</name></name> <operator>=</operator> <name>schemaCallback</name></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>SSTableHeaderFix</name></type> <name>build</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>paths</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>descriptors</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>new</operator> <call><name>AutomaticHeaderFix</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <return>return <expr><operator>new</operator> <call><name>ManualHeaderFix</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>

        <function><type><specifier>public</specifier> <name>Builder</name></type> <name>logToList</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>output</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><call><name>info</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ln</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>output</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"INFO  "</literal> <operator>+</operator> <name>ln</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                   <operator>.</operator><call><name>warn</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ln</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>output</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"WARN  "</literal> <operator>+</operator> <name>ln</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                   <operator>.</operator><call><name>error</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>ln</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>output</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"ERROR "</literal> <operator>+</operator> <name>ln</name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></function>
    }</block></class>

    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>prepare</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Processing {} sstables:{}"</literal></expr></argument>,
                     <argument><expr><call><name><name>descriptors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr><call><name><name>descriptors</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>Descriptor</name><operator>::</operator><name>toString</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>joining</name></name><argument_list>(<argument><expr><literal type="string">"\n    "</literal></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>descriptors</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><name>this</name><operator>::</operator><name>processSSTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>updates</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>hasErrors</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><literal type="string">"Stopping due to previous errors. Either fix the errors or specify the ignore-errors option."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dryRun</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><literal type="string">"Not fixing identified and fixable serialization-header issues."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><literal type="string">"Writing new metadata files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>updates</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>descAndMeta</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name>writeNewMetadata</name><argument_list>(<argument><expr><name><name>descAndMeta</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>descAndMeta</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><literal type="string">"Finished writing new metadata files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Whether {@link #execute()} encountered an error.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasError</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>hasErrors</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Whether {@link #execute()} found mismatches.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasChanges</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>updates</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function_decl><type><specifier>abstract</specifier> <name>void</name></type> <name>prepare</name><parameter_list>()</parameter_list>;</function_decl>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>error</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>Object</name><modifier>...</modifier></type> <name>args</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>hasErrors</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>error</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>processFileOrDirectory</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>Stream</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call>
              <operator>.</operator><call><name>flatMap</name><argument_list>(<argument><expr><name>SSTableHeaderFix</name><operator>::</operator><name>maybeExpandDirectory</name></expr></argument>)</argument_list></call>
              <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>p</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>Descriptor</name><operator>.</operator><name>fromFilenameWithComponent</name></name><argument_list>(<argument><expr><call><name><name>p</name><operator>.</operator><name>toFile</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name><name>right</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>Component</name><operator>.</operator><name>Type</name><operator>.</operator><name>DATA</name></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
              <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>Path</name><operator>::</operator><name>toString</name></expr></argument>)</argument_list></call>
              <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>Descriptor</name><operator>::</operator><name>fromFilename</name></expr></argument>)</argument_list></call>
              <operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><name>descriptors</name><operator>::</operator><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>Stream</name><argument_list type="generic">&lt;<argument><name>Path</name></argument>&gt;</argument_list></name></type> <name>maybeExpandDirectory</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>Files</name><operator>.</operator><name>isRegularFile</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>Stream</name><operator>.</operator><name>of</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><call><name><name>LifecycleTransaction</name><operator>.</operator><name>getFiles</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><lambda><parameter_list>(<parameter><decl><name>file</name></decl></parameter>, <parameter><decl><name>fileType</name></decl></parameter>)</parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name>fileType</name> <operator>==</operator> <name><name>Directories</name><operator>.</operator><name>FileType</name><operator>.</operator><name>FINAL</name></name></expr></block_content></block></lambda></expr></argument>, <argument><expr><name><name>Directories</name><operator>.</operator><name>OnTxnErr</name><operator>.</operator><name>IGNORE</name></name></expr></argument>)</argument_list></call>
                                   <operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call>
                                   <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>File</name><operator>::</operator><name>toPath</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>processSSTable</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>desc</name><operator>.</operator><name>cfname</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// secondary index not checked</comment>

            <comment type="line">// partition-key is the indexed column type</comment>
            <comment type="line">// clustering-key is org.apache.cassandra.db.marshal.PartitionerDefinedOrder</comment>
            <comment type="line">// no static columns, no regular columns</comment>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>TableMetadata</name></type> <name>tableMetadata</name> <init>= <expr><call><name><name>schemaCallback</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>tableMetadata</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Table %s.%s not found in the schema - NOT checking sstable %s"</literal></expr></argument>, <argument><expr><name><name>desc</name><operator>.</operator><name>ksname</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>.</operator><name>cfname</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name> <init>= <expr><call><name><name>SSTable</name><operator>.</operator><name>discoverComponentsFor</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>components</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>noneMatch</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>c</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name><name>c</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>Component</name><operator>.</operator><name>Type</name><operator>.</operator><name>STATS</name></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{
            <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s has no -Statistics.db component."</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></function>

        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></type> <name>metadata</name> <init>= <expr><call><name>readSSTableMetadata</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>metadata</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>MetadataComponent</name></type> <name>component</name> <init>= <expr><call><name><name>metadata</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>MetadataType</name><operator>.</operator><name>HEADER</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>component</name> <operator>instanceof</operator> <name><name>SerializationHeader</name><operator>.</operator><name>Component</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s: Expected %s, but got %s from metadata.get(MetadataType.HEADER)"</literal></expr></argument>,
                  <argument><expr><name>desc</name></expr></argument>,
                  <argument><expr><call><name><name>SerializationHeader</name><operator>.</operator><name>Component</name><operator>.</operator><name><name>class</name><operator>.</operator><name>getName</name></name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>component</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>component</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">"'null'"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>SerializationHeader</name><operator>.</operator><name>Component</name></name></type> <name>header</name> <init>= <expr><operator>(</operator><name><name>SerializationHeader</name><operator>.</operator><name>Component</name></name><operator>)</operator> <name>component</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// check partition key type</comment>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>keyType</name> <init>= <expr><call><name>validatePartitionKey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tableMetadata</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// check clustering columns</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>clusteringTypes</name> <init>= <expr><call><name>validateClusteringColumns</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tableMetadata</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// check static and regular columns</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>, <argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>staticColumns</name> <init>= <expr><call><name>validateColumns</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tableMetadata</name></expr></argument>, <argument><expr><call><name><name>header</name><operator>.</operator><name>getStaticColumns</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name><operator>.</operator><name>STATIC</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>, <argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>regularColumns</name> <init>= <expr><call><name>validateColumns</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tableMetadata</name></expr></argument>, <argument><expr><call><name><name>header</name><operator>.</operator><name>getRegularColumns</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name><operator>.</operator><name>REGULAR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>SerializationHeader</name><operator>.</operator><name>Component</name></name></type> <name>newHeader</name> <init>= <expr><call><name><name>SerializationHeader</name><operator>.</operator><name>Component</name><operator>.</operator><name>buildComponentForTools</name></name><argument_list>(<argument><expr><name>keyType</name></expr></argument>,
                                                                                                       <argument><expr><name>clusteringTypes</name></expr></argument>,
                                                                                                       <argument><expr><name>staticColumns</name></expr></argument>,
                                                                                                       <argument><expr><name>regularColumns</name></expr></argument>,
                                                                                                       <argument><expr><call><name><name>header</name><operator>.</operator><name>getEncodingStats</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// SerializationHeader.Component has no equals(), but a "good" toString()</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>header</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>newHeader</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></type> <name>newMetadata</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <constructor_decl><name><name>newMetadata</name><operator>.</operator><name>put</name></name><parameter_list>(<parameter><decl><type><name><name>MetadataType</name><operator>.</operator><name>HEADER</name></name></type></decl></parameter>, <parameter><decl><type><name>newHeader</name></type></decl></parameter>)</parameter_list>;</constructor_decl>

        <expr_stmt><expr><call><name><name>updates</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>Pair</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>newMetadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></class>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>validatePartitionKey</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>TableMetadata</name></type> <name>tableMetadata</name></decl></parameter>, <parameter><decl><type><name><name>SerializationHeader</name><operator>.</operator><name>Component</name></name></type> <name>header</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>keyMismatch</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>headerKeyType</name> <init>= <expr><call><name><name>header</name><operator>.</operator><name>getKeyType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>schemaKeyType</name> <init>= <expr><name><name>tableMetadata</name><operator>.</operator><name>partitionKeyType</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>headerKeyComposite</name> <init>= <expr><name>headerKeyType</name> <operator>instanceof</operator> <name>CompositeType</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>schemaKeyComposite</name> <init>= <expr><name>schemaKeyType</name> <operator>instanceof</operator> <name>CompositeType</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>headerKeyComposite</name> <operator>!=</operator> <name>schemaKeyComposite</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// one is a composite partition key, the other is not - very suspicious</comment>
            <expr_stmt><expr><name>keyMismatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>headerKeyComposite</name></expr>)</condition> <comment type="line">// &amp;&amp; schemaKeyComposite</comment>
        <block>{<block_content>
            <comment type="line">// Note, the logic is similar as just calling 'fixType()' using the composite partition key,</comment>
            <comment type="line">// but the log messages should use the composite partition key column names.</comment>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>headerKeyComponents</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CompositeType</name><operator>)</operator> <name>headerKeyType</name><operator>)</operator><operator>.</operator><name>types</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>schemaKeyComponents</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CompositeType</name><operator>)</operator> <name>schemaKeyType</name><operator>)</operator><operator>.</operator><name>types</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>headerKeyComponents</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>schemaKeyComponents</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// different number of components in composite partition keys - very suspicious</comment>
                <expr_stmt><expr><name>keyMismatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <comment type="line">// Just use the original type from the header. Since the number of partition key components</comment>
                <comment type="line">// don't match, there's nothing to meaningfully validate against.</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// fix components in composite partition key, if necessary</comment>
                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>newComponents</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>schemaKeyComponents</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>schemaKeyComponents</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>headerKeyComponent</name> <init>= <expr><call><name><name>headerKeyComponents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>schemaKeyComponent</name> <init>= <expr><call><name><name>schemaKeyComponents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixedType</name> <init>= <expr><call><name>fixType</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
                                                        <argument><expr><call><name><name>tableMetadata</name><operator>.</operator><name>partitionKeyColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>name</name><operator>.</operator><name>bytes</name></name></expr></argument>,
                                                        <argument><expr><name>headerKeyComponent</name></expr></argument>,
                                                        <argument><expr><name>schemaKeyComponent</name></expr></argument>,
                                                        <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fixedType</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>keyMismatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>headerKeyComponent</name> <operator>=</operator> <name>fixedType</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <expr_stmt><expr><call><name><name>newComponents</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>fixType</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
                                              <argument><expr><call><name><name>tableMetadata</name><operator>.</operator><name>partitionKeyColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>name</name><operator>.</operator><name>bytes</name></name></expr></argument>,
                                              <argument><expr><name>headerKeyComponent</name></expr></argument>,
                                              <argument><expr><name>schemaKeyComponent</name></expr></argument>,
                                              <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>headerKeyType</name> <operator>=</operator> <call><name><name>CompositeType</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><name>newComponents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// fix non-composite partition key, if necessary</comment>
            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixedType</name> <init>= <expr><call><name>fixType</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name><name>tableMetadata</name><operator>.</operator><name>partitionKeyColumns</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><name><name>name</name><operator>.</operator><name>bytes</name></name></expr></argument>, <argument><expr><name>headerKeyType</name></expr></argument>, <argument><expr><name>schemaKeyType</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fixedType</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <comment type="line">// non-composite partition key doesn't match and cannot be fixed</comment>
                <expr_stmt><expr><name>keyMismatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>headerKeyType</name> <operator>=</operator> <name>fixedType</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyMismatch</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s: Mismatch in partition key type between sstable serialization-header and schema (%s vs %s)"</literal></expr></argument>,
                  <argument><expr><name>desc</name></expr></argument>,
                  <argument><expr><call><name><name>headerKeyType</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>schemaKeyType</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>headerKeyType</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>validateClusteringColumns</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>TableMetadata</name></type> <name>tableMetadata</name></decl></parameter>, <parameter><decl><type><name><name>SerializationHeader</name><operator>.</operator><name>Component</name></name></type> <name>header</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>headerClusteringTypes</name> <init>= <expr><call><name><name>header</name><operator>.</operator><name>getClusteringTypes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>clusteringTypes</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>clusteringMismatch</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ColumnMetadata</name></argument>&gt;</argument_list></name></type> <name>schemaClustering</name> <init>= <expr><call><name><name>tableMetadata</name><operator>.</operator><name>clusteringColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>schemaClustering</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>headerClusteringTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>clusteringMismatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <comment type="line">// Just use the original types. Since the number of clustering columns don't match, there's nothing to</comment>
            <comment type="line">// meaningfully validate against.</comment>
            <expr_stmt><expr><call><name><name>clusteringTypes</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>headerClusteringTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>headerClusteringTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>headerType</name> <init>= <expr><call><name><name>headerClusteringTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ColumnMetadata</name></type> <name>column</name> <init>= <expr><call><name><name>schemaClustering</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>schemaType</name> <init>= <expr><name><name>column</name><operator>.</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixedType</name> <init>= <expr><call><name>fixType</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>column</name><operator>.</operator><name>name</name><operator>.</operator><name>bytes</name></name></expr></argument>, <argument><expr><name>headerType</name></expr></argument>, <argument><expr><name>schemaType</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>fixedType</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>clusteringMismatch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>headerType</name> <operator>=</operator> <name>fixedType</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name><name>clusteringTypes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>headerType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>clusteringMismatch</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s: mismatch in clustering columns between sstable serialization-header and schema (%s vs %s)"</literal></expr></argument>,
                  <argument><expr><name>desc</name></expr></argument>,
                  <argument><expr><call><name><name>headerClusteringTypes</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>AbstractType</name><operator>::</operator><name>asCQL3Type</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><name>CQL3Type</name><operator>::</operator><name>toString</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>joining</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>schemaClustering</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>cd</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>cd</name><operator>.</operator><name>type</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call><operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>Collectors</name><operator>.</operator><name>joining</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>clusteringTypes</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>, <argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>validateColumns</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>TableMetadata</name></type> <name>tableMetadata</name></decl></parameter>, <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>, <argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>columns</name></decl></parameter>, <parameter><decl><type><name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name></name></type> <name>kind</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>, <argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>target</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>ByteBuffer</name></argument>, <argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>nameAndType</name> <range>: <expr><call><name><name>columns</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>name</name> <init>= <expr><call><name><name>nameAndType</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name> <init>= <expr><call><name><name>nameAndType</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixedType</name> <init>= <expr><call><name>validateColumn</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tableMetadata</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fixedType</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s: contains column '%s' of type '%s', which could not be validated"</literal></expr></argument>,
                      <argument><expr><name>desc</name></expr></argument>,
                      <argument><expr><name>type</name></expr></argument>,
                      <argument><expr><call><name>logColumnName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// don't use a "null" type instance</comment>
                <expr_stmt><expr><name>fixedType</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name><name>target</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fixedType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>target</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>validateColumn</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>TableMetadata</name></type> <name>tableMetadata</name></decl></parameter>, <parameter><decl><type><name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name></name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnMetadata</name></type> <name>cd</name> <init>= <expr><call><name><name>tableMetadata</name><operator>.</operator><name>getColumn</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cd</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// In case the column was dropped, there is not much that we can actually validate.</comment>
            <comment type="line">// The column could have been recreated using the same or a different kind or the same or</comment>
            <comment type="line">// a different type. Lottery...</comment>

            <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name><name>tableMetadata</name><operator>.</operator><name>getDroppedColumn</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>kind</name> <operator>==</operator> <name><name>ColumnMetadata</name><operator>.</operator><name>Kind</name><operator>.</operator><name>STATIC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cd</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>IndexMetadata</name></type> <name>indexMetadata</name> <range>: <expr><name><name>tableMetadata</name><operator>.</operator><name>indexes</name></name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name></type> <name>target</name> <init>= <expr><call><name><name>indexMetadata</name><operator>.</operator><name>options</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>IndexTarget</name><operator>.</operator><name>TARGET_OPTION_NAME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>ByteBufferUtil</name><operator>.</operator><name>bytes</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>warn</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"sstable %s: contains column '%s', which is not a column in the table '%s.%s', but a target for that table's index '%s'"</literal></expr></argument>,
                                <argument><expr><name>desc</name></expr></argument>,
                                <argument><expr><call><name>logColumnName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>tableMetadata</name><operator>.</operator><name>keyspace</name></name></expr></argument>,
                                <argument><expr><name><name>tableMetadata</name><operator>.</operator><name>name</name></name></expr></argument>,
                                <argument><expr><name><name>indexMetadata</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>type</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><call><name><name>warn</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"sstable %s: contains column '%s', which is not present in the schema"</literal></expr></argument>,
                                          <argument><expr><name>desc</name></expr></argument>,
                                          <argument><expr><call><name>logColumnName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// This is a best-effort approach to handle the case of a UDT column created *AND* dropped in</comment>
                <comment type="line">// C* 3.0.</comment>
                <if_stmt><if>if <condition>(<expr><name>type</name> <operator>instanceof</operator> <name>UserType</name> <operator>&amp;&amp;</operator> <name><name>cd</name><operator>.</operator><name>type</name></name> <operator>instanceof</operator> <name>TupleType</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// At this point, we know that the type belongs to a dropped column, recorded with the</comment>
                    <comment type="line">// dropped column type "TupleType" and using "UserType" in the sstable. So it is very</comment>
                    <comment type="line">// likely, that this belongs to a dropped UDT. Fix that information to tuple-type.</comment>
                    <return>return <expr><call><name>fixType</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>cd</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <return>return <expr><name>type</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// At this point, the column name is known to be a "non-dropped" column in the table.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>.</operator><name>kind</name></name> <operator>!=</operator> <name>kind</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s: contains column '%s' as a %s column, but is of kind %s in the schema"</literal></expr></argument>,
                  <argument><expr><name>desc</name></expr></argument>,
                  <argument><expr><call><name>logColumnName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>kind</name><operator>.</operator><name>name</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toLowerCase</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>cd</name><operator>.</operator><name>kind</name><operator>.</operator><name>name</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toLowerCase</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>fixType</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>cd</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><name>type</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixType</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInHeader</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixedType</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>typeInHeader</name></expr></argument>, <argument><expr><name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fixedType</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>fixedType</name> <operator>!=</operator> <name>typeInHeader</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"sstable %s: Column '%s' needs to be updated from type '%s' to '%s'"</literal></expr></argument>,
                                          <argument><expr><name>desc</name></expr></argument>,
                                          <argument><expr><call><name>logColumnName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name><name>typeInHeader</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call></expr></argument>,
                                          <argument><expr><call><name><name>fixedType</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>fixedType</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"sstable %s: contains column '%s' as type '%s', but schema mentions '%s'"</literal></expr></argument>,
              <argument><expr><name>desc</name></expr></argument>,
              <argument><expr><call><name>logColumnName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><call><name><name>typeInHeader</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call></expr></argument>,
              <argument><expr><call><name><name>typeInSchema</name><operator>.</operator><name>asCQL3Type</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>typeInHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInner</name><parameter_list>(<parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInHeader</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>typeEquals</name><argument_list>(<argument><expr><name>typeInHeader</name></expr></argument>, <argument><expr><name>typeInSchema</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>typeInHeader</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>typeInHeader</name> <operator>instanceof</operator> <name>CollectionType</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerCollection</name><argument_list>(<argument><expr><name>typeInHeader</name></expr></argument>, <argument><expr><name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>typeInHeader</name> <operator>instanceof</operator> <name>AbstractCompositeType</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerAbstractComposite</name><argument_list>(<argument><expr><name>typeInHeader</name></expr></argument>, <argument><expr><name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>typeInHeader</name> <operator>instanceof</operator> <name>TupleType</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerAbstractTuple</name><argument_list>(<argument><expr><name>typeInHeader</name></expr></argument>, <argument><expr><name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// all types, beside CollectionType + AbstractCompositeType + TupleType, should be ok (no nested types) - just check for compatibility</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>isCompatibleWith</name></name><argument_list>(<argument><expr><name>typeInSchema</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>typeInHeader</name></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerAbstractTuple</name><parameter_list>(<parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInHeader</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// This first 'if' handles the case when a UDT has been dropped, as a dropped UDT is recorded as a tuple</comment>
        <comment type="line">// in dropped_columns. If a UDT is to be replaced with a tuple, then also do that for the inner UDTs.</comment>
        <if_stmt><if>if <condition>(<expr><name>droppedColumnMode</name> <operator>&amp;&amp;</operator> <call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>UserType</name><operator>.</operator><name>class</name></name> <operator>&amp;&amp;</operator> <name>typeInSchema</name> <operator>instanceof</operator> <name>TupleType</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerUserTypeDropped</name><argument_list>(<argument><expr><operator>(</operator><name>UserType</name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name>TupleType</name><operator>)</operator> <name>typeInSchema</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>typeInSchema</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>UserType</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerUserType</name><argument_list>(<argument><expr><operator>(</operator><name>UserType</name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name>UserType</name><operator>)</operator> <name>typeInSchema</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>TupleType</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerTuple</name><argument_list>(<argument><expr><operator>(</operator><name>TupleType</name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name>TupleType</name><operator>)</operator> <name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Unknown tuple type class "</literal> <operator>+</operator> <call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerCollection</name><parameter_list>(<parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInHeader</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>typeInSchema</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ListType</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerList</name><argument_list>(<argument><expr><operator>(</operator><name><name>ListType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name><name>ListType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>SetType</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerSet</name><argument_list>(<argument><expr><operator>(</operator><name><name>SetType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name><name>SetType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>MapType</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerMap</name><argument_list>(<argument><expr><operator>(</operator><name><name>MapType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name><name>MapType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name><operator>)</operator> <name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Unknown collection type class "</literal> <operator>+</operator> <call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerAbstractComposite</name><parameter_list>(<parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInHeader</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>typeInSchema</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>CompositeType</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>fixTypeInnerComposite</name><argument_list>(<argument><expr><operator>(</operator><name>CompositeType</name><operator>)</operator> <name>typeInHeader</name></expr></argument>, <argument><expr><operator>(</operator><name>CompositeType</name><operator>)</operator> <name>typeInSchema</name></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>DynamicCompositeType</name><operator>.</operator><name>class</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Not sure if we should care about UDTs in DynamicCompositeType at all...</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>typeInHeader</name><operator>.</operator><name>isCompatibleWith</name></name><argument_list>(<argument><expr><name>typeInSchema</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

            <return>return <expr><name>typeInHeader</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Unknown composite type class "</literal> <operator>+</operator> <call><name><name>typeInHeader</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerUserType</name><parameter_list>(<parameter><decl><type><name>UserType</name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name>UserType</name></type> <name>cSchema</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>cHeader</name><operator>.</operator><name>keyspace</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>cSchema</name><operator>.</operator><name>keyspace</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>cHeader</name><operator>.</operator><name>name</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>cSchema</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// different UDT - bummer...</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>cSchema</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>cSchema</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// C* 3.0 writes broken SerializationHeader.Component instances - i.e. broken UDT type</comment>
                <comment type="line">// definitions into the sstable -Stats.db file, because 3.0 does not enclose frozen UDTs</comment>
                <comment type="line">// (and all UDTs in 3.0 were frozen) with an '' bracket. Since CASSANDRA-7423 (support</comment>
                <comment type="line">// for non-frozen UDTs, committed to C* 3.6), that frozen-bracket is quite important.</comment>
                <comment type="line">// Non-frozen (= multi-cell) UDTs are serialized in a fundamentally different way than</comment>
                <comment type="line">// frozen UDTs in sstables - most importantly, the order of serialized columns depends on</comment>
                <comment type="line">// the type: fixed-width types first, then variable length types (like frozen types),</comment>
                <comment type="line">// multi-cell types last. If C* &gt;= 3.6 reads an sstable with a UDT that's written by</comment>
                <comment type="line">// C* &lt; 3.6, a variety of CorruptSSTableExceptions get logged and clients will encounter</comment>
                <comment type="line">// read errors.</comment>
                <comment type="line">// At this point, we know that the type belongs to a "live" (non-dropped) column, so it</comment>
                <comment type="line">// is safe to correct the information from the header.</comment>
                <return>return <expr><name>cSchema</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// In all other cases, there's not much we can do.</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerUserTypeDropped</name><parameter_list>(<parameter><decl><type><name>UserType</name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name>TupleType</name></type> <name>cSchema</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// Do not mess around with the UserType in the serialization header, if the column has been dropped.</comment>
        <comment type="line">// Only fix the multi-cell status when the header contains it as a multicell (non-frozen) UserType,</comment>
        <comment type="line">// but the schema says "frozen".</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>cSchema</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><operator>new</operator> <call><name>UserType</name><argument_list>(<argument><expr><name><name>cHeader</name><operator>.</operator><name>keyspace</name></name></expr></argument>, <argument><expr><name><name>cHeader</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name><name>cHeader</name><operator>.</operator><name>fieldNames</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cHeader</name><operator>.</operator><name>fieldTypes</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerTuple</name><parameter_list>(<parameter><decl><type><name>TupleType</name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name>TupleType</name></type> <name>cSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>cHeader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>cSchema</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// different number of components - bummer...</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>cHeaderFixed</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>cHeader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>anyChanged</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>cHeader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderComp</name> <init>= <expr><call><name><name>cHeader</name><operator>.</operator><name>type</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderCompFixed</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>cHeaderComp</name></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>type</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cHeaderCompFixed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <comment type="line">// incompatible, bummer...</comment>
                <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>cHeaderFixed</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>cHeaderCompFixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>anyChanged</name> <operator>|=</operator> <name>cHeaderComp</name> <operator>!=</operator> <name>cHeaderCompFixed</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>anyChanged</name> <operator>||</operator> <call><name><name>cSchema</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// TODO this should create a non-frozen tuple type for the sake of handling a dropped, non-frozen UDT</comment>
            <return>return <expr><operator>new</operator> <call><name>TupleType</name><argument_list>(<argument><expr><name>cHeaderFixed</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerComposite</name><parameter_list>(<parameter><decl><type><name>CompositeType</name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name>CompositeType</name></type> <name>cSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>cHeader</name><operator>.</operator><name>types</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>cSchema</name><operator>.</operator><name>types</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// different number of components - bummer...</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>cHeaderFixed</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>cHeader</name><operator>.</operator><name>types</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>anyChanged</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>cHeader</name><operator>.</operator><name>types</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderComp</name> <init>= <expr><call><name><name>cHeader</name><operator>.</operator><name>types</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderCompFixed</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>cHeaderComp</name></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>types</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cHeaderCompFixed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <comment type="line">// incompatible, bummer...</comment>
                <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>cHeaderFixed</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>cHeaderCompFixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>anyChanged</name> <operator>|=</operator> <name>cHeaderComp</name> <operator>!=</operator> <name>cHeaderCompFixed</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>anyChanged</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>CompositeType</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><name>cHeaderFixed</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerList</name><parameter_list>(<parameter><decl><type><name><name>ListType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name><name>ListType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderElem</name> <init>= <expr><call><name><name>cHeader</name><operator>.</operator><name>getElementsType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderElemFixed</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>cHeaderElem</name></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>getElementsType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cHeaderElemFixed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// bummer...</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cHeaderElem</name> <operator>!=</operator> <name>cHeaderElemFixed</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// element type changed</comment>
            <return>return <expr><call><name><name>ListType</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><name>cHeaderElemFixed</name></expr></argument>, <argument><expr><call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerSet</name><parameter_list>(<parameter><decl><type><name><name>SetType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name><name>SetType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderElem</name> <init>= <expr><call><name><name>cHeader</name><operator>.</operator><name>getElementsType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderElemFixed</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>cHeaderElem</name></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>getElementsType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cHeaderElemFixed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// bummer...</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cHeaderElem</name> <operator>!=</operator> <name>cHeaderElemFixed</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// element type changed</comment>
            <return>return <expr><call><name><name>SetType</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><name>cHeaderElemFixed</name></expr></argument>, <argument><expr><call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>fixTypeInnerMap</name><parameter_list>(<parameter><decl><type><name><name>MapType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeader</name></decl></parameter>, <parameter><decl><type><name><name>MapType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cSchema</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>droppedColumnMode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderKey</name> <init>= <expr><call><name><name>cHeader</name><operator>.</operator><name>getKeysType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderVal</name> <init>= <expr><call><name><name>cHeader</name><operator>.</operator><name>getValuesType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderKeyFixed</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>cHeaderKey</name></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>getKeysType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>cHeaderValFixed</name> <init>= <expr><call><name>fixTypeInner</name><argument_list>(<argument><expr><name>cHeaderVal</name></expr></argument>, <argument><expr><call><name><name>cSchema</name><operator>.</operator><name>getValuesType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>droppedColumnMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cHeaderKeyFixed</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>cHeaderValFixed</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// bummer...</comment>
            <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cHeaderKey</name> <operator>!=</operator> <name>cHeaderKeyFixed</name> <operator>||</operator> <name>cHeaderVal</name> <operator>!=</operator> <name>cHeaderValFixed</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// element type changed</comment>
            <return>return <expr><call><name><name>MapType</name><operator>.</operator><name>getInstance</name></name><argument_list>(<argument><expr><name>cHeaderKeyFixed</name></expr></argument>, <argument><expr><name>cHeaderValFixed</name></expr></argument>, <argument><expr><call><name><name>cHeader</name><operator>.</operator><name>isMultiCell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><name>cHeader</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>typeEquals</name><parameter_list>(<parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInHeader</name></decl></parameter>, <parameter><decl><type><name><name>AbstractType</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeInSchema</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// Quite annoying, but the implementations of equals() on some implementation of AbstractType seems to be</comment>
        <comment type="line">// wrong, but toString() seems to work in such cases.</comment>
        <return>return <expr><call><name><name>typeInHeader</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>typeInSchema</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>typeInHeader</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><call><name><name>typeInSchema</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>logColumnName</name><parameter_list>(<parameter><decl><type><name>ByteBuffer</name></type> <name>columnName</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <try>try
        <block>{<block_content>
            <return>return <expr><call><name><name>ByteBufferUtil</name><operator>.</operator><name>string</name></name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>CharacterCodingException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <return>return <expr><literal type="string">"?? "</literal> <operator>+</operator> <name>e</name></expr>;</return>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></type> <name>readSSTableMetadata</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></type> <name>metadata</name></decl>;</decl_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name><name>desc</name><operator>.</operator><name>getMetadataSerializer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>deserialize</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name><name>EnumSet</name><operator>.</operator><name>allOf</name></name><argument_list>(<argument><expr><name><name>MetadataType</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Failed to deserialize metadata for sstable %s: %s"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></catch></try>
        <return>return <expr><name>metadata</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeNewMetadata</name><parameter_list>(<parameter><decl><type><name>Descriptor</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>MetadataType</name></argument>, <argument><name>MetadataComponent</name></argument>&gt;</argument_list></name></type> <name>newMetadata</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>file</name> <init>= <expr><call><name><name>desc</name><operator>.</operator><name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name><operator>.</operator><name>STATS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"  Writing new metadata file %s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>desc</name><operator>.</operator><name>getMetadataSerializer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>rewriteSSTableMetadata</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>newMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Failed to write metadata component for %s: %s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Fix individually provided sstables or directories containing sstables.
     */</comment>
    <class><specifier>static</specifier> class <name>ManualHeaderFix</name> <super_list><extends>extends <super><name>SSTableHeaderFix</name></super></extends></super_list>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Path</name></argument>&gt;</argument_list></name></type> <name>paths</name></decl>;</decl_stmt>

        <constructor><name>ManualHeaderFix</name><parameter_list>(<parameter><decl><type><name>Builder</name></type> <name>builder</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>paths</name></name> <operator>=</operator> <name><name>builder</name><operator>.</operator><name>paths</name></name></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>prepare</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>paths</name><operator>.</operator><name>forEach</name></name><argument_list>(<argument><expr><name>this</name><operator>::</operator><name>processFileOrDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Fix all sstables in the configured data-directories.
     */</comment>
    <class><specifier>static</specifier> class <name>AutomaticHeaderFix</name> <super_list><extends>extends <super><name>SSTableHeaderFix</name></super></extends></super_list>
    <block>{
        <constructor><name>AutomaticHeaderFix</name><parameter_list>(<parameter><decl><type><name>Builder</name></type> <name>builder</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>prepare</name><parameter_list>()</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><literal type="string">"Scanning all data directories..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name><name>Directories</name><operator>.</operator><name>DataDirectory</name></name></type> <name>dataDirectory</name> <range>: <expr><name><name>Directories</name><operator>.</operator><name>dataDirectories</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>scanDataDirectory</name><argument_list>(<argument><expr><name>dataDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><literal type="string">"Finished scanning all data directories..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>scanDataDirectory</name><parameter_list>(<parameter><decl><type><name><name>Directories</name><operator>.</operator><name>DataDirectory</name></name></type> <name>dataDirectory</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Scanning data directory %s"</literal></expr></argument>, <argument><expr><name><name>dataDirectory</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>File</name><index>[]</index></name></type> <name>ksDirs</name> <init>= <expr><call><name><name>dataDirectory</name><operator>.</operator><name>location</name><operator>.</operator><name>listFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ksDirs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>File</name></type> <name>ksDir</name> <range>: <expr><name>ksDirs</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ksDir</name><operator>.</operator><name>isDirectory</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>ksDir</name><operator>.</operator><name>canRead</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><name>String</name></type> <name>name</name> <init>= <expr><call><name><name>ksDir</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// silently ignore all system keyspaces</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>SchemaConstants</name><operator>.</operator><name>isLocalSystemKeyspace</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>SchemaConstants</name><operator>.</operator><name>isReplicatedSystemKeyspace</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><name><name>File</name><index>[]</index></name></type> <name>tabDirs</name> <init>= <expr><call><name><name>ksDir</name><operator>.</operator><name>listFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>tabDirs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <for>for <control>(<init><decl><type><name>File</name></type> <name>tabDir</name> <range>: <expr><name>tabDirs</name></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>tabDir</name><operator>.</operator><name>isDirectory</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>tabDir</name><operator>.</operator><name>canRead</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>processFileOrDirectory</name><argument_list>(<argument><expr><call><name><name>tabDir</name><operator>.</operator><name>toPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block></function>
    }</block></class>
}
</unit>
