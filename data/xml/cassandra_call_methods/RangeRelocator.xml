<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/Users/wang/Documents/project/configuration_code_understanding/code3/data/system/cassandra/src/java/org/apache/cassandra/service/RangeRelocator.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>service</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collection</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>Future</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>annotations</name><operator>.</operator><name>VisibleForTesting</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Multimap</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>config</name><operator>.</operator><name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>db</name><operator>.</operator><name>Keyspace</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Range</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>RangeStreamer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>dht</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>gms</name><operator>.</operator><name>FailureDetector</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>AbstractReplicationStrategy</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>EndpointsByReplica</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>EndpointsForRange</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>InetAddressAndPort</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>RangesAtEndpoint</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>RangesByEndpoint</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>Replica</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>locator</name><operator>.</operator><name>TokenMetadata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>StreamOperation</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>StreamPlan</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>streaming</name><operator>.</operator><name>StreamState</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>cassandra</name><operator>.</operator><name>utils</name><operator>.</operator><name>Pair</name></name>;</import>

<class><annotation>@<name>VisibleForTesting</name></annotation>
<specifier>public</specifier> class <name>RangeRelocator</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><name><name>StorageService</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>StreamPlan</name></type> <name>streamPlan</name> <init>= <expr><operator>new</operator> <call><name>StreamPlan</name><argument_list>(<argument><expr><name><name>StreamOperation</name><operator>.</operator><name>RELOCATION</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>InetAddressAndPort</name></type> <name>localAddress</name> <init>= <expr><call><name><name>FBUtilities</name><operator>.</operator><name>getBroadcastAddressAndPort</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>TokenMetadata</name></type> <name>tokenMetaCloneAllSettled</name></decl>;</decl_stmt>
    <comment type="line">// clone to avoid concurrent modification in calculateNaturalReplicas</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>TokenMetadata</name></type> <name>tokenMetaClone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>keyspaceNames</name></decl>;</decl_stmt>


    <constructor><name>RangeRelocator</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>keyspaceNames</name></decl></parameter>, <parameter><decl><type><name>TokenMetadata</name></type> <name>tmd</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokens</name></name> <operator>=</operator> <name>tokens</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keyspaceNames</name></name> <operator>=</operator> <name>keyspaceNames</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokenMetaCloneAllSettled</name></name> <operator>=</operator> <call><name><name>tmd</name><operator>.</operator><name>cloneAfterAllSettled</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// clone to avoid concurrent modification in calculateNaturalReplicas</comment>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokenMetaClone</name></name> <operator>=</operator> <call><name><name>tmd</name><operator>.</operator><name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <constructor><annotation>@<name>VisibleForTesting</name></annotation>
    <specifier>public</specifier> <name>RangeRelocator</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokens</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keyspaceNames</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokenMetaCloneAllSettled</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tokenMetaClone</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/**
     * Wrapper that supplies accessors to the real implementations of the various dependencies for this method
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name><name>RangeStreamer</name><operator>.</operator><name>FetchReplica</name></name></argument>&gt;</argument_list></name></type> <name>calculateRangesToFetchWithPreferredEndpoints</name><parameter_list>(<parameter><decl><type><name>RangesAtEndpoint</name></type> <name>fetchRanges</name></decl></parameter>,
                                                                                                                         <parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name></decl></parameter>,
                                                                                                                         <parameter><decl><type><name>String</name></type> <name>keyspace</name></decl></parameter>,
                                                                                                                         <parameter><decl><type><name>TokenMetadata</name></type> <name>tmdBefore</name></decl></parameter>,
                                                                                                                         <parameter><decl><type><name>TokenMetadata</name></type> <name>tmdAfter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EndpointsByReplica</name></type> <name>preferredEndpoints</name> <init>=
        <expr><call><name><name>RangeStreamer</name><operator>.</operator><name>calculateRangesToFetchWithPreferredEndpoints</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call><operator>::</operator><name>sortedByProximity</name></expr></argument>,
                                                                   <argument><expr><name>strategy</name></expr></argument>,
                                                                   <argument><expr><name>fetchRanges</name></expr></argument>,
                                                                   <argument><expr><name><name>StorageService</name><operator>.</operator><name>useStrictConsistency</name></name></expr></argument>,
                                                                   <argument><expr><name>tmdBefore</name></expr></argument>,
                                                                   <argument><expr><name>tmdAfter</name></expr></argument>,
                                                                   <argument><expr><name>keyspace</name></expr></argument>,
                                                                   <argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>RangeStreamer</name><operator>.</operator><name>FailureDetectorSourceFilter</name></name><argument_list>(<argument><expr><name><name>FailureDetector</name><operator>.</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                                                 <argument><expr><operator>new</operator> <call><name><name>RangeStreamer</name><operator>.</operator><name>ExcludeLocalNodeFilter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>RangeStreamer</name><operator>.</operator><name>convertPreferredEndpointsToWorkMap</name></name><argument_list>(<argument><expr><name>preferredEndpoints</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * calculating endpoints to stream current ranges to if needed
     * in some situations node will handle current ranges as part of the new ranges
     **/</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>RangesByEndpoint</name></type> <name>calculateRangesToStreamWithEndpoints</name><parameter_list>(<parameter><decl><type><name>RangesAtEndpoint</name></type> <name>streamRanges</name></decl></parameter>,
                                                                        <parameter><decl><type><name>AbstractReplicationStrategy</name></type> <name>strat</name></decl></parameter>,
                                                                        <parameter><decl><type><name>TokenMetadata</name></type> <name>tmdBefore</name></decl></parameter>,
                                                                        <parameter><decl><type><name>TokenMetadata</name></type> <name>tmdAfter</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>RangesByEndpoint</name><operator>.</operator><name>Builder</name></name></type> <name>endpointRanges</name> <init>= <expr><operator>new</operator> <call><name><name>RangesByEndpoint</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Replica</name></type> <name>toStream</name> <range>: <expr><name>streamRanges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">//If the range we are sending is full only send it to the new full replica</comment>
            <comment type="line">//There will also be a new transient replica we need to send the data to, but not</comment>
            <comment type="line">//the repaired data</comment>
            <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>oldEndpoints</name> <init>= <expr><call><name><name>strat</name><operator>.</operator><name>calculateNaturalReplicas</name></name><argument_list>(<argument><expr><call><name><name>toStream</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><name>right</name></expr></argument>, <argument><expr><name>tmdBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EndpointsForRange</name></type> <name>newEndpoints</name> <init>= <expr><call><name><name>strat</name><operator>.</operator><name>calculateNaturalReplicas</name></name><argument_list>(<argument><expr><call><name><name>toStream</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><name>right</name></expr></argument>, <argument><expr><name>tmdAfter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Need to stream {}, current endpoints {}, new endpoints {}"</literal></expr></argument>, <argument><expr><name>toStream</name></expr></argument>, <argument><expr><name>oldEndpoints</name></expr></argument>, <argument><expr><name>newEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>newEndpoint</name> <range>: <expr><name>newEndpoints</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Replica</name></type> <name>oldEndpoint</name> <init>= <expr><call><name><name>oldEndpoints</name><operator>.</operator><name>byEndpoint</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><call><name><name>newEndpoint</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Nothing to do</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>newEndpoint</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>oldEndpoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// Completely new range for this endpoint</comment>
                <if_stmt><if>if <condition>(<expr><name>oldEndpoint</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>toStream</name><operator>.</operator><name>isTransient</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>newEndpoint</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><literal type="string">"Need to stream %s, but only have %s which is transient and not full"</literal></expr></argument>, <argument><expr><name>newEndpoint</name></expr></argument>, <argument><expr><name>toStream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

                    <for>for <control>(<init><decl><type><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>intersection</name> <range>: <expr><call><name><name>newEndpoint</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>intersectionWith</name><argument_list>(<argument><expr><call><name><name>toStream</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>endpointRanges</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>newEndpoint</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>newEndpoint</name><operator>.</operator><name>decorateSubrange</name></name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Range</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subsToStream</name> <init>= <expr><call><name><name>Collections</name><operator>.</operator><name>singleton</name></name><argument_list>(<argument><expr><call><name><name>toStream</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">//First subtract what we already have</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>oldEndpoint</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>newEndpoint</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>oldEndpoint</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>subsToStream</name> <operator>=</operator> <call><name><name>toStream</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>subtract</name><argument_list>(<argument><expr><call><name><name>oldEndpoint</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">//Now we only stream what is still replicated</comment>
                    <expr_stmt><expr><call><name><name>subsToStream</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                                <operator>.</operator><call><name>flatMap</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>range</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>range</name><operator>.</operator><name>intersectionWith</name></name><argument_list>(<argument><expr><call><name><name>newEndpoint</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>stream</name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                                <operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>tokenRange</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>endpointRanges</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>newEndpoint</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>newEndpoint</name><operator>.</operator><name>decorateSubrange</name></name><argument_list>(<argument><expr><name>tokenRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>endpointRanges</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>calculateToFromStreams</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Current tmd: {}, Updated tmd: {}"</literal></expr></argument>, <argument><expr><name>tokenMetaClone</name></expr></argument>, <argument><expr><name>tokenMetaCloneAllSettled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>String</name></type> <name>keyspace</name> <range>: <expr><name>keyspaceNames</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// replication strategy of the current keyspace</comment>
            <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name> <init>= <expr><call><name><name>Keyspace</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Calculating ranges to stream and request for keyspace {}"</literal></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//From what I have seen we only ever call this with a single token from StorageService.move(Token)</comment>
            <for>for <control>(<init><decl><type><name>Token</name></type> <name>newToken</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>currentTokens</name> <init>= <expr><call><name><name>tokenMetaClone</name><operator>.</operator><name>getTokens</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>currentTokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name><name>currentTokens</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>(<argument><expr><literal type="string">"Unexpected current tokens: "</literal> <operator>+</operator> <name>currentTokens</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// calculated parts of the ranges to request/stream from/to nodes in the ring</comment>
                <decl_stmt><decl><type><name><name>Pair</name><argument_list type="generic">&lt;<argument><name>RangesAtEndpoint</name></argument>, <argument><name>RangesAtEndpoint</name></argument>&gt;</argument_list></name></type> <name>streamAndFetchOwnRanges</name></decl>;</decl_stmt>

                <comment type="line">//In the single node token move there is nothing to do and Range subtraction is broken</comment>
                <comment type="line">//so it's easier to just identify this case up front.</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>tokenMetaClone</name><operator>.</operator><name>getTopology</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDatacenterEndpoints</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name><operator>.</operator><name>getEndpointSnitch</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocalDatacenter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// getting collection of the currently used ranges by this keyspace</comment>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>currentReplicas</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getAddressReplicas</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// collection of ranges which this node will serve after move to the new token</comment>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>updatedReplicas</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>getPendingAddressRanges</name></name><argument_list>(<argument><expr><name>tokenMetaClone</name></expr></argument>, <argument><expr><name>newToken</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>streamAndFetchOwnRanges</name> <operator>=</operator> <call><name>calculateStreamAndFetchRanges</name><argument_list>(<argument><expr><name>currentReplicas</name></expr></argument>, <argument><expr><name>updatedReplicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                     <expr_stmt><expr><name>streamAndFetchOwnRanges</name> <operator>=</operator> <call><name><name>Pair</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>empty</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <decl_stmt><decl><type><name>RangesByEndpoint</name></type> <name>rangesToStream</name> <init>= <expr><call><name>calculateRangesToStreamWithEndpoints</name><argument_list>(<argument><expr><name><name>streamAndFetchOwnRanges</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>tokenMetaClone</name></expr></argument>, <argument><expr><name>tokenMetaCloneAllSettled</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"Endpoint ranges to stream to "</literal> <operator>+</operator> <name>rangesToStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// stream ranges</comment>
                <for>for <control>(<init><decl><type><name>InetAddressAndPort</name></type> <name>address</name> <range>: <expr><call><name><name>rangesToStream</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Will stream range {} of keyspace {} to endpoint {}"</literal></expr></argument>, <argument><expr><call><name><name>rangesToStream</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>ranges</name> <init>= <expr><call><name><name>rangesToStream</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>streamPlan</name><operator>.</operator><name>transferRanges</name></name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>InetAddressAndPort</name></argument>, <argument><name><name>RangeStreamer</name><operator>.</operator><name>FetchReplica</name></name></argument>&gt;</argument_list></name></type> <name>rangesToFetch</name> <init>= <expr><call><name>calculateRangesToFetchWithPreferredEndpoints</name><argument_list>(<argument><expr><name><name>streamAndFetchOwnRanges</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>tokenMetaClone</name></expr></argument>, <argument><expr><name>tokenMetaCloneAllSettled</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// stream requests</comment>
                <expr_stmt><expr><call><name><name>rangesToFetch</name><operator>.</operator><name>asMap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>forEach</name><argument_list>(<argument><expr><lambda><parameter_list>(<parameter><decl><name>address</name></decl></parameter>, <parameter><decl><name>sourceAndOurReplicas</name></decl></parameter>)</parameter_list> -&gt; <block>{<block_content>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>full</name> <init>= <expr><call><name><name>sourceAndOurReplicas</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                            <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>pair</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>pair</name><operator>.</operator><name>remote</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                            <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>pair</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name><name>pair</name><operator>.</operator><name>local</name></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                            <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>collector</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>trans</name> <init>= <expr><call><name><name>sourceAndOurReplicas</name><operator>.</operator><name>stream</name></name><argument_list>()</argument_list></call>
                            <operator>.</operator><call><name>filter</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>pair</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><call><name><name>pair</name><operator>.</operator><name>remote</name><operator>.</operator><name>isTransient</name></name><argument_list>()</argument_list></call></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                            <operator>.</operator><call><name>map</name><argument_list>(<argument><expr><lambda><parameter_list type="pseudo"><parameter><decl><name>pair</name></decl></parameter></parameter_list> -&gt;<block type="pseudo"><block_content> <expr><name><name>pair</name><operator>.</operator><name>local</name></name></expr></block_content></block></lambda></expr></argument>)</argument_list></call>
                            <operator>.</operator><call><name>collect</name><argument_list>(<argument><expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>collector</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Will request range {} of keyspace {} from endpoint {}"</literal></expr></argument>, <argument><expr><call><name><name>rangesToFetch</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>streamPlan</name><operator>.</operator><name>requestRanges</name></name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>full</name></expr></argument>, <argument><expr><name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Keyspace {}: work map {}."</literal></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>rangesToFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate pair of ranges to stream/fetch for given two range collections
     * (current ranges for keyspace and ranges after move to new token)
     *
     * With transient replication the added wrinkle is that if a range transitions from full to transient then
     * we need to stream the range despite the fact that we are retaining it as transient. Some replica
     * somewhere needs to transition from transient to full and we will be the source.
     *
     * If the range is transient and is transitioning to full then always fetch even if the range was already transient
     * since a transiently replicated obviously needs to fetch data to become full.
     *
     * This why there is a continue after checking for instersection because intersection is not sufficient reason
     * to do the subtraction since we might need to stream/fetch data anyways.
     *
     * @param currentRanges collection of the ranges by current token
     * @param updatedRanges collection of the ranges after token is changed
     * @return pair of ranges to stream/fetch for given current and updated range collections
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Pair</name><argument_list type="generic">&lt;<argument><name>RangesAtEndpoint</name></argument>, <argument><name>RangesAtEndpoint</name></argument>&gt;</argument_list></name></type> <name>calculateStreamAndFetchRanges</name><parameter_list>(<parameter><decl><type><name>RangesAtEndpoint</name></type> <name>currentRanges</name></decl></parameter>, <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>updatedRanges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>RangesAtEndpoint</name><operator>.</operator><name>Builder</name></name></type> <name>toStream</name> <init>= <expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>builder</name></name><argument_list>(<argument><expr><call><name><name>currentRanges</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>RangesAtEndpoint</name><operator>.</operator><name>Builder</name></name></type> <name>toFetch</name>  <init>= <expr><call><name><name>RangesAtEndpoint</name><operator>.</operator><name>builder</name></name><argument_list>(<argument><expr><call><name><name>currentRanges</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Calculating toStream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>computeRanges</name><argument_list>(<argument><expr><name>currentRanges</name></expr></argument>, <argument><expr><name>updatedRanges</name></expr></argument>, <argument><expr><name>toStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Calculating toFetch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>computeRanges</name><argument_list>(<argument><expr><name>updatedRanges</name></expr></argument>, <argument><expr><name>currentRanges</name></expr></argument>, <argument><expr><name>toFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"To stream {}"</literal></expr></argument>, <argument><expr><name>toStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"To fetch {}"</literal></expr></argument>, <argument><expr><name>toFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>Pair</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>toStream</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>toFetch</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>computeRanges</name><parameter_list>(<parameter><decl><type><name>RangesAtEndpoint</name></type> <name>srcRanges</name></decl></parameter>, <parameter><decl><type><name>RangesAtEndpoint</name></type> <name>dstRanges</name></decl></parameter>, <parameter><decl><type><name><name>RangesAtEndpoint</name><operator>.</operator><name>Builder</name></name></type> <name>ranges</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>Replica</name></type> <name>src</name> <range>: <expr><name>srcRanges</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>boolean</name></type> <name>intersect</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangesAtEndpoint</name></type> <name>remainder</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>Replica</name></type> <name>dst</name> <range>: <expr><name>dstRanges</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"Comparing {} and {}"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Stream the full range if there's no intersection</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>src</name><operator>.</operator><name>intersectsOnRange</name></name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// If we're transitioning from full to transient</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>src</name><operator>.</operator><name>isFull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>dst</name><operator>.</operator><name>isTransient</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name><name>src</name><operator>.</operator><name>subtractIgnoreTransientStatus</name></name><argument_list>(<argument><expr><call><name><name>dst</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// Re-subtract ranges to avoid overstreaming in cases when the single range is split or merged</comment>
                    <decl_stmt><decl><type><name><name>RangesAtEndpoint</name><operator>.</operator><name>Builder</name></name></type> <name>newRemainder</name> <init>= <expr><operator>new</operator> <call><name><name>RangesAtEndpoint</name><operator>.</operator><name>Builder</name></name><argument_list>(<argument><expr><call><name><name>remainder</name><operator>.</operator><name>endpoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>Replica</name></type> <name>replica</name> <range>: <expr><name>remainder</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>newRemainder</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>replica</name><operator>.</operator><name>subtractIgnoreTransientStatus</name></name><argument_list>(<argument><expr><call><name><name>dst</name><operator>.</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                    <expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name><name>newRemainder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>intersect</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>intersect</name></expr>)</condition>
            <block>{<block_content>
                <assert>assert <expr><name>remainder</name> <operator>==</operator> <literal type="null">null</literal></expr>;</assert>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"    Doesn't intersect adding {}"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ranges</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// should stream whole old range</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>ranges</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>logger</name><operator>.</operator><name>debug</name></name><argument_list>(<argument><expr><literal type="string">"    Intersects adding {}"</literal></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list type="generic">&lt;<argument><name>StreamState</name></argument>&gt;</argument_list></name></type> <name>stream</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name><name>streamPlan</name><operator>.</operator><name>execute</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>streamsNeeded</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <return>return <expr><operator>!</operator><call><name><name>streamPlan</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
}</block></class>
</unit>
