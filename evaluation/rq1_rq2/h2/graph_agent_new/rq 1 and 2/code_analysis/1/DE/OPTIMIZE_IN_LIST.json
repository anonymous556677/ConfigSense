{
    "unclear_methods": [
        {
            "unclear_method_name": "haveSameOrdering",
            "unclear_method_body": "/**\n     * Determines whether two specified types have the same ordering rules.\n     *\n     * @param t1\n     *            first data type\n     * @param t2\n     *            second data type\n     * @return whether types are comparable\n     */\npublic static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {\n        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();\n        if (vt1 > vt2) {\n            int vt = vt1;\n            vt1 = vt2;\n            vt2 = vt;\n            TypeInfo t = t1;\n            t1 = t2;\n            t2 = t;\n        }\n        if (vt1 <= Value.NULL) {\n            return true;\n        }\n        if (vt1 == vt2) {\n            switch (vt1) {\n            case Value.ARRAY:\n                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());\n            case Value.ROW: {\n                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();\n                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();\n                int degree = f1.size();\n                if (f2.size() != degree) {\n                    return false;\n                }\n                Iterator<Entry<String, TypeInfo>> i1 = f1.iterator(), i2 = f2.iterator();\n                while (i1.hasNext()) {\n                    if (!haveSameOrdering(i1.next().getValue(), i2.next().getValue())) {\n                        return false;\n                    }\n                }\n            }\n            //$FALL-THROUGH$\n            default:\n                return true;\n            }\n        }\n        byte g1 = Value.GROUPS[vt1], g2 = Value.GROUPS[vt2];\n        if (g1 == g2) {\n            switch (g1) {\n            default:\n                return true;\n            case Value.GROUP_CHARACTER_STRING:\n                return (vt1 == Value.VARCHAR_IGNORECASE) == (vt2 == Value.VARCHAR_IGNORECASE);\n            case Value.GROUP_DATETIME:\n                switch (vt1) {\n                case Value.DATE:\n                    return vt2 == Value.TIMESTAMP || vt2 == Value.TIMESTAMP_TZ;\n                case Value.TIME:\n                case Value.TIME_TZ:\n                    return vt2 == Value.TIME || vt2 == Value.TIME_TZ;\n                default: // TIMESTAMP TIMESTAMP_TZ\n                    return true;\n                }\n            case Value.GROUP_OTHER:\n            case Value.GROUP_COLLECTION:\n                return false;\n            }\n        }\n        if (g1 == Value.GROUP_BINARY_STRING) {\n            switch (vt2) {\n            case Value.JAVA_OBJECT:\n            case Value.GEOMETRY:\n            case Value.JSON:\n            case Value.UUID:\n                return true;\n            default:\n                return false;\n            }\n        }\n        return false;\n    }\n\n    ",
            "understanding": {
                "developer_understanding_on_unclear_method": "The unclear code is a method that determines whether two specified types have the same ordering rules.",
                "developer_understanding_on_unclear_code_to_configuration": "The unclear code is related to the configuration setting OPTIMIZE_IN_LIST. The method in the unclear code is used to optimize comparisons for SELECT, DELETE, and UPDATE operations involving the IN(...) and IN(SELECT ...) clauses."
            }
        }
    ],
    "code_context": "@Override\n    public void createIndexConditions(SessionLocal session, TableFilter filter) {\n        if (not || whenOperand || !(left instanceof ExpressionColumn)) {\n            return;\n        }\n        ExpressionColumn l = (ExpressionColumn) left;\n        if (filter != l.getTableFilter()) {\n            return;\n        }\n        if (session.getDatabase().getSettings().optimizeInList) {\n            TypeInfo colType = l.getType();\n            if (TypeInfo.haveSameOrdering(colType, TypeInfo.getHigherType(colType, type))) {\n                filter.addIndexCondition(IndexCondition.getInList(l, valueList));\n            }\n        }\n    }\n\n    \n@Override\n    public void createIndexConditions(SessionLocal session, TableFilter filter) {\n        if (!session.getDatabase().getSettings().optimizeInList) {\n            return;\n        }\n        if (not || compareType != Comparison.EQUAL) {\n            return;\n        }\n        if (query.getColumnCount() != 1) {\n            return;\n        }\n        if (!(left instanceof ExpressionColumn)) {\n            return;\n        }\n        TypeInfo colType = left.getType();\n        TypeInfo queryType = query.getExpressions().get(0).getType();\n        if (!TypeInfo.haveSameOrdering(colType, TypeInfo.getHigherType(colType, queryType))) {\n            return;\n        }\n        int leftType = colType.getValueType();\n        if (!DataType.hasTotalOrdering(leftType) && leftType != queryType.getValueType()) {\n            return;\n        }\n        ExpressionColumn l = (ExpressionColumn) left;\n        if (filter != l.getTableFilter()) {\n            return;\n        }\n        ExpressionVisitor visitor = ExpressionVisitor.getNotFromResolverVisitor(filter);\n        if (!query.isEverything(visitor)) {\n            return;\n        }\n        filter.addIndexCondition(IndexCondition.getInQuery(l, query));\n    }\n\n}\n\n@Override\n    public void createIndexConditions(SessionLocal session, TableFilter filter) {\n        if (not || whenOperand || !(left instanceof ExpressionColumn)) {\n            return;\n        }\n        ExpressionColumn l = (ExpressionColumn) left;\n        if (filter != l.getTableFilter()) {\n            return;\n        }\n        if (session.getDatabase().getSettings().optimizeInList) {\n            ExpressionVisitor visitor = ExpressionVisitor.getNotFromResolverVisitor(filter);\n            TypeInfo colType = l.getType();\n            for (Expression e : valueList) {\n                if (!e.isEverything(visitor)\n                        || !TypeInfo.haveSameOrdering(colType, TypeInfo.getHigherType(colType, e.getType()))) {\n                    return;\n                }\n            }\n            filter.addIndexCondition(IndexCondition.getInList(l, valueList));\n        }\n    }\n\n    ",
    "config_description": "    /**\n     * Database setting <code>OPTIMIZE_IN_LIST</code> (default: true).\n     * Optimize IN(...) and IN(SELECT ...) comparisons. This includes\n     * optimization for SELECT, DELETE, and UPDATE.\n     */",
    "developer_understanding_on_working": "The OPTIMIZE_IN_LIST configuration is used to optimize the performance of IN(...) and IN(SELECT ...) comparisons in the code. When the configuration is set to true, the code checks if the session's database settings have OPTIMIZE_IN_LIST enabled before applying optimizations to the queries involving the IN operator.",
    "developer_understanding_on_triggering_frequency": "The triggering frequency of the OPTIMIZE_IN_LIST configuration in the system depends on how often queries with the IN operator are executed. If there are many queries with the IN operator, the configuration will be triggered more frequently.",
    "developer_understanding_on_size_impact": "Enabling the OPTIMIZE_IN_LIST configuration can have a significant impact on the system's performance when dealing with queries involving the IN operator. By optimizing these queries, the system can potentially execute them more efficiently, leading to faster query execution times and improved overall system performance."
}