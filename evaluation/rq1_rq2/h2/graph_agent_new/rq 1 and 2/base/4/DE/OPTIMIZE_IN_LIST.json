{
    "unclear_methods": [
        {
            "unclear_method_name": "haveSameOrdering",
            "unclear_method_body": "/**\n     * Determines whether two specified types have the same ordering rules.\n     *\n     * @param t1\n     *            first data type\n     * @param t2\n     *            second data type\n     * @return whether types are comparable\n     */\npublic static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {\n        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();\n        if (vt1 > vt2) {\n            int vt = vt1;\n            vt1 = vt2;\n            vt2 = vt;\n            TypeInfo t = t1;\n            t1 = t2;\n            t2 = t;\n        }\n        if (vt1 <= Value.NULL) {\n            return true;\n        }\n        if (vt1 == vt2) {\n            switch (vt1) {\n            case Value.ARRAY:\n                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());\n            case Value.ROW: {\n                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();\n                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();\n                int degree = f1.size();\n                if (f2.size() != degree) {\n                    return false;\n                }\n                Iterator<Entry<String, TypeInfo>> i1 = f1.iterator(), i2 = f2.iterator();\n                while (i1.hasNext()) {\n                    if (!haveSameOrdering(i1.next().getValue(), i2.next().getValue())) {\n                        return false;\n                    }\n                }\n            }\n            //$FALL-THROUGH$\n            default:\n                return true;\n            }\n        }\n        byte g1 = Value.GROUPS[vt1], g2 = Value.GROUPS[vt2];\n        if (g1 == g2) {\n            switch (g1) {\n            default:\n                return true;\n            case Value.GROUP_CHARACTER_STRING:\n                return (vt1 == Value.VARCHAR_IGNORECASE) == (vt2 == Value.VARCHAR_IGNORECASE);\n            case Value.GROUP_DATETIME:\n                switch (vt1) {\n                case Value.DATE:\n                    return vt2 == Value.TIMESTAMP || vt2 == Value.TIMESTAMP_TZ;\n                case Value.TIME:\n                case Value.TIME_TZ:\n                    return vt2 == Value.TIME || vt2 == Value.TIME_TZ;\n                default: // TIMESTAMP TIMESTAMP_TZ\n                    return true;\n                }\n            case Value.GROUP_OTHER:\n            case Value.GROUP_COLLECTION:\n                return false;\n            }\n        }\n        if (g1 == Value.GROUP_BINARY_STRING) {\n            switch (vt2) {\n            case Value.JAVA_OBJECT:\n            case Value.GEOMETRY:\n            case Value.JSON:\n            case Value.UUID:\n                return true;\n            default:\n                return false;\n            }\n        }\n        return false;\n    }\n\n    ",
            "understanding": {
                "developer_understanding_on_unclear_method": "The unclear code is a method that determines whether two specified types have the same ordering rules.",
                "developer_understanding_on_unclear_code_to_configuration": "The unclear code is related to the configuration setting OPTIMIZE_IN_LIST, which optimizes the performance of IN(...) and IN(SELECT ...) comparisons in the database."
            }
        }
    ],
    "code_context": "@Override\n    public void createIndexConditions(SessionLocal session, TableFilter filter) {\n        if (not || whenOperand || !(left instanceof ExpressionColumn)) {\n            return;\n        }\n        ExpressionColumn l = (ExpressionColumn) left;\n        if (filter != l.getTableFilter()) {\n            return;\n        }\n        if (session.getDatabase().getSettings().optimizeInList) {\n            TypeInfo colType = l.getType();\n            if (TypeInfo.haveSameOrdering(colType, TypeInfo.getHigherType(colType, type))) {\n                filter.addIndexCondition(IndexCondition.getInList(l, valueList));\n            }\n        }\n    }\n\n    \n@Override\n    public void createIndexConditions(SessionLocal session, TableFilter filter) {\n        if (!session.getDatabase().getSettings().optimizeInList) {\n            return;\n        }\n        if (not || compareType != Comparison.EQUAL) {\n            return;\n        }\n        if (query.getColumnCount() != 1) {\n            return;\n        }\n        if (!(left instanceof ExpressionColumn)) {\n            return;\n        }\n        TypeInfo colType = left.getType();\n        TypeInfo queryType = query.getExpressions().get(0).getType();\n        if (!TypeInfo.haveSameOrdering(colType, TypeInfo.getHigherType(colType, queryType))) {\n            return;\n        }\n        int leftType = colType.getValueType();\n        if (!DataType.hasTotalOrdering(leftType) && leftType != queryType.getValueType()) {\n            return;\n        }\n        ExpressionColumn l = (ExpressionColumn) left;\n        if (filter != l.getTableFilter()) {\n            return;\n        }\n        ExpressionVisitor visitor = ExpressionVisitor.getNotFromResolverVisitor(filter);\n        if (!query.isEverything(visitor)) {\n            return;\n        }\n        filter.addIndexCondition(IndexCondition.getInQuery(l, query));\n    }\n\n}\n\n@Override\n    public void createIndexConditions(SessionLocal session, TableFilter filter) {\n        if (not || whenOperand || !(left instanceof ExpressionColumn)) {\n            return;\n        }\n        ExpressionColumn l = (ExpressionColumn) left;\n        if (filter != l.getTableFilter()) {\n            return;\n        }\n        if (session.getDatabase().getSettings().optimizeInList) {\n            ExpressionVisitor visitor = ExpressionVisitor.getNotFromResolverVisitor(filter);\n            TypeInfo colType = l.getType();\n            for (Expression e : valueList) {\n                if (!e.isEverything(visitor)\n                        || !TypeInfo.haveSameOrdering(colType, TypeInfo.getHigherType(colType, e.getType()))) {\n                    return;\n                }\n            }\n            filter.addIndexCondition(IndexCondition.getInList(l, valueList));\n        }\n    }\n\n    ",
    "config_description": "    /**\n     * Database setting <code>OPTIMIZE_IN_LIST</code> (default: true).\n     * Optimize IN(...) and IN(SELECT ...) comparisons. This includes\n     * optimization for SELECT, DELETE, and UPDATE.\n     */",
    "developer_understanding_on_working": "The configuration OPTIMIZE_IN_LIST is checked in the code to determine whether to optimize IN(...) and IN(SELECT ...) comparisons. If the setting is true, the code will optimize these comparisons by adding index conditions.",
    "developer_understanding_on_triggering_frequency": "The configuration OPTIMIZE_IN_LIST is triggered whenever the session's database setting for optimizeInList is true. This means that the configuration is triggered whenever the code encounters a situation where optimization for IN(...) and IN(SELECT ...) comparisons is needed.",
    "developer_understanding_on_size_impact": "The impact of the OPTIMIZE_IN_LIST configuration option is that it improves the performance of queries that involve IN(...) and IN(SELECT ...) comparisons by optimizing the index conditions. This can lead to faster query execution and improved overall system performance."
}